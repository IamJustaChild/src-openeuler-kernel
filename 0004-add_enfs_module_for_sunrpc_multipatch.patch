diff --git a/fs/nfs/enfs/enfs_multipath.h b/fs/nfs/enfs/enfs_multipath.h
new file mode 100644
index 000000000000..e064c2929ced
--- /dev/null
+++ b/fs/nfs/enfs/enfs_multipath.h
@@ -0,0 +1,24 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (c) Huawei Technologies Co., Ltd. 2023-2023. All rights reserved.
+ * Description: enfs multipath
+ * Author:
+ * Create: 2023-07-31
+ */
+
+#ifndef ENFS_MULTIPATH_H
+#define ENFS_MULTIPATH_H
+#include <linux/sunrpc/clnt.h>
+
+#define MAX_XPRT_NUM_PER_CLIENT 32
+
+int enfs_multipath_init(void);
+void enfs_multipath_exit(void);
+void enfs_xprt_ippair_create(struct xprt_create *xprtargs,
+			struct rpc_clnt *clnt, void *data);
+int enfs_config_xprt_create_args(struct xprt_create *xprtargs,
+			struct rpc_create_args *args,
+			char *servername, size_t length);
+void print_enfs_multipath_addr(struct sockaddr *local, struct sockaddr *remote);
+
+#endif // ENFS_MULTIPATH_H
diff --git a/fs/nfs/enfs/enfs_multipath_client.c b/fs/nfs/enfs/enfs_multipath_client.c
new file mode 100644
index 000000000000..63c02898a42c
--- /dev/null
+++ b/fs/nfs/enfs/enfs_multipath_client.c
@@ -0,0 +1,340 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Client-side ENFS adapter.
+ *
+ * Copyright (c) 2023. Huawei Technologies Co., Ltd. All rights reserved.
+ */
+#include <linux/types.h>
+#include <linux/nfs.h>
+#include <linux/nfs4.h>
+#include <linux/nfs_fs.h>
+#include <linux/nfs_fs_sb.h>
+#include <linux/proc_fs.h>
+#include <linux/seq_file.h>
+#include <linux/sunrpc/clnt.h>
+#include <linux/sunrpc/addr.h>
+#include "enfs_multipath_client.h"
+#include "enfs_multipath_parse.h"
+
+int
+nfs_multipath_client_mount_info_init(struct multipath_client_info *client_info,
+	const struct nfs_client_initdata *client_init_data)
+{
+	struct multipath_mount_options *mount_options =
+		(struct multipath_mount_options *)client_init_data->enfs_option;
+
+	if (mount_options->local_ip_list) {
+		client_info->local_ip_list =
+		kzalloc(sizeof(struct nfs_ip_list), GFP_KERNEL);
+
+		if (!client_info->local_ip_list)
+			return -ENOMEM;
+
+		memcpy(client_info->local_ip_list, mount_options->local_ip_list,
+			sizeof(struct nfs_ip_list));
+	}
+
+	if (mount_options->remote_ip_list) {
+
+		client_info->remote_ip_list =
+		kzalloc(sizeof(struct nfs_ip_list), GFP_KERNEL);
+
+		if (!client_info->remote_ip_list) {
+			kfree(client_info->local_ip_list);
+			client_info->local_ip_list = NULL;
+			return -ENOMEM;
+		}
+		memcpy(client_info->remote_ip_list,
+			mount_options->remote_ip_list,
+			sizeof(struct nfs_ip_list));
+	}
+
+	if (mount_options->pRemoteDnsInfo) {
+		client_info->pRemoteDnsInfo =
+		kzalloc(sizeof(struct NFS_ROUTE_DNS_INFO_S), GFP_KERNEL);
+
+		if (!client_info->pRemoteDnsInfo) {
+			kfree(client_info->local_ip_list);
+			client_info->local_ip_list = NULL;
+			kfree(client_info->remote_ip_list);
+			client_info->remote_ip_list = NULL;
+			return -ENOMEM;
+		}
+		memcpy(client_info->pRemoteDnsInfo,
+		mount_options->pRemoteDnsInfo,
+		sizeof(struct NFS_ROUTE_DNS_INFO_S));
+	}
+	return 0;
+}
+
+void nfs_multipath_client_info_free_work(struct work_struct *work)
+{
+
+	struct multipath_client_info *clp_info;
+
+	if (work == NULL)
+		return;
+
+	clp_info = container_of(work, struct multipath_client_info, work);
+
+	if (clp_info->local_ip_list != NULL) {
+		kfree(clp_info->local_ip_list);
+		clp_info->local_ip_list = NULL;
+	}
+	if (clp_info->remote_ip_list != NULL) {
+		kfree(clp_info->remote_ip_list);
+		clp_info->remote_ip_list = NULL;
+	}
+	kfree(clp_info);
+}
+
+void nfs_multipath_client_info_free(void *data)
+{
+	struct multipath_client_info *clp_info =
+		(struct multipath_client_info *)data;
+
+	if (clp_info == NULL)
+		return;
+	pr_info("free client info %p.\n", clp_info);
+	INIT_WORK(&clp_info->work, nfs_multipath_client_info_free_work);
+	schedule_work(&clp_info->work);
+}
+
+int nfs_multipath_client_info_init(void **data,
+			const struct nfs_client_initdata *cl_init)
+{
+	int rc;
+	struct multipath_client_info *info;
+	struct multipath_client_info **enfs_info;
+    /* no multi path info, no need do multipath init */
+	if (cl_init->enfs_option == NULL)
+		return 0;
+	enfs_info = (struct multipath_client_info **)data;
+	if (enfs_info == NULL)
+		return -EINVAL;
+
+	if (*enfs_info == NULL)
+		*enfs_info = kzalloc(sizeof(struct multipath_client_info),
+						GFP_KERNEL);
+
+	if (*enfs_info == NULL)
+		return -ENOMEM;
+
+	info = (struct multipath_client_info *)*enfs_info;
+	pr_info("init client info %p.\n", info);
+	rc = nfs_multipath_client_mount_info_init(info, cl_init);
+	if (rc) {
+		nfs_multipath_client_info_free((void *)info);
+		return rc;
+	}
+	return rc;
+}
+
+bool nfs_multipath_ip_list_info_match(const struct nfs_ip_list *ip_list_src,
+	const struct nfs_ip_list *ip_list_dst)
+{
+	int i;
+	int j;
+	bool is_find;
+	/* if both are equal or NULL, then return true. */
+	if (ip_list_src == ip_list_dst)
+		return true;
+
+	if ((ip_list_src == NULL || ip_list_dst == NULL))
+		return false;
+
+	if (ip_list_src->count != ip_list_dst->count)
+		return false;
+
+	for (i = 0; i < ip_list_src->count; i++) {
+		is_find = false;
+		for (j = 0; j < ip_list_src->count; j++) {
+			if (rpc_cmp_addr_port(
+				(const struct sockaddr *)
+				&ip_list_src->address[i],
+				(const struct sockaddr *)
+				&ip_list_dst->address[j])
+				) {
+				is_find = true;
+				break;
+			}
+		}
+		if (is_find == false)
+			return false;
+	}
+	return true;
+}
+
+int
+nfs_multipath_dns_list_info_match(
+			const struct NFS_ROUTE_DNS_INFO_S *pRemoteDnsInfoSrc,
+			const struct NFS_ROUTE_DNS_INFO_S *pRemoteDnsInfoDst)
+{
+	int i;
+
+	/* if both are equal or NULL, then return true. */
+	if (pRemoteDnsInfoSrc == pRemoteDnsInfoDst)
+		return true;
+
+	if ((pRemoteDnsInfoSrc == NULL || pRemoteDnsInfoDst == NULL))
+		return false;
+
+	if (pRemoteDnsInfoSrc->dnsNameCount != pRemoteDnsInfoDst->dnsNameCount)
+		return false;
+
+	for (i = 0; i < pRemoteDnsInfoSrc->dnsNameCount; i++) {
+		if (!strcmp(pRemoteDnsInfoSrc->routeRemoteDnsList[i].dnsname,
+		pRemoteDnsInfoDst->routeRemoteDnsList[i].dnsname))
+			return false;
+	}
+	return true;
+}
+
+int nfs_multipath_client_info_match(void *src, void *dst)
+{
+	int ret = true;
+
+	struct multipath_client_info *src_info;
+	struct multipath_mount_options *dst_info;
+
+	src_info = (struct multipath_client_info *)src;
+	dst_info = (struct multipath_mount_options *)dst;
+	pr_info("try match client .\n");
+	ret = nfs_multipath_ip_list_info_match(src_info->local_ip_list,
+				dst_info->local_ip_list);
+	if (ret == false) {
+		pr_err("local_ip not match.\n");
+		return ret;
+	}
+
+	ret = nfs_multipath_ip_list_info_match(src_info->remote_ip_list,
+			dst_info->remote_ip_list);
+	if (ret == false) {
+		pr_err("remote_ip not match.\n");
+		return ret;
+	}
+
+	ret = nfs_multipath_dns_list_info_match(src_info->pRemoteDnsInfo,
+			dst_info->pRemoteDnsInfo);
+	if (ret == false) {
+		pr_err("dns not match.\n");
+		return ret;
+	}
+	pr_info("try match client ret %d.\n", ret);
+	return ret;
+}
+
+void nfs_multipath_print_ip_info(struct seq_file *mount_option,
+			struct nfs_ip_list *ip_list,
+			const char *type)
+{
+	char buf[IP_ADDRESS_LEN_MAX + 1];
+	int len = 0;
+	int i = 0;
+
+	seq_printf(mount_option, ",%s=", type);
+	for (i = 0; i < ip_list->count; i++) {
+		len = rpc_ntop((struct sockaddr *)&ip_list->address[i],
+				buf, IP_ADDRESS_LEN_MAX);
+		if (len > 0 && len < IP_ADDRESS_LEN_MAX)
+			buf[len] = '\0';
+
+		if (i == 0)
+			seq_printf(mount_option, "%s", buf);
+		else
+			seq_printf(mount_option, "~%s", buf);
+		dfprintk(MOUNT,
+			"NFS:   show nfs mount option type:%s %s [%s]\n",
+			type, buf, __func__);
+	}
+}
+
+void nfs_multipath_print_dns_info(struct seq_file *mount_option,
+			struct NFS_ROUTE_DNS_INFO_S *pRemoteDnsInfo,
+			const char *type)
+{
+	int i = 0;
+
+	seq_printf(mount_option, ",%s=", type);
+	for (i = 0; i < pRemoteDnsInfo->dnsNameCount; i++) {
+		if (i == 0)
+			seq_printf(mount_option,
+			"[%s", pRemoteDnsInfo->routeRemoteDnsList[i].dnsname);
+		else if (i == pRemoteDnsInfo->dnsNameCount - 1)
+			seq_printf(mount_option, ",%s]",
+			pRemoteDnsInfo->routeRemoteDnsList[i].dnsname);
+		else
+			seq_printf(mount_option,
+			",%s", pRemoteDnsInfo->routeRemoteDnsList[i].dnsname);
+	}
+}
+
+
+static void multipath_print_sockaddr(struct seq_file *seq,
+			struct sockaddr *addr)
+{
+	switch (addr->sa_family) {
+	case AF_INET: {
+		struct sockaddr_in *sin = (struct sockaddr_in *)addr;
+
+		seq_printf(seq, "%pI4", &sin->sin_addr);
+		return;
+	}
+	case AF_INET6: {
+		struct sockaddr_in6 *sin6 = (struct sockaddr_in6 *)addr;
+
+		seq_printf(seq, "%pI6", &sin6->sin6_addr);
+		return;
+	}
+	default:
+		break;
+	}
+	pr_err("unsupport family:%d\n", addr->sa_family);
+}
+
+static void multipath_print_enfs_info(struct seq_file *seq,
+			struct nfs_server *server)
+{
+	struct sockaddr_storage peeraddr;
+	struct rpc_clnt *next = server->client;
+
+	rpc_peeraddr(server->client,
+			(struct sockaddr *)&peeraddr, sizeof(peeraddr));
+	seq_puts(seq, ",enfs_info=");
+	multipath_print_sockaddr(seq, (struct sockaddr *)&peeraddr);
+
+	while (next->cl_parent) {
+		if (next == next->cl_parent)
+			break;
+		next = next->cl_parent;
+	}
+	seq_printf(seq, "_%u", next->cl_clid);
+}
+
+void nfs_multipath_client_info_show(struct seq_file *mount_option, void *data)
+{
+	struct nfs_server *server = data;
+	struct multipath_client_info *client_info =
+			server->nfs_client->cl_multipath_data;
+
+	dfprintk(MOUNT, "NFS:   show nfs mount option[%s]\n", __func__);
+	if ((client_info->remote_ip_list) &&
+		(client_info->remote_ip_list->count > 0))
+		nfs_multipath_print_ip_info(mount_option,
+			client_info->remote_ip_list,
+			"remoteaddrs");
+
+	if ((client_info->local_ip_list) &&
+		(client_info->local_ip_list->count > 0))
+		nfs_multipath_print_ip_info(mount_option,
+			client_info->local_ip_list,
+			"localaddrs");
+
+	if ((client_info->pRemoteDnsInfo) &&
+		(client_info->pRemoteDnsInfo->dnsNameCount > 0))
+		nfs_multipath_print_dns_info(mount_option,
+			client_info->pRemoteDnsInfo,
+			"remotednsname");
+
+	multipath_print_enfs_info(mount_option, server);
+}
diff --git a/fs/nfs/enfs/enfs_multipath_client.h b/fs/nfs/enfs/enfs_multipath_client.h
new file mode 100644
index 000000000000..208f7260690d
--- /dev/null
+++ b/fs/nfs/enfs/enfs_multipath_client.h
@@ -0,0 +1,26 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Client-side ENFS adapter.
+ *
+ * Copyright (c) 2023. Huawei Technologies Co., Ltd. All rights reserved.
+ */
+#ifndef _ENFS_MULTIPATH_CLIENT_H_
+#define _ENFS_MULTIPATH_CLIENT_H_
+
+#include "enfs.h"
+
+struct multipath_client_info {
+	struct work_struct   work;
+	struct nfs_ip_list  *remote_ip_list;
+	struct nfs_ip_list  *local_ip_list;
+	struct NFS_ROUTE_DNS_INFO_S    *pRemoteDnsInfo;
+	s64 client_id;
+};
+
+int nfs_multipath_client_info_init(void **data,
+			const struct nfs_client_initdata *cl_init);
+void nfs_multipath_client_info_free(void *data);
+int nfs_multipath_client_info_match(void *src, void *dst);
+void nfs_multipath_client_info_show(struct seq_file *mount_option, void *data);
+
+#endif
diff --git a/fs/nfs/enfs/enfs_path.c b/fs/nfs/enfs/enfs_path.c
new file mode 100644
index 000000000000..7355f8c2f672
--- /dev/null
+++ b/fs/nfs/enfs/enfs_path.c
@@ -0,0 +1,47 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (c) Huawei Technologies Co., Ltd. 2023-2023. All rights reserved.
+ */
+
+#include <linux/sunrpc/metrics.h>
+#include <linux/sunrpc/xprt.h>
+
+#include "enfs.h"
+#include "enfs_log.h"
+#include "enfs_path.h"
+
+// only create ctx in this function
+// alloc iostat memory in create_clnt
+int enfs_alloc_xprt_ctx(struct rpc_xprt *xprt)
+{
+	struct enfs_xprt_context *ctx;
+
+	if (!xprt) {
+		enfs_log_error("invalid xprt pointer.\n");
+		return -EINVAL;
+	}
+
+	ctx = kzalloc(sizeof(struct enfs_xprt_context), GFP_KERNEL);
+	if (!ctx) {
+		enfs_log_error("add xprt test failed.\n");
+		return -ENOMEM;
+	}
+
+	xprt->multipath_context = (void *)ctx;
+	return 0;
+}
+
+// free multi_context and iostat memory
+void enfs_free_xprt_ctx(struct rpc_xprt *xprt)
+{
+	struct enfs_xprt_context *ctx = xprt->multipath_context;
+
+	if (ctx) {
+		if (ctx->stats) {
+			rpc_free_iostats(ctx->stats);
+			ctx->stats = NULL;
+		}
+		kfree(xprt->multipath_context);
+		xprt->multipath_context = NULL;
+	}
+}
diff --git a/fs/nfs/enfs/enfs_path.h b/fs/nfs/enfs/enfs_path.h
new file mode 100644
index 000000000000..97b1ef3730b8
--- /dev/null
+++ b/fs/nfs/enfs/enfs_path.h
@@ -0,0 +1,12 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (c) Huawei Technologies Co., Ltd. 2023-2023. All rights reserved.
+ */
+
+#ifndef ENFS_PATH_H
+#define ENFS_PATH_H
+
+int enfs_alloc_xprt_ctx(struct rpc_xprt *xprt);
+void enfs_free_xprt_ctx(struct rpc_xprt *xprt);
+
+#endif  // ENFS_PATH_H
diff --git a/fs/nfs/enfs/enfs_proc.c b/fs/nfs/enfs/enfs_proc.c
new file mode 100644
index 000000000000..53fa1a07642f
--- /dev/null
+++ b/fs/nfs/enfs/enfs_proc.c
@@ -0,0 +1,545 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (c) Huawei Technologies Co., Ltd. 2023-2023. All rights reserved.
+ */
+#include <linux/module.h>
+#include <linux/proc_fs.h>
+#include <linux/seq_file.h>
+#include <linux/spinlock.h>
+#include <linux/sunrpc/clnt.h>
+#include <linux/sunrpc/metrics.h>
+#include <linux/sunrpc/xprtsock.h>
+#include <net/netns/generic.h>
+
+#include "../../../net/sunrpc/netns.h"
+
+#include "enfs.h"
+#include "enfs_log.h"
+#include "enfs_proc.h"
+#include "enfs_multipath.h"
+#include "pm_state.h"
+
+#define ENFS_PROC_DIR "enfs"
+#define ENFS_PROC_PATH_STATUS_LEN 256
+
+static struct proc_dir_entry *enfs_proc_parent;
+
+void
+enfs_iterate_each_rpc_clnt(int (*fn)(struct rpc_clnt *clnt, void *data),
+			void *data)
+{
+	struct net *net;
+	struct sunrpc_net *sn;
+	struct rpc_clnt *clnt;
+
+	rcu_read_lock();
+	for_each_net_rcu(net) {
+		sn = net_generic(net, sunrpc_net_id);
+		if (sn == NULL)
+			continue;
+		spin_lock(&sn->rpc_client_lock);
+		list_for_each_entry(clnt, &sn->all_clients, cl_clients) {
+			fn(clnt, data);
+		}
+		spin_unlock(&sn->rpc_client_lock);
+	}
+	rcu_read_unlock();
+}
+
+struct proc_dir_entry *enfs_get_proc_parent(void)
+{
+	return enfs_proc_parent;
+}
+
+static int sockaddr_ip_to_str(struct sockaddr *addr, char *buf, int len)
+{
+	switch (addr->sa_family) {
+	case AF_INET: {
+		struct sockaddr_in *sin = (struct sockaddr_in *)addr;
+
+		snprintf(buf, len, "%pI4", &sin->sin_addr);
+		return 0;
+	}
+	case AF_INET6: {
+		struct sockaddr_in6 *sin6 = (struct sockaddr_in6 *)addr;
+
+		snprintf(buf, len, "%pI6", &sin6->sin6_addr);
+		return 0;
+	}
+	default:
+		break;
+	}
+	return 1;
+}
+
+static bool should_print(const char *name)
+{
+	int i;
+	static const char * const proc_names[] = {
+	    "READ",
+	    "WRITE",
+	};
+
+	if (name == NULL)
+		return false;
+
+	for (i = 0; i < ARRAY_SIZE(proc_names); i++) {
+		if (strcmp(name, proc_names[i]) == 0)
+			return true;
+	}
+	return false;
+}
+
+struct enfs_xprt_iter {
+	unsigned int id;
+	struct seq_file *seq;
+	unsigned int max_addrs_length;
+};
+
+static int debug_show_xprt(struct rpc_clnt *clnt,
+			struct rpc_xprt *xprt,
+			void *data)
+{
+	struct enfs_xprt_context *ctx = NULL;
+
+	if (xprt->multipath_context)
+		ctx = xprt->multipath_context;
+
+	pr_info("	xprt:%p ctx:%p main:%d queue_len:%lu.\n", xprt,
+			xprt->multipath_context,
+			ctx ? ctx->main : false,
+			atomic_long_read(&xprt->queuelen));
+	return 0;
+}
+
+static int debug_show_clnt(struct rpc_clnt *clnt, void *data)
+{
+	pr_info("    clnt %d addr:%p enfs:%d\n",
+			clnt->cl_clid, clnt,
+			clnt->cl_enfs);
+	rpc_clnt_iterate_for_each_xprt(clnt, debug_show_xprt, NULL);
+	return 0;
+}
+
+static void debug_print_all_xprt(void)
+{
+	enfs_iterate_each_rpc_clnt(debug_show_clnt, NULL);
+}
+
+static
+void enfs_proc_format_xprt_addr_display(struct rpc_clnt *clnt,
+			struct rpc_xprt *xprt,
+			char *local_name_buf,
+			int local_name_buf_len,
+			char *remote_name_buf,
+			int remote_name_buf_len)
+{
+	int err;
+	struct sockaddr_storage srcaddr;
+	struct enfs_xprt_context *ctx;
+
+	ctx = (struct enfs_xprt_context *)xprt->multipath_context;
+
+	sockaddr_ip_to_str((struct sockaddr *)&xprt->addr,
+				remote_name_buf, remote_name_buf_len);
+
+	// get local address depend one main or not
+	if (enfs_is_main_xprt(xprt)) {
+		err = rpc_localaddr(clnt, (struct sockaddr *)&srcaddr,
+					sizeof(srcaddr));
+		if (err != 0)
+			(void)snprintf(local_name_buf,
+						local_name_buf_len, "Unknown");
+		else
+			sockaddr_ip_to_str((struct sockaddr *)&srcaddr,
+						local_name_buf,
+						local_name_buf_len);
+	} else {
+		sockaddr_ip_to_str((struct sockaddr *)&ctx->srcaddr,
+					local_name_buf,
+					local_name_buf_len);
+	}
+}
+
+static int enfs_show_xprt_stats(struct rpc_clnt *clnt,
+			struct rpc_xprt *xprt,
+			void *data)
+{
+	unsigned int op;
+	unsigned int maxproc = clnt->cl_maxproc;
+	struct enfs_xprt_iter *iter = (struct enfs_xprt_iter *)data;
+	struct enfs_xprt_context *ctx;
+	char local_name[INET6_ADDRSTRLEN];
+	char remote_name[INET6_ADDRSTRLEN];
+
+	if (!xprt->multipath_context)
+		return 0;
+
+	ctx = (struct enfs_xprt_context *)xprt->multipath_context;
+
+	enfs_proc_format_xprt_addr_display(clnt, xprt, local_name,
+					sizeof(local_name),
+					remote_name, sizeof(remote_name));
+
+	seq_printf(iter->seq, "%-6u%-*s%-*s", iter->id,
+			iter->max_addrs_length + 4,
+			local_name,
+			iter->max_addrs_length + 4,
+			remote_name);
+
+	iter->id++;
+
+	for (op = 0; op < maxproc; op++) {
+		if (!should_print(clnt->cl_procinfo[op].p_name))
+			continue;
+
+		seq_printf(iter->seq, "%-22lu%-22Lu%-22Lu",
+			ctx->stats[op].om_ops,
+			ctx->stats[op].om_ops == 0 ? 0 :
+			ktime_to_ms(ctx->stats[op].om_rtt) /
+			ctx->stats[op].om_ops,
+			ctx->stats[op].om_ops == 0 ? 0 :
+			ktime_to_ms(ctx->stats[op].om_execute) /
+			ctx->stats[op].om_ops);
+	}
+	seq_puts(iter->seq, "\n");
+	return 0;
+}
+
+static int rpc_proc_show_path_status(struct rpc_clnt *clnt,
+			struct rpc_xprt *xprt,
+			void *data)
+{
+	struct enfs_xprt_iter *iter = (struct enfs_xprt_iter *)data;
+	struct enfs_xprt_context *ctx = NULL;
+	char local_name[INET6_ADDRSTRLEN] = {0};
+	char remote_name[INET6_ADDRSTRLEN] = {0};
+	char multiapth_status[ENFS_PROC_PATH_STATUS_LEN] = {0};
+	char xprt_status[ENFS_PROC_PATH_STATUS_LEN] = {0};
+
+	if (!xprt->multipath_context) {
+		enfs_log_debug("multipath_context is null.\n");
+		return 0;
+	}
+	ctx = (struct enfs_xprt_context *)xprt->multipath_context;
+
+	enfs_proc_format_xprt_addr_display(clnt, xprt,
+				local_name,
+				sizeof(local_name),
+				remote_name, sizeof(remote_name));
+
+	pm_get_path_state_desc(xprt,
+				multiapth_status,
+				ENFS_PROC_PATH_STATUS_LEN);
+
+	pm_get_xprt_state_desc(xprt,
+				xprt_status,
+				ENFS_PROC_PATH_STATUS_LEN);
+
+	seq_printf(iter->seq, "%-6u%-*s%-*s%-12s%-12s\n",
+			iter->id, iter->max_addrs_length + 4,
+			local_name, iter->max_addrs_length + 4,
+			remote_name, multiapth_status,
+			xprt_status);
+	iter->id++;
+	return 0;
+}
+
+static int enfs_get_max_addrs_length(struct rpc_clnt *clnt,
+			struct rpc_xprt *xprt,
+			void *data)
+{
+	struct enfs_xprt_iter *iter = (struct enfs_xprt_iter *)data;
+	char local_name[INET6_ADDRSTRLEN];
+	char remote_name[INET6_ADDRSTRLEN];
+
+	enfs_proc_format_xprt_addr_display(clnt, xprt,
+				local_name, sizeof(local_name),
+				remote_name, sizeof(remote_name));
+
+	if (iter->max_addrs_length < strlen(local_name))
+		iter->max_addrs_length = strlen(local_name);
+
+	if (iter->max_addrs_length < strlen(remote_name))
+		iter->max_addrs_length = strlen(remote_name);
+
+	return 0;
+}
+
+static int rpc_proc_clnt_showpath(struct seq_file *seq, void *v)
+{
+	struct rpc_clnt *clnt = seq->private;
+	struct enfs_xprt_iter iter;
+
+	iter.seq = seq;
+	iter.id = 0;
+	iter.max_addrs_length = 0;
+
+	rpc_clnt_iterate_for_each_xprt(clnt,
+				enfs_get_max_addrs_length,
+				(void *)&iter);
+
+	seq_printf(seq, "%-6s%-*s%-*s%-12s%-12s\n", "id",
+			iter.max_addrs_length + 4,
+			"local_addr",
+			iter.max_addrs_length + 4,
+			"remote_addr",
+			"path_state",
+			"xprt_state");
+
+	rpc_clnt_iterate_for_each_xprt(clnt,
+				rpc_proc_show_path_status,
+				(void *)&iter);
+	return 0;
+}
+
+static int enfs_rpc_proc_show(struct seq_file *seq, void *v)
+{
+	struct rpc_clnt *clnt = seq->private;
+	struct enfs_xprt_iter iter;
+
+	iter.seq = seq;
+	iter.id = 0;
+	iter.max_addrs_length = 0;
+
+	debug_print_all_xprt();
+	pr_info("enfs proc clnt:%p\n", clnt);
+
+	rpc_clnt_iterate_for_each_xprt(clnt,
+				enfs_get_max_addrs_length,
+				(void *)&iter);
+
+	seq_printf(seq, "%-6s%-*s%-*s%-22s%-22s%-22s%-22s%-22s%-22s\n", "id",
+			iter.max_addrs_length + 4, "local_addr",
+			iter.max_addrs_length + 4,
+			"remote_addr", "r_count",
+			"r_rtt", "r_exec", "w_count", "w_rtt", "w_exec");
+
+	// rpc_clnt_show_stats(seq, clnt);
+	rpc_clnt_iterate_for_each_xprt(clnt,
+				enfs_show_xprt_stats,
+				(void *)&iter);
+	return 0;
+}
+
+static int rpc_proc_open(struct inode *inode, struct file *file)
+{
+	struct rpc_clnt *clnt = PDE_DATA(inode);
+
+	pr_info("%s %p\n", __func__, clnt);
+	return single_open(file, enfs_rpc_proc_show, clnt);
+}
+
+static int enfs_reset_xprt_stats(struct rpc_clnt *clnt,
+			struct rpc_xprt *xprt,
+			void *data)
+{
+	unsigned int op;
+	struct enfs_xprt_context *ctx;
+	unsigned int maxproc = clnt->cl_maxproc;
+	struct rpc_iostats stats = {0};
+
+	if (!xprt->multipath_context)
+		return 0;
+	ctx = (struct enfs_xprt_context *)xprt->multipath_context;
+
+	for (op = 0; op < maxproc; op++) {
+		spin_lock(&ctx->stats[op].om_lock);
+		ctx->stats[op] = stats;
+		spin_unlock(&ctx->stats[op].om_lock);
+	}
+	return 0;
+}
+
+static void trim_newline_ch(char *str, int len)
+{
+	int i;
+
+	for (i = 0; str[i] != '\0' && i < len; i++) {
+		if (str[i] == '\n')
+			str[i] = '\0';
+	}
+}
+
+static ssize_t enfs_proc_write(struct file *file,
+			const char __user *user_buf,
+			size_t len,
+			loff_t *offset)
+{
+	char buffer[128];
+	struct rpc_clnt *clnt =
+	((struct seq_file *)file->private_data)->private;
+
+	if (len >= sizeof(buffer))
+		return -E2BIG;
+
+	if (copy_from_user(buffer, user_buf, len) != 0)
+		return -EFAULT;
+
+	buffer[len] = '\0';
+	trim_newline_ch(buffer, len);
+	if (strcmp(buffer, "reset") != 0)
+		return -EINVAL;
+
+	rpc_clnt_iterate_for_each_xprt(clnt, enfs_reset_xprt_stats, NULL);
+	return len;
+}
+
+static int rpc_proc_show_path(struct inode *inode, struct file *file)
+{
+	struct rpc_clnt *clnt = PDE_DATA(inode);
+
+	return single_open(file, rpc_proc_clnt_showpath, clnt);
+}
+
+static const struct file_operations rpc_proc_fops = {
+	.owner = THIS_MODULE,
+	.open = rpc_proc_open,
+	.read = seq_read,
+	.llseek = seq_lseek,
+	.release = single_release,
+	.write = enfs_proc_write,
+};
+
+static const struct file_operations rpc_show_path_fops = {
+	.owner = THIS_MODULE,
+	.open = rpc_proc_show_path,
+	.read = seq_read,
+	.llseek = seq_lseek,
+	.release = single_release,
+};
+
+static int clnt_proc_name(struct rpc_clnt *clnt, char *buf, int len)
+{
+	int ret;
+
+	ret = snprintf(buf, len, "%s_%u",
+				rpc_peeraddr2str(clnt, RPC_DISPLAY_ADDR),
+				clnt->cl_clid);
+	if (ret > len)
+		return -E2BIG;
+	return 0;
+}
+
+static int enfs_proc_create_file(struct rpc_clnt *clnt)
+{
+	int err;
+	char buf[128];
+
+	struct proc_dir_entry *clnt_entry;
+	struct proc_dir_entry *stat_entry;
+
+	err = clnt_proc_name(clnt, buf, sizeof(buf));
+	if (err)
+		return err;
+
+	clnt_entry = proc_mkdir(buf, enfs_proc_parent);
+	if (clnt_entry == NULL)
+		return -EINVAL;
+
+	stat_entry = proc_create_data("stat",
+				0, clnt_entry,
+				&rpc_proc_fops, clnt);
+
+	if (stat_entry == NULL)
+		return -EINVAL;
+
+	stat_entry = proc_create_data("path",
+				0, clnt_entry,
+				&rpc_show_path_fops, clnt);
+
+	if (stat_entry == NULL)
+		return -EINVAL;
+
+	return 0;
+}
+
+void enfs_count_iostat(struct rpc_task *task)
+{
+	struct enfs_xprt_context *ctx = task->tk_xprt->multipath_context;
+
+	if (!ctx || !ctx->stats)
+		return;
+	rpc_count_iostats(task, ctx->stats);
+}
+
+static void enfs_proc_delete_file(struct rpc_clnt *clnt)
+{
+	int err;
+	char buf[128];
+
+	err = clnt_proc_name(clnt, buf, sizeof(buf));
+	if (err) {
+		pr_err("gen clnt name failed.\n");
+		return;
+	}
+	remove_proc_subtree(buf, enfs_proc_parent);
+}
+
+// create proc file "/porc/enfs/[mount_ip]_[id]/stat"
+int enfs_proc_create_clnt(struct rpc_clnt *clnt)
+{
+	int err;
+
+	err = enfs_proc_create_file(clnt);
+	if (err) {
+		pr_err("create client %d\n", err);
+		return err;
+	}
+
+	return 0;
+}
+
+void enfs_proc_delete_clnt(struct rpc_clnt *clnt)
+{
+	if (clnt->cl_enfs)
+		enfs_proc_delete_file(clnt);
+}
+
+static int enfs_proc_create_parent(void)
+{
+	enfs_proc_parent = proc_mkdir(ENFS_PROC_DIR, NULL);
+
+	if (enfs_proc_parent == NULL) {
+		pr_err("Enfs create proc dir err\n");
+		return -ENOMEM;
+	}
+	return 0;
+}
+
+static void enfs_proc_delete_parent(void)
+{
+	remove_proc_entry(ENFS_PROC_DIR, NULL);
+}
+
+static int enfs_proc_init_create_clnt(struct rpc_clnt *clnt, void *data)
+{
+	if (clnt->cl_enfs)
+		enfs_proc_create_file(clnt);
+	return 0;
+}
+
+static int enfs_proc_destroy_clnt(struct rpc_clnt *clnt, void *data)
+{
+	if (clnt->cl_enfs)
+		enfs_proc_delete_file(clnt);
+	return 0;
+}
+
+int enfs_proc_init(void)
+{
+	int err;
+
+	err = enfs_proc_create_parent();
+	if (err)
+		return err;
+
+	enfs_iterate_each_rpc_clnt(enfs_proc_init_create_clnt, NULL);
+	return 0;
+}
+
+void enfs_proc_exit(void)
+{
+	enfs_iterate_each_rpc_clnt(enfs_proc_destroy_clnt, NULL);
+	enfs_proc_delete_parent();
+}
diff --git a/fs/nfs/enfs/enfs_proc.h b/fs/nfs/enfs/enfs_proc.h
new file mode 100644
index 000000000000..321951031c2e
--- /dev/null
+++ b/fs/nfs/enfs/enfs_proc.h
@@ -0,0 +1,21 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Client-side ENFS PROC.
+ *
+ * Copyright (c) 2023. Huawei Technologies Co., Ltd. All rights reserved.
+ */
+#ifndef ENFS_PROC_H
+#define ENFS_PROC_H
+
+struct rpc_clnt;
+struct rpc_task;
+struct proc_dir_entry;
+
+int enfs_proc_init(void);
+void enfs_proc_exit(void);
+struct proc_dir_entry *enfs_get_proc_parent(void);
+int enfs_proc_create_clnt(struct rpc_clnt *clnt);
+void enfs_proc_delete_clnt(struct rpc_clnt *clnt);
+void enfs_count_iostat(struct rpc_task *task);
+
+#endif
diff --git a/fs/nfs/enfs/enfs_remount.c b/fs/nfs/enfs/enfs_remount.c
new file mode 100644
index 000000000000..2c3fe125c735
--- /dev/null
+++ b/fs/nfs/enfs/enfs_remount.c
@@ -0,0 +1,221 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (c) Huawei Technologies Co., Ltd. 2023-2023. All rights reserved.
+ * Description: remount ip source file
+ * Author: y00583252
+ * Create: 2023-08-12
+ */
+#include "enfs_remount.h"
+
+#include <linux/string.h>
+#include <linux/in.h>
+#include <linux/in6.h>
+#include <linux/sunrpc/clnt.h>
+#include <linux/spinlock.h>
+#include <linux/sunrpc/addr.h>
+#include <linux/sunrpc/metrics.h>
+#include <linux/sunrpc/xprtmultipath.h>
+#include <linux/sunrpc/xprtsock.h>
+#include <linux/sunrpc/xprt.h>
+#include <linux/smp.h>
+#include <linux/delay.h>
+
+#include "enfs.h"
+#include "enfs_log.h"
+#include "enfs_multipath.h"
+#include "enfs_multipath_parse.h"
+#include "enfs_path.h"
+#include "enfs_proc.h"
+#include "enfs_multipath_client.h"
+
+static bool enfs_rpc_xprt_switch_need_delete_addr(
+	struct multipath_mount_options *enfs_option,
+	struct sockaddr *dstaddr, struct sockaddr *srcaddr)
+{
+	int i;
+	bool find_same_ip = false;
+	int32_t local_total;
+	int32_t remote_total;
+
+	local_total = enfs_option->local_ip_list->count;
+	remote_total = enfs_option->remote_ip_list->count;
+	if (local_total == 0 || remote_total == 0) {
+		pr_err("no ip list is present.\n");
+		return false;
+	}
+
+	for (i = 0; i < local_total; i++) {
+		find_same_ip =
+		rpc_cmp_addr((struct sockaddr *)
+		&enfs_option->local_ip_list->address[i],
+		srcaddr);
+		if (find_same_ip)
+			break;
+	}
+
+	if (find_same_ip == false)
+		return true;
+
+	find_same_ip = false;
+	for (i = 0; i < remote_total; i++) {
+		find_same_ip =
+		rpc_cmp_addr((struct sockaddr *)
+		&enfs_option->remote_ip_list->address[i],
+		dstaddr);
+		if (find_same_ip)
+			break;
+	}
+
+	if (find_same_ip == false)
+		return true;
+
+	return false;
+}
+
+// Used in rcu_lock
+static bool enfs_delete_xprt_from_switch(struct rpc_xprt *xprt,
+			void *enfs_option,
+			struct rpc_xprt_switch *xps)
+{
+	struct enfs_xprt_context *ctx = NULL;
+	struct multipath_mount_options *mopt =
+	(struct multipath_mount_options *)enfs_option;
+
+	if (enfs_is_main_xprt(xprt))
+		return true;
+
+	ctx = (struct enfs_xprt_context *)xprt->multipath_context;
+	if (enfs_rpc_xprt_switch_need_delete_addr(mopt,
+		(struct sockaddr *)&xprt->addr,
+		(struct sockaddr *)&ctx->srcaddr)) {
+
+		print_enfs_multipath_addr((struct sockaddr *)&ctx->srcaddr,
+					(struct sockaddr *)&xprt->addr);
+		rpc_xprt_switch_remove_xprt(xps, xprt);
+		return true;
+	}
+
+	return false;
+}
+
+void enfs_clnt_delete_obsolete_xprts(struct nfs_client *nfs_client,
+			void *enfs_option)
+{
+	int xprt_count = 0;
+	struct rpc_xprt *pos = NULL;
+	struct rpc_xprt_switch *xps = NULL;
+
+	rcu_read_lock();
+	xps = xprt_switch_get(
+		rcu_dereference(
+		nfs_client->cl_rpcclient->cl_xpi.xpi_xpswitch));
+	if (xps == NULL) {
+		rcu_read_unlock();
+		xprt_switch_put(xps);
+		return;
+	}
+	list_for_each_entry_rcu(pos, &xps->xps_xprt_list, xprt_switch) {
+		if (xprt_count < MAX_XPRT_NUM_PER_CLIENT) {
+			if (enfs_delete_xprt_from_switch(
+				pos, enfs_option, xps) == false)
+				xprt_count++;
+		} else
+			rpc_xprt_switch_remove_xprt(xps, pos);
+	}
+	rcu_read_unlock();
+	xprt_switch_put(xps);
+}
+
+int enfs_remount_iplist(struct nfs_client *nfs_client, void *enfs_option)
+{
+	int errno = 0;
+	char servername[48];
+	struct multipath_mount_options *remount_lists =
+	(struct multipath_mount_options *)enfs_option;
+	struct multipath_client_info *client_info =
+	(struct multipath_client_info *)nfs_client->cl_multipath_data;
+	struct xprt_create xprtargs;
+	struct rpc_create_args args = {
+		.protocol = nfs_client->cl_proto,
+		.net = nfs_client->cl_net,
+		.addrsize = nfs_client->cl_addrlen,
+		.servername = nfs_client->cl_hostname,
+	};
+
+	memset(&xprtargs, 0, sizeof(struct xprt_create));
+
+	//mount is not use multipath
+	if (client_info == NULL || enfs_option == NULL) {
+		enfs_log_error(
+		"mount information or remount information is empty.\n");
+		return -EINVAL;
+	}
+
+	//remount : localaddrs and remoteaddrs are empty
+	if (remount_lists->local_ip_list->count == 0 &&
+		remount_lists->remote_ip_list->count == 0) {
+		enfs_log_info("remount local_ip_list and remote_ip_list are NULL\n");
+		return 0;
+	}
+
+	errno = enfs_config_xprt_create_args(&xprtargs,
+		&args, servername, sizeof(servername));
+
+	if (errno) {
+		enfs_log_error("config_xprt_create failed! errno:%d\n", errno);
+		return errno;
+	}
+
+	if (remount_lists->local_ip_list->count == 0) {
+		if (client_info->local_ip_list->count == 0) {
+			errno = rpc_localaddr(nfs_client->cl_rpcclient,
+				(struct sockaddr *)
+				&remount_lists->local_ip_list->address[0],
+				sizeof(struct sockaddr_storage));
+			if (errno) {
+				enfs_log_error("get clnt srcaddr errno:%d\n",
+				errno);
+				return errno;
+			}
+			remount_lists->local_ip_list->count = 1;
+		} else
+			memcpy(remount_lists->local_ip_list,
+			client_info->local_ip_list,
+			sizeof(struct nfs_ip_list));
+	}
+
+	if (remount_lists->remote_ip_list->count == 0) {
+		if (client_info->remote_ip_list->count == 0) {
+			errno = rpc_peeraddr(nfs_client->cl_rpcclient,
+				(struct sockaddr *)
+				&remount_lists->remote_ip_list->address[0],
+				sizeof(struct sockaddr_storage));
+			if (errno == 0) {
+				enfs_log_error("get clnt dstaddr errno:%d\n",
+				errno);
+				return errno;
+			}
+			remount_lists->remote_ip_list->count = 1;
+		} else
+			memcpy(remount_lists->remote_ip_list,
+				client_info->remote_ip_list,
+				sizeof(struct nfs_ip_list));
+	}
+
+	enfs_log_info("Remount creating new links...\n");
+	enfs_xprt_ippair_create(&xprtargs,
+				nfs_client->cl_rpcclient,
+				remount_lists);
+
+	enfs_log_info("Remount deleting obsolete links...\n");
+	enfs_clnt_delete_obsolete_xprts(nfs_client, remount_lists);
+
+	memcpy(client_info->local_ip_list,
+		remount_lists->local_ip_list,
+		sizeof(struct nfs_ip_list));
+	memcpy(client_info->remote_ip_list,
+		remount_lists->remote_ip_list,
+		sizeof(struct nfs_ip_list));
+
+	return 0;
+}
diff --git a/fs/nfs/enfs/enfs_remount.h b/fs/nfs/enfs/enfs_remount.h
new file mode 100644
index 000000000000..a663ed257004
--- /dev/null
+++ b/fs/nfs/enfs/enfs_remount.h
@@ -0,0 +1,15 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (c) Huawei Technologies Co., Ltd. 2023-2023. All rights reserved.
+ * Description: remount ip header file
+ * Author: y00583252
+ * Create: 2023-08-12
+ */
+#ifndef _ENFS_REMOUNT_
+#define _ENFS_REMOUNT_
+#include <linux/string.h>
+#include "enfs.h"
+
+int enfs_remount_iplist(struct nfs_client *nfs_client, void *enfs_option);
+
+#endif
diff --git a/fs/nfs/enfs/enfs_roundrobin.c b/fs/nfs/enfs/enfs_roundrobin.c
new file mode 100644
index 000000000000..4e4eda784a3e
--- /dev/null
+++ b/fs/nfs/enfs/enfs_roundrobin.c
@@ -0,0 +1,255 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (c) Huawei Technologies Co., Ltd. 2023-2023. All rights reserved.
+ */
+#include <linux/spinlock.h>
+#include <linux/module.h>
+#include <linux/printk.h>
+#include <linux/kref.h>
+#include <linux/rculist.h>
+#include <linux/types.h>
+#include <linux/sunrpc/xprt.h>
+#include <linux/sunrpc/clnt.h>
+#include <linux/sunrpc/xprtmultipath.h>
+#include "enfs_roundrobin.h"
+
+#include "enfs.h"
+#include "enfs_config.h"
+#include "pm_state.h"
+
+typedef struct rpc_xprt *(*enfs_xprt_switch_find_xprt_t)(
+	struct rpc_xprt_switch *xps, const struct rpc_xprt *cur);
+static const struct rpc_xprt_iter_ops enfs_xprt_iter_roundrobin;
+static const struct rpc_xprt_iter_ops enfs_xprt_iter_singular;
+
+static bool enfs_xprt_is_active(struct rpc_xprt *xprt)
+{
+	enum pm_path_state state;
+
+	if (kref_read(&xprt->kref) <= 0)
+		return false;
+
+	state = pm_get_path_state(xprt);
+	if (state == PM_STATE_NORMAL)
+		return true;
+
+	return false;
+}
+
+static struct rpc_xprt *enfs_lb_set_cursor_xprt(
+	struct rpc_xprt_switch *xps, struct rpc_xprt **cursor,
+	enfs_xprt_switch_find_xprt_t find_next)
+{
+	struct rpc_xprt *pos;
+	struct rpc_xprt *old;
+
+	old = smp_load_acquire(cursor); /* read latest cursor */
+	pos = find_next(xps, old);
+	smp_store_release(cursor, pos); /* let cursor point to pos */
+	return pos;
+}
+
+static
+struct rpc_xprt *enfs_lb_find_next_entry_roundrobin(
+		struct rpc_xprt_switch *xps, const struct rpc_xprt *cur)
+{
+	struct rpc_xprt *pos;
+	struct rpc_xprt *prev = NULL;
+	bool found = false;
+	struct rpc_xprt *min_queuelen_xprt = NULL;
+	unsigned long pos_xprt_queuelen;
+	unsigned long min_xprt_queuelen = 0;
+
+	unsigned long xps_queuelen = atomic_long_read(&xps->xps_queuelen);
+	// delete origin xprt
+	unsigned int multipath_nactive = READ_ONCE(xps->xps_nactive) - 1;
+
+	list_for_each_entry_rcu(pos, &xps->xps_xprt_list, xprt_switch) {
+		if (enfs_is_main_xprt(pos) || !enfs_xprt_is_active(pos)) {
+			prev = pos;
+			continue;
+		}
+
+		pos_xprt_queuelen = atomic_long_read(&pos->queuelen);
+		if (min_queuelen_xprt == NULL ||
+			pos_xprt_queuelen < min_xprt_queuelen) {
+
+			min_queuelen_xprt = pos;
+			min_xprt_queuelen = pos_xprt_queuelen;
+		}
+
+		if (cur == prev)
+			found = true;
+
+		if (found && pos_xprt_queuelen *
+			multipath_nactive <= xps_queuelen)
+			return pos;
+		prev = pos;
+	};
+
+	return min_queuelen_xprt;
+}
+
+struct rpc_xprt *enfs_lb_switch_find_first_active_xprt(
+			struct rpc_xprt_switch *xps)
+{
+	struct rpc_xprt *pos;
+
+	list_for_each_entry_rcu(pos, &xps->xps_xprt_list, xprt_switch) {
+		if (enfs_xprt_is_active(pos))
+			return pos;
+	};
+	return NULL;
+}
+
+struct rpc_xprt *enfs_lb_switch_get_main_xprt(struct rpc_xprt_switch *xps)
+{
+	return list_first_or_null_rcu(&xps->xps_xprt_list,
+				struct rpc_xprt, xprt_switch);
+}
+
+static struct rpc_xprt *enfs_lb_switch_get_next_xprt_roundrobin(
+			struct rpc_xprt_switch *xps, const struct rpc_xprt *cur)
+{
+	struct rpc_xprt *xprt;
+
+	// disable multipath
+	if (enfs_get_config_multipath_state())
+		return enfs_lb_switch_get_main_xprt(xps);
+
+	xprt = enfs_lb_find_next_entry_roundrobin(xps, cur);
+	if (xprt != NULL)
+		return xprt;
+
+	return enfs_lb_switch_get_main_xprt(xps);
+}
+
+static
+struct rpc_xprt *enfs_lb_iter_next_entry_roundrobin(struct rpc_xprt_iter *xpi)
+{
+	struct rpc_xprt_switch *xps = rcu_dereference(xpi->xpi_xpswitch);
+
+	if (xps == NULL)
+		return NULL;
+
+	return enfs_lb_set_cursor_xprt(xps, &xpi->xpi_cursor,
+				enfs_lb_switch_get_next_xprt_roundrobin);
+}
+
+static
+struct rpc_xprt *enfs_lb_switch_find_singular_entry(
+			struct rpc_xprt_switch *xps, const struct rpc_xprt *cur)
+{
+	struct rpc_xprt *pos;
+	bool found = false;
+
+	list_for_each_entry_rcu(pos, &xps->xps_xprt_list, xprt_switch) {
+		if (cur == pos)
+			found = true;
+
+		if (found && enfs_xprt_is_active(pos))
+			return pos;
+	}
+	return NULL;
+}
+
+struct rpc_xprt *enfs_lb_get_singular_xprt(
+			struct rpc_xprt_switch *xps, const struct rpc_xprt *cur)
+{
+	struct rpc_xprt *xprt;
+
+	if (xps == NULL)
+		return NULL;
+
+	// disable multipath
+	if (enfs_get_config_multipath_state())
+		return enfs_lb_switch_get_main_xprt(xps);
+
+	if (cur == NULL || xps->xps_nxprts < 2)
+		return enfs_lb_switch_find_first_active_xprt(xps);
+
+	xprt = enfs_lb_switch_find_singular_entry(xps, cur);
+	if (!xprt)
+		return enfs_lb_switch_get_main_xprt(xps);
+
+	return xprt;
+}
+
+static
+struct rpc_xprt *enfs_lb_iter_next_entry_sigular(struct rpc_xprt_iter *xpi)
+{
+	struct rpc_xprt_switch *xps = rcu_dereference(xpi->xpi_xpswitch);
+
+	if (xps == NULL)
+		return NULL;
+
+	return enfs_lb_set_cursor_xprt(xps, &xpi->xpi_cursor,
+				enfs_lb_get_singular_xprt);
+}
+
+static void enfs_lb_iter_default_rewind(struct rpc_xprt_iter *xpi)
+{
+	WRITE_ONCE(xpi->xpi_cursor, NULL);
+}
+
+static void enfs_lb_switch_set_roundrobin(struct rpc_clnt *clnt)
+{
+	struct rpc_xprt_switch *xps;
+
+	rcu_read_lock();
+	xps = rcu_dereference(clnt->cl_xpi.xpi_xpswitch);
+	rcu_read_unlock();
+	if (clnt->cl_vers == 3) {
+
+		if (READ_ONCE(xps->xps_iter_ops) != &enfs_xprt_iter_roundrobin)
+			WRITE_ONCE(xps->xps_iter_ops,
+			&enfs_xprt_iter_roundrobin);
+
+		return;
+	}
+	if (READ_ONCE(xps->xps_iter_ops) != &enfs_xprt_iter_singular)
+		WRITE_ONCE(xps->xps_iter_ops, &enfs_xprt_iter_singular);
+}
+
+static
+struct rpc_xprt *enfs_lb_switch_find_current(struct list_head *head,
+			const struct rpc_xprt *cur)
+{
+	struct rpc_xprt *pos;
+
+	list_for_each_entry_rcu(pos, head, xprt_switch) {
+		if (cur == pos)
+			return pos;
+	}
+	return NULL;
+}
+
+static struct rpc_xprt *enfs_lb_iter_current_entry(struct rpc_xprt_iter *xpi)
+{
+	struct rpc_xprt_switch *xps = rcu_dereference(xpi->xpi_xpswitch);
+	struct list_head *head;
+
+	if (xps == NULL)
+		return NULL;
+	head = &xps->xps_xprt_list;
+	if (xpi->xpi_cursor == NULL || xps->xps_nxprts < 2)
+		return enfs_lb_switch_get_main_xprt(xps);
+	return enfs_lb_switch_find_current(head, xpi->xpi_cursor);
+}
+
+void enfs_lb_set_policy(struct rpc_clnt *clnt)
+{
+	enfs_lb_switch_set_roundrobin(clnt);
+}
+
+static const struct rpc_xprt_iter_ops enfs_xprt_iter_roundrobin = {
+	.xpi_rewind = enfs_lb_iter_default_rewind,
+	.xpi_xprt = enfs_lb_iter_current_entry,
+	.xpi_next = enfs_lb_iter_next_entry_roundrobin,
+};
+
+static const struct rpc_xprt_iter_ops enfs_xprt_iter_singular = {
+	.xpi_rewind = enfs_lb_iter_default_rewind,
+	.xpi_xprt = enfs_lb_iter_current_entry,
+	.xpi_next = enfs_lb_iter_next_entry_sigular,
+};
diff --git a/fs/nfs/enfs/enfs_roundrobin.h b/fs/nfs/enfs/enfs_roundrobin.h
new file mode 100644
index 000000000000..b72b088a6258
--- /dev/null
+++ b/fs/nfs/enfs/enfs_roundrobin.h
@@ -0,0 +1,9 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (c) Huawei Technologies Co., Ltd. 2023-2023. All rights reserved.
+ */
+#ifndef ENFS_ROUNDROBIN_H
+#define ENFS_ROUNDROBIN_H
+
+void enfs_lb_set_policy(struct rpc_clnt *clnt);
+#endif
