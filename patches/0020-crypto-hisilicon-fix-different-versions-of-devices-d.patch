From f28828d9b8b7171aa25f83cd9db9a95493db7c81 Mon Sep 17 00:00:00 2001
From: lauyarn <liuyang645@huawei.com>
Date: Tue, 14 Nov 2023 11:25:22 +0800
Subject: [PATCH] Subject: [PATCH] crypto: hisilicon - fix different versions
 of devices driver  compatibility issue

driver inclusion
category: feature
bugzilla: https://gitee.com/openeuler/kernel/issues/I8BFOM
CVE: NA

----------------------------------------------------------------------

In order to be compatible with devices of different versions, V1 in the
accelerator driver is now isolated, and other versions are the previous
V2 processing flow.

Signed-off-by: Liu Yang <liuyang645@huawei.com>
---
 drivers/crypto/hisilicon/hpre/hpre_main.c |  2 +-
 drivers/crypto/hisilicon/qm.c             | 70 +++++++++--------------
 drivers/crypto/hisilicon/qm.h             | 14 ++---
 drivers/crypto/hisilicon/rde/rde_main.c   | 12 +---
 drivers/crypto/hisilicon/sec2/sec_main.c  | 12 +---
 drivers/crypto/hisilicon/zip/zip_main.c   | 17 ++----
 6 files changed, 41 insertions(+), 86 deletions(-)

diff --git a/drivers/crypto/hisilicon/hpre/hpre_main.c b/drivers/crypto/hisilicon/hpre/hpre_main.c
index cbe8ea438fd2..8c71353cd4b5 100644
--- a/drivers/crypto/hisilicon/hpre/hpre_main.c
+++ b/drivers/crypto/hisilicon/hpre/hpre_main.c
@@ -840,7 +840,7 @@ static int hpre_pf_probe_init(struct hisi_qm *qm)
 {
 	int ret;
 
-	if (qm->ver != QM_HW_V2)
+	if (qm->ver == QM_HW_V1)
 		return -EINVAL;
 
 	qm->ctrl_q_num = HPRE_QUEUE_NUM_V2;
diff --git a/drivers/crypto/hisilicon/qm.c b/drivers/crypto/hisilicon/qm.c
index 25bb24b4c131..398d5bab439e 100644
--- a/drivers/crypto/hisilicon/qm.c
+++ b/drivers/crypto/hisilicon/qm.c
@@ -814,7 +814,7 @@ static int qm_irq_register(struct hisi_qm *qm)
 	if (ret)
 		return ret;
 
-	if (qm->ver == QM_HW_V2) {
+	if (qm->ver != QM_HW_V1) {
 		ret = request_irq(pci_irq_vector(pdev, QM_AEQ_EVENT_IRQ_VECTOR),
 				  qm_aeq_irq, IRQF_SHARED, qm->dev_name, qm);
 		if (ret)
@@ -845,13 +845,12 @@ static void qm_irq_unregister(struct hisi_qm *qm)
 
 	free_irq(pci_irq_vector(pdev, QM_EQ_EVENT_IRQ_VECTOR), qm);
 
-	if (qm->ver == QM_HW_V2) {
-		free_irq(pci_irq_vector(pdev, QM_AEQ_EVENT_IRQ_VECTOR), qm);
+	if (qm->ver == QM_HW_V1)
+		return;
 
-		if (qm->fun_type == QM_HW_PF)
-			free_irq(pci_irq_vector(pdev,
-				 QM_ABNORMAL_EVENT_IRQ_VECTOR), qm);
-	}
+	free_irq(pci_irq_vector(pdev, QM_AEQ_EVENT_IRQ_VECTOR), qm);
+	if (qm->fun_type == QM_HW_PF)
+		free_irq(pci_irq_vector(pdev, QM_ABNORMAL_EVENT_IRQ_VECTOR), qm);
 }
 
 static void qm_init_qp_status(struct hisi_qp *qp)
@@ -873,36 +872,26 @@ static void qm_vft_data_cfg(struct hisi_qm *qm, enum vft_type type, u32 base,
 	if (number > 0) {
 		switch (type) {
 		case SQC_VFT:
-			switch (qm->ver) {
-			case QM_HW_V1:
+			if (qm->ver == QM_HW_V1) {
 				tmp = QM_SQC_VFT_BUF_SIZE |
 				      QM_SQC_VFT_SQC_SIZE |
 				      QM_SQC_VFT_INDEX_NUMBER |
 				      QM_SQC_VFT_VALID |
 				      (u64)base << QM_SQC_VFT_START_SQN_SHIFT;
-				break;
-			case QM_HW_V2:
+				} else {
 				tmp = (u64)base << QM_SQC_VFT_START_SQN_SHIFT |
 				      QM_SQC_VFT_VALID |
 				      (u64)(number - 1) << QM_SQC_VFT_SQN_SHIFT;
-				break;
-			case QM_HW_UNKNOWN:
-				break;
 			}
 			break;
 		case CQC_VFT:
-			switch (qm->ver) {
-			case QM_HW_V1:
+			if (qm->ver == QM_HW_V1) {
 				tmp = QM_CQC_VFT_BUF_SIZE |
 				      QM_CQC_VFT_SQC_SIZE |
 				      QM_CQC_VFT_INDEX_NUMBER |
 				      QM_CQC_VFT_VALID;
-				break;
-			case QM_HW_V2:
+				} else {
 				tmp = QM_CQC_VFT_VALID;
-				break;
-			case QM_HW_UNKNOWN:
-				break;
 			}
 			break;
 		}
@@ -1850,7 +1839,7 @@ static int qm_sq_ctx_cfg(struct hisi_qp *qp, int qp_id, int pasid)
 	if (ver == QM_HW_V1) {
 		sqc.dw3 = cpu_to_le32(QM_MK_SQC_DW3_V1(0, 0, 0, qm->sqe_size));
 		sqc.w8 = cpu_to_le16(QM_Q_DEPTH - 1);
-	} else if (ver == QM_HW_V2) {
+	} else {
 		sqc.dw3 = cpu_to_le32(QM_MK_SQC_DW3_V2(qm->sqe_size));
 		sqc.w8 = 0; /* rand_qc */
 	}
@@ -1873,7 +1862,7 @@ static int qm_cq_ctx_cfg(struct hisi_qp *qp, int qp_id, int pasid)
 		cqc.dw3 = cpu_to_le32(QM_MK_CQC_DW3_V1(0, 0, 0,
 							QM_QC_CQE_SIZE));
 		cqc.w8 = cpu_to_le16(QM_Q_DEPTH - 1);
-	} else if (ver == QM_HW_V2) {
+	} else {
 		cqc.dw3 = cpu_to_le32(QM_MK_CQC_DW3_V2(QM_QC_CQE_SIZE));
 		cqc.w8 = 0; /* rand_qc */
 	}
@@ -2094,14 +2083,13 @@ static void hisi_qm_cache_wb(struct hisi_qm *qm)
 {
 	unsigned int val;
 
-	if (qm->ver == QM_HW_V2) {
-		writel(0x1, qm->io_base + QM_CACHE_WB_START);
-		if (readl_relaxed_poll_timeout(qm->io_base + QM_CACHE_WB_DONE,
-					       val, val & BIT(0), POLL_PERIOD,
-					       POLL_TIMEOUT))
-			dev_err(&qm->pdev->dev,
-				"QM writeback sqc cache fail!\n");
-	}
+	if (qm->ver == QM_HW_V1)
+		return;
+
+	writel(0x1, qm->io_base + QM_CACHE_WB_START);
+	if (readl_relaxed_poll_timeout(qm->io_base + QM_CACHE_WB_DONE,
+					    val, val & BIT(0), 10, 1000))
+		dev_err(&qm->pdev->dev, "QM writeback sqc cache fail!\n");
 }
 
 int hisi_qm_get_free_qp_num(struct hisi_qm *qm)
@@ -2202,12 +2190,12 @@ static int hisi_qm_uacce_mmap(struct uacce_queue *q,
 
 	switch (qfr->type) {
 	case UACCE_QFRT_MMIO:
-		if (qm->ver == QM_HW_V2) {
-			if (WARN_ON(sz > PAGE_SIZE * (QM_DOORBELL_PAGE_NR +
-				QM_V2_DOORBELL_OFFSET / PAGE_SIZE)))
+		if (qm->ver == QM_HW_V1) {
+			if (WARN_ON(sz > PAGE_SIZE * QM_DOORBELL_PAGE_NR))
 				return -EINVAL;
 		} else {
-			if (WARN_ON(sz > PAGE_SIZE * QM_DOORBELL_PAGE_NR))
+			if (WARN_ON(sz > PAGE_SIZE * (QM_DOORBELL_PAGE_NR +
+				QM_V2_DOORBELL_OFFSET / PAGE_SIZE)))
 				return -EINVAL;
 		}
 
@@ -2743,16 +2731,10 @@ int hisi_qm_init(struct hisi_qm *qm)
 	struct device *dev = &pdev->dev;
 	int ret;
 
-	switch (qm->ver) {
-	case QM_HW_V1:
+	if (qm->ver == QM_HW_V1)
 		qm->ops = &qm_hw_ops_v1;
-		break;
-	case QM_HW_V2:
+	else
 		qm->ops = &qm_hw_ops_v2;
-		break;
-	default:
-		return -EINVAL;
-	}
 
 	if (qm->use_uacce) {
 		dev_info(dev, "qm register to uacce\n");
@@ -2772,7 +2754,7 @@ int hisi_qm_init(struct hisi_qm *qm)
 		goto err_irq_register;
 
 	mutex_init(&qm->mailbox_lock);
-	if (qm->fun_type == QM_HW_VF && qm->ver == QM_HW_V2) {
+	if (qm->fun_type == QM_HW_VF && qm->ver != QM_HW_V1) {
 		/* v2 or v3 starts to support get vft by mailbox */
 		ret = hisi_qm_get_vft(qm, &qm->qp_base, &qm->qp_num);
 		if (ret)
diff --git a/drivers/crypto/hisilicon/qm.h b/drivers/crypto/hisilicon/qm.h
index 9f5e440d7396..89c0977ac81f 100644
--- a/drivers/crypto/hisilicon/qm.h
+++ b/drivers/crypto/hisilicon/qm.h
@@ -114,6 +114,7 @@ enum qm_hw_ver {
 	QM_HW_UNKNOWN = -1,
 	QM_HW_V1 = 0x20,
 	QM_HW_V2 = 0x21,
+	QM_HW_V3 = 0x30,
 };
 
 enum qm_fun_type {
@@ -398,7 +399,6 @@ static inline int q_num_set(const char *val, const struct kernel_param *kp,
 	struct pci_dev *pdev = pci_get_device(PCI_VENDOR_ID_HUAWEI,
 					      device, NULL);
 	u32 n, q_num;
-	u8 rev_id;
 	int ret;
 
 	if (!val)
@@ -409,17 +409,10 @@ static inline int q_num_set(const char *val, const struct kernel_param *kp,
 		pr_info("No device found currently, suppose queue number is %d\n",
 			q_num);
 	} else {
-		rev_id = pdev->revision;
-		switch (rev_id) {
-		case QM_HW_V1:
+		if (pdev->revision == QM_HW_V1)
 			q_num = QNUM_V1;
-			break;
-		case QM_HW_V2:
+		else
 			q_num = QNUM_V2;
-			break;
-		default:
-			return -EINVAL;
-		}
 	}
 
 	ret = kstrtou32(val, 10, &n);
@@ -487,6 +480,7 @@ static inline int hisi_qm_pre_init(struct hisi_qm *qm,
 	switch (pdev->revision) {
 	case QM_HW_V1:
 	case QM_HW_V2:
+	case QM_HW_V3:
 		qm->ver = pdev->revision;
 		break;
 	default:
diff --git a/drivers/crypto/hisilicon/rde/rde_main.c b/drivers/crypto/hisilicon/rde/rde_main.c
index f2e00ff891db..9fee21bfaed0 100644
--- a/drivers/crypto/hisilicon/rde/rde_main.c
+++ b/drivers/crypto/hisilicon/rde/rde_main.c
@@ -647,18 +647,10 @@ static int hisi_rde_pf_probe_init(struct hisi_qm *qm)
 	hisi_rde->ctrl = ctrl;
 	ctrl->hisi_rde = hisi_rde;
 
-	switch (qm->ver) {
-	case QM_HW_V1:
+	if (qm->ver == QM_HW_V1)
 		qm->ctrl_q_num = HRDE_QUEUE_NUM_V1;
-		break;
-
-	case QM_HW_V2:
+	else
 		qm->ctrl_q_num = HRDE_QUEUE_NUM_V2;
-		break;
-
-	default:
-		return -EINVAL;
-	}
 
 	ret = qm->err_ini.set_usr_domain_cache(qm);
 	if (ret)
diff --git a/drivers/crypto/hisilicon/sec2/sec_main.c b/drivers/crypto/hisilicon/sec2/sec_main.c
index 0f32dcb69e12..2f8dd6c30cb1 100644
--- a/drivers/crypto/hisilicon/sec2/sec_main.c
+++ b/drivers/crypto/hisilicon/sec2/sec_main.c
@@ -738,18 +738,10 @@ static int sec_pf_probe_init(struct hisi_qm *qm)
 {
 	int ret;
 
-	switch (qm->ver) {
-	case QM_HW_V1:
+	if (qm->ver == QM_HW_V1)
 		qm->ctrl_q_num = SEC_QUEUE_NUM_V1;
-		break;
-
-	case QM_HW_V2:
+	else
 		qm->ctrl_q_num = SEC_QUEUE_NUM_V2;
-		break;
-
-	default:
-		return -EINVAL;
-	}
 
 	ret = qm->err_ini.set_usr_domain_cache(qm);
 	if (ret)
diff --git a/drivers/crypto/hisilicon/zip/zip_main.c b/drivers/crypto/hisilicon/zip/zip_main.c
index 1ca51793e26a..34c62e990602 100644
--- a/drivers/crypto/hisilicon/zip/zip_main.c
+++ b/drivers/crypto/hisilicon/zip/zip_main.c
@@ -790,18 +790,10 @@ static int hisi_zip_pf_probe_init(struct hisi_qm *qm)
 	zip->ctrl = ctrl;
 	ctrl->hisi_zip = zip;
 
-	switch (qm->ver) {
-	case QM_HW_V1:
+	if (qm->ver == QM_HW_V1)
 		qm->ctrl_q_num = HZIP_QUEUE_NUM_V1;
-		break;
-
-	case QM_HW_V2:
+	else
 		qm->ctrl_q_num = HZIP_QUEUE_NUM_V2;
-		break;
-
-	default:
-		return -EINVAL;
-	}
 
 	ret = qm->err_ini.set_usr_domain_cache(qm);
 	if (ret)
@@ -818,7 +810,10 @@ static int hisi_zip_qm_pre_init(struct hisi_qm *qm, struct pci_dev *pdev)
 {
 	int ret;
 
-	qm->algs = "zlib\ngzip\nxts(sm4)\nxts(aes)\n";
+	if (pdev->revision >= QM_HW_V3)
+		qm->algs = "zlib\ngzip\nxts(sm4)\nxts(aes)\ndeflate\n";
+	else
+		qm->algs = "zlib\ngzip\nxts(sm4)\nxts(aes)\n";
 	qm->uacce_mode = uacce_mode;
 	qm->pdev = pdev;
 	ret = hisi_qm_pre_init(qm, pf_q_num, HZIP_PF_DEF_Q_BASE);
-- 
2.33.0

