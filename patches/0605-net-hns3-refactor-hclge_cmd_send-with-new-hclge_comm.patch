From 7900620e28e61fcd7d4970c6b649e292567363b8 Mon Sep 17 00:00:00 2001
From: Jie Wang <wangjie125@huawei.com>
Date: Wed, 12 Jan 2022 15:16:50 +0800
Subject: [PATCH 244/283] net: hns3: refactor hclge_cmd_send with new
 hclge_comm_cmd_send API

mainline inclusion
from mainline-v5.17-rc1
commit eaa5607db377a73e639162a459d8b125c6a67bfb
category: feature
bugzilla: https://gitee.com/src-openeuler/kernel/issues/I8EN49
CVE: NA

Reference: https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=eaa5607db377a73e639162a459d8b125c6a67bfb

----------------------------------------------------------------------

This patch firstly uses new hardware description struct hclge_comm_hw as
child member of hclge_hw and deletes the original child memebers of
hclge_hw. All the hclge_hw variables used in PF module is modified
according to the new hclge_hw.

Secondly hclge_cmd_send is refactored to use hclge_comm_cmd_send APIs. The
old functions called by hclge_cmd_send are deleted and hclge_cmd_send is
kept to avoid too many meaningless modifications.

Signed-off-by: Jie Wang <wangjie125@huawei.com>
Signed-off-by: Guangbin Huang <huangguangbin2@huawei.com>
Signed-off-by: David S. Miller <davem@davemloft.net>
Reviewed-by: Jian Shen <shenjian15@huawei.com>
Reviewed-by: Yue Haibing <yuehaibing@huawei.com>
Signed-off-by: Zheng Zengkai <zhengzengkai@huawei.com>
Signed-off-by: Xiaodong Li <lixiaodong67@huawei.com>

 Conflicts:
	drivers/net/ethernet/hisilicon/hns3/Makefile
	drivers/net/ethernet/hisilicon/hns3/hns3pf/hclge_cmd.c
	drivers/net/ethernet/hisilicon/hns3/hns3pf/hclge_cmd.h
	drivers/net/ethernet/hisilicon/hns3/hns3pf/hclge_main.c
	drivers/net/ethernet/hisilicon/hns3/hns3pf/hclge_main.h
---
 drivers/net/ethernet/hisilicon/hns3/Makefile  |   3 +-
 .../hisilicon/hns3/hns3_cae/hns3_cae_cmd.c    |  68 ++--
 .../hisilicon/hns3/hns3_cae/hns3_cae_qos.c    |  16 +-
 .../hisilicon/hns3/hns3_cae/hns3_cae_rss.c    |   6 +-
 .../hisilicon/hns3/hns3_cae/hns3_cae_stat.c   |  20 +-
 .../hisilicon/hns3/hns3pf/hclge_cmd.c         | 305 +++---------------
 .../hisilicon/hns3/hns3pf/hclge_cmd.h         |  75 +----
 .../hisilicon/hns3/hns3pf/hclge_main.c        |  65 ++--
 .../hisilicon/hns3/hns3pf/hclge_main.h        |   8 +-
 .../hisilicon/hns3/hns3pf/hclge_mbx.c         |  11 +-
 .../hisilicon/hns3/hns3pf/hclge_mdio.c        |   4 +-
 .../hisilicon/hns3/hns3pf/hclge_ptp.c         |   2 +-
 12 files changed, 160 insertions(+), 423 deletions(-)

diff --git a/drivers/net/ethernet/hisilicon/hns3/Makefile b/drivers/net/ethernet/hisilicon/hns3/Makefile
index 7ff21cdf43b9..95069b38ab65 100644
--- a/drivers/net/ethernet/hisilicon/hns3/Makefile
+++ b/drivers/net/ethernet/hisilicon/hns3/Makefile
@@ -42,7 +42,6 @@ HCLGE_OBJ = 	hns3pf/hclge_main.o \
 			hns3pf/hclge_ptp.o \
 			hns3pf/hclge_devlink.o
 
-
 HCLGE_OBJ_IT_MAIN	=	hns3_extension/hns3pf/hclge_main_it.o \
 				hns3_extension/hns3pf/hclge_sysfs.o
 obj-$(CONFIG_HNS3_HCLGE) += hclge.o
@@ -53,7 +52,7 @@ hclge-objs += hns3_common/hclge_comm_cmd.o
 hclge-$(CONFIG_HNS3_DCB) += hns3pf/hclge_dcb.o
 #### compile hclgevf.ko
 obj-$(CONFIG_HNS3_HCLGEVF) += hclgevf.o
-hclgevf-objs := hns3vf/hclgevf_main.o hns3vf/hclgevf_cmd.o hns3vf/hclgevf_mbx.o hns3vf/hclgevf_devlink.o
+hclgevf-objs := hns3vf/hclgevf_main.o hns3vf/hclgevf_cmd.o hns3vf/hclgevf_mbx.o hns3vf/hclgevf_devlink.o hns3_common/hclge_comm_cmd.o
 
 #### compile hns3_cae.ko
 #add rally code
diff --git a/drivers/net/ethernet/hisilicon/hns3/hns3_cae/hns3_cae_cmd.c b/drivers/net/ethernet/hisilicon/hns3/hns3_cae/hns3_cae_cmd.c
index 10ae1eee1ab9..203ee3135f9d 100644
--- a/drivers/net/ethernet/hisilicon/hns3/hns3_cae/hns3_cae_cmd.c
+++ b/drivers/net/ethernet/hisilicon/hns3/hns3_cae/hns3_cae_cmd.c
@@ -3,7 +3,7 @@
 
 #include "hns3_cae_cmd.h"
 
-static int hns3_cae_ring_space(struct hclge_cmq_ring *ring)
+static int hns3_cae_ring_space(struct hclge_comm_cmq_ring *ring)
 {
 	int ntu = ring->next_to_use;
 	int ntc = ring->next_to_clean;
@@ -12,7 +12,7 @@ static int hns3_cae_ring_space(struct hclge_cmq_ring *ring)
 	return ring->desc_num - used - 1;
 }
 
-static int is_valid_csq_clean_head(struct hclge_cmq_ring *ring, int head)
+static int is_valid_csq_clean_head(struct hclge_comm_cmq_ring *ring, int head)
 {
 	int ntu = ring->next_to_use;
 	int ntc = ring->next_to_clean;
@@ -51,29 +51,29 @@ static bool hns3_cae_is_special_opcode(u16 opcode)
 static int hns3_cae_cmd_convert_err_code(u16 desc_ret)
 {
 	switch (desc_ret) {
-	case HCLGE_CMD_EXEC_SUCCESS:
+	case HCLGE_COMM_CMD_EXEC_SUCCESS:
 		return 0;
-	case HCLGE_CMD_NO_AUTH:
+	case HCLGE_COMM_CMD_NO_AUTH:
 		return -EPERM;
-	case HCLGE_CMD_NOT_SUPPORTED:
+	case HCLGE_COMM_CMD_NOT_SUPPORTED:
 		return -EOPNOTSUPP;
-	case HCLGE_CMD_QUEUE_FULL:
+	case HCLGE_COMM_CMD_QUEUE_FULL:
 		return -EXFULL;
-	case HCLGE_CMD_NEXT_ERR:
+	case HCLGE_COMM_CMD_NEXT_ERR:
 		return -ENOSR;
-	case HCLGE_CMD_UNEXE_ERR:
+	case HCLGE_COMM_CMD_UNEXE_ERR:
 		return -ENOTBLK;
-	case HCLGE_CMD_PARA_ERR:
+	case HCLGE_COMM_CMD_PARA_ERR:
 		return -EINVAL;
-	case HCLGE_CMD_RESULT_ERR:
+	case HCLGE_COMM_CMD_RESULT_ERR:
 		return -ERANGE;
-	case HCLGE_CMD_TIMEOUT:
+	case HCLGE_COMM_CMD_TIMEOUT:
 		return -ETIME;
-	case HCLGE_CMD_HILINK_ERR:
+	case HCLGE_COMM_CMD_HILINK_ERR:
 		return -ENOLINK;
-	case HCLGE_CMD_QUEUE_ILLEGAL:
+	case HCLGE_COMM_CMD_QUEUE_ILLEGAL:
 		return -ENXIO;
-	case HCLGE_CMD_INVALID:
+	case HCLGE_COMM_CMD_INVALID:
 		return -EBADR;
 	default:
 		return -EIO;
@@ -84,13 +84,13 @@ static int hns3_cae_cmd_csq_done(struct hclge_hw *hw)
 {
 	u32 head = hclge_read_dev(hw, HCLGE_NIC_CSQ_HEAD_REG);
 
-	return head == hw->cmq.csq.next_to_use;
+	return head == hw->hw.cmq.csq.next_to_use;
 }
 
 static int hns3_cae_cmd_csq_clean(struct hclge_hw *hw)
 {
 	struct hclge_dev *hdev = container_of(hw, struct hclge_dev, hw);
-	struct hclge_cmq_ring *csq = &hw->cmq.csq;
+	struct hclge_comm_cmq_ring *csq = &hw->hw.cmq.csq;
 	int clean;
 	u32 head;
 
@@ -120,9 +120,9 @@ static int hns3_cae_cmd_check_retval(struct hclge_hw *hw,
 
 	opcode = le16_to_cpu(desc[0].opcode);
 	for (handle = 0; handle < num; handle++) {
-		desc[handle] = hw->cmq.csq.desc[ntc];
+		desc[handle] = hw->hw.cmq.csq.desc[ntc];
 		ntc++;
-		if (ntc >= hw->cmq.csq.desc_num)
+		if (ntc >= hw->hw.cmq.csq.desc_num)
 			ntc = 0;
 	}
 	if (likely(!hns3_cae_is_special_opcode(opcode)))
@@ -130,7 +130,7 @@ static int hns3_cae_cmd_check_retval(struct hclge_hw *hw,
 	else
 		desc_ret = le16_to_cpu(desc[0].retval);
 
-	hw->cmq.last_status = desc_ret;
+	hw->hw.cmq.last_status = desc_ret;
 
 	return hns3_cae_cmd_convert_err_code(desc_ret);
 }
@@ -167,28 +167,28 @@ void hns3_cae_cmd_setup_basic_desc(struct hclge_desc *desc,
 int hns3_cae_cmd_send(struct hclge_dev *hdev, struct hclge_desc *desc, int num)
 {
 	struct hclge_desc *desc_to_use = NULL;
-	struct hclge_cmq_ring *csq = NULL;
+	struct hclge_comm_cmq_ring *csq = NULL;
 	bool complete = false;
 	u32 timeout = 0;
 	int handle = 0;
 	int retval;
 	int ntc;
 
-	csq = &hdev->hw.cmq.csq;
-	spin_lock_bh(&hdev->hw.cmq.csq.lock);
+	csq = &hdev->hw.hw.cmq.csq;
+	spin_lock_bh(&hdev->hw.hw.cmq.csq.lock);
 
 	if (test_bit(HCLGE_STATE_CMD_DISABLE, &hdev->state)) {
-		spin_unlock_bh(&hdev->hw.cmq.csq.lock);
+		spin_unlock_bh(&hdev->hw.hw.cmq.csq.lock);
 		return -EBUSY;
 	}
 
-	if (num > hns3_cae_ring_space(&hdev->hw.cmq.csq)) {
+	if (num > hns3_cae_ring_space(&hdev->hw.hw.cmq.csq)) {
 		/* If CMDQ ring is full, SW HEAD and HW HEAD may be different,
 		 * need update the SW HEAD pointer csq->next_to_clean
 		 */
 		csq->next_to_clean = hclge_read_dev(&hdev->hw,
 						    HCLGE_NIC_CSQ_HEAD_REG);
-		spin_unlock_bh(&hdev->hw.cmq.csq.lock);
+		spin_unlock_bh(&hdev->hw.hw.cmq.csq.lock);
 		return -EBUSY;
 	}
 
@@ -196,26 +196,26 @@ int hns3_cae_cmd_send(struct hclge_dev *hdev, struct hclge_desc *desc, int num)
 	 * Record the location of desc in the ring for this time
 	 * which will be use for hardware to write back
 	 */
-	ntc = hdev->hw.cmq.csq.next_to_use;
+	ntc = hdev->hw.hw.cmq.csq.next_to_use;
 	while (handle < num) {
 		desc_to_use =
-			&hdev->hw.cmq.csq.desc[hdev->hw.cmq.csq.next_to_use];
+			&hdev->hw.hw.cmq.csq.desc[hdev->hw.hw.cmq.csq.next_to_use];
 		*desc_to_use = desc[handle];
-		(hdev->hw.cmq.csq.next_to_use)++;
-		if (hdev->hw.cmq.csq.next_to_use >= hdev->hw.cmq.csq.desc_num)
-			hdev->hw.cmq.csq.next_to_use = 0;
+		(hdev->hw.hw.cmq.csq.next_to_use)++;
+		if (hdev->hw.hw.cmq.csq.next_to_use >= hdev->hw.hw.cmq.csq.desc_num)
+			hdev->hw.hw.cmq.csq.next_to_use = 0;
 		handle++;
 	}
 
 	/* Write to hardware */
 	hclge_write_dev(&hdev->hw, HCLGE_NIC_CSQ_TAIL_REG,
-			hdev->hw.cmq.csq.next_to_use);
+			hdev->hw.hw.cmq.csq.next_to_use);
 
 	/**
 	 * If the command is sync, wait for the firmware to write back,
 	 * if multi descriptors to be sent, use the first one to check
 	 */
-	if (HCLGE_SEND_SYNC(le16_to_cpu(desc->flag))) {
+	if (HCLGE_COMM_SEND_SYNC(le16_to_cpu(desc->flag))) {
 		do {
 			if (hns3_cae_cmd_csq_done(&hdev->hw)) {
 				complete = true;
@@ -223,7 +223,7 @@ int hns3_cae_cmd_send(struct hclge_dev *hdev, struct hclge_desc *desc, int num)
 			}
 			udelay(1);
 			timeout++;
-		} while (timeout < hdev->hw.cmq.tx_timeout);
+		} while (timeout < hdev->hw.hw.cmq.tx_timeout);
 	}
 
 	if (!complete)
@@ -238,7 +238,7 @@ int hns3_cae_cmd_send(struct hclge_dev *hdev, struct hclge_desc *desc, int num)
 		dev_warn(&hdev->pdev->dev,
 			 "cleaned %d, need to clean %d\n", handle, num);
 
-	spin_unlock_bh(&hdev->hw.cmq.csq.lock);
+	spin_unlock_bh(&hdev->hw.hw.cmq.csq.lock);
 
 	return retval;
 }
diff --git a/drivers/net/ethernet/hisilicon/hns3/hns3_cae/hns3_cae_qos.c b/drivers/net/ethernet/hisilicon/hns3/hns3_cae/hns3_cae_qos.c
index fb872de05c97..4bbe8bbcfe03 100644
--- a/drivers/net/ethernet/hisilicon/hns3/hns3_cae/hns3_cae_qos.c
+++ b/drivers/net/ethernet/hisilicon/hns3/hns3_cae/hns3_cae_qos.c
@@ -21,7 +21,7 @@ int hns3_cmd_rx_priv_wl_config(struct hclge_dev *hdev, u16 tc,
 			       u32 high, u32 low, u32 en)
 {
 	struct hclge_rx_priv_wl_buf *req = NULL;
-	enum hclge_cmd_status status;
+	enum hclge_comm_cmd_status status;
 	struct hclge_desc desc[2];
 	int idx;
 	int i;
@@ -94,7 +94,7 @@ int hns3_cmd_common_thrd_config(struct hclge_dev *hdev, u16 tc,
 {
 #define HNS3_CAE_THRD_ALLOC_BD_NUM	2
 	struct hclge_rx_com_thrd *req = NULL;
-	enum hclge_cmd_status status;
+	enum hclge_comm_cmd_status status;
 	struct hclge_desc desc[2];
 	int idx;
 	int i;
@@ -166,7 +166,7 @@ int hns3_cae_common_thrd_cfg(const struct hns3_nic_priv *net_priv,
 
 int hns3_cmd_common_wl_config(struct hclge_dev *hdev, u32 high, u32 low, u32 en)
 {
-	enum hclge_cmd_status status;
+	enum hclge_comm_cmd_status status;
 	struct hclge_rx_com_wl *req = NULL;
 	struct hclge_desc desc;
 
@@ -196,7 +196,7 @@ int hns3_cae_common_wl_cfg(const struct hns3_nic_priv *net_priv,
 				    (struct hns3_rx_priv_buff_wl_param *)buf_in;
 	bool check = !buf_in ||
 		     in_size < sizeof(struct hns3_rx_priv_buff_wl_param);
-	enum hclge_cmd_status status;
+	enum hclge_comm_cmd_status status;
 	struct hclge_rx_com_wl *req = NULL;
 	struct hclge_vport *vport = NULL;
 	struct hclge_desc desc;
@@ -248,7 +248,7 @@ int hns3_cae_rx_buff_cfg(const struct hns3_nic_priv *net_priv,
 					   (struct hns3_rx_buff_param *)buf_out;
 	struct hns3_rx_buff_param *in_info =
 					    (struct hns3_rx_buff_param *)buf_in;
-	enum hclge_cmd_status status;
+	enum hclge_comm_cmd_status status;
 	struct hclge_vport *vport = NULL;
 	struct hclge_dev *hdev = NULL;
 	struct hclge_desc desc;
@@ -293,7 +293,7 @@ int hns3_cae_tx_buff_cfg(const struct hns3_nic_priv *net_priv,
 					   (struct hns3_tx_buff_param *)buf_out;
 	struct hns3_tx_buff_param *in_info =
 					    (struct hns3_tx_buff_param *)buf_in;
-	enum hclge_cmd_status status;
+	enum hclge_comm_cmd_status status;
 	struct hclge_vport *vport = NULL;
 	struct hclge_desc desc;
 	struct hclge_dev *hdev = NULL;
@@ -335,7 +335,7 @@ int hns3_cae_show_comm_thres(const struct hns3_nic_priv *net_priv,
 	struct hns3_total_priv_wl_param *out_info =
 				     (struct hns3_total_priv_wl_param *)buf_out;
 	struct hclge_rx_com_thrd *req = NULL;
-	enum hclge_cmd_status status;
+	enum hclge_comm_cmd_status status;
 	struct hclge_desc desc[2];
 	bool check = !buf_out ||
 		     out_size < sizeof(struct hns3_total_priv_wl_param);
@@ -386,7 +386,7 @@ int hns3_cae_show_rx_priv_wl(const struct hns3_nic_priv *net_priv,
 	struct hns3_total_priv_wl_param *out_info =
 				     (struct hns3_total_priv_wl_param *)buf_out;
 	struct hclge_rx_priv_wl_buf *req = NULL;
-	enum hclge_cmd_status status;
+	enum hclge_comm_cmd_status status;
 	struct hclge_desc desc[2];
 	bool check = !buf_out ||
 		     out_size < sizeof(struct hns3_total_priv_wl_param);
diff --git a/drivers/net/ethernet/hisilicon/hns3/hns3_cae/hns3_cae_rss.c b/drivers/net/ethernet/hisilicon/hns3/hns3_cae/hns3_cae_rss.c
index f263156bc547..e62f8585d7ec 100644
--- a/drivers/net/ethernet/hisilicon/hns3/hns3_cae/hns3_cae_rss.c
+++ b/drivers/net/ethernet/hisilicon/hns3/hns3_cae/hns3_cae_rss.c
@@ -23,7 +23,7 @@ static int hclge_set_rss_algo_key(struct hclge_dev *hdev,
 				  const u8 hfunc, const u8 *key)
 {
 	struct hclge_rss_config_cmd *req = NULL;
-	enum hclge_cmd_status status;
+	enum hclge_comm_cmd_status status;
 	struct hclge_desc desc;
 	int key_offset;
 	int key_size;
@@ -64,7 +64,7 @@ static int hns3_cae_set_rss_cfg(const struct hns3_nic_priv *net_priv,
 	struct hclge_vport *vport = hns3_cae_get_vport(net_priv->ae_handle);
 	struct hclge_dev *hdev = vport->back;
 	u8 *key = vport->rss_hash_key;
-	enum hclge_cmd_status status;
+	enum hclge_comm_cmd_status status;
 	u8 hash_config;
 
 	if (check) {
@@ -93,7 +93,7 @@ static int hns3_cae_get_rss_cfg(const struct hns3_nic_priv *net_priv,
 	bool check = !buf_out || out_size < sizeof(u8);
 	struct hclge_rss_config_cmd *req = NULL;
 	struct hclge_dev *hdev = vport->back;
-	enum hclge_cmd_status status;
+	enum hclge_comm_cmd_status status;
 	u8 *out_buf = (u8 *)buf_out;
 	struct hclge_desc desc;
 
diff --git a/drivers/net/ethernet/hisilicon/hns3/hns3_cae/hns3_cae_stat.c b/drivers/net/ethernet/hisilicon/hns3/hns3_cae/hns3_cae_stat.c
index 684d72953c30..fe68f6908224 100644
--- a/drivers/net/ethernet/hisilicon/hns3/hns3_cae/hns3_cae_stat.c
+++ b/drivers/net/ethernet/hisilicon/hns3/hns3_cae/hns3_cae_stat.c
@@ -30,7 +30,7 @@ static int hns3_get_stat_val(struct ring_stats *r_stats, char *val_name,
 
 	if (!r_stats || !val_name || !val || strlen(val_name) >= max_name_len) {
 		pr_info("%s param is null.\n", __func__);
-		return HCLGE_ERR_CSQ_ERROR;
+		return HCLGE_COMM_ERR_CSQ_ERROR;
 	}
 
 	*val = NULL;
@@ -92,10 +92,10 @@ static int hns3_get_stat_val(struct ring_stats *r_stats, char *val_name,
 		break;
 	default:
 		pr_info("val name [%s] is not existed.\n", val_name);
-		return HCLGE_ERR_CSQ_ERROR;
+		return HCLGE_COMM_ERR_CSQ_ERROR;
 	}
 
-	return HCLGE_STATUS_SUCCESS;
+	return HCLGE_COMM_STATUS_SUCCESS;
 }
 
 static int hns3_read_stat_mode_cfg(const struct hns3_nic_priv *nic_dev,
@@ -119,7 +119,7 @@ static int hns3_read_stat_mode_cfg(const struct hns3_nic_priv *nic_dev,
 	stat_sw_param = (struct stat_sw_mode_param *)buf_in;
 	if (!buf_out || out_size < sizeof(u64)) {
 		dev_err(&hdev->pdev->dev, "Get stat buf out is null.\n");
-		return HCLGE_ERR_CSQ_ERROR;
+		return HCLGE_COMM_ERR_CSQ_ERROR;
 	}
 
 	ring_idx = stat_sw_param->ring_idx;
@@ -127,7 +127,7 @@ static int hns3_read_stat_mode_cfg(const struct hns3_nic_priv *nic_dev,
 		dev_err(&hdev->pdev->dev,
 			"Get stat ring_idx[%d] >= num_tqps[%d].\n", ring_idx,
 			kinfo->num_tqps);
-		return HCLGE_ERR_CSQ_ERROR;
+		return HCLGE_COMM_ERR_CSQ_ERROR;
 	}
 
 	if (stat_sw_param->is_rx)
@@ -139,12 +139,12 @@ static int hns3_read_stat_mode_cfg(const struct hns3_nic_priv *nic_dev,
 	if (ret || !val) {
 		pr_info("get stat val name [%s] error.\n",
 			stat_sw_param->val_name);
-		return HCLGE_ERR_CSQ_ERROR;
+		return HCLGE_COMM_ERR_CSQ_ERROR;
 	}
 
 	*ret_data = le64_to_cpu(*val);
 
-	return HCLGE_STATUS_SUCCESS;
+	return HCLGE_COMM_STATUS_SUCCESS;
 }
 
 static int hns3_set_stat_mode_cfg(const struct hns3_nic_priv *nic_dev,
@@ -170,7 +170,7 @@ static int hns3_set_stat_mode_cfg(const struct hns3_nic_priv *nic_dev,
 		dev_err(&hdev->pdev->dev,
 			"Set stat ring_idx[%d] >= num_tqps[%d].\n", ring_idx,
 			kinfo->num_tqps);
-		return HCLGE_ERR_CSQ_ERROR;
+		return HCLGE_COMM_ERR_CSQ_ERROR;
 	}
 
 	if (stat_sw_param->is_rx)
@@ -182,12 +182,12 @@ static int hns3_set_stat_mode_cfg(const struct hns3_nic_priv *nic_dev,
 	if (ret || !val) {
 		pr_info("Set stat val name [%s] error.\n",
 			stat_sw_param->val_name);
-		return HCLGE_ERR_CSQ_ERROR;
+		return HCLGE_COMM_ERR_CSQ_ERROR;
 	}
 
 	*val = cpu_to_le64(stat_sw_param->data);
 
-	return HCLGE_STATUS_SUCCESS;
+	return HCLGE_COMM_STATUS_SUCCESS;
 }
 
 int hns3_stat_mode_cfg(const struct hns3_nic_priv *nic_dev,
diff --git a/drivers/net/ethernet/hisilicon/hns3/hns3pf/hclge_cmd.c b/drivers/net/ethernet/hisilicon/hns3/hns3pf/hclge_cmd.c
index 6d9c3945328a..dc73c90605dc 100644
--- a/drivers/net/ethernet/hisilicon/hns3/hns3pf/hclge_cmd.c
+++ b/drivers/net/ethernet/hisilicon/hns3/hns3pf/hclge_cmd.c
@@ -12,29 +12,7 @@
 #include "hnae3.h"
 #include "hclge_main.h"
 
-#define cmq_ring_to_dev(ring)   (&(ring)->dev->pdev->dev)
-
-static int hclge_ring_space(struct hclge_cmq_ring *ring)
-{
-	int ntu = ring->next_to_use;
-	int ntc = ring->next_to_clean;
-	int used = (ntu - ntc + ring->desc_num) % ring->desc_num;
-
-	return ring->desc_num - used - 1;
-}
-
-static int is_valid_csq_clean_head(struct hclge_cmq_ring *ring, int head)
-{
-	int ntu = ring->next_to_use;
-	int ntc = ring->next_to_clean;
-
-	if (ntu > ntc)
-		return head >= ntc && head <= ntu;
-
-	return head >= ntc || head <= ntu;
-}
-
-static int hclge_alloc_cmd_desc(struct hclge_cmq_ring *ring)
+static int hclge_alloc_cmd_desc(struct hclge_comm_cmq_ring *ring)
 {
 	int size  = ring->desc_num * sizeof(struct hclge_desc);
 
@@ -47,12 +25,12 @@ static int hclge_alloc_cmd_desc(struct hclge_cmq_ring *ring)
 	return 0;
 }
 
-static void hclge_free_cmd_desc(struct hclge_cmq_ring *ring)
+static void hclge_free_cmd_desc(struct hclge_comm_cmq_ring *ring)
 {
 	int size  = ring->desc_num * sizeof(struct hclge_desc);
 
 	if (ring->desc) {
-		dma_free_coherent(cmq_ring_to_dev(ring), size,
+		dma_free_coherent(&ring->pdev->dev, size,
 				  ring->desc, ring->desc_dma_addr);
 		ring->desc = NULL;
 	}
@@ -61,12 +39,13 @@ static void hclge_free_cmd_desc(struct hclge_cmq_ring *ring)
 static int hclge_alloc_cmd_queue(struct hclge_dev *hdev, int ring_type)
 {
 	struct hclge_hw *hw = &hdev->hw;
-	struct hclge_cmq_ring *ring =
-		(ring_type == HCLGE_TYPE_CSQ) ? &hw->cmq.csq : &hw->cmq.crq;
+	struct hclge_comm_cmq_ring *ring =
+		(ring_type == HCLGE_TYPE_CSQ) ? &hw->hw.cmq.csq :
+						&hw->hw.cmq.crq;
 	int ret;
 
 	ring->ring_type = ring_type;
-	ring->dev = hdev;
+	ring->pdev = hdev->pdev;
 
 	ret = hclge_alloc_cmd_desc(ring);
 	if (ret) {
@@ -98,11 +77,10 @@ void hclge_cmd_setup_basic_desc(struct hclge_desc *desc,
 		desc->flag |= cpu_to_le16(HCLGE_CMD_FLAG_WR);
 }
 
-static void hclge_cmd_config_regs(struct hclge_cmq_ring *ring)
+static void hclge_cmd_config_regs(struct hclge_hw *hw,
+				  struct hclge_comm_cmq_ring *ring)
 {
 	dma_addr_t dma = ring->desc_dma_addr;
-	struct hclge_dev *hdev = ring->dev;
-	struct hclge_hw *hw = &hdev->hw;
 	u32 reg_val;
 
 	if (ring->ring_type == HCLGE_TYPE_CSQ) {
@@ -144,174 +122,8 @@ static void hclge_cmd_clear_regs(struct hclge_hw *hw)
 
 static void hclge_cmd_init_regs(struct hclge_hw *hw)
 {
-	hclge_cmd_config_regs(&hw->cmq.csq);
-	hclge_cmd_config_regs(&hw->cmq.crq);
-}
-
-static int hclge_cmd_csq_clean(struct hclge_hw *hw)
-{
-	struct hclge_dev *hdev = container_of(hw, struct hclge_dev, hw);
-	struct hclge_cmq_ring *csq = &hw->cmq.csq;
-	u32 head;
-	int clean;
-
-	head = hclge_read_dev(hw, HCLGE_NIC_CSQ_HEAD_REG);
-	rmb(); /* Make sure head is ready before touch any data */
-
-	if (!is_valid_csq_clean_head(csq, head)) {
-		dev_warn(&hdev->pdev->dev, "wrong cmd head (%u, %d-%d)\n", head,
-			 csq->next_to_use, csq->next_to_clean);
-		dev_warn(&hdev->pdev->dev,
-			 "Disabling any further commands to IMP firmware\n");
-		set_bit(HCLGE_STATE_CMD_DISABLE, &hdev->state);
-		dev_warn(&hdev->pdev->dev,
-			 "IMP firmware watchdog reset soon expected!\n");
-		return -EIO;
-	}
-
-	clean = (head - csq->next_to_clean + csq->desc_num) % csq->desc_num;
-	csq->next_to_clean = head;
-	return clean;
-}
-
-static int hclge_cmd_csq_done(struct hclge_hw *hw)
-{
-	u32 head = hclge_read_dev(hw, HCLGE_NIC_CSQ_HEAD_REG);
-	return head == hw->cmq.csq.next_to_use;
-}
-
-static bool hclge_is_special_opcode(u16 opcode)
-{
-	/* these commands have several descriptors,
-	 * and use the first one to save opcode and return value
-	 */
-	u16 spec_opcode[] = {HCLGE_OPC_STATS_64_BIT,
-			     HCLGE_OPC_STATS_32_BIT,
-			     HCLGE_OPC_STATS_MAC,
-			     HCLGE_OPC_STATS_MAC_ALL,
-			     HCLGE_OPC_QUERY_32_BIT_REG,
-			     HCLGE_OPC_QUERY_64_BIT_REG,
-			     HCLGE_QUERY_CLEAR_MPF_RAS_INT,
-			     HCLGE_QUERY_CLEAR_PF_RAS_INT,
-			     HCLGE_QUERY_CLEAR_ALL_MPF_MSIX_INT,
-			     HCLGE_QUERY_CLEAR_ALL_PF_MSIX_INT,
-			     HCLGE_QUERY_ALL_ERR_INFO};
-	int i;
-
-	for (i = 0; i < ARRAY_SIZE(spec_opcode); i++) {
-		if (spec_opcode[i] == opcode)
-			return true;
-	}
-
-	return false;
-}
-
-struct errcode {
-	u32 imp_errcode;
-	int common_errno;
-};
-
-static void hclge_cmd_copy_desc(struct hclge_hw *hw, struct hclge_desc *desc,
-				int num)
-{
-	struct hclge_desc *desc_to_use;
-	int handle = 0;
-
-	while (handle < num) {
-		desc_to_use = &hw->cmq.csq.desc[hw->cmq.csq.next_to_use];
-		*desc_to_use = desc[handle];
-		(hw->cmq.csq.next_to_use)++;
-		if (hw->cmq.csq.next_to_use >= hw->cmq.csq.desc_num)
-			hw->cmq.csq.next_to_use = 0;
-		handle++;
-	}
-}
-
-static int hclge_cmd_convert_err_code(u16 desc_ret)
-{
-	struct errcode hclge_cmd_errcode[] = {
-		{HCLGE_CMD_EXEC_SUCCESS, 0},
-		{HCLGE_CMD_NO_AUTH, -EPERM},
-		{HCLGE_CMD_NOT_SUPPORTED, -EOPNOTSUPP},
-		{HCLGE_CMD_QUEUE_FULL, -EXFULL},
-		{HCLGE_CMD_NEXT_ERR, -ENOSR},
-		{HCLGE_CMD_UNEXE_ERR, -ENOTBLK},
-		{HCLGE_CMD_PARA_ERR, -EINVAL},
-		{HCLGE_CMD_RESULT_ERR, -ERANGE},
-		{HCLGE_CMD_TIMEOUT, -ETIME},
-		{HCLGE_CMD_HILINK_ERR, -ENOLINK},
-		{HCLGE_CMD_QUEUE_ILLEGAL, -ENXIO},
-		{HCLGE_CMD_INVALID, -EBADR},
-	};
-	u32 errcode_count = ARRAY_SIZE(hclge_cmd_errcode);
-	u32 i;
-
-	for (i = 0; i < errcode_count; i++)
-		if (hclge_cmd_errcode[i].imp_errcode == desc_ret)
-			return hclge_cmd_errcode[i].common_errno;
-
-	return -EIO;
-}
-
-static int hclge_cmd_check_retval(struct hclge_hw *hw, struct hclge_desc *desc,
-				  int num, int ntc)
-{
-	u16 opcode, desc_ret;
-	int handle;
-
-	opcode = le16_to_cpu(desc[0].opcode);
-	for (handle = 0; handle < num; handle++) {
-		desc[handle] = hw->cmq.csq.desc[ntc];
-		ntc++;
-		if (ntc >= hw->cmq.csq.desc_num)
-			ntc = 0;
-	}
-	if (likely(!hclge_is_special_opcode(opcode)))
-		desc_ret = le16_to_cpu(desc[num - 1].retval);
-	else
-		desc_ret = le16_to_cpu(desc[0].retval);
-
-	hw->cmq.last_status = desc_ret;
-
-	return hclge_cmd_convert_err_code(desc_ret);
-}
-
-static int hclge_cmd_check_result(struct hclge_hw *hw, struct hclge_desc *desc,
-				  int num, int ntc)
-{
-	struct hclge_dev *hdev = container_of(hw, struct hclge_dev, hw);
-	bool is_completed = false;
-	u32 timeout = 0;
-	int handle, ret;
-
-	/**
-	 * If the command is sync, wait for the firmware to write back,
-	 * if multi descriptors to be sent, use the first one to check
-	 */
-	if (HCLGE_SEND_SYNC(le16_to_cpu(desc->flag))) {
-		do {
-			if (hclge_cmd_csq_done(hw)) {
-				is_completed = true;
-				break;
-			}
-			udelay(1);
-			timeout++;
-		} while (timeout < hw->cmq.tx_timeout);
-	}
-
-	if (!is_completed)
-		ret = -EBADE;
-	else
-		ret = hclge_cmd_check_retval(hw, desc, num, ntc);
-
-	/* Clean the command send queue */
-	handle = hclge_cmd_csq_clean(hw);
-	if (handle < 0)
-		ret = handle;
-	else if (handle != num)
-		dev_warn(&hdev->pdev->dev,
-			 "cleaned %d, need to clean %d\n", handle, num);
-	return ret;
+	hclge_cmd_config_regs(hw, &hw->hw.cmq.csq);
+	hclge_cmd_config_regs(hw, &hw->hw.cmq.crq);
 }
 
 /**
@@ -325,43 +137,7 @@ static int hclge_cmd_check_result(struct hclge_hw *hw, struct hclge_desc *desc,
  **/
 int hclge_cmd_send(struct hclge_hw *hw, struct hclge_desc *desc, int num)
 {
-	struct hclge_dev *hdev = container_of(hw, struct hclge_dev, hw);
-	struct hclge_cmq_ring *csq = &hw->cmq.csq;
-	int ret;
-	int ntc;
-
-	spin_lock_bh(&hw->cmq.csq.lock);
-
-	if (test_bit(HCLGE_STATE_CMD_DISABLE, &hdev->state)) {
-		spin_unlock_bh(&hw->cmq.csq.lock);
-		return -EBUSY;
-	}
-
-	if (num > hclge_ring_space(&hw->cmq.csq)) {
-		/* If CMDQ ring is full, SW HEAD and HW HEAD may be different,
-		 * need update the SW HEAD pointer csq->next_to_clean
-		 */
-		csq->next_to_clean = hclge_read_dev(hw, HCLGE_NIC_CSQ_HEAD_REG);
-		spin_unlock_bh(&hw->cmq.csq.lock);
-		return -EBUSY;
-	}
-
-	/**
-	 * Record the location of desc in the ring for this time
-	 * which will be use for hardware to write back
-	 */
-	ntc = hw->cmq.csq.next_to_use;
-
-	hclge_cmd_copy_desc(hw, desc, num);
-
-	/* Write to hardware */
-	hclge_write_dev(hw, HCLGE_NIC_CSQ_TAIL_REG, hw->cmq.csq.next_to_use);
-
-	ret = hclge_cmd_check_result(hw, desc, num, ntc);
-
-	spin_unlock_bh(&hw->cmq.csq.lock);
-
-	return ret;
+	return hclge_comm_cmd_send(&hw->hw, desc, num);
 }
 
 static void hclge_set_default_capability(struct hclge_dev *hdev)
@@ -403,7 +179,7 @@ static void hclge_parse_capability(struct hclge_dev *hdev,
 				ae_dev->caps);
 }
 
-static enum hclge_cmd_status
+static enum hclge_comm_cmd_status
 hclge_cmd_query_version_and_capability(struct hclge_dev *hdev)
 {
 	struct hnae3_ae_dev *ae_dev = pci_get_drvdata(hdev->pdev);
@@ -434,11 +210,15 @@ hclge_cmd_query_version_and_capability(struct hclge_dev *hdev)
 
 int hclge_cmd_queue_init(struct hclge_dev *hdev)
 {
+	struct hclge_comm_cmq *cmdq = &hdev->hw.hw.cmq;
 	int ret;
 
 	/* Setup the lock for command queue */
-	spin_lock_init(&hdev->hw.cmq.csq.lock);
-	spin_lock_init(&hdev->hw.cmq.crq.lock);
+	spin_lock_init(&cmdq->csq.lock);
+	spin_lock_init(&cmdq->crq.lock);
+
+	cmdq->csq.pdev = hdev->pdev;
+	cmdq->crq.pdev = hdev->pdev;
 
 	/* clear up all command register,
 	 * in case there are some residual values
@@ -446,11 +226,11 @@ int hclge_cmd_queue_init(struct hclge_dev *hdev)
 	hclge_cmd_clear_regs(&hdev->hw);
 
 	/* Setup the queue entries for use cmd queue */
-	hdev->hw.cmq.csq.desc_num = HCLGE_NIC_CMQ_DESC_NUM;
-	hdev->hw.cmq.crq.desc_num = HCLGE_NIC_CMQ_DESC_NUM;
+	cmdq->csq.desc_num = HCLGE_NIC_CMQ_DESC_NUM;
+	cmdq->crq.desc_num = HCLGE_NIC_CMQ_DESC_NUM;
 
 	/* Setup Tx write back timeout */
-	hdev->hw.cmq.tx_timeout = HCLGE_CMDQ_TX_TIMEOUT;
+	cmdq->tx_timeout = HCLGE_CMDQ_TX_TIMEOUT;
 
 	/* Setup queue rings */
 	ret = hclge_alloc_cmd_queue(hdev, HCLGE_TYPE_CSQ);
@@ -469,7 +249,7 @@ int hclge_cmd_queue_init(struct hclge_dev *hdev)
 
 	return 0;
 err_csq:
-	hclge_free_cmd_desc(&hdev->hw.cmq.csq);
+	hclge_free_cmd_desc(&hdev->hw.hw.cmq.csq);
 	return ret;
 }
 
@@ -500,22 +280,23 @@ static int hclge_firmware_compat_config(struct hclge_dev *hdev, bool en)
 
 int hclge_cmd_init(struct hclge_dev *hdev)
 {
+	struct hclge_comm_cmq *cmdq = &hdev->hw.hw.cmq;
 	int ret;
 
-	spin_lock_bh(&hdev->hw.cmq.csq.lock);
-	spin_lock(&hdev->hw.cmq.crq.lock);
+	spin_lock_bh(&cmdq->csq.lock);
+	spin_lock(&cmdq->crq.lock);
 
-	hdev->hw.cmq.csq.next_to_clean = 0;
-	hdev->hw.cmq.csq.next_to_use = 0;
-	hdev->hw.cmq.crq.next_to_clean = 0;
-	hdev->hw.cmq.crq.next_to_use = 0;
+	cmdq->csq.next_to_clean = 0;
+	cmdq->csq.next_to_use = 0;
+	cmdq->crq.next_to_clean = 0;
+	cmdq->crq.next_to_use = 0;
 
 	hclge_cmd_init_regs(&hdev->hw);
 
-	spin_unlock(&hdev->hw.cmq.crq.lock);
-	spin_unlock_bh(&hdev->hw.cmq.csq.lock);
+	spin_unlock(&cmdq->crq.lock);
+	spin_unlock_bh(&cmdq->csq.lock);
 
-	clear_bit(HCLGE_STATE_CMD_DISABLE, &hdev->state);
+	clear_bit(HCLGE_COMM_STATE_CMD_DISABLE, &hdev->hw.hw.comm_state);
 
 	/* Check if there is new reset pending, because the higher level
 	 * reset may happen when lower level reset is being processed.
@@ -559,26 +340,30 @@ int hclge_cmd_init(struct hclge_dev *hdev)
 	return 0;
 
 err_cmd_init:
-	set_bit(HCLGE_STATE_CMD_DISABLE, &hdev->state);
+	set_bit(HCLGE_COMM_STATE_CMD_DISABLE, &hdev->hw.hw.comm_state);
 
 	return ret;
 }
 
 void hclge_cmd_uninit(struct hclge_dev *hdev)
 {
+	struct hclge_comm_cmq *cmdq = &hdev->hw.hw.cmq;
+
+	cmdq->csq.pdev = hdev->pdev;
+
 	hclge_firmware_compat_config(hdev, false);
 
-	set_bit(HCLGE_STATE_CMD_DISABLE, &hdev->state);
+	set_bit(HCLGE_COMM_STATE_CMD_DISABLE, &hdev->hw.hw.comm_state);
 	/* wait to ensure that the firmware completes the possible left
 	 * over commands.
 	 */
 	msleep(HCLGE_CMDQ_CLEAR_WAIT_TIME);
-	spin_lock_bh(&hdev->hw.cmq.csq.lock);
-	spin_lock(&hdev->hw.cmq.crq.lock);
+	spin_lock_bh(&cmdq->csq.lock);
+	spin_lock(&cmdq->crq.lock);
 	hclge_cmd_clear_regs(&hdev->hw);
-	spin_unlock(&hdev->hw.cmq.crq.lock);
-	spin_unlock_bh(&hdev->hw.cmq.csq.lock);
+	spin_unlock(&cmdq->crq.lock);
+	spin_unlock_bh(&cmdq->csq.lock);
 
-	hclge_free_cmd_desc(&hdev->hw.cmq.csq);
-	hclge_free_cmd_desc(&hdev->hw.cmq.crq);
+	hclge_free_cmd_desc(&cmdq->csq);
+	hclge_free_cmd_desc(&cmdq->crq);
 }
diff --git a/drivers/net/ethernet/hisilicon/hns3/hns3pf/hclge_cmd.h b/drivers/net/ethernet/hisilicon/hns3/hns3pf/hclge_cmd.h
index 8d1914041bd1..1a980ba5e59d 100644
--- a/drivers/net/ethernet/hisilicon/hns3/hns3pf/hclge_cmd.h
+++ b/drivers/net/ethernet/hisilicon/hns3/hns3pf/hclge_cmd.h
@@ -11,63 +11,18 @@
 
 #define HCLGE_CMDQ_TX_TIMEOUT		30000
 #define HCLGE_CMDQ_CLEAR_WAIT_TIME	200
-#define HCLGE_DESC_DATA_LEN		6
 
 struct hclge_dev;
 
 #define HCLGE_CMDQ_RX_INVLD_B		0
 #define HCLGE_CMDQ_RX_OUTVLD_B		1
 
-struct hclge_cmq_ring {
-	dma_addr_t desc_dma_addr;
-	struct hclge_desc *desc;
-	struct hclge_dev *dev;
-	u32 head;
-	u32 tail;
-
-	u16 buf_size;
-	u16 desc_num;
-	int next_to_use;
-	int next_to_clean;
-	u8 ring_type; /* cmq ring type */
-	spinlock_t lock; /* Command queue lock */
-};
-
-enum hclge_cmd_return_status {
-	HCLGE_CMD_EXEC_SUCCESS	= 0,
-	HCLGE_CMD_NO_AUTH	= 1,
-	HCLGE_CMD_NOT_SUPPORTED	= 2,
-	HCLGE_CMD_QUEUE_FULL	= 3,
-	HCLGE_CMD_NEXT_ERR	= 4,
-	HCLGE_CMD_UNEXE_ERR	= 5,
-	HCLGE_CMD_PARA_ERR	= 6,
-	HCLGE_CMD_RESULT_ERR	= 7,
-	HCLGE_CMD_TIMEOUT	= 8,
-	HCLGE_CMD_HILINK_ERR	= 9,
-	HCLGE_CMD_QUEUE_ILLEGAL	= 10,
-	HCLGE_CMD_INVALID	= 11,
-};
-
-enum hclge_cmd_status {
-	HCLGE_STATUS_SUCCESS	= 0,
-	HCLGE_ERR_CSQ_FULL	= -1,
-	HCLGE_ERR_CSQ_TIMEOUT	= -2,
-	HCLGE_ERR_CSQ_ERROR	= -3,
-};
-
 struct hclge_misc_vector {
 	u8 __iomem *addr;
 	int vector_irq;
 	char name[HNAE3_INT_NAME_LEN];
 };
 
-struct hclge_cmq {
-	struct hclge_cmq_ring csq;
-	struct hclge_cmq_ring crq;
-	u16 tx_timeout;
-	enum hclge_cmd_status last_status;
-};
-
 #define HCLGE_CMD_FLAG_IN	BIT(0)
 #define HCLGE_CMD_FLAG_OUT	BIT(1)
 #define HCLGE_CMD_FLAG_NEXT	BIT(2)
@@ -329,6 +284,9 @@ enum hclge_opcode_type {
 #define HCLGE_TQP_REG_OFFSET		0x80000
 #define HCLGE_TQP_REG_SIZE		0x200
 
+#define HCLGE_TQP_MAX_SIZE_DEV_V2	1024
+#define HCLGE_TQP_EXT_REG_OFFSET	0x100
+
 #define HCLGE_RCB_INIT_QUERY_TIMEOUT	10
 #define HCLGE_RCB_INIT_FLAG_EN_B	0
 #define HCLGE_RCB_INIT_FLAG_FINI_B	8
@@ -1289,25 +1247,6 @@ struct hclge_caps_bit_map {
 };
 
 int hclge_cmd_init(struct hclge_dev *hdev);
-static inline void hclge_write_reg(void __iomem *base, u32 reg, u32 value)
-{
-	writel(value, base + reg);
-}
-
-#define hclge_write_dev(a, reg, value) \
-	hclge_write_reg((a)->io_base, reg, value)
-#define hclge_read_dev(a, reg) \
-	hclge_read_reg((a)->io_base, reg)
-
-static inline u32 hclge_read_reg(u8 __iomem *base, u32 reg)
-{
-	u8 __iomem *reg_addr = READ_ONCE(base);
-
-	return readl(reg_addr + reg);
-}
-
-#define HCLGE_SEND_SYNC(flag) \
-	((flag) & HCLGE_CMD_FLAG_NO_INTR)
 enum HCLGE_WOL_MODE {
 	HCLGE_WOL_PHY           = BIT(0),
 	HCLGE_WOL_UNICAST       = BIT(1),
@@ -1338,10 +1277,10 @@ void hclge_cmd_setup_basic_desc(struct hclge_desc *desc,
 				enum hclge_opcode_type opcode, bool is_read);
 void hclge_cmd_reuse_desc(struct hclge_desc *desc, bool is_read);
 
-enum hclge_cmd_status hclge_cmd_mdio_write(struct hclge_hw *hw,
-					   struct hclge_desc *desc);
-enum hclge_cmd_status hclge_cmd_mdio_read(struct hclge_hw *hw,
-					  struct hclge_desc *desc);
+enum hclge_comm_cmd_status hclge_cmd_mdio_write(struct hclge_hw *hw,
+						struct hclge_desc *desc);
+enum hclge_comm_cmd_status hclge_cmd_mdio_read(struct hclge_hw *hw,
+					       struct hclge_desc *desc);
 
 void hclge_cmd_uninit(struct hclge_dev *hdev);
 int hclge_cmd_queue_init(struct hclge_dev *hdev);
diff --git a/drivers/net/ethernet/hisilicon/hns3/hns3pf/hclge_main.c b/drivers/net/ethernet/hisilicon/hns3/hns3pf/hclge_main.c
index 26054593839a..f680f58451db 100644
--- a/drivers/net/ethernet/hisilicon/hns3/hns3pf/hclge_main.c
+++ b/drivers/net/ethernet/hisilicon/hns3/hns3pf/hclge_main.c
@@ -27,6 +27,7 @@
 #include "hclge_err.h"
 #include "hnae3.h"
 #include "hclge_devlink.h"
+#include "hclge_comm_cmd.h"
 
 #define HCLGE_NAME			"hclge"
 
@@ -1764,8 +1765,17 @@ static int hclge_alloc_tqps(struct hclge_dev *hdev)
 		tqp->q.buf_size = hdev->rx_buf_len;
 		tqp->q.tx_desc_num = hdev->num_tx_desc;
 		tqp->q.rx_desc_num = hdev->num_rx_desc;
-		tqp->q.io_base = hdev->hw.io_base + HCLGE_TQP_REG_OFFSET +
-			i * HCLGE_TQP_REG_SIZE;
+
+		if (i < HCLGE_TQP_MAX_SIZE_DEV_V2)
+			tqp->q.io_base = hdev->hw.hw.io_base +
+					 HCLGE_TQP_REG_OFFSET +
+					 i * HCLGE_TQP_REG_SIZE;
+		else
+			tqp->q.io_base = hdev->hw.hw.io_base +
+					 HCLGE_TQP_REG_OFFSET +
+					 HCLGE_TQP_EXT_REG_OFFSET +
+					 (i - HCLGE_TQP_MAX_SIZE_DEV_V2) *
+					 HCLGE_TQP_REG_SIZE;
 
 		/* when device supports tx push and has device memory,
 		 * the queue can execute push mode or doorbell mode on
@@ -2598,8 +2608,8 @@ static int hclge_init_roce_base_info(struct hclge_vport *vport)
 	roce->rinfo.base_vector = hdev->num_nic_msi;
 
 	roce->rinfo.netdev = nic->kinfo.netdev;
-	roce->rinfo.roce_io_base = hdev->hw.io_base;
-	roce->rinfo.roce_mem_base = hdev->hw.mem_base;
+	roce->rinfo.roce_io_base = hdev->hw.hw.io_base;
+	roce->rinfo.roce_mem_base = hdev->hw.hw.mem_base;
 
 	roce->pdev = nic->pdev;
 	roce->ae_algo = nic->ae_algo;
@@ -3682,7 +3692,7 @@ static u32 hclge_check_event_cause(struct hclge_dev *hdev, u32 *clearval)
 	if (BIT(HCLGE_VECTOR0_IMPRESET_INT_B) & msix_src_reg) {
 		dev_info(&hdev->pdev->dev, "IMP reset interrupt\n");
 		set_bit(HNAE3_IMP_RESET, &hdev->reset_pending);
-		set_bit(HCLGE_STATE_CMD_DISABLE, &hdev->state);
+		set_bit(HCLGE_COMM_STATE_CMD_DISABLE, &hdev->hw.hw.comm_state);
 		*clearval = BIT(HCLGE_VECTOR0_IMPRESET_INT_B);
 		hdev->rst_stats.imp_rst_cnt++;
 		return HCLGE_VECTOR0_EVENT_RST;
@@ -3690,7 +3700,7 @@ static u32 hclge_check_event_cause(struct hclge_dev *hdev, u32 *clearval)
 
 	if (BIT(HCLGE_VECTOR0_GLOBALRESET_INT_B) & msix_src_reg) {
 		dev_info(&hdev->pdev->dev, "global reset interrupt\n");
-		set_bit(HCLGE_STATE_CMD_DISABLE, &hdev->state);
+		set_bit(HCLGE_COMM_STATE_CMD_DISABLE, &hdev->hw.hw.comm_state);
 		set_bit(HNAE3_GLOBAL_RESET, &hdev->reset_pending);
 		*clearval = BIT(HCLGE_VECTOR0_GLOBALRESET_INT_B);
 		hdev->rst_stats.global_rst_cnt++;
@@ -3824,7 +3834,7 @@ static void hclge_get_misc_vector(struct hclge_dev *hdev)
 
 	vector->vector_irq = pci_irq_vector(hdev->pdev, 0);
 
-	vector->addr = hdev->hw.io_base + HCLGE_MISC_VECTOR_REG_BASE;
+	vector->addr = hdev->hw.hw.io_base + HCLGE_MISC_VECTOR_REG_BASE;
 	hdev->vector_status[0] = 0;
 
 	hdev->num_msi_left -= 1;
@@ -4016,7 +4026,7 @@ static int hclge_set_all_vf_rst(struct hclge_dev *hdev, bool reset)
 static void hclge_mailbox_service_task(struct hclge_dev *hdev)
 {
 	if (!test_and_clear_bit(HCLGE_STATE_MBX_SERVICE_SCHED, &hdev->state) ||
-	    test_bit(HCLGE_STATE_CMD_DISABLE, &hdev->state) ||
+	    test_bit(HCLGE_COMM_STATE_CMD_DISABLE, &hdev->hw.hw.comm_state) ||
 	    test_and_set_bit(HCLGE_STATE_MBX_HANDLING, &hdev->state))
 		return;
 
@@ -4263,7 +4273,7 @@ static int hclge_reset_prepare_wait(struct hclge_dev *hdev)
 		 * any mailbox handling or command to firmware is only valid
 		 * after hclge_cmd_init is called.
 		 */
-		set_bit(HCLGE_STATE_CMD_DISABLE, &hdev->state);
+		set_bit(HCLGE_COMM_STATE_CMD_DISABLE, &hdev->hw.hw.comm_state);
 		hdev->rst_stats.pf_rst_cnt++;
 		break;
 	case HNAE3_FLR_RESET:
@@ -4983,11 +4993,11 @@ static void hclge_get_vector_info(struct hclge_dev *hdev, u16 idx,
 
 	/* need an extend offset to config vector >= 64 */
 	if (idx - 1 < HCLGE_PF_MAX_VECTOR_NUM_DEV_V2)
-		vector_info->io_addr = hdev->hw.io_base +
+		vector_info->io_addr = hdev->hw.hw.io_base +
 				HCLGE_VECTOR_REG_BASE +
 				(idx - 1) * HCLGE_VECTOR_REG_OFFSET;
 	else
-		vector_info->io_addr = hdev->hw.io_base +
+		vector_info->io_addr = hdev->hw.hw.io_base +
 				HCLGE_VECTOR_EXT_REG_BASE +
 				(idx - 1) / HCLGE_PF_MAX_VECTOR_NUM_DEV_V2 *
 				HCLGE_VECTOR_REG_OFFSET_H +
@@ -5598,7 +5608,7 @@ int hclge_bind_ring_with_vector(struct hclge_vport *vport,
 	struct hclge_desc desc;
 	struct hclge_ctrl_vector_chain_cmd *req =
 		(struct hclge_ctrl_vector_chain_cmd *)desc.data;
-	enum hclge_cmd_status status;
+	enum hclge_comm_cmd_status status;
 	enum hclge_opcode_type op;
 	u16 tqp_type_and_id;
 	int i;
@@ -7661,7 +7671,7 @@ static bool hclge_get_cmdq_stat(struct hnae3_handle *handle)
 	struct hclge_vport *vport = hclge_get_vport(handle);
 	struct hclge_dev *hdev = vport->back;
 
-	return test_bit(HCLGE_STATE_CMD_DISABLE, &hdev->state);
+	return test_bit(HCLGE_COMM_STATE_CMD_DISABLE, &hdev->hw.hw.comm_state);
 }
 
 static bool hclge_ae_dev_resetting(struct hnae3_handle *handle)
@@ -8864,7 +8874,7 @@ int hclge_rm_mc_addr_common(struct hclge_vport *vport,
 	char format_mac_addr[HNAE3_FORMAT_MAC_ADDR_LEN];
 	struct hclge_dev *hdev = vport->back;
 	struct hclge_mac_vlan_tbl_entry_cmd req;
-	enum hclge_cmd_status status;
+	enum hclge_comm_cmd_status status;
 	struct hclge_desc desc[3];
 
 	/* mac addr check */
@@ -11370,11 +11380,12 @@ static int hclge_dev_mem_map(struct hclge_dev *hdev)
 	if (!(pci_select_bars(pdev, IORESOURCE_MEM) & BIT(HCLGE_MEM_BAR)))
 		return 0;
 
-	hw->mem_base = devm_ioremap_wc(&pdev->dev,
-				       pci_resource_start(pdev, HCLGE_MEM_BAR),
-				       pci_resource_len(pdev, HCLGE_MEM_BAR));
-	if (!hw->mem_base) {
-		dev_err(&pdev->dev, "failed to map device memroy\n");
+	hw->hw.mem_base =
+		devm_ioremap_wc(&pdev->dev,
+				pci_resource_start(pdev, HCLGE_MEM_BAR),
+				pci_resource_len(pdev, HCLGE_MEM_BAR));
+	if (!hw->hw.mem_base) {
+		dev_err(&pdev->dev, "failed to map device memory\n");
 		return -EFAULT;
 	}
 
@@ -11412,8 +11423,8 @@ static int hclge_pci_init(struct hclge_dev *hdev)
 
 	pci_set_master(pdev);
 	hw = &hdev->hw;
-	hw->io_base = pcim_iomap(pdev, 2, 0);
-	if (!hw->io_base) {
+	hw->hw.io_base = pcim_iomap(pdev, 2, 0);
+	if (!hw->hw.io_base) {
 		dev_err(&pdev->dev, "Can't map configuration register space\n");
 		ret = -ENOMEM;
 		goto err_clr_master;
@@ -11428,7 +11439,7 @@ static int hclge_pci_init(struct hclge_dev *hdev)
 	return 0;
 
 err_unmap_io_base:
-	pcim_iounmap(pdev, hdev->hw.io_base);
+	pcim_iounmap(pdev, hdev->hw.hw.io_base);
 err_clr_master:
 	pci_clear_master(pdev);
 	pci_release_regions(pdev);
@@ -11442,10 +11453,10 @@ static void hclge_pci_uninit(struct hclge_dev *hdev)
 {
 	struct pci_dev *pdev = hdev->pdev;
 
-	if (hdev->hw.mem_base)
-		devm_iounmap(&pdev->dev, hdev->hw.mem_base);
+	if (hdev->hw.hw.mem_base)
+		devm_iounmap(&pdev->dev, hdev->hw.hw.mem_base);
 
-	pcim_iounmap(pdev, hdev->hw.io_base);
+	pcim_iounmap(pdev, hdev->hw.hw.io_base);
 	pci_free_irq_vectors(pdev);
 	pci_clear_master(pdev);
 	pci_release_mem_regions(pdev);
@@ -11506,7 +11517,7 @@ static void hclge_reset_prepare_general(struct hnae3_ae_dev *ae_dev,
 
 	/* disable misc vector before reset done */
 	hclge_enable_vector(&hdev->misc_vector, false);
-	set_bit(HCLGE_STATE_CMD_DISABLE, &hdev->state);
+	set_bit(HCLGE_COMM_STATE_CMD_DISABLE, &hdev->hw.hw.comm_state);
 
 	if (hdev->reset_type == HNAE3_FLR_RESET)
 		hdev->rst_stats.flr_rst_cnt++;
@@ -11979,7 +11990,7 @@ static int hclge_init_ae_dev(struct hnae3_ae_dev *ae_dev)
 err_devlink_uninit:
 	hclge_devlink_uninit(hdev);
 err_pci_uninit:
-	pcim_iounmap(pdev, hdev->hw.io_base);
+	pcim_iounmap(pdev, hdev->hw.hw.io_base);
 	pci_clear_master(pdev);
 	pci_release_regions(pdev);
 	pci_disable_device(pdev);
diff --git a/drivers/net/ethernet/hisilicon/hns3/hns3pf/hclge_main.h b/drivers/net/ethernet/hisilicon/hns3/hns3pf/hclge_main.h
index 2caf07f80484..87ec658d5cde 100644
--- a/drivers/net/ethernet/hisilicon/hns3/hns3pf/hclge_main.h
+++ b/drivers/net/ethernet/hisilicon/hns3/hns3pf/hclge_main.h
@@ -317,11 +317,8 @@ struct hclge_mac {
 
 struct hclge_hw {
 	struct hclge_comm_hw hw;
-	void __iomem *io_base;
-	void __iomem *mem_base;
 	struct hclge_mac mac;
 	int num_vec;
-	struct hclge_cmq cmq;
 };
 
 /* TQP stats */
@@ -683,6 +680,11 @@ struct key_info {
 #define MAX_FD_FILTER_NUM	4096
 #define HCLGE_ARFS_EXPIRE_INTERVAL	5UL
 
+#define hclge_read_dev(a, reg) \
+	hclge_comm_read_reg((a)->hw.io_base, reg)
+#define hclge_write_dev(a, reg, value) \
+	hclge_comm_write_reg((a)->hw.io_base, reg, value)
+
 enum HCLGE_FD_ACTIVE_RULE_TYPE {
 	HCLGE_FD_RULE_NONE,
 	HCLGE_FD_ARFS_ACTIVE,
diff --git a/drivers/net/ethernet/hisilicon/hns3/hns3pf/hclge_mbx.c b/drivers/net/ethernet/hisilicon/hns3/hns3pf/hclge_mbx.c
index 4c270073c607..eb47d03ad625 100644
--- a/drivers/net/ethernet/hisilicon/hns3/hns3pf/hclge_mbx.c
+++ b/drivers/net/ethernet/hisilicon/hns3/hns3pf/hclge_mbx.c
@@ -46,7 +46,7 @@ static int hclge_gen_resp_to_vf(struct hclge_vport *vport,
 {
 	struct hclge_mbx_pf_to_vf_cmd *resp_pf_to_vf;
 	struct hclge_dev *hdev = vport->back;
-	enum hclge_cmd_status status;
+	enum hclge_comm_cmd_status status;
 	struct hclge_desc desc;
 
 	resp_pf_to_vf = (struct hclge_mbx_pf_to_vf_cmd *)desc.data;
@@ -93,7 +93,7 @@ static int hclge_send_mbx_msg(struct hclge_vport *vport, u8 *msg, u16 msg_len,
 {
 	struct hclge_mbx_pf_to_vf_cmd *resp_pf_to_vf;
 	struct hclge_dev *hdev = vport->back;
-	enum hclge_cmd_status status;
+	enum hclge_comm_cmd_status status;
 	struct hclge_desc desc;
 
 	resp_pf_to_vf = (struct hclge_mbx_pf_to_vf_cmd *)desc.data;
@@ -793,7 +793,7 @@ static bool hclge_cmd_crq_empty(struct hclge_hw *hw)
 {
 	u32 tail = hclge_read_dev(hw, HCLGE_NIC_CRQ_TAIL_REG);
 
-	return tail == hw->cmq.crq.next_to_use;
+	return tail == hw->hw.cmq.crq.next_to_use;
 }
 
 static void hclge_handle_ncsi_error(struct hclge_dev *hdev)
@@ -1130,7 +1130,7 @@ static void hclge_mbx_request_handling(struct hclge_mbx_ops_param *param)
 
 void hclge_mbx_handler(struct hclge_dev *hdev)
 {
-	struct hclge_cmq_ring *crq = &hdev->hw.cmq.crq;
+	struct hclge_comm_cmq_ring *crq = &hdev->hw.hw.cmq.crq;
 	struct hclge_respond_to_vf_msg resp_msg;
 	struct hclge_mbx_vf_to_pf_cmd *req;
 	struct hclge_mbx_ops_param param;
@@ -1140,7 +1140,8 @@ void hclge_mbx_handler(struct hclge_dev *hdev)
 	param.resp_msg = &resp_msg;
 	/* handle all the mailbox requests in the queue */
 	while (!hclge_cmd_crq_empty(&hdev->hw)) {
-		if (test_bit(HCLGE_STATE_CMD_DISABLE, &hdev->state)) {
+		if (test_bit(HCLGE_COMM_STATE_CMD_DISABLE,
+			     &hdev->hw.hw.comm_state)) {
 			dev_warn(&hdev->pdev->dev,
 				 "command queue needs re-initializing\n");
 			return;
diff --git a/drivers/net/ethernet/hisilicon/hns3/hns3pf/hclge_mdio.c b/drivers/net/ethernet/hisilicon/hns3/hns3pf/hclge_mdio.c
index 3f2c898b0bf9..11723c13c96a 100644
--- a/drivers/net/ethernet/hisilicon/hns3/hns3pf/hclge_mdio.c
+++ b/drivers/net/ethernet/hisilicon/hns3/hns3pf/hclge_mdio.c
@@ -47,7 +47,7 @@ static int hclge_mdio_write(struct mii_bus *bus, int phyid, int regnum,
 	struct hclge_desc desc;
 	int ret;
 
-	if (test_bit(HCLGE_STATE_CMD_DISABLE, &hdev->state))
+	if (test_bit(HCLGE_COMM_STATE_CMD_DISABLE, &hdev->hw.hw.comm_state))
 		return 0;
 
 	hclge_cmd_setup_basic_desc(&desc, HCLGE_OPC_MDIO_CONFIG, false);
@@ -85,7 +85,7 @@ static int hclge_mdio_read(struct mii_bus *bus, int phyid, int regnum)
 	struct hclge_desc desc;
 	int ret;
 
-	if (test_bit(HCLGE_STATE_CMD_DISABLE, &hdev->state))
+	if (test_bit(HCLGE_COMM_STATE_CMD_DISABLE, &hdev->hw.hw.comm_state))
 		return 0;
 
 	hclge_cmd_setup_basic_desc(&desc, HCLGE_OPC_MDIO_CONFIG, true);
diff --git a/drivers/net/ethernet/hisilicon/hns3/hns3pf/hclge_ptp.c b/drivers/net/ethernet/hisilicon/hns3/hns3pf/hclge_ptp.c
index befa9bcc2f2f..a40b1583f114 100644
--- a/drivers/net/ethernet/hisilicon/hns3/hns3pf/hclge_ptp.c
+++ b/drivers/net/ethernet/hisilicon/hns3/hns3pf/hclge_ptp.c
@@ -464,7 +464,7 @@ static int hclge_ptp_create_clock(struct hclge_dev *hdev)
 	}
 
 	spin_lock_init(&ptp->lock);
-	ptp->io_base = hdev->hw.io_base + HCLGE_PTP_REG_OFFSET;
+	ptp->io_base = hdev->hw.hw.io_base + HCLGE_PTP_REG_OFFSET;
 	ptp->ts_cfg.rx_filter = HWTSTAMP_FILTER_NONE;
 	ptp->ts_cfg.tx_type = HWTSTAMP_TX_OFF;
 	hdev->ptp = ptp;
-- 
2.34.1

