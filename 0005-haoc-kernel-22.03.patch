From d355274da48be15267ae57ec98537d217f923071 Mon Sep 17 00:00:00 2001
From: liuzh <liuzhh@zgclab.edu.cn>
Date: Wed, 10 Jul 2024 10:57:31 +0800
Subject: [PATCH] Squashed commit of the following:

commit 58ee2e8dc8b7df0e009c123bc8b33860aa18f6f3
Author: liuzh <liuzhh@zgclab.edu.cn>
Date:   Wed Jul 10 10:52:28 2024 +0800

    disable HIVE and KOI

commit d9bf4b256b0c4eef5c5493f4d4c71a29a1c2823c
Author: ljl <lvjinglin2013@163.com>
Date:   Tue Jun 18 12:59:16 2024 +0800

    HIVE: fixed parameter error of set_pte in sfi_bpf.c.

commit 9c1738021128a134802f18277170ed9e21dabdbf
Author: clf <1599101385@qq.com>
Date:   Mon Jun 17 14:03:49 2024 +0000

    set all kernel pagetable to nG in KOI

commit db890e88f3f53b19ff4f08abbf9f59d007767f03
Author: clf <1599101385@qq.com>
Date:   Mon Jun 17 12:58:49 2024 +0000

    fix koi nG bug

commit 2c4b8d3cf7db816e78972d15ed9a6e51a6f1b016
Author: clf <1599101385@qq.com>
Date:   Sat Jun 15 14:36:12 2024 +0000

    fix koi kaslr bug

commit 9314a7bd72f7d927d68a90f9329ecd68d6816b3f
Author: mxy <1356464784@qq.com>
Date:   Wed Jun 12 17:33:23 2024 +0800

    fix ifdef err, delete pr_err output, modify hive config

commit 90789672bb85b33c362c967c84fa5aabc5947f24
Author: mxy <1356464784@qq.com>
Date:   Tue Jun 11 20:40:43 2024 +0800

    fix an ignorance of ifdef

commit ef4354bdc059754532de080d865076c9b9e3c313
Author: mxy <1356464784@qq.com>
Date:   Mon Jun 10 19:59:30 2024 +0800

    merge bpf sfi

commit a87b2acf5c274841dc578eab7205bc433cc7f934
Author: clingfei <1599101385@qq.com>
Date:   Tue May 28 14:13:17 2024 +0800

    reset tcp_bbr

commit 0113543b9e8875eecf160d8157592d61c3155129
Author: clingfei <1599101385@qq.com>
Date:   Tue May 28 14:06:28 2024 +0800

    fix deadlock

commit 1540918bd8afbf1ae287091b5e0513edb4a0d7a8
Author: clingfei <1599101385@qq.com>
Date:   Mon May 27 19:13:41 2024 +0800

    fix uninitialized ptl in struct page

commit 65191c9e3033858c832b1d21f07254416162913c
Author: clingfei <1599101385@qq.com>
Date:   Fri May 24 16:25:53 2024 +0800

    update

commit 3d585e02921143516188bd290d5ff473ab7e8712
Author: clingfei <1599101385@qq.com>
Date:   Fri May 24 09:48:43 2024 +0800

    update

commit 6c6d487118385b36a0cde5041778744e496040cf
Author: clingfei <1599101385@qq.com>
Date:   Thu May 23 10:48:54 2024 +0800

    fix dead lock

commit 2b61b4da6f7e170cd417bbe09cbb058b6b4b6eb2
Author: clingfei <1599101385@qq.com>
Date:   Thu May 23 09:53:24 2024 +0800

    fix koi again

commit 12248ddb567879b86b85712e537a4b5709907991
Author: clingfei <1599101385@qq.com>
Date:   Mon May 20 21:43:01 2024 +0800

    fix koi

commit a4f2e693bf727a0b0bf69506ea5bb474f3af0712
Author: clingfei <1599101385@qq.com>
Date:   Tue May 14 14:19:49 2024 +0800

    fix bugs

commit f0f6975bc4290582465b6ec8eb0f03aa61c58673
Author: clingfei <1599101385@qq.com>
Date:   Mon May 13 19:07:29 2024 +0800

    set non-global

commit e59d6a2ffe4d796f429c64848667c3752c11e7bb
Author: zhangsy <zhangshiyang17@mails.ucas.ac.cn>
Date:   Wed May 15 09:56:34 2024 +0800

    Adapted to default config.

commit 2c6e2af32308ebc9f06b662e001b686425339241
Merge: 8354d1f4736e f59751a65815
Author: zhangshiyang17@mails.ucas.ac.cn <zhangshiyang17@mails.ucas.ac.cn>
Date:   Mon May 13 12:11:35 2024 +0000

    Merge branch 'openeuler-commit' of http://10.208.128.169/hhz/linux-kernel-pti into openeuler-commit

commit 8354d1f4736e1713070a21f70e5486f198337ceb
Author: zhangshiyang17@mails.ucas.ac.cn <zhangshiyang17@mails.ucas.ac.cn>
Date:   Mon May 13 12:10:37 2024 +0000

    Adapted to default config.

commit f59751a6581571cf9e08d5cd03bd030b02fbf12f
Author: ljl <lvjinglin2013@163.com>
Date:   Mon May 13 17:33:46 2024 +0800

    fixed KOI errors in merge with zsy.

commit e6169b6b43aa1df0e433bdde07267f4c77dcf08c
Author: ljl <lvjinglin2013@163.com>
Date:   Mon May 13 16:49:49 2024 +0800

    fixed error in merge with zsy.

commit 7891772450a90a19c8fe05d63769407fcbc9bc94
Author: clingfei <1599101385@qq.com>
Date:   Mon May 13 16:12:31 2024 +0800

    reset tcp_bbr

commit 75f28e7873dbe3e85dd3f6ecc2f8b195641354f6
Merge: b3a40347c537 b8494c14ad48
Author: zhangshiyang17@mails.ucas.ac.cn <zhangshiyang17@mails.ucas.ac.cn>
Date:   Mon May 13 07:00:10 2024 +0000

    Merge but KOI has compiling error.

commit b3a40347c537c42a07c6da3929fb2ef52fac54a9
Author: zhangshiyang17@mails.ucas.ac.cn <zhangshiyang17@mails.ucas.ac.cn>
Date:   Mon May 13 05:51:27 2024 +0000

    Optimize for UnixBench.

commit b8494c14ad480518f005d6c086c48f92f80474bd
Author: ljl <lvjinglin2013@163.com>
Date:   Tue Apr 30 11:39:30 2024 +0800

    IEE SI: KOI switch gates are updated.

commit 06b282d95ae216f507f1dd950afe7feef6214a8a
Author: clingfei <1599101385@qq.com>
Date:   Tue Apr 30 10:17:06 2024 +0800

    alloc new asid for koi when CONFIG_IEE is enabled, the original is the best:)

commit 0f1579fa5c1191c84838c9f755f0a1700590c0da
Author: clingfei <1599101385@qq.com>
Date:   Mon Apr 29 14:18:57 2024 +0800

    fix free_task

commit 74f5b10b6e9bffe32b35054f5180d4dc5a009b2b
Author: clingfei <1599101385@qq.com>
Date:   Mon Apr 29 11:45:10 2024 +0800

    fix koi_copy_pagetable, remove rwx_gate temporarily

commit 38e53f0027fe37d6afa6790a9e18967ede464b99
Author: clingfei <1599101385@qq.com>
Date:   Mon Apr 29 06:25:19 2024 +0800

    fix TLB conflict in koi

commit 98d1f71e529878ecca018c19c1173870d27896ff
Author: clingfei <1599101385@qq.com>
Date:   Sat Apr 27 09:30:19 2024 +0800

    bypass iee switch stack when rwx gate called by koi, fix iee_set_koi_pgd_writable

commit d348c8cdb01a51529a47bc6cfa9525e7e9f51f67
Author: clingfei <1599101385@qq.com>
Date:   Wed Apr 24 18:48:57 2024 +0800

    fix bugs

commit 1afd0068d2f159e109ed5a835fcf5908a7fa984f
Author: clingfei <1599101385@qq.com>
Date:   Mon Apr 22 16:58:14 2024 +0800

    fix koi_destroy_pagetable

commit 4a32d063b1763551bbc74c83ff0997e130bc2d27
Author: clingfei <1599101385@qq.com>
Date:   Tue Apr 23 11:50:54 2024 +0800

    fix koi_unmap_mem

commit f396d85c384daaa4e0a33ec4ab868b921a58a80d
Author: clingfei <1599101385@qq.com>
Date:   Tue Apr 23 08:10:23 2024 +0800

    update

commit 7ed8f17b7def1a12cf10f108e81e185349103a04
Author: clingfei <1599101385@qq.com>
Date:   Tue Apr 23 07:42:08 2024 +0800

    fix panic when rmmod

commit 1c3459295642313147ff2b76b694698acfc777c8
Author: clingfei <1599101385@qq.com>
Date:   Sat Apr 20 10:11:32 2024 +0800

    fix delete module to avoid access to struct module even after module has been unloaded

commit 32669f34e8166261d05e4a7b67d46ead6a7027ab
Author: clingfei <1599101385@qq.com>
Date:   Sat Apr 20 07:19:45 2024 +0800

    bypass DEP check when creating pagetable, release memory when unload kernel modules

commit b5a71ce835beadadbebb447e54eea90f62d18eb0
Author: ljl <lvjinglin2013@163.com>
Date:   Tue Apr 23 13:35:52 2024 +0800

    IEE SI: Added Interface IEE_SET_KOI_PGD for KOI.

commit 663d8efd796b608703256c98389275c57b617167
Author: ljl <lvjinglin2013@163.com>
Date:   Tue Apr 23 12:02:40 2024 +0800

    IEE: Replace iee flags by enum in KOI switch gates.

commit 5cfff7f0d02bf344fa990a505d6e1fc4208fd7cd
Merge: c31d6b374677 d0d955095e0d
Author: ljl <lvjinglin2013@163.com>
Date:   Tue Apr 23 09:24:43 2024 +0800

    Merge branch 'ljl-tmp' into openeuler-commit

commit d0d955095e0d6a33e24fbbcdb43977e2b502e2e2
Author: ljl <lvjinglin2013@163.com>
Date:   Tue Apr 23 06:23:36 2024 +0800

    Removed file token (IEE CREDP) and reworked iee flags by enum.

commit c31d6b374677505f6c03a6afc899a0920ee49dfe
Author: clingfei <1599101385@qq.com>
Date:   Tue Apr 16 18:45:36 2024 +0800

    fix bugs, still CAN NOT pass DEP check when creating ko's pagetable NOW

commit 1efff823c329d220dd7cbc1b86e383699ebb1514
Merge: 71277723ab8d 3b597cbc4f92
Author: clingfei <1599101385@qq.com>
Date:   Sat Apr 13 09:38:11 2024 +0800

    Merge branch 'koi-dev' into openeuler-commit

commit 4ec1144f0dac49a73e00ccb622112ea709382463
Author: ljl <ljl2013@163.com>
Date:   Fri Apr 12 10:04:13 2024 +0000

    IEE SI: Provides KOI switch gates.

commit f5fdc1a66a1ded5e8d054b13e8430bfe1605dd6e
Author: ljl <lvjinglin2013@163.com>
Date:   Fri Apr 12 15:14:19 2024 +0800

    IEE CREDP: protect commit_creds from ROP reuse.

commit bcfecdb511efb02f30ee557714ef3a62c9cc7b43
Author: ljl <lvjinglin2013@163.com>
Date:   Wed Apr 10 11:59:05 2024 +0800

    IEE CREDP: added file token.

commit 71277723ab8da283d5c56b6ed5d0f9adda91c410
Author: zhangshiyang17@mails.ucas.ac.cn <zhangshiyang17@mails.ucas.ac.cn>
Date:   Sun Apr 7 10:04:23 2024 +0000

    Fix bug of CONFIG_IEE.

commit 540714959404ca367788594b1a79cb4e1fd76093
Author: zhangshiyang17@mails.ucas.ac.cn <zhangshiyang17@mails.ucas.ac.cn>
Date:   Sun Apr 7 02:25:37 2024 +0000

    Fix compiling error.

commit 2092ed22afda2f84ec1e1e6ae62902bd22f91a76
Author: zhangshiyang17@mails.ucas.ac.cn <zhangshiyang17@mails.ucas.ac.cn>
Date:   Wed Apr 3 10:46:38 2024 +0000

    Optimize CONFIG_IEE and CONFIG_PTP.

commit 3b597cbc4f92b233e8585de7f990246c1780c744
Author: clingfei <1599101385@qq.com>
Date:   Mon Apr 1 14:23:24 2024 +0800

    fix bug

commit a453e89af4d693d9d450f42b9caf3a7c38b438bf
Author: clingfei <1599101385@qq.com>
Date:   Sat Mar 30 22:26:01 2024 +0800

    fix bug

commit aef9920d23eed46ec100c69e6a543bd99db31f7f
Author: clingfei <1599101385@qq.com>
Date:   Tue Mar 26 17:18:14 2024 +0800

    fix koi_create_pagetable bug caused by huge pud page

commit 4520db7d8b0fc6f2a5e740b6757c8965dd0cdaf7
Author: clingfei <1599101385@qq.com>
Date:   Tue Mar 26 14:22:51 2024 +0800

    update

commit 3e389afbb70cdf7f0f51e7fee495b8f4755b0fff
Author: clingfei <1599101385@qq.com>
Date:   Sat Mar 23 22:34:05 2024 +0800

    fix bugs

commit 8c15bc003ba4cc95b5bed6aeafd5b82192b970d4
Author: clingfei <1599101385@qq.com>
Date:   Sat Mar 23 10:58:54 2024 +0800

    fix koi only, now it can boot successfully

commit d9f7c428fd871f2053bcd3549dd5231241421462
Author: clingfei <1599101385@qq.com>
Date:   Tue Feb 13 15:56:24 2024 +0800

    enable configs

commit b0d72dfa149958f8688329a65a709bc7d4ae255b
Author: zhangshiyang17@mails.ucas.ac.cn <zhangshiyang17@mails.ucas.ac.cn>
Date:   Thu Mar 21 03:22:30 2024 +0000

    Fix pgtable free bug.

commit 5a995cebd8b894373ac80cc2f8dea87f4c1a643c
Author: zhangshiyang17@mails.ucas.ac.cn <zhangshiyang17@mails.ucas.ac.cn>
Date:   Thu Mar 21 02:55:25 2024 +0000

    Fix TLB FLUSH bug when switching HPD1.

commit 1dc1d72cd4fa7915974c3425505f0b9795dabfd0
Author: ljl <ljl2013@163.com>
Date:   Tue Mar 19 10:26:47 2024 +0000

    IEE SI: Disable PAN in rwx gate to skip the CNP BUG.

commit 628e782c8093d0dac99e02ad73a7eefc990492ed
Author: ljl <ljl2013@163.com>
Date:   Mon Mar 18 15:21:15 2024 +0000

    IEE SI: Skip CNP setting BUG.

commit 6bd2f269909700d98e47ab62cde16f8156c4b5c9
Merge: 22a030598732 34a590c91cda
Author: zhangsy <zhangshiyang17@mails.ucas.ac.cn>
Date:   Mon Mar 18 19:57:16 2024 +0800

    Merge branch 'openeuler-commit' of http://10.208.128.169/hhz/linux-kernel-pti into openeuler-commit

commit 22a030598732108955634de4afbe7537de809c27
Author: zhangsy <zhangshiyang17@mails.ucas.ac.cn>
Date:   Mon Mar 18 19:56:15 2024 +0800

    Fix bugs existing in 5.10 but only triggered in 6.6.

commit 34a590c91cda756c1aeffa4fdda9523edd56120d
Author: ljl <ljl2013@163.com>
Date:   Thu Mar 14 11:57:21 2024 +0000

    IEE SI [WARN]:STILL May crash when booting up. Please reboot when it happens :).

commit e5ffbb8fef97847ac592265e3f7202749f2ddaec
Author: ljl <ljl2013@163.com>
Date:   Wed Mar 13 16:11:49 2024 +0000

    IEE SI [WARN]: Remake rwx gate by TCR switching. May crush when booting up.

commit d5bdf02493bfe29b7c82452769183e64346827da
Author: zhangsy <zhangshiyang17@mails.ucas.ac.cn>
Date:   Thu Mar 7 10:58:26 2024 +0800

    Fix a compiling error of CONFIG_IEE.

commit 5421759f866ee45eeca3a07c2b97a855fcb8440b
Merge: cb56dac142c1 88acc4ad4875
Author: zhangsy <zhangshiyang17@mails.ucas.ac.cn>
Date:   Tue Mar 5 17:29:43 2024 +0800

    Merge branch 'openeuler-commit' of http://10.208.128.169/hhz/linux-kernel-pti into openeuler-commit

commit cb56dac142c1136c45f303a45fc50317caba2975
Author: zhangsy <zhangshiyang17@mails.ucas.ac.cn>
Date:   Tue Mar 5 17:24:33 2024 +0800

    Fix CONFIG bug.

commit 88acc4ad4875088325931169f7626d19e529a3dd
Author: zhangshiyang17@mails.ucas.ac.cn <zhangshiyang17@mails.ucas.ac.cn>
Date:   Thu Feb 29 11:57:17 2024 +0000

    Fix some warnings of credp.

commit 71ed6a79a9672f4afc0827a332878f5ad09d7701
Author: zhangsy <zhangshiyang17@mails.ucas.ac.cn>
Date:   Wed Feb 28 18:17:40 2024 +0800

    Opt interruption support of iee.

commit 3b19f12592e3907c33aaf46a75f0ede24544e260
Author: zhangsy <zhangshiyang17@mails.ucas.ac.cn>
Date:   Wed Feb 28 16:36:58 2024 +0800

    Change support of iee interruption as a config and optimize the EL1 exception.

commit d19a552fd1b14a6bb1156c6aedce084a70a03324
Author: zhangshiyang17@mails.ucas.ac.cn <zhangshiyang17@mails.ucas.ac.cn>
Date:   Mon Feb 26 12:05:58 2024 +0000

    Fix ELR_EL1 set error.

commit a33d7d4976a4aa555bc2a1f0c474e16ac5a46aa2
Author: zhangsy <zhangshiyang17@mails.ucas.ac.cn>
Date:   Mon Feb 26 17:21:55 2024 +0800

    Normalize the iee code.

commit 5db8d4b57cc062191f657d307d2693cfaa73edc5
Author: zhangsy <zhangshiyang17@mails.ucas.ac.cn>
Date:   Mon Feb 26 11:36:37 2024 +0800

    Normalize interfaces of setting iee and simplify iee_exception_gate.

commit 66d0f9ca5e7a62256137a8797e3e3ca9a770912e
Author: ljl <ljl2013@163.com>
Date:   Fri Feb 23 12:01:32 2024 +0000

    IEE SI: Commented all DBG breakpoint codes to prepare remaking rwx gate again :)

commit a3312aca506dc8b23ecce85713e513729dc3b1c8
Merge: 2905589e9912 70f6d17b3f2b
Author: zhangshiyang17@mails.ucas.ac.cn <zhangshiyang17@mails.ucas.ac.cn>
Date:   Fri Feb 23 06:57:19 2024 +0000

    Merge branch 'openeuler-commit' of http://10.208.128.169/hhz/linux-kernel-pti into openeuler-commit

commit 2905589e99122db5c3978a3c260e861c5d932b75
Author: zhangshiyang17@mails.ucas.ac.cn <zhangshiyang17@mails.ucas.ac.cn>
Date:   Fri Feb 23 06:57:10 2024 +0000

    Optimize HPDS switch.

commit 70f6d17b3f2bb33b30bf0bd20f5e58ffc800b159
Author: ljl <ljl2013@163.com>
Date:   Fri Feb 23 05:18:25 2024 +0000

    IEE SI: Optimized DBG Breakpoint ctrl.

commit 9d51a74c200a1326a5a7b28c33196e2ddb42a9d9
Author: zhangsy <zhangshiyang17@mails.ucas.ac.cn>
Date:   Thu Feb 22 09:19:27 2024 +0800

    Fix kaslr bug when opening KPTI.

commit b3d02e656e163f6d2423c0f9e4039d43c6c9cb2b
Author: clingfei <1599101385@qq.com>
Date:   Tue Feb 13 10:19:31 2024 +0800

    free koi stack and set token page invalid

commit 73be7b30b7e42611a877610d1821efbe5ed9574b
Author: clingfei <1599101385@qq.com>
Date:   Sat Feb 10 20:27:06 2024 +0800

    fix koi token alloc, fix koi_create_pagetable

commit 8ff4b296e3cf5ab14c44fa782b9d2b6daa344609
Author: clingfei <1599101385@qq.com>
Date:   Tue Feb 6 21:15:13 2024 +0800

    fix koi

commit 78b8cbe4ac4a2f28e9946df3ecafbe80dcc9b73b
Author: clingfei <1599101385@qq.com>
Date:   Tue Feb 6 14:10:05 2024 +0800

    Fix koi token alloc and free

commit e521d2363044e5a0d6cfbb6173452b5514f08f12
Author: clingfei <1599101385@qq.com>
Date:   Sun Feb 4 17:42:45 2024 +0800

    use user process's asid when calling into driver view, and use corresponding kernel's asid when returning from driver view

commit fe3c93519cdb1cc22ae499a12fca80fea88fa0d8
Author: ljl <ljl2013@163.com>
Date:   Tue Feb 6 04:11:12 2024 +0000

    IEE tested on Unixbench without KOI.

commit d8c00905445df1b7c0c78e5de9a9bcf3c709e2cb
Author: zhangsy <zhangshiyang17@mails.ucas.ac.cn>
Date:   Mon Feb 5 20:54:34 2024 +0800

    Fix Unix bench bugs.

commit 3c8d267ab1035b7acbe1b3610adcd3e44d0f8410
Author: ljl <lvjinglin2013@163.com>
Date:   Sun Feb 4 19:04:48 2024 +0800

    IEE SI: Temporaily remove modification in arch_local_irq_restore() to eliminate deadlock BUG.

commit 71c2b981d33fb54b299be09875ac9c82e2bbfc7a
Author: clingfei <1599101385@qq.com>
Date:   Sun Feb 4 17:42:45 2024 +0800

    use user process's asid when calling into driver view, and use corresponding kernel's asid when returning from driver view

commit 1c37c2f3bf4153d59d6cd64da7b683506038a29f
Author: clingfei <1599101385@qq.com>
Date:   Sun Feb 4 16:23:57 2024 +0800

    free koi stack when free task_struct

commit f0b258973fbba56d9e6baeed21e12e339a8f7de8
Author: ljl <lvjinglin2013@163.com>
Date:   Sat Feb 3 21:43:10 2024 +0800

    IEE SI: MFit in KOI switch with new ASID design.

commit 145387a16b9a2fa08c6a8060a9220b4ec6e14912
Author: ljl <lvjinglin2013@163.com>
Date:   Wed Jan 31 12:20:38 2024 +0800

    IEE SI: Remove PSTATE D to protect iee rwx gate.

commit 1ec930d63303de3cc1fd36ddbe48a1509cb4c91c
Author: clingfei <1599101385@qq.com>
Date:   Fri Feb 2 20:52:37 2024 +0800

    modify koi to adapt to UEFI

commit eb53dbe1880794ad71612cc924b7638c3d4e1b57
Author: clingfei <1599101385@qq.com>
Date:   Thu Feb 1 19:46:38 2024 +0800

    modify ASID design in KOI

commit 4ba5fde05b09c2d2e3183973a8185c28ce358d0e
Author: clingfei <1599101385@qq.com>
Date:   Thu Feb 1 15:25:00 2024 +0800

    fix koi token init and switch stack bugs

commit a1f16dfcb3683f98d403fa6fd324bfb5c01d8159
Author: clingfei <1599101385@qq.com>
Date:   Thu Feb 1 10:06:21 2024 +0800

    put ko's pgtable in IEE region when PTP is enabled

commit f95804874b5d648f2339cb476a4a81f9771d2af9
Author: clingfei <1599101385@qq.com>
Date:   Wed Jan 31 09:22:07 2024 +0800

    fix dead lock when mapping from kernel pgtable to driver pgtable, which is caused by spin_lock used in irq context

commit 9d9b2d60c3a3a6a5d21a8c3e002ba5dc121d84f4
Author: zhangsy <zhangshiyang17@mails.ucas.ac.cn>
Date:   Thu Feb 1 16:21:33 2024 +0800

    Fix rw gate bugs and modify ASID design.

commit a0c84631af4d6f6b830a031b1602a220bf718d99
Author: zhangsy <zhangshiyang17@mails.ucas.ac.cn>
Date:   Wed Jan 31 16:26:37 2024 +0800

    Fix cred KABI.

commit 955a01eeacd81d7d05aefbb907ba4ddc86f102b3
Author: clingfei <1599101385@qq.com>
Date:   Sat Jan 27 15:16:54 2024 +0800

    Add koi_irq_current_ttbr1 to record the ttbr1 status in softirq context, fix compile errors when koi enabled only

commit b5368c3eca57aa6a81f904a8cb84c70ea33d37f2
Merge: c19756c5df85 a10d30ec7087
Author: clingfei <1599101385@qq.com>
Date:   Wed Jan 24 11:30:20 2024 +0800

    Merge branch 'openeuler-commit' into koi-dev

commit c19756c5df85de506621ade90f9c8113760e1e1d
Author: clingfei <1599101385@qq.com>
Date:   Tue Jan 23 21:24:19 2024 +0800

    modify koi interfaces to adapt to iee_rw_gate and iee_rwx_gate

commit a10d30ec7087f97e2c43191b8c11132097f8677e
Author: ljl <lvjinglin2013@163.com>
Date:   Tue Jan 23 11:01:17 2024 +0800

    IEE SI: fixed KASLR bug in smp.

commit 5863c857fc17aa85d568cdf736b18767ba3da04b
Author: zhangsy <zhangshiyang17@mails.ucas.ac.cn>
Date:   Mon Jan 22 16:07:09 2024 +0800

    Delete set iee_pg_dir rw.

commit 7168c8974763ed1af9646d612e063ead9654c39d
Author: zhangsy <zhangshiyang17@mails.ucas.ac.cn>
Date:   Mon Jan 22 15:03:28 2024 +0800

    Fix DEP error.

commit a225a6aa75b88fd12c53bb5e6a7561972201c1dc
Author: zhangsy <zhangshiyang17@mails.ucas.ac.cn>
Date:   Sat Jan 20 17:57:03 2024 +0800

    Fix iee si error when opening CONFIG_IEE only with nokaslr, but remaining problem on kaslr.

commit f5ee81865751b031f102bf70cbb55490bf343a0e
Author: zhangsy <zhangshiyang17@mails.ucas.ac.cn>
Date:   Sat Jan 20 15:16:06 2024 +0800

    Merge IEE:oooo patch.

commit 2bc2f6fd16e5499e27794886bc052b2b5c317f25
Merge: 605411e7042e e9f44b355842
Author: zhangsy <zhangshiyang17@mails.ucas.ac.cn>
Date:   Sat Jan 20 15:00:41 2024 +0800

    Merge branch 'openeuler-commit' of http://10.208.128.169/hhz/linux-kernel-pti into openeuler-commit

commit 605411e7042e55c4c2395234e65a6b028c6e6466
Author: zhangsy <zhangshiyang17@mails.ucas.ac.cn>
Date:   Sat Jan 20 14:58:58 2024 +0800

    Fix memblock size.

commit e9f44b355842193322ed8657755fd83ed7a76131
Author: clingfei <1599101385@qq.com>
Date:   Fri Jan 19 17:09:02 2024 +0800

    add iee_rw_gate handlers to support access to task_token in koi, use iee_rwx_gate_entry to switch kernel and ko pgtable, and modify koi interfaces to use iee_rw_gate to access task_token

commit c25f4c4ad1e8fe00d1f8ac5421869922c72b843f
Author: clingfei <1599101385@qq.com>
Date:   Fri Jan 19 09:31:14 2024 +0800

    optimize implementation of switch pgtable and stack between kernel and ko, now tpiddro_el0 is not needed

commit 4691190f9c6bf7ee74742ca428636eb7208b5010
Author: clingfei <1599101385@qq.com>
Date:   Wed Jan 17 22:02:17 2024 +0800

    add koi support for softirq

commit 4b0e20c9e749b5d091797107072d2f6414a346dc
Author: losky <502878997@qq.com>
Date:   Wed Jan 17 09:16:30 2024 +0800

    wrap iee_rw_gate, make interface looks more concise

commit 54d6046e009429fab2a9ab88de26ef191363e4fc
Author: ljl <lvjinglin2013@163.com>
Date:   Wed Jan 17 19:54:05 2024 +0800

    IEE SI: testing on lmbench successfully.

commit af8a4a94639cdeb1298834b845bbbce14385fbe3
Author: ljl <lvjinglin2013@163.com>
Date:   Wed Jan 17 15:33:21 2024 +0800

    IEE SI: Remake again. Who cares what's new? :)

commit 2eed3cff6ce7e1e4a57301c8c3ede3279fc73f0c
Author: zhangsy <zhangshiyang17@mails.ucas.ac.cn>
Date:   Wed Jan 17 18:58:05 2024 +0800

    Fix smp sp_el0 check error.

commit 0287a93c2cfbb1c21c36d3f4fc540d1a133bd3b3
Merge: e622cff6564b d6cce9128bae
Author: zhangsy <zhangshiyang17@mails.ucas.ac.cn>
Date:   Wed Jan 17 13:59:09 2024 +0800

    Merge branch 'openeuler-commit' of http://10.208.128.169/hhz/linux-kernel-pti into openeuler-commit

commit e622cff6564b4001f6cf2b4d1e433e39e8480e41
Author: zhangsy <zhangshiyang17@mails.ucas.ac.cn>
Date:   Wed Jan 17 13:56:12 2024 +0800

    Fix task->children!=lm_va error.

commit d6cce9128bae909033a59649d7d33f545e0dfcee
Author: clingfei <1599101385@qq.com>
Date:   Wed Jan 17 12:48:20 2024 +0800

    Fix ko stack alloc policy

commit d007b35066a5d87338a25a9fb42a7c441b15afe7
Author: zhangsy <zhangshiyang17@mails.ucas.ac.cn>
Date:   Wed Jan 17 10:12:32 2024 +0800

    Fix SP_EL0 check error.

commit a5b72dd0449b4342d40d12477fb5b0b241d424bd
Author: clingfei <1599101385@qq.com>
Date:   Tue Jan 16 19:47:16 2024 +0800

    Fix koi

commit 41683e1d2df452ab9331f5d0eda805636472b85c
Author: clingfei <1599101385@qq.com>
Date:   Tue Jan 16 19:12:11 2024 +0800

    Fix conflict between KOI NG and set_pte/pmd/pud_pre_init

commit 7c47cf8b51dd033f86c804cab58d17b6096ff501
Merge: e977de979261 55d205381288
Author: clingfei <1599101385@qq.com>
Date:   Tue Jan 16 18:39:33 2024 +0800

    Merge branch 'openeuler-commit' into koi-dev

commit 55d205381288b02f433be1be1c231fe0571308fa
Author: zhangsy <zhangshiyang17@mails.ucas.ac.cn>
Date:   Tue Jan 16 16:52:06 2024 +0800

    Fix conflict between KOI NG and IEE_RWX_GATE.

commit e977de9792612ef4b677c45e7b56a6ede8249fdb
Author: clingfei <1599101385@qq.com>
Date:   Tue Jan 16 16:42:53 2024 +0800

    fix koi, now dm-zero can run successfully with KOI Enabled, IEE/PTP/CREDP and kaslr disabled

commit c5738930667262dc3b2e98b90622a7b38b984c39
Author: zhangsy <zhangshiyang17@mails.ucas.ac.cn>
Date:   Tue Jan 16 12:32:34 2024 +0800

    Add __entry_task protection and SP_EL0 check.

commit e03710aebb040b8169316a461cfbe58f4c578f0a
Author: clingfei <1599101385@qq.com>
Date:   Tue Jan 16 08:58:17 2024 +0800

    fix kabi breakage caused by koi

commit 7b74a6853c277086c7bf13e0083128105d818d3f
Author: zhangsy <zhangshiyang17@mails.ucas.ac.cn>
Date:   Mon Jan 15 16:57:07 2024 +0800

    Adapted to openeuler_cfg.

commit 7449451399268f501a269b8de5069a82d5b04eb9
Author: zhangsy <zhangshiyang17@mails.ucas.ac.cn>
Date:   Mon Jan 15 16:09:21 2024 +0800

    Fix smp error and optimize rw_gate.

commit e972fcb324951320b38861a8f9a761aabe69cd50
Author: clingfei <1599101385@qq.com>
Date:   Mon Jan 15 11:24:02 2024 +0800

    refactor koi

commit 15f40f87ed137a545c1f77b2fa1f5102681ac3ff
Author: zhangsy <zhangshiyang17@mails.ucas.ac.cn>
Date:   Sat Jan 13 20:46:01 2024 +0800

    Modify design of task_token

commit 54643bae59a581556b84838d5bd5e219e6337df7
Author: zhangsy <zhangshiyang17@mails.ucas.ac.cn>
Date:   Fri Jan 12 19:08:09 2024 +0800

    Adapted DEP to EFI.

commit 8ccb559a9a2582e430fd4f62e211e804600690a2
Author: zsy <zhangshiyang17@mails.ucas.ac.cn>
Date:   Fri Jan 12 14:01:58 2024 +0800

    IEE adapted to EFI.

commit ed6d4da47fb65f9ebc1a008ed840773469383ecc
Author: zzw <zhangzhenwei22b@ict.ac.cn>
Date:   Thu Jan 11 09:40:40 2024 +0800

    asid set  ttbr

commit d9b3ad405e430996324f2ccfb5accee6ed5eff43
Author: zzw <zhangzhenwei22b@ict.ac.cn>
Date:   Thu Jan 11 09:12:06 2024 +0800

    asid set  ttbr

commit 120155a515243cd90f3098ebdd91e133d54962ff
Author: zzw <zhangzhenwei22b@ict.ac.cn>
Date:   Tue Jan 9 22:51:12 2024 +0800

    asid

commit a668e6b7b8ff591bd20292a7cbfabc063283af67
Author: ljl <lvjinglin2013@163.com>
Date:   Sat Jan 6 12:58:56 2024 +0800

    IEE SI: fixed merge bugs.

commit 73608d30048363d1e4b6aafaeae3bceb93835cf8
Author: ljl <lvjinglin2013@163.com>
Date:   Sat Jan 6 11:12:57 2024 +0800

    IEE SI: added DBG ctrl protection and fixed some bug.

commit c86cc6cd8be0bb92e2cfd934e6a62301c95c1925
Author: zhangsy <zhangshiyang17@mails.ucas.ac.cn>
Date:   Fri Jan 5 15:05:23 2024 +0800

    Revert "Merge branch 'openeuler-commit' of http://10.208.128.169/hhz/linux-kernel-pti into openeuler-commit"

    This reverts commit 7ba23365ca846837af0857e2eab196bc4c196d46, reversing
    changes made to 551cbb14d965ae2b147c11eb953a0da2cfe02bf5.

commit 7ba23365ca846837af0857e2eab196bc4c196d46
Merge: 551cbb14d965 a3f69446f6ce
Author: zhangsy <zhangshiyang17@mails.ucas.ac.cn>
Date:   Fri Jan 5 15:00:15 2024 +0800

    Merge branch 'openeuler-commit' of http://10.208.128.169/hhz/linux-kernel-pti into openeuler-commit

commit 551cbb14d965ae2b147c11eb953a0da2cfe02bf5
Author: zhangsy <zhangshiyang17@mails.ucas.ac.cn>
Date:   Fri Jan 5 14:04:22 2024 +0800

    Add iee stack check.

commit a3f69446f6ce9a166581ecf964c5ebbf4f464e03
Author: clingfei <1599101385@qq.com>
Date:   Thu Jan 4 09:45:27 2024 +0000

    modify iee_rwx_gate_entry to support msr ttbr1 in koi

commit d40dcb4321ea26adc9fd32c3edfe5cff13bfc0f0
Author: zhangsy <zhangshiyang17@mails.ucas.ac.cn>
Date:   Tue Jan 2 12:23:07 2024 +0000

    Fix some merge errors.

commit 0f486f03c11afc34b95107ca418a6506b5fbac76
Merge: 625c02b1f925 b535dc2e0aca
Author: zhangsy <zhangshiyang17@mails.ucas.ac.cn>
Date:   Tue Jan 2 11:59:40 2024 +0000

    Merge IEE selfprotect.

commit 625c02b1f925f963d2ca4a27d73c50649d1b2d27
Author: zhangsy <zhangshiyang17@mails.ucas.ac.cn>
Date:   Tue Jan 2 11:53:02 2024 +0000

    Add owner registing but not checked iee stack and more.

commit bf8f9c888410a7cef0e4f4711bd4b437238cfb1b
Author: zhangsy <zhangshiyang17@mails.ucas.ac.cn>
Date:   Tue Jan 2 08:37:03 2024 +0000

    Fix the random error and add IEE selfprotect.

commit b535dc2e0aca2821f891a25c6e44a212a7e4a2e3
Author: ljl <lvjinglin2013@163.com>
Date:   Mon Jan 1 14:39:09 2024 +0000

    IEE SI: expend iee si stack to 4 pg with 8 pg alignment.

commit c9cd56e2751b17268b92d00b1b935339aa09bdfd
Merge: 530cda0ba12a 00c25ac42f2f
Author: zhangsy <zhangshiyang17@mails.ucas.ac.cn>
Date:   Mon Jan 1 13:21:41 2024 +0000

    Merge but have random error.

commit 530cda0ba12a018413f94f68b0890427bf8f46ef
Author: zhangsy <zhangshiyang17@mails.ucas.ac.cn>
Date:   Mon Jan 1 11:10:31 2024 +0000

    Add check for remapping IEE region.

commit 73386fb999dd8bca213a19a27889652335d42d17
Author: clingfei <1599101385@qq.com>
Date:   Mon Jan 1 09:57:07 2024 +0000

    set all kernel pte to NG

commit 6fef90196ad86bde91265e8e33830d3dfd6daac8
Author: zzw <zhangzhenwei22b@ict.ac.cn>
Date:   Mon Jan 1 04:35:33 2024 +0000

    add notes finish

commit 7df2e0c3b2535e690d9ce023876841c09afba088
Author: clingfei <1599101385@qq.com>
Date:   Sun Dec 31 16:22:41 2023 +0000

    add switch pgtable, buffer management, heap allocator wrapper interfaces

commit 00c25ac42f2f1fe86177b1390d6cecd33319140d
Author: zyf <zhouyangfan20s@ict.ac.cn>
Date:   Sun Dec 31 16:17:22 2023 +0000

    Replaced switch with function pointers in iee.c and added documentation.

commit 14dc2fa9680d2a6eeaa6083788f239f64e3696ec
Author: ljl <lvjinglin2013@163.com>
Date:   Sun Dec 31 14:55:06 2023 +0000

    replaced el1 sctlr, tcr, ttbr0 inst by iee si gate in kernel.

commit d44dffc7097063c743f46fa8da95132421778263
Author: zyf <zhouyangfan20s@ict.ac.cn>
Date:   Sun Dec 31 12:13:33 2023 +0000

    Standardize IEE InterfacIEEing Convention

commit ce4d2be5ea9dbe52f9e5297f90a872404e8aa358
Merge: 6e4c9d9917ef 977c5bb0e4f3
Author: zzw <zhangzhenwei22b@ict.ac.cn>
Date:   Sun Dec 31 06:54:16 2023 +0000

    Merge remote-tracking branch 'origin/openeuler-commit' into openeuler-commit

commit 6e4c9d9917efcbf9d12ba121998ce9b4b925a370
Author: zzw <zhangzhenwei22b@ict.ac.cn>
Date:   Sun Dec 31 06:49:37 2023 +0000

    add notes 2nd

commit 95bf3e5bcce82283406ac65154e97c65e4ea104f
Author: zhangsy <zhangshiyang17@mails.ucas.ac.cn>
Date:   Sun Dec 31 05:02:42 2023 +0000

    Add TCR check.

commit 977c5bb0e4f351d2f5886e12624b08c24fc878de
Author: ljl <lvjinglin2013@163.com>
Date:   Sun Dec 31 03:25:25 2023 +0000

    implemented iee si base functions.

commit c914e698f371651bec2a1fbe2358c0bc9da0cc51
Author: zzw <zhangzhenwei22b@ict.ac.cn>
Date:   Sun Dec 31 03:42:51 2023 +0000

    add notes 2

commit b453ea4f5822d6809f175bf3a9986c3ed8c06487
Author: zzw <zhangzhenwei22b@ict.ac.cn>
Date:   Sun Dec 31 03:33:31 2023 +0000

    add notes 1

commit bb450696d12d38c9adc5c9a3d1f18dabcf20afbe
Author: clingfei <1599101385@qq.com>
Date:   Sun Dec 31 02:30:25 2023 +0000

    add ko pagetable construction interfaces

commit 4137f4b1fb1c760a190cbedd2f6b36054b07586e
Author: zhangsy <zhangshiyang17@mails.ucas.ac.cn>
Date:   Sat Dec 30 09:23:45 2023 +0000

    Modify config name.

commit a125bf2d678187d714a245dde8d17f90bda905da
Author: zhangsy <zhangshiyang17@mails.ucas.ac.cn>
Date:   Sat Dec 30 09:11:53 2023 +0000

    Add achitecture check.

commit 11d2b6b3c5d9db1ce9e41983f7300dc033b93e65
Author: clingfei <1599101385@qq.com>
Date:   Sat Dec 30 04:58:09 2023 +0000

    merge koi modification for Kconfig, kernel_ventry, vmlinux.lds, pgd_alloc and set_pte/set_pud/set_pmd, BUT set_pte will cause kernel crash, remains to be fixed

commit 688816c920e476f68ff23e89bdad5f48cf6e37d1
Author: zhangsy <zhangshiyang17@mails.ucas.ac.cn>
Date:   Fri Dec 29 13:49:11 2023 +0000

    Add kernel DEP.

commit 782697697fc139aadb5320d52a5d87ce4f355024
Author: zhangsy <zhangshiyang17@mails.ucas.ac.cn>
Date:   Fri Dec 29 12:51:19 2023 +0000

    Fix rcu problem and set track problem. Disable interrupt in iee_exception_exit.

commit 8d07f2656e3526e8e35b5b4f3db8353de921f7d9
Author: zhangsy <zhangshiyang17@mails.ucas.ac.cn>
Date:   Thu Dec 21 06:28:32 2023 +0000

    Adapted to openeuler_defconfig.

commit 70e7d3764252e417924df0c44635a9b8b8dee993
Author: zhangsy <zhangshiyang17@mails.ucas.ac.cn>
Date:   Tue Dec 19 06:26:46 2023 +0000

    Add cred protection.

commit 70e9ee95aa14d6bbe35a0467f566bbfa99e62cce
Author: zhangsy <zhangshiyang17@mails.ucas.ac.cn>
Date:   Fri Dec 15 08:45:05 2023 +0000

    Fix flush tlb bug.

commit 9e9f14e3731fd9a0d2ec4fc5ae675ed817674ce6
Author: zhangsy <zhangshiyang17@mails.ucas.ac.cn>
Date:   Sat Dec 9 11:34:37 2023 +0000

    Fix synchronize bugs.

commit 2f2628aa7cae5b007e17ee992d42b736677673b8
Author: zhangsy <zhangshiyang17@mails.ucas.ac.cn>
Date:   Mon Dec 4 08:39:30 2023 +0000

    Switch ASID instead of flush TLB.

commit 3644911dfc5bc7710515e49d164394654eccc315
Author: zhangsy <zhangshiyang17@mails.ucas.ac.cn>
Date:   Thu Nov 30 09:18:45 2023 +0000

    Fix KASLR Error.

commit 0673a6190b0cb0c8db67a7833e1ccdb283f146ed
Author: zhangsy <zhangshiyang17@mails.ucas.ac.cn>
Date:   Thu Sep 28 03:58:04 2023 +0000

    Adapted to GCC.

commit 0d2ab7303bdb644815329dffbb558334fd2cb3ab
Author: zhangsy <zhangshiyang17@mails.ucas.ac.cn>
Date:   Tue Sep 26 07:43:59 2023 +0000

    Fix set pte by cmpxchg bug.

commit 548152aee5caf3e460ae3402b7fcb3f6401d63c0
Author: zhangsy <zhangshiyang17@mails.ucas.ac.cn>
Date:   Fri Sep 22 02:52:26 2023 +0000

    Add Page Table Isolation.
---
 .gitignore                              |   12 +
 Makefile                                |    4 +-
 arch/arm64/Kconfig                      |   18 +
 arch/arm64/include/asm/assembler.h      |   75 +
 arch/arm64/include/asm/daifflags.h      |   16 +
 arch/arm64/include/asm/efi.h            |    4 +
 arch/arm64/include/asm/fixmap.h         |    3 +
 arch/arm64/include/asm/hw_breakpoint.h  |   12 +
 arch/arm64/include/asm/iee-access.h     |   41 +
 arch/arm64/include/asm/iee-cred.h       |  156 ++
 arch/arm64/include/asm/iee-def.h        |   29 +
 arch/arm64/include/asm/iee-si.h         |   73 +
 arch/arm64/include/asm/iee-slab.h       |   16 +
 arch/arm64/include/asm/iee-token.h      |   33 +
 arch/arm64/include/asm/iee.h            |    8 +
 arch/arm64/include/asm/irqflags.h       |   12 +
 arch/arm64/include/asm/kernel-pgtable.h |   12 +
 arch/arm64/include/asm/koi.h            |  346 +++++
 arch/arm64/include/asm/memory.h         |   27 +
 arch/arm64/include/asm/mmu_context.h    |   16 +
 arch/arm64/include/asm/pgalloc.h        |    4 +
 arch/arm64/include/asm/pgtable-hwdef.h  |   13 +
 arch/arm64/include/asm/pgtable.h        |  179 ++-
 arch/arm64/include/asm/pgtable_slab.h   |   15 +
 arch/arm64/include/asm/sysreg.h         |   58 +
 arch/arm64/include/asm/tlb.h            |   32 +
 arch/arm64/include/asm/tlbflush.h       |   35 +-
 arch/arm64/kernel/Makefile              |    2 +
 arch/arm64/kernel/armv8_deprecated.c    |   16 +
 arch/arm64/kernel/asm-offsets.c         |   12 +
 arch/arm64/kernel/cpu_errata.c          |   12 +
 arch/arm64/kernel/cpufeature.c          |  101 ++
 arch/arm64/kernel/debug-monitors.c      |    4 +
 arch/arm64/kernel/entry.S               |  732 +++++++++-
 arch/arm64/kernel/head.S                |   12 +
 arch/arm64/kernel/hibernate.c           |   35 +
 arch/arm64/kernel/hw_breakpoint.c       |   99 ++
 arch/arm64/kernel/iee/Makefile          |    1 +
 arch/arm64/kernel/iee/iee-func.c        |  883 +++++++++++
 arch/arm64/kernel/iee/iee-gate.S        |  326 +++++
 arch/arm64/kernel/iee/iee-pgtable.c     |  356 +++++
 arch/arm64/kernel/iee/iee.c             | 1427 ++++++++++++++++++
 arch/arm64/kernel/iee/pgtable_slab.c    |  116 ++
 arch/arm64/kernel/irq.c                 |    4 +-
 arch/arm64/kernel/koi/Makefile          |    1 +
 arch/arm64/kernel/koi/koi.c             | 1653 +++++++++++++++++++++
 arch/arm64/kernel/mte.c                 |    4 +
 arch/arm64/kernel/process.c             |   17 +-
 arch/arm64/kernel/proton-pack.c         |    8 +
 arch/arm64/kernel/setup.c               |   35 +
 arch/arm64/kernel/syscall.c             |    8 +
 arch/arm64/kernel/traps.c               |    6 +-
 arch/arm64/kernel/vmlinux.lds.S         |   62 +
 arch/arm64/mm/context.c                 |  126 +-
 arch/arm64/mm/fault.c                   |   20 +
 arch/arm64/mm/init.c                    |   37 +-
 arch/arm64/mm/mmu.c                     | 1783 +++++++++++++++++++++--
 arch/arm64/mm/numa.c                    |    4 +
 arch/arm64/mm/pgd.c                     |   30 +
 arch/arm64/mm/proc.S                    |    9 +
 arch/arm64/net/bpf_jit_comp.c           |  138 +-
 drivers/firmware/efi/arm-runtime.c      |    4 +
 drivers/firmware/efi/memmap.c           |   20 +
 drivers/tty/serial/earlycon.c           |    4 +
 drivers/usb/early/ehci-dbgp.c           |    4 +
 fs/cifs/cifs_spnego.c                   |    9 +
 fs/cifs/cifsacl.c                       |    9 +
 fs/coredump.c                           |    8 +
 fs/exec.c                               |   23 +
 fs/file_table.c                         |    1 +
 fs/nfs/flexfilelayout/flexfilelayout.c  |    9 +
 fs/nfs/nfs4idmap.c                      |    9 +
 fs/nfsd/auth.c                          |   38 +
 fs/nfsd/nfs4callback.c                  |    8 +
 fs/nfsd/nfs4recover.c                   |    9 +
 fs/nfsd/nfsfh.c                         |    9 +
 fs/open.c                               |   23 +
 fs/overlayfs/dir.c                      |    9 +
 fs/overlayfs/super.c                    |   12 +
 include/asm-generic/early_ioremap.h     |    3 +
 include/asm-generic/fixmap.h            |   18 +
 include/asm-generic/pgalloc.h           |   44 +
 include/asm-generic/tlb.h               |    3 +
 include/asm-generic/vmlinux.lds.h       |   24 +-
 include/linux/bpf.h                     |   11 +
 include/linux/bpf_verifier.h            |   18 +
 include/linux/cred.h                    |   43 +
 include/linux/efi.h                     |    3 +
 include/linux/filter.h                  |   11 +
 include/linux/iee-flag.h                |   74 +
 include/linux/iee-func.h                |   39 +
 include/linux/mm.h                      |   24 +
 include/linux/mm_types.h                |   28 +
 include/linux/module.h                  |    1 +
 include/linux/sched.h                   |   23 +
 include/linux/sfi_bpf.h                 |   89 ++
 include/linux/skbuff.h                  |    7 +
 include/linux/stacktrace.h              |    4 +
 include/uapi/linux/bpf.h                |    1 +
 include/uapi/linux/bpf_common.h         |    1 +
 init/Kconfig                            |   12 +
 init/main.c                             |   34 +-
 kernel/bpf/Makefile                     |    1 +
 kernel/bpf/arraymap.c                   |  208 ++-
 kernel/bpf/hashtab.c                    |  298 ++++
 kernel/bpf/sfi_bpf.c                    | 1430 ++++++++++++++++++
 kernel/bpf/verifier.c                   |  352 ++++-
 kernel/cred.c                           |  174 +++
 kernel/exit.c                           |    7 +
 kernel/fork.c                           |  386 +++--
 kernel/groups.c                         |    7 +
 kernel/kthread.c                        |   10 +
 kernel/module.c                         |   71 +-
 kernel/smpboot.c                        |    1 +
 kernel/stacktrace.c                     |   38 +
 kernel/sys.c                            |  107 ++
 kernel/umh.c                            |   10 +
 kernel/user_namespace.c                 |   18 +
 mm/Kconfig                              |   12 +
 mm/damon/ops-common.c                   |    8 +
 mm/debug_vm_pgtable.c                   |   24 +
 mm/early_ioremap.c                      |   57 +
 mm/huge_memory.c                        |   10 +-
 mm/init-mm.c                            |   17 +
 mm/memory.c                             |   54 +-
 mm/mmap.c                               |    8 +
 mm/mmu_gather.c                         |  118 ++
 mm/pgtable-generic.c                    |   23 +
 mm/slab.h                               |   16 +
 mm/slab_common.c                        |   18 +
 mm/slub.c                               |  391 ++++-
 mm/sparse-vmemmap.c                     |   10 +
 mm/swap.c                               |    2 +-
 mm/vmalloc.c                            |    4 +
 net/core/filter.c                       |   20 +-
 net/dns_resolver/dns_key.c              |    9 +
 net/ipv4/tcp_bbr.c                      |    2 +-
 net/sched/cls_bpf.c                     |  136 ++
 samples/bpf/Makefile                    |    4 +-
 security/commoncap.c                    |  153 ++
 security/keys/keyctl.c                  |   23 +
 security/keys/process_keys.c            |   45 +
 security/security.c                     |   15 +
 143 files changed, 13970 insertions(+), 378 deletions(-)
 create mode 100644 arch/arm64/include/asm/iee-access.h
 create mode 100644 arch/arm64/include/asm/iee-cred.h
 create mode 100644 arch/arm64/include/asm/iee-def.h
 create mode 100644 arch/arm64/include/asm/iee-si.h
 create mode 100644 arch/arm64/include/asm/iee-slab.h
 create mode 100644 arch/arm64/include/asm/iee-token.h
 create mode 100644 arch/arm64/include/asm/iee.h
 create mode 100644 arch/arm64/include/asm/koi.h
 create mode 100644 arch/arm64/include/asm/pgtable_slab.h
 create mode 100644 arch/arm64/kernel/iee/Makefile
 create mode 100644 arch/arm64/kernel/iee/iee-func.c
 create mode 100644 arch/arm64/kernel/iee/iee-gate.S
 create mode 100644 arch/arm64/kernel/iee/iee-pgtable.c
 create mode 100644 arch/arm64/kernel/iee/iee.c
 create mode 100644 arch/arm64/kernel/iee/pgtable_slab.c
 create mode 100644 arch/arm64/kernel/koi/Makefile
 create mode 100644 arch/arm64/kernel/koi/koi.c
 create mode 100644 include/linux/iee-flag.h
 create mode 100644 include/linux/iee-func.h
 create mode 100644 include/linux/sfi_bpf.h
 create mode 100644 kernel/bpf/sfi_bpf.c

diff --git a/.gitignore b/.gitignore
index 67d2f3503128..2702bc437ab3 100644
--- a/.gitignore
+++ b/.gitignore
@@ -45,6 +45,7 @@
 *.tar
 *.xz
 *.zst
+*.log
 Module.symvers
 modules.builtin
 modules.order
@@ -156,3 +157,14 @@ x509.genkey
 
 # Documentation toolchain
 sphinx_*/
+
+#command
+command.txt
+
+#build
+/build/*
+
+dm-zero.c.koi
+
+run.sh
+gdb.txt
diff --git a/Makefile b/Makefile
index e1e4ca4737a7..803c77376c46 100644
--- a/Makefile
+++ b/Makefile
@@ -504,12 +504,12 @@ LINUXINCLUDE    := \
 		-I$(objtree)/include \
 		$(USERINCLUDE)
 
-KBUILD_AFLAGS   := -D__ASSEMBLY__ -fno-PIE
+KBUILD_AFLAGS   := -D__ASSEMBLY__ -fno-PIE -march=armv8.2-a
 KBUILD_CFLAGS   := -Wall -Wundef -Werror=strict-prototypes -Wno-trigraphs \
 		   -fno-strict-aliasing -fno-common -fshort-wchar -fno-PIE \
 		   -Werror=implicit-function-declaration -Werror=implicit-int \
 		   -Werror=return-type -Wno-format-security \
-		   -std=gnu89
+		   -std=gnu89 -march=armv8.2-a
 KBUILD_CPPFLAGS := -D__KERNEL__
 KBUILD_AFLAGS_KERNEL :=
 KBUILD_CFLAGS_KERNEL :=
diff --git a/arch/arm64/Kconfig b/arch/arm64/Kconfig
index cae54a9bf65d..79b06f0c11d5 100644
--- a/arch/arm64/Kconfig
+++ b/arch/arm64/Kconfig
@@ -1394,6 +1394,24 @@ config UNMAP_KERNEL_AT_EL0
 
 	  If unsure, say Y.
 
+# Config for iee
+config IEE
+	depends on ARM64
+	depends on ARM64_PAN
+	depends on ARM64_VA_BITS_48
+	depends on ARM64_4K_PAGES
+	def_bool y
+
+# Config for support of interruption of iee
+config IEE_INTERRUPTABLE
+	depends on IEE
+	def_bool n
+
+# Config for credentials isolation
+config CREDP
+	depends on IEE
+	def_bool y
+
 config MITIGATE_SPECTRE_BRANCH_HISTORY
 	bool "Mitigate Spectre style attacks against branch history" if EXPERT
 	default y
diff --git a/arch/arm64/include/asm/assembler.h b/arch/arm64/include/asm/assembler.h
index 5e6bacda05d8..090ce447d576 100644
--- a/arch/arm64/include/asm/assembler.h
+++ b/arch/arm64/include/asm/assembler.h
@@ -24,6 +24,41 @@
 #include <asm/ptrace.h>
 #include <asm/thread_info.h>
 
+#ifdef CONFIG_IEE
+    .macro iee_si_restore_daif, flags:req
+    msr daifclr, #0xf
+    tbnz \flags, #6, 114221f
+    tbnz \flags, #7, 114210f
+    tbnz \flags, #8, 114100f
+    msr daifset, #0b000
+    b 114514f
+114221:
+    tbnz \flags, #7, 114211f
+    tbnz \flags, #8, 114101f
+    msr daifset, #0b001
+    b 114514f
+114211:
+    tbnz \flags, #8, 114111f
+    msr daifset, #0b011
+    b 114514f
+114210:
+    tbnz \flags, #8, 114110f
+    msr daifset, #0b010
+    b 114514f
+114100:
+    msr daifset, #0b100
+    b 114514f
+114101:
+    msr daifset, #0b101
+    b 114514f
+114110:
+    msr daifset, #0b110
+    b 114514f
+114111:
+    msr daifset, #0b111
+114514:
+    .endm
+#endif
 	/*
 	 * Provide a wxN alias for each wN register so what we can paste a xN
 	 * reference after a 'w' to obtain the 32-bit version.
@@ -34,11 +69,19 @@
 
 	.macro save_and_disable_daif, flags
 	mrs	\flags, daif
+// #ifdef CONFIG_IEE
+// 	msr	daifset, #0x7
+// #else
 	msr	daifset, #0xf
+// #endif
 	.endm
 
 	.macro disable_daif
+// #ifdef CONFIG_IEE
+// 	msr	daifset, #0x7
+// #else
 	msr	daifset, #0xf
+// #endif
 	.endm
 
 	.macro enable_daif
@@ -46,7 +89,11 @@
 	.endm
 
 	.macro	restore_daif, flags:req
+// #ifdef CONFIG_IEE
+//     iee_si_restore_daif \flags
+// #else
 	msr	daif, \flags
+// #endif
 	.endm
 
 	/* IRQ is the lowest priority flag, unconditionally unmask the rest. */
@@ -63,7 +110,11 @@
 	.endm
 
 	.macro	restore_irq, flags
+// #ifdef CONFIG_IEE
+//     iee_si_restore_daif \flags
+// #else
 	msr	daif, \flags
+// #endif
 	.endm
 
 	.macro	enable_dbg
@@ -71,20 +122,44 @@
 	.endm
 
 	.macro	disable_step_tsk, flgs, tmp
+// #ifdef CONFIG_IEE
+// 1145:
+//     tbz	\flgs, #TIF_SINGLESTEP, 9990f
+// 	mrs	\tmp, mdscr_el1
+// 	bic	\tmp, \tmp, #DBG_MDSCR_SS
+//     orr	\tmp, \tmp, #DBG_MDSCR_MDE
+// 	msr	mdscr_el1, \tmp
+// 	isb	// Synchronise with enable_dbg
+//     mrs \tmp, mdscr_el1
+//     tbz \tmp, #15, 1145b
+// #else
 	tbz	\flgs, #TIF_SINGLESTEP, 9990f
 	mrs	\tmp, mdscr_el1
 	bic	\tmp, \tmp, #DBG_MDSCR_SS
 	msr	mdscr_el1, \tmp
 	isb	// Synchronise with enable_dbg
+// #endif
 9990:
 	.endm
 
 	/* call with daif masked */
 	.macro	enable_step_tsk, flgs, tmp
+// #ifdef CONFIG_IEE
+// 1146:
+//     tbz	\flgs, #TIF_SINGLESTEP, 9990f
+// 	mrs	\tmp, mdscr_el1
+// 	orr	\tmp, \tmp, #DBG_MDSCR_SS
+//     orr	\tmp, \tmp, #DBG_MDSCR_MDE
+// 	msr	mdscr_el1, \tmp
+// 	isb	// Synchronise with enable_dbg
+//     mrs \tmp, mdscr_el1
+//     tbz \tmp, #15, 1146b
+// #else
 	tbz	\flgs, #TIF_SINGLESTEP, 9990f
 	mrs	\tmp, mdscr_el1
 	orr	\tmp, \tmp, #DBG_MDSCR_SS
 	msr	mdscr_el1, \tmp
+// #endif
 9990:
 	.endm
 
diff --git a/arch/arm64/include/asm/daifflags.h b/arch/arm64/include/asm/daifflags.h
index cfdde3a56805..9bc43023c072 100644
--- a/arch/arm64/include/asm/daifflags.h
+++ b/arch/arm64/include/asm/daifflags.h
@@ -25,11 +25,19 @@ static inline void local_daif_mask(void)
 		(read_sysreg_s(SYS_ICC_PMR_EL1) == (GIC_PRIO_IRQOFF |
 						    GIC_PRIO_PSR_I_SET)));
 
+// #ifdef CONFIG_IEE
+// 	asm volatile(
+// 		"msr	daifset, #0x7		// local_daif_mask\n"
+// 		:
+// 		:
+// 		: "memory");
+// #else
 	asm volatile(
 		"msr	daifset, #0xf		// local_daif_mask\n"
 		:
 		:
 		: "memory");
+// #endif
 
 	/* Don't really care for a dsb here, we don't intend to enable IRQs */
 	if (system_uses_irq_prio_masking())
@@ -114,7 +122,11 @@ static inline void local_daif_restore(unsigned long flags)
 		gic_write_pmr(pmr);
 	}
 
+// #ifdef CONFIG_IEE
+//     iee_si_write_daif(flags);
+// #else
 	write_sysreg(flags, daif);
+// #endif
 
 	if (irq_disabled)
 		trace_hardirqs_off();
@@ -139,6 +151,10 @@ static inline void local_daif_inherit(struct pt_regs *regs)
 	 * system_has_prio_mask_debugging() won't restore the I bit if it can
 	 * use the pmr instead.
 	 */
+// #ifdef CONFIG_IEE
+//     iee_si_write_daif(flags);
+// #else
 	write_sysreg(flags, daif);
+// #endif
 }
 #endif
diff --git a/arch/arm64/include/asm/efi.h b/arch/arm64/include/asm/efi.h
index 8fa8a3c9af3e..518ce0d6aa49 100644
--- a/arch/arm64/include/asm/efi.h
+++ b/arch/arm64/include/asm/efi.h
@@ -52,7 +52,11 @@ efi_status_t __efi_rt_asm_wrapper(void *, const char *, ...);
 #define arch_efi_save_flags(state_flags)		\
 	((void)((state_flags) = read_sysreg(daif)))
 
+// #ifdef CONFIG_IEE
+// #define arch_efi_restore_flags(state_flags)	iee_si_write_daif(state_flags)
+// #else
 #define arch_efi_restore_flags(state_flags)	write_sysreg(state_flags, daif)
+// #endif
 
 
 /* arch specific definitions used by the stub code */
diff --git a/arch/arm64/include/asm/fixmap.h b/arch/arm64/include/asm/fixmap.h
index daff882883f9..7511e89ed954 100644
--- a/arch/arm64/include/asm/fixmap.h
+++ b/arch/arm64/include/asm/fixmap.h
@@ -106,6 +106,9 @@ void __init early_fixmap_init(void);
 #define __late_clear_fixmap(idx) __set_fixmap((idx), 0, FIXMAP_PAGE_CLEAR)
 
 extern void __set_fixmap(enum fixed_addresses idx, phys_addr_t phys, pgprot_t prot);
+#ifdef CONFIG_PTP
+extern void __iee_set_fixmap_pre_init(enum fixed_addresses idx, phys_addr_t phys, pgprot_t prot);
+#endif
 
 #include <asm-generic/fixmap.h>
 
diff --git a/arch/arm64/include/asm/hw_breakpoint.h b/arch/arm64/include/asm/hw_breakpoint.h
index bc7aaed4b34e..16e0e8cfea1d 100644
--- a/arch/arm64/include/asm/hw_breakpoint.h
+++ b/arch/arm64/include/asm/hw_breakpoint.h
@@ -104,6 +104,18 @@ static inline void decode_ctrl_reg(u32 reg,
 	write_sysreg(VAL, dbg##REG##N##_el1);\
 } while (0)
 
+#ifdef CONFIG_IEE
+#define IEE_SI_AARCH64_DBG_READ(N, REG, VAL) do{\
+    VAL = this_cpu_read(iee_si_user_##REG##N);\
+} while (0)
+
+#define IEE_SI_AARCH64_DBG_WRITE(N, REG, VAL) do{\
+    u64 __val = (u64)(VAL);  \
+	this_cpu_write(iee_si_user_##REG##N, __val);\
+    iee_rwx_gate_entry(IEE_WRITE_AFSR0);\
+} while (0)
+#endif
+
 struct task_struct;
 struct notifier_block;
 struct perf_event_attr;
diff --git a/arch/arm64/include/asm/iee-access.h b/arch/arm64/include/asm/iee-access.h
new file mode 100644
index 000000000000..cd3344090d0b
--- /dev/null
+++ b/arch/arm64/include/asm/iee-access.h
@@ -0,0 +1,41 @@
+#ifndef _LINUX_IEE_ACCESS_H
+#define _LINUX_IEE_ACCESS_H
+
+#include <asm/iee-def.h>
+#include <asm/iee-slab.h>
+
+extern unsigned long long iee_rw_gate(int flag, ...);
+
+#ifdef CONFIG_IEE
+void iee_write_in_byte(void *ptr, u64 data, int length)
+{
+	iee_rw_gate(IEE_WRITE_IN_BYTE, ptr, data, length);
+}
+
+void iee_memset(void *ptr, int data, size_t n)
+{
+	iee_rw_gate(IEE_MEMSET, ptr, data, n);
+}
+
+void iee_set_track(struct track *ptr, struct track *data)
+{
+	iee_rw_gate(IEE_OP_SET_TRACK, ptr, data);
+}
+
+void iee_set_freeptr(void **pptr, void *ptr)
+{
+	iee_rw_gate(IEE_OP_SET_FREEPTR, pptr, ptr);
+}
+
+void iee_copy_pte_range(pte_t *new_dst, pte_t *old_dst, pte_t *src_pte, struct vm_area_struct *src_vma, unsigned long dst_vm_flags, pte_t *end_pte)
+{
+	iee_rw_gate(IEE_COPY_PTE_RANGE, new_dst, old_dst, src_pte, src_vma, dst_vm_flags, end_pte);
+}
+
+void iee_split_huge_pmd(pmd_t *pmdp, pte_t *pgtable)
+{
+	iee_rw_gate(IEE_SPLIT_HUGE_PMD, pmdp, pgtable);
+}
+#endif
+
+#endif
\ No newline at end of file
diff --git a/arch/arm64/include/asm/iee-cred.h b/arch/arm64/include/asm/iee-cred.h
new file mode 100644
index 000000000000..a9c0dafbfe9c
--- /dev/null
+++ b/arch/arm64/include/asm/iee-cred.h
@@ -0,0 +1,156 @@
+#ifndef _LINUX_IEE_CRED_H
+#define _LINUX_IEE_CRED_H
+
+#include <linux/cred.h>
+#include <asm/iee-def.h>
+
+extern unsigned long long iee_rw_gate(int flag, ...);
+
+#ifdef CONFIG_CREDP
+
+extern void _iee_do_commit_cred(unsigned long iee_offset, struct cred *new);
+static void __maybe_unused iee_commit_cred(struct cred *cred)
+{
+    iee_rw_gate(IEE_OP_COMMIT_CRED, cred);
+}
+static void __maybe_unused iee_copy_cred_kernel(const struct cred *old, struct cred *new)
+{
+    iee_rw_gate(IEE_OP_COPY_CRED_KERNEL,old,new);
+}
+
+static void __maybe_unused iee_copy_cred(const struct cred *old, struct cred *new)
+{
+    iee_rw_gate(IEE_OP_COPY_CRED,old,new);
+}
+
+static void __maybe_unused iee_set_cred_uid(struct cred *cred, kuid_t uid)
+{
+    iee_rw_gate(IEE_OP_SET_CRED_UID,cred,uid);
+}
+
+static void __maybe_unused iee_set_cred_gid(struct cred *cred, kgid_t gid)
+{
+    iee_rw_gate(IEE_OP_SET_CRED_GID,cred,gid);
+}
+
+static void __maybe_unused iee_set_cred_suid(struct cred *cred, kuid_t suid)
+{
+    iee_rw_gate(IEE_OP_SET_CRED_SUID,cred,suid);
+}
+
+static void __maybe_unused iee_set_cred_sgid(struct cred *cred, kgid_t sgid)
+{
+    iee_rw_gate(IEE_OP_SET_CRED_SGID,cred,sgid);
+}
+
+static void __maybe_unused iee_set_cred_euid(struct cred *cred, kuid_t euid)
+{
+    iee_rw_gate(IEE_OP_SET_CRED_EUID,cred,euid);
+}
+
+static void __maybe_unused iee_set_cred_egid(struct cred *cred, kgid_t egid)
+{
+    iee_rw_gate(IEE_OP_SET_CRED_EGID,cred,egid);
+}
+
+static void __maybe_unused iee_set_cred_fsuid(struct cred *cred, kuid_t fsuid)
+{
+    iee_rw_gate(IEE_OP_SET_CRED_FSUID,cred,fsuid);
+}
+
+static void __maybe_unused iee_set_cred_fsgid(struct cred *cred, kgid_t fsgid)
+{
+    iee_rw_gate(IEE_OP_SET_CRED_FSGID,cred,fsgid);
+}
+
+static void __maybe_unused iee_set_cred_user(struct cred *cred, struct user_struct *user)
+{
+    iee_rw_gate(IEE_OP_SET_CRED_USER,cred,user);
+}
+
+static void __maybe_unused iee_set_cred_user_ns(struct cred *cred, struct user_namespace *user_ns)
+{
+    iee_rw_gate(IEE_OP_SET_CRED_USER_NS,cred,user_ns);
+}
+
+static void __maybe_unused iee_set_cred_group_info(struct cred *cred, struct group_info *group_info)
+{
+    iee_rw_gate(IEE_OP_SET_CRED_GROUP_INFO,cred,group_info);
+}
+
+static void __maybe_unused iee_set_cred_securebits(struct cred *cred, unsigned securebits)
+{
+    iee_rw_gate(IEE_OP_SET_CRED_SECUREBITS,cred,securebits);
+}
+
+static void __maybe_unused iee_set_cred_cap_inheritable(struct cred *cred, kernel_cap_t cap_inheritable)
+{
+    iee_rw_gate(IEE_OP_SET_CRED_CAP_INHER,cred,cap_inheritable);
+}
+
+static void __maybe_unused iee_set_cred_cap_permitted(struct cred *cred, kernel_cap_t cap_permitted)
+{
+    iee_rw_gate(IEE_OP_SET_CRED_CAP_PERM,cred,cap_permitted);
+}
+
+static void __maybe_unused iee_set_cred_cap_effective(struct cred *cred, kernel_cap_t cap_effective)
+{
+    iee_rw_gate(IEE_OP_SET_CRED_CAP_EFFECT,cred,cap_effective);
+}
+
+static void __maybe_unused iee_set_cred_cap_bset(struct cred *cred, kernel_cap_t cap_bset)
+{
+    iee_rw_gate(IEE_OP_SET_CRED_CAP_BSET,cred,cap_bset);
+}
+
+static void __maybe_unused iee_set_cred_cap_ambient(struct cred *cred, kernel_cap_t cap_ambient)
+{
+    iee_rw_gate(IEE_OP_SET_CRED_CAP_AMBIENT,cred,cap_ambient);
+}
+
+#ifdef CONFIG_KEYS
+static void __maybe_unused iee_set_cred_jit_keyring(struct cred *cred, unsigned char jit_keyring)
+{
+    iee_rw_gate(IEE_OP_SET_CRED_JIT_KEYRING,cred,jit_keyring);
+}
+
+static void __maybe_unused iee_set_cred_session_keyring(struct cred *cred, struct key *session_keyring)
+{
+    iee_rw_gate(IEE_OP_SET_CRED_SESS_KEYRING,cred,session_keyring);
+}
+
+static void __maybe_unused iee_set_cred_process_keyring(struct cred *cred, struct key *process_keyring)
+{
+    iee_rw_gate(IEE_OP_SET_CRED_PROC_KEYRING,cred,process_keyring);
+}
+
+static void __maybe_unused iee_set_cred_thread_keyring(struct cred *cred, struct key *thread_keyring)
+{
+    iee_rw_gate(IEE_OP_SET_CRED_THREAD_KEYRING,cred,thread_keyring);
+}
+
+static void __maybe_unused iee_set_cred_request_key_auth(struct cred *cred, struct key *request_key_auth)
+{
+    iee_rw_gate(IEE_OP_SET_CRED_REQ_KEYRING,cred,request_key_auth);
+}
+#endif
+
+static void __maybe_unused iee_set_cred_atomic_set_usage(struct cred *cred, int i)
+{
+    iee_rw_gate(IEE_OP_SET_CRED_ATSET_USAGE,cred,i);
+}
+
+#ifdef CONFIG_SECURITY
+static void __maybe_unused iee_set_cred_security(struct cred *cred, void *security)
+{
+    iee_rw_gate(IEE_OP_SET_CRED_SECURITY,cred,security);
+}
+#endif
+
+static void __maybe_unused iee_set_cred_rcu(struct cred *cred, struct rcu_head *rcu)
+{
+    iee_rw_gate(IEE_OP_SET_CRED_RCU,cred,rcu);
+}
+#endif
+
+#endif
\ No newline at end of file
diff --git a/arch/arm64/include/asm/iee-def.h b/arch/arm64/include/asm/iee-def.h
new file mode 100644
index 000000000000..bcd0502b28c4
--- /dev/null
+++ b/arch/arm64/include/asm/iee-def.h
@@ -0,0 +1,29 @@
+#ifndef _LINUX_IEE_DEF_H
+#define _LINUX_IEE_DEF_H
+// Function Identifiers with Parameters Description
+
+/* Add new IEE ops here */
+
+#define AT_INC 1
+#define AT_INC_NOT_ZERO 2
+#define AT_DEC_AND_TEST 3
+/* Atomic ops for atomic_t */
+
+#ifdef CONFIG_KOI
+#define IEE_SWITCH_TO_KERNEL    7
+#define IEE_SWITCH_TO_KOI       8
+#endif
+
+#if defined(CONFIG_KOI) && defined(CONFIG_IEE)
+#define IEE_READ_KOI_STACK 51
+#define IEE_WRITE_KOI_STACK 52
+#define IEE_READ_TOKEN_TTBR1 53
+#define IEE_WRITE_TOKEN_TTBR1 54
+#define IEE_READ_KOI_KERNEL_STACK 55
+#define IEE_WRITE_KOI_KERNEL_STACK 56
+#define IEE_READ_KOI_STACK_BASE 57
+#define IEE_WRITE_KOI_STACK_BASE 58
+#define IEE_SET_KOI_PGD 59
+#endif
+
+#endif
\ No newline at end of file
diff --git a/arch/arm64/include/asm/iee-si.h b/arch/arm64/include/asm/iee-si.h
new file mode 100644
index 000000000000..6a48fe0aef9d
--- /dev/null
+++ b/arch/arm64/include/asm/iee-si.h
@@ -0,0 +1,73 @@
+#ifndef _LINUX_IEE_SI_H
+#define _LINUX_IEE_SI_H
+
+#include <asm/sysreg.h>
+#define __iee_si_code   __section(".iee.si_text")
+#define __iee_si_base   __section(".iee.si_base")
+#define __iee_si_data   __section(".iee.si_data")
+
+/* Used for copying globals that iee rwx gate needs. */
+extern unsigned long iee_base_swapper_pg_dir;
+extern unsigned long iee_base_idmap_pg_dir;
+extern unsigned long iee_base_reserved_pg_dir;
+extern unsigned long iee_base__bp_harden_el1_vectors;
+extern bool iee_init_done;
+extern unsigned long iee_si_tcr;
+extern unsigned long iee_si_tcr_outside;
+extern unsigned long iee_si_tcr_inside;
+
+DECLARE_PER_CPU(unsigned long, iee_si_user_bvr0);
+DECLARE_PER_CPU(unsigned long, iee_si_user_bcr0);
+
+/* The following are __init functions used for iee si initialization. */
+extern void mark_idmap_vmallc_map_ROU(void);
+extern void iee_si_prepare_data(void);
+
+extern int iee_si_test_page_attr(unsigned long addr);
+// extern void iee_si_test_page_attr_all(unsigned long addr);
+extern unsigned long __iee_si_start[];
+// Handler function for sensitive inst
+u64 iee_si_handler(int flag, ...);
+/* 
+ * TODO: scan a page to check whether it contains sensitive instructions 
+ * return 1 when finding sensitive inst, 0 on safe page.
+ */
+extern int iee_si_scan_page(unsigned long addr);
+
+
+#define DBG_MDSCR_SS		(1 << 0)
+#define DBG_MDSCR_MDE		(1 << 15)
+
+#define IEE_SI_TEST 0
+#define IEE_WRITE_SCTLR 1
+#define IEE_WRITE_TTBR0 2
+#define IEE_WRITE_VBAR  3
+#define IEE_WRITE_TCR   4
+#define IEE_WRITE_MDSCR   5
+#define IEE_CONTEXT_SWITCH      6
+#define IEE_WRITE_AFSR0     10
+#define IEE_ENABLE_CNP      11
+#define IEE_NONBOOT_TTBR1   12
+/* Provide ttbr1 switch gate for KOI */
+#ifdef CONFIG_KOI
+#define IEE_SWITCH_TO_KERNEL    7
+#define IEE_SWITCH_TO_KOI       8
+#endif
+/* MASK modify-permitted bits on IEE protected sys registers */
+#define IEE_SCTLR_MASK  (SCTLR_EL1_CP15BEN | SCTLR_EL1_SED | SCTLR_EL1_UCT | SCTLR_EL1_UCI |\
+                    SCTLR_EL1_BT0 | SCTLR_EL1_BT1 | SCTLR_EL1_TCF0_MASK | SCTLR_ELx_DSSBS)
+#define IEE_TTBR0_MASK  ~0
+#define IEE_TTBR1_MASK  ~0
+#define IEE_TCR_MASK    (TCR_HD | TCR_T0SZ_MASK | TCR_E0PD1)
+#define IEE_MDSCR_MASK  (DBG_MDSCR_SS | DBG_MDSCR_MDE)
+
+#define IEE_DBGBCR_BT 0b0000 << 20
+#define IEE_DBGBCR_SSC 0b00 << 14
+#define IEE_DBGBCR_HMC 0b1 << 13
+#define IEE_DBGBCR_BAS 0b1111 << 5
+#define IEE_DBGBCR_PMC 0b11 << 1
+#define IEE_DBGBCR_E 0b1
+#define IEE_DBGBCR IEE_DBGBCR_BT | IEE_DBGBCR_SSC | IEE_DBGBCR_HMC | IEE_DBGBCR_BAS \
+                | IEE_DBGBCR_PMC | IEE_DBGBCR_E
+
+#endif
\ No newline at end of file
diff --git a/arch/arm64/include/asm/iee-slab.h b/arch/arm64/include/asm/iee-slab.h
new file mode 100644
index 000000000000..7a0bba204483
--- /dev/null
+++ b/arch/arm64/include/asm/iee-slab.h
@@ -0,0 +1,16 @@
+#ifndef _LINUX_IEE_SLAB_H
+#define _LINUX_IEE_SLAB_H
+
+#define TRACK_ADDRS_COUNT 16
+
+struct track {
+	unsigned long addr;	/* Called from address */
+#ifdef CONFIG_STACKTRACE
+	unsigned long addrs[TRACK_ADDRS_COUNT];	/* Called from address */
+#endif
+	int cpu;		/* Was running on cpu */
+	int pid;		/* Pid context */
+	unsigned long when;	/* When did the operation occur */
+};
+
+#endif
\ No newline at end of file
diff --git a/arch/arm64/include/asm/iee-token.h b/arch/arm64/include/asm/iee-token.h
new file mode 100644
index 000000000000..14b21cb63bd9
--- /dev/null
+++ b/arch/arm64/include/asm/iee-token.h
@@ -0,0 +1,33 @@
+#ifndef _LINUX_IEE_TOKEN_H
+#define _LINUX_IEE_TOKEN_H
+
+#include <asm/iee-def.h>
+
+extern unsigned long long iee_rw_gate(int flag, ...);
+struct task_token;
+struct task_struct;
+struct mm_struct;
+
+#ifdef CONFIG_IEE
+void iee_set_token_pgd(struct task_struct *tsk, pgd_t *pgd)
+{
+	iee_rw_gate(IEE_SET_TOKEN_PGD, tsk, pgd);
+}
+
+void iee_init_token(struct task_struct *tsk, void *iee_stack, void *tmp_page)
+{
+	iee_rw_gate(IEE_INIT_TOKEN, tsk, iee_stack, tmp_page);
+}
+
+void iee_invalidate_token(struct task_struct *tsk)
+{
+	iee_rw_gate(IEE_INVALIDATE_TOKEN, tsk);
+}
+
+void iee_validate_token(struct task_struct *tsk)
+{
+	iee_rw_gate(IEE_VALIDATE_TOKEN, tsk);
+}
+#endif
+
+#endif
\ No newline at end of file
diff --git a/arch/arm64/include/asm/iee.h b/arch/arm64/include/asm/iee.h
new file mode 100644
index 000000000000..2afdfe6cf89b
--- /dev/null
+++ b/arch/arm64/include/asm/iee.h
@@ -0,0 +1,8 @@
+#ifndef _LINUX_IEE_H
+#define _LINUX_IEE_H
+#define __iee_code		__section(".iee.text")
+#define __iee_header  __section(".iee.text.header")
+
+#include <asm/iee-def.h>
+
+#endif
diff --git a/arch/arm64/include/asm/irqflags.h b/arch/arm64/include/asm/irqflags.h
index ff328e5bbb75..022acbea44cc 100644
--- a/arch/arm64/include/asm/irqflags.h
+++ b/arch/arm64/include/asm/irqflags.h
@@ -121,6 +121,17 @@ static inline unsigned long arch_local_irq_save(void)
  */
 static inline void arch_local_irq_restore(unsigned long flags)
 {
+// #ifdef CONFIG_IEE
+// 	asm volatile(ALTERNATIVE(
+// 		IEE_SI_WRITE_DAIF_SEL,
+// 		__msr_s(SYS_ICC_PMR_EL1, "%0")"\n\tb 114f\n\tnop\n\tnop\n\tnop\n\tnop"
+//         "\n\tnop\n\tnop\n\tnop\n\tnop\n\tnop\n\tnop\n\tnop\n\tnop\n\tnop"
+//         "\n\tnop\n\tnop\n\tnop\n\tnop\n\tnop\n\tnop\n\tnop\n\tnop\n\t114:\n\t",
+// 		ARM64_HAS_IRQ_PRIO_MASKING)
+// 		:
+// 		: "r" (flags)
+// 		: "memory");
+// #else
 	asm volatile(ALTERNATIVE(
 		"msr	daif, %0",
 		__msr_s(SYS_ICC_PMR_EL1, "%0"),
@@ -129,6 +140,7 @@ static inline void arch_local_irq_restore(unsigned long flags)
 		: "r" (flags)
 		: "memory");
 
+// #endif
 	pmr_sync();
 }
 
diff --git a/arch/arm64/include/asm/kernel-pgtable.h b/arch/arm64/include/asm/kernel-pgtable.h
index 4b06cf9a8c8a..67b9b6c04093 100644
--- a/arch/arm64/include/asm/kernel-pgtable.h
+++ b/arch/arm64/include/asm/kernel-pgtable.h
@@ -115,6 +115,18 @@
 #define SWAPPER_MM_MMUFLAGS	(PTE_ATTRINDX(MT_NORMAL) | SWAPPER_PTE_FLAGS)
 #endif
 
+#ifdef CONFIG_IEE
+
+#define SWAPPER_PTE_FLAGS_IDMAP	(PTE_TYPE_PAGE | PTE_AF | PTE_SHARED | PTE_RDONLY)
+#define SWAPPER_PMD_FLAGS_IDMAP	(PMD_TYPE_SECT | PMD_SECT_AF | PMD_SECT_S | PMD_SECT_RDONLY)
+
+#if ARM64_SWAPPER_USES_SECTION_MAPS
+#define SWAPPER_MM_MMUFLAGS_IDMAP	(PMD_ATTRINDX(MT_NORMAL) | SWAPPER_PMD_FLAGS_IDMAP)
+#else
+#define SWAPPER_MM_MMUFLAGS_IDMAP	(PTE_ATTRINDX(MT_NORMAL) | SWAPPER_PTE_FLAGS_IDMAP)
+#endif
+
+#endif
 /*
  * To make optimal use of block mappings when laying out the linear
  * mapping, round down the base of physical memory to a size that can
diff --git a/arch/arm64/include/asm/koi.h b/arch/arm64/include/asm/koi.h
new file mode 100644
index 000000000000..2955ac6b0208
--- /dev/null
+++ b/arch/arm64/include/asm/koi.h
@@ -0,0 +1,346 @@
+#include "linux/mm.h"
+#include "asm/current.h"
+#include "asm/pgtable-hwdef.h"
+#include "asm/pgtable-types.h"
+#include "asm/pgtable.h"
+#include "linux/mm_types.h"
+#include "linux/pgtable.h"
+#include "linux/printk.h"
+#include "linux/slab.h"
+#include "linux/string.h"
+#include <linux/sched.h>
+#include "linux/hashtable.h"
+#include "linux/module.h"
+#include "linux/vmalloc.h"
+#include "stacktrace.h"
+#include "asm/mmu.h"
+#ifdef CONFIG_IEE
+#include "asm/iee-si.h"
+#include "asm/iee-def.h"
+#endif
+
+#ifdef CONFIG_KOI
+#ifdef CONFIG_PTP
+extern void set_iee_page(unsigned long addr);
+#endif
+
+#define HASH_TABLE_BIT 10
+#define HASH_TABLE_LEN (1 << HASH_TABLE_BIT)
+#define HASH_KEY_MASK ((1 << HASH_TABLE_BIT) - 1)
+
+#define MAX_VAR_NAME 64
+#define DRIVER_ISOLATION_VAR_ARRAY_SIZE 32
+#define DRIVER_ISOLATION_MAX_VAL 256
+
+extern struct hlist_head koi_mem_htbl[1024];
+extern spinlock_t koi_mem_htbl_spin_lock;
+extern unsigned long koi_swapper_ttbr1;
+extern s64 koi_offset;
+
+#ifdef CONFIG_IEE
+extern unsigned long long iee_rw_gate(int flag, ...);
+#endif
+
+DECLARE_PER_CPU(unsigned long[PAGE_SIZE / sizeof(unsigned long)],
+		koi_irq_current_ttbr1);
+
+/**
+* struct koi_mem_hash_node - 
+*@mod:pointer to driver module
+*@mem_list_head:free memory list head
+*@ko_mm: mm_struct in each driver
+*@pgdp:entry to Page Global Directory :pgd
+*@node:hash linked list node
+*@addr_htbl[1 << (HASH_TABLE_BIT)]: 
+*@rcu:
+*/
+struct koi_mem_hash_node {
+	struct module *mod;
+	struct list_head mem_list_head;
+	struct mm_struct *ko_mm;
+	pgd_t *pgdp;
+	unsigned long ko_ttbr1;
+	struct hlist_node node;
+	struct hlist_head addr_htbl[1 << (HASH_TABLE_BIT)];
+	struct rcu_head rcu;
+	// used to protect free mem list
+	spinlock_t spin_lock;
+	// used to protect addr hashtable
+	spinlock_t addr_htbl_spin_lock;
+    bool is_valid;
+    spinlock_t mod_lock;
+};
+//describe the global shared var
+struct shared_variable_descriptor {
+	unsigned int id;
+	unsigned int type;
+	char name[MAX_VAR_NAME];
+	unsigned long offset;
+	unsigned int size;
+	unsigned int self_ptr_ids[DRIVER_ISOLATION_VAR_ARRAY_SIZE];
+};
+
+int koi_do_switch_to_kernel_pgtbl(void);
+
+int koi_copy_pagetable(struct mm_struct *ko_mm, pgd_t *koi_pg_dir,
+		       unsigned long addr, unsigned long end);
+
+void koi_create_pagetable(struct module *mod);
+void koi_destroy_pagetable(struct module *mod);
+
+void koi_map_kostack(struct module *mod);
+unsigned long koi_mem_alloc(struct module *mod, unsigned long orig_addr,
+			    unsigned long size);
+void koi_mem_free(struct module *mod, unsigned long addr, unsigned long size,
+		  bool is_const, int count, ...);
+void *koi_mem_lookup(struct module *mod, unsigned long addr);
+void koi_mem_free_callback(struct module *mod, unsigned long addr,
+			   unsigned long size, void (*func)(void *));
+void koi_map_mem(struct module *mod, unsigned long addr, unsigned long size);
+void koi_unmap_mem(struct module *mod, unsigned long addr, unsigned long size);
+void koi_mem_free_to_user(struct module *mod, unsigned long addr,
+			  unsigned long size);
+
+unsigned long koi_ttbr_ctor(struct module *mod);
+extern void koi_do_switch_to_kernel_stack(void);
+extern void koi_do_switch_to_ko_stack(void);
+
+// unsigned long koi_get_token_addr(struct task_struct *tsk);
+
+#define switch_pgtable(ttbr1)                                                  \
+	do {                                                                   \
+		write_sysreg((ttbr1), ttbr1_el1);                                \
+		isb();                                                         \
+		asm volatile(ALTERNATIVE("nop; nop; nop",                      \
+					 "ic iallu; dsb nsh; isb",             \
+					 ARM64_WORKAROUND_CAVIUM_27456));      \
+	} while (0);
+
+#ifndef CONFIG_IEE
+#define koi_switch_to_ko()                                                     \
+	do {                                                                   \
+		unsigned long flags, ko_ttbr1, cur_sp;                         \
+		unsigned long *ptr;                                            \
+		struct task_token *token;                                      \
+		asm volatile("mrs %0, daif\n"                                  \
+			     "msr daifset, #2\n"                               \
+			     "isb\n"                                           \
+			     "mov %1, sp\n"                                    \
+			     : "=r"(flags), "=r"(cur_sp)                       \
+			     :);                                               \
+		if (!on_irq_stack(cur_sp, NULL)) {                             \
+			koi_do_switch_to_ko_stack();                           \
+			ko_ttbr1 = koi_ttbr_ctor(THIS_MODULE);                 \
+			token = (struct task_token *)((unsigned long)current + \
+						      (unsigned long)koi_offset);             \
+			token->current_ttbr1 = ko_ttbr1 & (~TTBR_ASID_MASK);   \
+		} else {                                                       \
+			ko_ttbr1 = koi_ttbr_ctor(THIS_MODULE);                 \
+			ptr = SHIFT_PERCPU_PTR(koi_irq_current_ttbr1,          \
+					       __kern_my_cpu_offset());        \
+			*ptr = ko_ttbr1 & ~(TTBR_ASID_MASK);                   \
+		}                                                              \
+		switch_pgtable(ko_ttbr1);                                      \
+		asm volatile("msr daif, %0\n"                                  \
+			     "isb\n"                                           \
+			     :                                                 \
+			     : "r"(flags));                                    \
+	} while (0);
+
+#define koi_switch_to_kernel()                                                 \
+	do {                                                                   \
+		unsigned long cur_sp, flags, asid;                                   \
+		unsigned long *ptr;                                            \
+		struct task_token *token;                                      \
+		asm volatile("mrs %0, daif\n"                                  \
+			     "msr daifset, #2\n"                               \
+			     "isb\n"                                           \
+			     "mov %1, sp\n"                                    \
+			     : "=r"(flags), "=r"(cur_sp)                     \
+			     :);                                               \
+        asid = read_sysreg(ttbr0_el1) & (~USER_ASID_FLAG);            \
+        asid &= TTBR_ASID_MASK;             \
+		switch_pgtable((koi_swapper_ttbr1 | asid));                             \
+		if (!on_irq_stack(cur_sp, NULL)) {                             \
+			token = (struct task_token *)((unsigned long)current + \
+						      (unsigned long)koi_offset);             \
+			token->current_ttbr1 = koi_swapper_ttbr1;              \
+			koi_do_switch_to_kernel_stack();                       \
+		} else {                                                       \
+			ptr = SHIFT_PERCPU_PTR(koi_irq_current_ttbr1,              \
+					       __kern_my_cpu_offset());        \
+			*ptr = koi_swapper_ttbr1;                                  \
+		}                                                              \
+		asm volatile("msr daif, %0\n"                                  \
+			     "isb\n"                                           \
+			     :                                                 \
+			     : "r"(flags));                                    \
+	} while (0);
+#else
+#define koi_switch_to_ko()                                                     \
+	do {                                                                   \
+		unsigned long cur_sp, flags, ko_ttbr1;                         \
+		unsigned long *ptr;                                            \
+		asm volatile("mrs %0, daif\n"                                  \
+			     "msr daifset, #2\n"                               \
+			     "isb\n"                                           \
+			     "mov %1, sp\n"                                    \
+			     : "=r"(flags), "=r"(cur_sp)                       \
+			     :);                                               \
+		if (!on_irq_stack(cur_sp, NULL)) {                             \
+			koi_do_switch_to_ko_stack();                           \
+			ko_ttbr1 = koi_ttbr_ctor(THIS_MODULE);                 \
+			iee_rw_gate(IEE_WRITE_TOKEN_TTBR1, current,            \
+				    ko_ttbr1 &(~TTBR_ASID_MASK));              \
+		} else {                                                       \
+			ko_ttbr1 = koi_ttbr_ctor(THIS_MODULE);                 \
+			ptr = SHIFT_PERCPU_PTR(koi_irq_current_ttbr1,          \
+					       __kern_my_cpu_offset());        \
+			*ptr = ko_ttbr1 & (~TTBR_ASID_MASK);                   \
+		}                                                              \
+		iee_rwx_gate_entry(IEE_SWITCH_TO_KOI, ko_ttbr1);               \
+		asm volatile("msr daif, %0\n"                                  \
+			     "isb\n"                                           \
+			     :                                                 \
+			     : "r"(flags));                                    \
+	} while (0);
+
+#define koi_switch_to_kernel()                                                 \
+	do {                                                                   \
+		unsigned long flags, cur_sp;                                   \
+		unsigned long *ptr;                                            \
+		asm volatile("mrs %0, daif\n"                                  \
+			     "msr daifset, #2\n"                               \
+			     "isb\n"                                           \
+			     "mov %1, sp\n"                                    \
+			     : "=r"(flags), "=r"(cur_sp)                       \
+			     :);                                               \
+		iee_rwx_gate_entry(IEE_SWITCH_TO_KERNEL);					\
+		if (!on_irq_stack(cur_sp, NULL)) {                             \
+			iee_rw_gate(IEE_WRITE_TOKEN_TTBR1, current,            \
+				    koi_swapper_ttbr1);                        \
+			koi_do_switch_to_kernel_stack();                       \
+		} else {                                                       \
+			ptr = SHIFT_PERCPU_PTR(koi_irq_current_ttbr1,              \
+					       __kern_my_cpu_offset());        \
+			*ptr = koi_swapper_ttbr1;                                  \
+		}                                                              \
+		asm volatile("msr daif, %0\n"                                  \
+			     "isb\n"                                           \
+			     :                                                 \
+			     : "r"(flags));                                    \
+	} while (0);
+#endif
+//kzalloc function in driver space
+static __maybe_unused noinline void *
+koi_kzalloc_wrapper(struct module *mod, size_t size, gfp_t flags)
+{
+	int cnt = (size + PAGE_SIZE - 1) / PAGE_SIZE;
+	void *addr;
+	struct koi_mem_hash_node *target = NULL;
+	koi_switch_to_kernel();
+	rcu_read_lock();
+	hash_for_each_possible_rcu (koi_mem_htbl, target, node,
+				    (unsigned long)mod) {
+		if (target->mod == mod) {
+			break;
+		}
+	}
+	rcu_read_unlock();
+	if (target == NULL) {
+		printk("mem node for module: %s not found\n", mod->name);
+		return NULL;
+	}
+
+	addr = kzalloc(size, flags);
+	koi_copy_pagetable(target->ko_mm, target->pgdp, (unsigned long)addr,
+			   (unsigned long)addr + PAGE_SIZE * cnt);
+	koi_switch_to_ko();
+	return addr;
+}
+//kmalloc function in driver space
+static __maybe_unused __always_inline void *
+koi_kmalloc_wrapper(struct module *mod, size_t size, gfp_t flags)
+{
+	int cnt = (size + PAGE_SIZE - 1) / PAGE_SIZE;
+	void *addr;
+	struct koi_mem_hash_node *target = NULL;
+	koi_switch_to_kernel();
+
+	rcu_read_lock();
+	hash_for_each_possible_rcu (koi_mem_htbl, target, node,
+				    (unsigned long)mod) {
+		if (target->mod == mod) {
+			break;
+		}
+	}
+	rcu_read_unlock();
+	if (target == NULL) {
+		printk("mem node for module: %s not found\n", mod->name);
+		return 0;
+	}
+
+	addr = kmalloc(cnt * PAGE_SIZE, flags);
+	koi_copy_pagetable(target->ko_mm, target->pgdp, (unsigned long)addr,
+			   (unsigned long)addr + PAGE_SIZE * cnt);
+	koi_switch_to_ko();
+	return (void *)addr;
+}
+//vmalloc function in driver space
+static __maybe_unused void *koi_vmalloc_wrapper(struct module *mod,
+						unsigned long size)
+{
+	int cnt = (size + PAGE_SIZE - 1) / PAGE_SIZE;
+	void *addr;
+	struct koi_mem_hash_node *target = NULL;
+	koi_switch_to_kernel();
+	rcu_read_lock();
+	hash_for_each_possible_rcu (koi_mem_htbl, target, node,
+				    (unsigned long)mod) {
+		if (target->mod == mod) {
+			break;
+		}
+	}
+	rcu_read_unlock();
+	if (target == NULL) {
+		printk("mem node for module: %s not found\n", mod->name);
+		koi_switch_to_ko();
+		return 0;
+	}
+	addr = vmalloc(cnt * PAGE_SIZE);
+	koi_copy_pagetable(target->ko_mm, target->pgdp, (unsigned long)addr,
+			   (unsigned long)addr + PAGE_SIZE * cnt);
+	koi_switch_to_ko();
+	return addr;
+}
+//kmalloc_array function in driver space
+static __maybe_unused void *koi_kmalloc_array_wrapper(struct module *mod,
+						      size_t n, size_t size,
+						      gfp_t flags)
+{
+	int kpage;
+	void *addr;
+	struct koi_mem_hash_node *target = NULL;
+	koi_switch_to_kernel();
+	rcu_read_lock();
+	hash_for_each_possible_rcu (koi_mem_htbl, target, node,
+				    (unsigned long)mod) {
+		if (target->mod == mod) {
+			break;
+		}
+	}
+	rcu_read_unlock();
+	if (target == NULL) {
+		printk("mem node for module: %s not found\n", mod->name);
+		koi_switch_to_ko();
+		return 0;
+	}
+	kpage = (n * size + PAGE_SIZE - 1) / PAGE_SIZE;
+	n = (kpage * PAGE_SIZE) / size;
+	addr = kmalloc_array(n, size, flags);
+	koi_copy_pagetable(target->ko_mm, target->pgdp, (unsigned long)addr,
+			   (unsigned long)addr + PAGE_SIZE * kpage);
+	koi_switch_to_ko();
+	return addr;
+}
+#endif
\ No newline at end of file
diff --git a/arch/arm64/include/asm/memory.h b/arch/arm64/include/asm/memory.h
index 644cfa3284a7..40e8a384c55e 100644
--- a/arch/arm64/include/asm/memory.h
+++ b/arch/arm64/include/asm/memory.h
@@ -170,6 +170,13 @@ extern u64			vabits_actual;
 #define PAGE_END		(_PAGE_END(vabits_actual))
 
 extern s64			memstart_addr;
+
+#if defined(CONFIG_IEE) || defined(CONFIG_KOI)
+extern s64			memstart_addr_init;
+extern s64			iee_offset;
+#define LOGICAL_RANDOM	(long long int)((long unsigned int)__va(memstart_addr_init) & (~PAGE_OFFSET))
+#endif
+
 /* PHYS_OFFSET - the physical address of the start of memory. */
 #define PHYS_OFFSET		({ VM_BUG_ON(memstart_addr & 1); memstart_addr; })
 
@@ -265,6 +272,26 @@ extern phys_addr_t __phys_addr_symbol(unsigned long x);
 #define __phys_to_virt(x)	((unsigned long)((x) - PHYS_OFFSET) | PAGE_OFFSET)
 #define __phys_to_kimg(x)	((unsigned long)((x) + kimage_voffset))
 
+#ifdef CONFIG_KOI
+#define KOI_OFFSET (((unsigned long)BIT(vabits_actual - 2)) - LOGICAL_RANDOM)
+#endif
+
+#ifdef CONFIG_IEE
+#ifdef CONFIG_IEE_OFFSET
+#define IEE_OFFSET	((CONFIG_IEE_OFFSET) - LOGICAL_RANDOM)
+#else
+#define IEE_OFFSET	(((unsigned long)BIT(vabits_actual - 2)) - LOGICAL_RANDOM)
+#endif
+#define __phys_to_iee(x)	(__phys_to_virt(x) + IEE_OFFSET)
+#define SET_UPAGE(x)	__pgprot(pgprot_val(x) | PTE_USER)
+#define SET_PPAGE(x)	__pgprot(pgprot_val(x) & (~PTE_USER))
+#endif
+
+#if defined(CONFIG_IEE) || defined (CONFIG_KOI)
+#define SET_NG(x)	__pgprot(pgprot_val(x) | PTE_NG)
+#define SET_INVALID(x)	__pgprot(pgprot_val(x) & (~PTE_VALID))
+#endif
+
 /*
  * Convert a page to/from a physical address
  */
diff --git a/arch/arm64/include/asm/mmu_context.h b/arch/arm64/include/asm/mmu_context.h
index 5a54a5ab5f92..dec84d69bcc1 100644
--- a/arch/arm64/include/asm/mmu_context.h
+++ b/arch/arm64/include/asm/mmu_context.h
@@ -23,6 +23,9 @@
 #include <asm/cputype.h>
 #include <asm/sysreg.h>
 #include <asm/tlbflush.h>
+#ifdef CONFIG_IEE
+#define INIT_ASID 0x2
+#endif
 
 extern bool rodata_full;
 
@@ -42,7 +45,12 @@ static inline void cpu_set_reserved_ttbr0(void)
 {
 	unsigned long ttbr = phys_to_ttbr(__pa_symbol(reserved_pg_dir));
 
+#ifdef CONFIG_IEE
+    ttbr |= FIELD_PREP(TTBR_ASID_MASK, 1);
+    iee_rwx_gate_entry(IEE_WRITE_ttbr0_el1, ttbr);
+#else
 	write_sysreg(ttbr, ttbr0_el1);
+#endif
 	isb();
 }
 
@@ -90,7 +98,11 @@ static inline void __cpu_set_tcr_t0sz(unsigned long t0sz)
 	tcr = read_sysreg(tcr_el1);
 	tcr &= ~TCR_T0SZ_MASK;
 	tcr |= t0sz << TCR_T0SZ_OFFSET;
+#ifdef CONFIG_IEE
+    iee_rwx_gate_entry(IEE_WRITE_tcr_el1, tcr);
+#else
 	write_sysreg(tcr, tcr_el1);
+#endif
 	isb();
 }
 
@@ -155,6 +167,10 @@ static inline void cpu_replace_ttbr1(pgd_t *pgdp)
 		ttbr1 |= TTBR_CNP_BIT;
 	}
 
+	#ifdef CONFIG_IEE
+	ttbr1 |= FIELD_PREP(TTBR_ASID_MASK, ASID(current->active_mm));
+	#endif
+
 	replace_phys = (void *)__pa_symbol(idmap_cpu_replace_ttbr1);
 
 	cpu_install_idmap();
diff --git a/arch/arm64/include/asm/pgalloc.h b/arch/arm64/include/asm/pgalloc.h
index 3c6a7f5988b1..157aead56290 100644
--- a/arch/arm64/include/asm/pgalloc.h
+++ b/arch/arm64/include/asm/pgalloc.h
@@ -57,6 +57,10 @@ static inline void __p4d_populate(p4d_t *p4dp, phys_addr_t pudp, p4dval_t prot)
 extern pgd_t *pgd_alloc(struct mm_struct *mm);
 extern void pgd_free(struct mm_struct *mm, pgd_t *pgdp);
 
+#ifdef CONFIG_KOI
+pgd_t *koi_pgd_alloc(void);
+#endif
+
 static inline void __pmd_populate(pmd_t *pmdp, phys_addr_t ptep,
 				  pmdval_t prot)
 {
diff --git a/arch/arm64/include/asm/pgtable-hwdef.h b/arch/arm64/include/asm/pgtable-hwdef.h
index a5cff5b376f6..9ff234b3ba74 100644
--- a/arch/arm64/include/asm/pgtable-hwdef.h
+++ b/arch/arm64/include/asm/pgtable-hwdef.h
@@ -91,6 +91,13 @@
 #define CONT_PMD_SIZE		(CONT_PMDS * PMD_SIZE)
 #define CONT_PMD_MASK		(~(CONT_PMD_SIZE - 1))
 
+#ifdef CONFIG_IEE
+#define PGD_APT_RO		(_AT(pudval_t, 1) << 62)
+#endif
+#define PGD_APT		(_AT(pudval_t, 1) << 61)
+#define PGD_PXN		(_AT(pudval_t, 1) << 59)
+#define PGD_UXN		(_AT(pudval_t, 1) << 60)
+
 /*
  * Hardware page table definitions.
  *
@@ -148,6 +155,9 @@
 #define PTE_UXN			(_AT(pteval_t, 1) << 54)	/* User XN */
 #define PTE_PBHA_MASK		(_AT(pteval_t, 0xf) << 59)	/* Page Base Hardware Attributes */
 #define PTE_PBHA0		(_AT(pteval_t, 1) << 59)	/* PBHA 59 bit */
+#ifdef CONFIG_HIVE
+#define PTE_BPF_SFI_GP	(_AT(pteval_t, 1) << 55)	/* BPF_SFI guarded */
+#endif
 
 #define PTE_ADDR_LOW		(((_AT(pteval_t, 1) << (48 - PAGE_SHIFT)) - 1) << PAGE_SHIFT)
 #ifdef CONFIG_ARM64_PA_BITS_52
@@ -271,6 +281,9 @@
 #define TCR_E0PD0		(UL(1) << 55)
 #define TCR_E0PD1		(UL(1) << 56)
 
+#ifdef CONFIG_IEE
+#define TCR_HPD1		(UL(1) << 42)
+#endif
 /*
  * TTBR.
  */
diff --git a/arch/arm64/include/asm/pgtable.h b/arch/arm64/include/asm/pgtable.h
index f914c30b7487..9bfe99662758 100644
--- a/arch/arm64/include/asm/pgtable.h
+++ b/arch/arm64/include/asm/pgtable.h
@@ -35,6 +35,9 @@
 #include <linux/mmdebug.h>
 #include <linux/mm_types.h>
 #include <linux/sched.h>
+#ifdef CONFIG_PTP
+#include <asm/iee.h>
+#endif
 
 #ifdef CONFIG_TRANSPARENT_HUGEPAGE
 #define __HAVE_ARCH_FLUSH_PMD_TLB_RANGE
@@ -156,6 +159,15 @@ static inline pteval_t __phys_to_pte_val(phys_addr_t phys)
 #define pud_access_permitted(pud, write) \
 	(pte_access_permitted(pud_pte(pud), (write)))
 
+#ifdef CONFIG_PTP
+extern bool in_tramp_pgdir(void *addr);
+extern unsigned long long iee_rw_gate(int flag, ...);
+
+extern void iee_set_tramp_pgd_pre_init(pgd_t *pgdp, pgd_t pgd);
+extern pteval_t iee_set_xchg_relaxed(pte_t *ptep, pteval_t pteval);
+extern pteval_t iee_set_cmpxchg_relaxed(pte_t *ptep, pteval_t old_pteval, pteval_t new_pteval);
+#endif
+
 static inline pte_t clear_pte_bit(pte_t pte, pgprot_t prot)
 {
 	pte_val(pte) &= ~pgprot_val(prot);
@@ -260,19 +272,35 @@ static inline pte_t pte_mkdevmap(pte_t pte)
 	return set_pte_bit(pte, __pgprot(PTE_DEVMAP | PTE_SPECIAL));
 }
 
+#ifdef CONFIG_PTP
+extern void iee_set_bm_pte(pte_t *ptep, pte_t pte);
+extern void iee_set_fixmap_pte_pre_init(pte_t *ptep, pte_t pte);
+#endif
+
+#ifdef CONFIG_IEE
+extern void set_pte(pte_t *ptep, pte_t pte);
+#else
 static inline void set_pte(pte_t *ptep, pte_t pte)
 {
+#ifdef CONFIG_KOI
+    if (pte_valid(pte)) {
+		pte = __pte(pte_val(pte) | PTE_NG);
+    }
+#endif
 	WRITE_ONCE(*ptep, pte);
-
-	/*
-	 * Only if the new pte is valid and kernel, otherwise TLB maintenance
-	 * or update_mmu_cache() have the necessary barriers.
-	 */
 	if (pte_valid_not_user(pte)) {
 		dsb(ishst);
 		isb();
 	}
 }
+#endif
+
+#ifdef CONFIG_IEE
+extern void iee_set_pte_upage(pte_t *ptep, int order, int use_block_pmd);
+extern void iee_set_pte_ppage(pte_t *ptep, int order, int use_block_pmd);
+extern void iee_set_sensitive_pte(pte_t *lm_ptep, pte_t *iee_ptep, int order, int use_block_pmd);
+extern void iee_unset_sensitive_pte(pte_t *lm_ptep, pte_t *iee_ptep, int order, int use_block_pmd);
+#endif
 
 extern void __sync_icache_dcache(pte_t pteval);
 
@@ -335,6 +363,14 @@ static inline void set_pte_at(struct mm_struct *mm, unsigned long addr,
 	set_pte(ptep, pte);
 }
 
+#ifdef CONFIG_PTP
+extern void iee_set_pte_pre_init(pte_t *ptep, pte_t pte);
+extern void iee_set_pte_at(struct mm_struct *mm, unsigned long addr,
+			      pte_t *ptep, pte_t pte);
+extern void iee_set_pte_at_delayed(struct mm_struct *mm, unsigned long addr,
+			      pte_t *ptep, pte_t pte);
+#endif
+
 /*
  * Huge pte definitions.
  */
@@ -476,8 +512,42 @@ static inline pmd_t pmd_mkdevmap(pmd_t pmd)
 #define pud_pfn(pud)		((__pud_to_phys(pud) & PUD_MASK) >> PAGE_SHIFT)
 #define pfn_pud(pfn,prot)	__pud(__phys_to_pud_val((phys_addr_t)(pfn) << PAGE_SHIFT) | pgprot_val(prot))
 
+#ifdef CONFIG_PTP
+extern void set_pmd(pmd_t *pmdp, pmd_t pmd);
+static inline void set_pmd_at(struct mm_struct *mm, unsigned long addr,
+			      pmd_t *pmdp, pmd_t pmd)
+{
+	if (pte_present(pmd_pte(pmd)) && pte_user_exec(pmd_pte(pmd)) && !pte_special(pmd_pte(pmd)))
+		__sync_icache_dcache(pmd_pte(pmd));
+
+	if (system_supports_mte() &&
+	    pte_present(pmd_pte(pmd)) && pte_tagged(pmd_pte(pmd)) && !pte_special(pmd_pte(pmd)))
+		mte_sync_tags((pte_t *)pmdp, pmd_pte(pmd));
+
+	__check_racy_pte_update(mm, (pte_t *)pmdp, pmd_pte(pmd));
+
+	set_pmd(pmdp, pmd);
+}
+
+extern void set_pud(pud_t *pudp, pud_t pud);
+static inline void set_pud_at(struct mm_struct *mm, unsigned long addr,
+			      pud_t *pudp, pud_t pud)
+{
+	if (pte_present(pud_pte(pud)) && pte_user_exec(pud_pte(pud)) && !pte_special(pud_pte(pud)))
+		__sync_icache_dcache(pud_pte(pud));
+
+	if (system_supports_mte() &&
+	    pte_present(pud_pte(pud)) && pte_tagged(pud_pte(pud)) && !pte_special(pud_pte(pud)))
+		mte_sync_tags((pte_t *)pudp, pud_pte(pud));
+
+	__check_racy_pte_update(mm, (pte_t *)pudp, pud_pte(pud));
+
+	set_pud(pudp, pud);
+}
+#else
 #define set_pmd_at(mm, addr, pmdp, pmd)	set_pte_at(mm, addr, (pte_t *)pmdp, pmd_pte(pmd))
 #define set_pud_at(mm, addr, pudp, pud)	set_pte_at(mm, addr, (pte_t *)pudp, pud_pte(pud))
+#endif
 
 #define __p4d_to_phys(p4d)	__pte_to_phys(p4d_pte(p4d))
 #define __phys_to_p4d_val(phys)	__phys_to_pte_val(phys)
@@ -581,6 +651,14 @@ static inline bool in_swapper_pgdir(void *addr)
 	        ((unsigned long)swapper_pg_dir & PAGE_MASK);
 }
 
+#ifdef CONFIG_PTP
+extern bool in_tramp_pgdir(void *addr);
+extern void iee_set_fixmap_pmd_pre_init(pmd_t *pmdp, pmd_t pmd);
+#endif
+
+#ifdef CONFIG_IEE
+extern void set_pmd(pmd_t *pmdp, pmd_t pmd);
+#else
 static inline void set_pmd(pmd_t *pmdp, pmd_t pmd)
 {
 #ifdef __PAGETABLE_PMD_FOLDED
@@ -589,14 +667,19 @@ static inline void set_pmd(pmd_t *pmdp, pmd_t pmd)
 		return;
 	}
 #endif /* __PAGETABLE_PMD_FOLDED */
-
+#ifdef CONFIG_KOI
+    pmdval_t val = pmd_val(pmd);
+    if (pmd_valid(pmd) && !(val & PMD_TABLE_BIT)) {
+        pmd = __pmd(val | PMD_SECT_NG);
+    }
+#endif
 	WRITE_ONCE(*pmdp, pmd);
-
 	if (pmd_valid(pmd)) {
 		dsb(ishst);
 		isb();
 	}
 }
+#endif
 
 static inline void pmd_clear(pmd_t *pmdp)
 {
@@ -616,6 +699,12 @@ static inline unsigned long pmd_page_vaddr(pmd_t pmd)
 /* Find an entry in the third-level page table. */
 #define pte_offset_phys(dir,addr)	(pmd_page_paddr(READ_ONCE(*(dir))) + pte_index(addr) * sizeof(pte_t))
 
+#ifdef CONFIG_PTP
+#define pte_set_fixmap_init(addr)		((pte_t *)iee_set_fixmap_offset_pre_init(FIX_PTE, addr))
+#define pte_set_fixmap_offset_init(pmd, addr)	pte_set_fixmap_init(pte_offset_phys(pmd, addr))
+#define pte_clear_fixmap_init()		clear_fixmap_init(FIX_PTE)
+#endif
+
 #define pte_set_fixmap(addr)		((pte_t *)set_fixmap_offset(FIX_PTE, addr))
 #define pte_set_fixmap_offset(pmd, addr)	pte_set_fixmap(pte_offset_phys(pmd, addr))
 #define pte_clear_fixmap()		clear_fixmap(FIX_PTE)
@@ -642,6 +731,14 @@ static inline unsigned long pmd_page_vaddr(pmd_t pmd)
 #define pud_leaf(pud)		(pud_present(pud) && !pud_table(pud))
 #define pud_valid(pud)		pte_valid(pud_pte(pud))
 
+
+#ifdef CONFIG_PTP
+extern void iee_set_fixmap_pud_pre_init(pud_t *pudp, pud_t pud);
+#endif
+
+#ifdef CONFIG_IEE
+extern void set_pud(pud_t *pudp, pud_t pud);
+#else
 static inline void set_pud(pud_t *pudp, pud_t pud)
 {
 #ifdef __PAGETABLE_PUD_FOLDED
@@ -650,14 +747,20 @@ static inline void set_pud(pud_t *pudp, pud_t pud)
 		return;
 	}
 #endif /* __PAGETABLE_PUD_FOLDED */
-
+#ifdef CONFIG_KOI
+    pudval_t val = pud_val(pud);
+    if (pud_valid(pud) && !(val & PUD_TABLE_BIT)) {
+        // There is no PUD_SEC_NG, so we use PMD_SECT_NG instead.
+        pud = __pud(val | PMD_SECT_NG);
+    }
+#endif
 	WRITE_ONCE(*pudp, pud);
-
 	if (pud_valid(pud)) {
 		dsb(ishst);
 		isb();
 	}
 }
+#endif
 
 static inline void pud_clear(pud_t *pudp)
 {
@@ -677,6 +780,12 @@ static inline pmd_t *pud_pgtable(pud_t pud)
 /* Find an entry in the second-level page table. */
 #define pmd_offset_phys(dir, addr)	(pud_page_paddr(READ_ONCE(*(dir))) + pmd_index(addr) * sizeof(pmd_t))
 
+#ifdef CONFIG_PTP
+#define pmd_set_fixmap_init(addr)		((pmd_t *)iee_set_fixmap_offset_pre_init(FIX_PMD, addr))
+#define pmd_set_fixmap_offset_init(pud, addr)	pmd_set_fixmap_init(pmd_offset_phys(pud, addr))
+#define pmd_clear_fixmap_init()		clear_fixmap_init(FIX_PMD)
+#endif
+
 #define pmd_set_fixmap(addr)		((pmd_t *)set_fixmap_offset(FIX_PMD, addr))
 #define pmd_set_fixmap_offset(pud, addr)	pmd_set_fixmap(pmd_offset_phys(pud, addr))
 #define pmd_clear_fixmap()		clear_fixmap(FIX_PMD)
@@ -707,10 +816,15 @@ static inline pmd_t *pud_pgtable(pud_t pud)
 #define p4d_none(p4d)		(!p4d_val(p4d))
 #define p4d_bad(p4d)		(!(p4d_val(p4d) & 2))
 #define p4d_present(p4d)	(p4d_val(p4d))
+#define p4d_valid(p4d)		pte_valid(p4d_pte(p4d))
 
+#ifdef CONFIG_IEE
+extern void set_p4d(p4d_t *p4dp, p4d_t p4d);
+#else
 static inline void set_p4d(p4d_t *p4dp, p4d_t p4d)
 {
-	if (in_swapper_pgdir(p4dp)) {
+	if (in_swapper_pgdir(p4dp))
+	{
 		set_swapper_pgd((pgd_t *)p4dp, __pgd(p4d_val(p4d)));
 		return;
 	}
@@ -719,6 +833,7 @@ static inline void set_p4d(p4d_t *p4dp, p4d_t p4d)
 	dsb(ishst);
 	isb();
 }
+#endif
 
 static inline void p4d_clear(p4d_t *p4dp)
 {
@@ -738,6 +853,12 @@ static inline pud_t *p4d_pgtable(p4d_t p4d)
 /* Find an entry in the frst-level page table. */
 #define pud_offset_phys(dir, addr)	(p4d_page_paddr(READ_ONCE(*(dir))) + pud_index(addr) * sizeof(pud_t))
 
+#ifdef CONFIG_PTP
+#define pud_set_fixmap_init(addr)		((pud_t *)iee_set_fixmap_offset_pre_init(FIX_PUD, addr))
+#define pud_set_fixmap_offset_init(p4d, addr)	pud_set_fixmap_init(pud_offset_phys(p4d, addr))
+#define pud_clear_fixmap_init()		clear_fixmap_init(FIX_PUD)
+#endif
+
 #define pud_set_fixmap(addr)		((pud_t *)set_fixmap_offset(FIX_PUD, addr))
 #define pud_set_fixmap_offset(p4d, addr)	pud_set_fixmap(pud_offset_phys(p4d, addr))
 #define pud_clear_fixmap()		clear_fixmap(FIX_PUD)
@@ -764,6 +885,10 @@ static inline pud_t *p4d_pgtable(p4d_t p4d)
 #define pgd_ERROR(e)	\
 	pr_err("%s:%d: bad pgd %016llx.\n", __FILE__, __LINE__, pgd_val(e))
 
+#ifdef CONFIG_PTP
+#define pgd_set_fixmap_init(addr) ((pgd_t *)iee_set_fixmap_offset_pre_init(FIX_PGD, addr))
+#define pgd_clear_fixmap_init() clear_fixmap_init(FIX_PGD)
+#endif
 #define pgd_set_fixmap(addr)	((pgd_t *)set_fixmap_offset(FIX_PGD, addr))
 #define pgd_clear_fixmap()	clear_fixmap(FIX_PGD)
 
@@ -829,10 +954,19 @@ static inline int __ptep_test_and_clear_young(pte_t *ptep)
 
 	pte = READ_ONCE(*ptep);
 	do {
+        #ifdef CONFIG_KOI
+            if (pte_valid(pte))
+                pte = __pte(pte_val(pte) | PTE_NG);
+        #endif
 		old_pte = pte;
 		pte = pte_mkold(pte);
+		#ifdef CONFIG_PTP
+		pte_val(pte) = iee_set_cmpxchg_relaxed(ptep,
+					       pte_val(old_pte), pte_val(pte));
+		#else
 		pte_val(pte) = cmpxchg_relaxed(&pte_val(*ptep),
 					       pte_val(old_pte), pte_val(pte));
+		#endif
 	} while (pte_val(pte) != pte_val(old_pte));
 
 	return pte_young(pte);
@@ -880,7 +1014,13 @@ static inline int pmdp_test_and_clear_young(struct vm_area_struct *vma,
 static inline pte_t ptep_get_and_clear(struct mm_struct *mm,
 				       unsigned long address, pte_t *ptep)
 {
+	#ifdef CONFIG_PTP
+	pteval_t pteval= iee_set_xchg_relaxed(ptep, (pteval_t)0);
+	pte_t ret = __pte(pteval);
+	return ret;
+	#else
 	return __pte(xchg_relaxed(&pte_val(*ptep), 0));
+	#endif
 }
 
 #ifdef CONFIG_TRANSPARENT_HUGEPAGE
@@ -903,10 +1043,19 @@ static inline void ptep_set_wrprotect(struct mm_struct *mm, unsigned long addres
 
 	pte = READ_ONCE(*ptep);
 	do {
+        #ifdef CONFIG_KOI
+        if (pte_valid(pte)) {
+		    pte = __pte(pte_val(pte) | PTE_NG);
+        }
+        #endif
 		old_pte = pte;
 		pte = pte_wrprotect(pte);
+		#ifdef CONFIG_PTP
+		pte_val(pte) = iee_set_cmpxchg_relaxed(ptep,pte_val(old_pte), pte_val(pte));
+		#else
 		pte_val(pte) = cmpxchg_relaxed(&pte_val(*ptep),
 					       pte_val(old_pte), pte_val(pte));
+		#endif
 	} while (pte_val(pte) != pte_val(old_pte));
 }
 
@@ -922,7 +1071,17 @@ static inline void pmdp_set_wrprotect(struct mm_struct *mm,
 static inline pmd_t pmdp_establish(struct vm_area_struct *vma,
 		unsigned long address, pmd_t *pmdp, pmd_t pmd)
 {
+    #ifdef CONFIG_KOI
+    pmdval_t val = pmd_val(pmd);
+    if (pmd_valid(pmd) && !(val & PMD_TABLE_BIT)) {
+        pmd = __pmd(val | PMD_SECT_NG);
+    }
+    #endif
+	#ifdef CONFIG_PTP
+	return __pmd(iee_set_xchg_relaxed((pte_t *)pmdp, pmd_val(pmd)));
+	#else
 	return __pmd(xchg_relaxed(&pmd_val(*pmdp), pmd_val(pmd)));
+	#endif
 }
 #endif
 
diff --git a/arch/arm64/include/asm/pgtable_slab.h b/arch/arm64/include/asm/pgtable_slab.h
new file mode 100644
index 000000000000..00a0af999201
--- /dev/null
+++ b/arch/arm64/include/asm/pgtable_slab.h
@@ -0,0 +1,15 @@
+#ifndef _LINUX_PGTABLE_SLAB_H
+#define _LINUX_PGTABLE_SLAB_H
+
+#define PGTABLE_ORDER 9
+#define PGTABLE_MAX_ORDER (20-PGTABLE_ORDER)
+
+extern void __init iee_pgtable_init(void);
+extern void *get_iee_pgtable_page(gfp_t gfpflags);
+extern void free_iee_pgtable_page(void *obj);
+
+extern void __init iee_stack_init(void);
+extern void *get_iee_stack(void);
+extern void free_iee_stack(void *obj);
+
+#endif
\ No newline at end of file
diff --git a/arch/arm64/include/asm/sysreg.h b/arch/arm64/include/asm/sysreg.h
index 8bcc9ac9963e..7e833c5dbf0a 100644
--- a/arch/arm64/include/asm/sysreg.h
+++ b/arch/arm64/include/asm/sysreg.h
@@ -1784,6 +1784,64 @@
 		write_sysreg_s(__scs_new, sysreg);			\
 } while (0)
 
+
+#ifdef CONFIG_IEE
+
+#define SYS_TCR_IEE_SI      TCR_HPD1 | TCR_A1
+
+extern void iee_rwx_gate_entry(int flag, ...);
+#define IEE_SI_TEST 0
+#define IEE_WRITE_sctlr_el1 1
+#define IEE_WRITE_ttbr0_el1 2
+#define IEE_WRITE_vbar_el1  3
+#define IEE_WRITE_tcr_el1   4
+#define IEE_WRITE_mdscr_el1   5
+#define IEE_WRITE_AFSR0   10
+
+#define sysreg_clear_set_iee_si(sysreg, clear, set) do {			\
+	u64 __scs_val = read_sysreg(sysreg);				\
+	u64 __scs_new = (__scs_val & ~(u64)(clear)) | (set);		\
+	if (__scs_new != __scs_val)					\
+		iee_rwx_gate_entry(IEE_WRITE_##sysreg, __scs_new);			\
+} while (0)
+
+#define IEE_SI_WRITE_DAIF_SEL  "msr daifclr, #0xf\n\t"	\
+	"tbnz %x0, #6, 114221f\n\t"    \
+    "tbnz %x0, #7, 114210f\n\t"                 \
+    "tbnz %x0, #8, 114100f\n\t"                 \
+    "msr daifset, #0b000\n\t"                   \
+    "b 114514f\n\t"                            \
+"114221:\n\t"                                  \
+    "tbnz %x0, #7, 114211f\n\t"     \
+    "tbnz %x0, #8, 114101f\n\t"     \
+    "msr daifset, #0b001\n\t"       \
+    "b 114514f\n\t"                \
+"114211:\n\t"              \
+    "tbnz %x0, #8, 114111f\n\t"     \
+    "msr daifset, #0b011\n\t"       \
+    "b 114514f\n\t"        \
+"114210:\n\t"              \
+    "tbnz %x0, #8, 114110f\n\t"     \
+    "msr daifset, #0b010\n\t"       \
+    "b 114514f\n\t"        \
+"114100:\n\t"              \
+    "msr daifset, #0b100\n\t"       \
+    "b 114514f\n\t"        \
+"114101:\n\t"              \
+    "msr daifset, #0b101\n\t"       \
+    "b 114514f\n\t"                \
+"114110:\n\t"              \
+    "msr daifset, #0b110\n\t"       \
+    "b 114514f\n\t"        \
+"114111:\n\t"              \
+    "msr daifset, #0b111\n\t"       \
+"114514:\n\t" 
+
+#define iee_si_write_daif(v) do {           \
+    u64 __val = (u64)(v);                   \
+    asm volatile(IEE_SI_WRITE_DAIF_SEL: : "rZ" (__val));} while (0)
+#endif
+
 #define read_sysreg_par() ({						\
 	u64 par;							\
 	asm(ALTERNATIVE("nop", "dmb sy", ARM64_WORKAROUND_1508412));	\
diff --git a/arch/arm64/include/asm/tlb.h b/arch/arm64/include/asm/tlb.h
index c995d1f4594f..04fbba7d8846 100644
--- a/arch/arm64/include/asm/tlb.h
+++ b/arch/arm64/include/asm/tlb.h
@@ -11,11 +11,31 @@
 #include <linux/pagemap.h>
 #include <linux/swap.h>
 
+#ifdef CONFIG_PTP
+#include <linux/iee-func.h>
+#include "pgtable_slab.h"
+#endif
+
 static inline void __tlb_remove_table(void *_table)
 {
 	free_page_and_swap_cache((struct page *)_table);
 }
 
+#ifdef CONFIG_PTP
+static inline void __iee_tlb_remove_table(void *_table)
+{
+	struct page *page = (struct page *)_table;
+
+	if (!is_huge_zero_page(page))
+	{
+		if (page_ref_dec_return(page) == 1)
+		{
+			free_iee_pgtable_page((void *)page_to_virt(page));
+		}
+	}
+}
+#endif
+
 #define tlb_flush tlb_flush
 static void tlb_flush(struct mmu_gather *tlb);
 
@@ -76,7 +96,11 @@ static inline void __pte_free_tlb(struct mmu_gather *tlb, pgtable_t pte,
 				  unsigned long addr)
 {
 	pgtable_pte_page_dtor(pte);
+	#ifdef CONFIG_PTP
+	iee_tlb_remove_table(tlb, pte);
+	#else
 	tlb_remove_table(tlb, pte);
+	#endif
 }
 
 #if CONFIG_PGTABLE_LEVELS > 2
@@ -86,7 +110,11 @@ static inline void __pmd_free_tlb(struct mmu_gather *tlb, pmd_t *pmdp,
 	struct page *page = virt_to_page(pmdp);
 
 	pgtable_pmd_page_dtor(page);
+	#ifdef CONFIG_PTP
+	iee_tlb_remove_table(tlb, page);
+	#else
 	tlb_remove_table(tlb, page);
+	#endif
 }
 #endif
 
@@ -94,7 +122,11 @@ static inline void __pmd_free_tlb(struct mmu_gather *tlb, pmd_t *pmdp,
 static inline void __pud_free_tlb(struct mmu_gather *tlb, pud_t *pudp,
 				  unsigned long addr)
 {
+	#ifdef CONFIG_PTP
+	iee_tlb_remove_table(tlb, virt_to_page(pudp));
+	#else
 	tlb_remove_table(tlb, virt_to_page(pudp));
+	#endif
 }
 #endif
 
diff --git a/arch/arm64/include/asm/tlbflush.h b/arch/arm64/include/asm/tlbflush.h
index 353ec955915e..1ddb0de4d682 100644
--- a/arch/arm64/include/asm/tlbflush.h
+++ b/arch/arm64/include/asm/tlbflush.h
@@ -48,6 +48,7 @@
 
 #define __tlbi(op, ...)		__TLBI_N(op, ##__VA_ARGS__, 1, 0)
 
+
 #define __tlbi_user(op, arg) do {						\
 	if (arm64_kernel_unmapped_at_el0())					\
 		__tlbi(op, (arg) | USER_ASID_FLAG);				\
@@ -251,6 +252,11 @@ static inline void flush_tlb_mm(struct mm_struct *mm)
 	asid = __TLBI_VADDR(0, ASID(mm));
 	__tlbi(aside1is, asid);
 	__tlbi_user(aside1is, asid);
+	#if defined(CONFIG_IEE) || defined (CONFIG_KOI)
+	asid = __TLBI_VADDR(0, ASID(mm)+1);
+	__tlbi(aside1is, asid);
+	__tlbi_user(aside1is, asid);
+	#endif
 	dsb(ish);
 }
 
@@ -263,6 +269,11 @@ static inline void __flush_tlb_page_nosync(struct mm_struct *mm,
 	addr = __TLBI_VADDR(uaddr, ASID(mm));
 	__tlbi(vale1is, addr);
 	__tlbi_user(vale1is, addr);
+	#if defined(CONFIG_IEE) || defined(CONFIG_KOI)
+	addr = __TLBI_VADDR(uaddr, ASID(mm)+1);
+	__tlbi(vale1is, addr);
+	__tlbi_user(vale1is, addr);
+	#endif
 }
 
 static inline void flush_tlb_page_nosync(struct vm_area_struct *vma,
@@ -369,9 +380,17 @@ static inline void __flush_tlb_range(struct vm_area_struct *vma,
 			addr = __TLBI_VADDR(start, asid);
 			if (last_level) {
 				__tlbi_level(vale1is, addr, tlb_level);
+				#if defined(CONFIG_IEE) || defined(CONFIG_KOI)
+                    if (!arm64_kernel_unmapped_at_el0())
+				        __tlbi_level(vale1is, addr | USER_ASID_FLAG, tlb_level);
+				#endif
 				__tlbi_user_level(vale1is, addr, tlb_level);
 			} else {
 				__tlbi_level(vae1is, addr, tlb_level);
+				#if defined(CONFIG_IEE) || defined(CONFIG_KOI)
+                    if (!arm64_kernel_unmapped_at_el0())
+				        __tlbi_level(vae1is, addr | USER_ASID_FLAG, tlb_level);
+				#endif
 				__tlbi_user_level(vae1is, addr, tlb_level);
 			}
 			start += stride;
@@ -385,9 +404,17 @@ static inline void __flush_tlb_range(struct vm_area_struct *vma,
 						  num, tlb_level);
 			if (last_level) {
 				__tlbi(rvale1is, addr);
+				#if defined(CONFIG_IEE) || defined(CONFIG_KOI)
+                    if (!arm64_kernel_unmapped_at_el0())
+				        __tlbi(rvale1is, addr | USER_ASID_FLAG);
+				#endif
 				__tlbi_user(rvale1is, addr);
 			} else {
 				__tlbi(rvae1is, addr);
+				#if defined(CONFIG_IEE) || defined (CONFIG_KOI)
+				    if (!arm64_kernel_unmapped_at_el0())
+				        __tlbi(rvae1is, addr | USER_ASID_FLAG);
+				#endif
 				__tlbi_user(rvae1is, addr);
 			}
 			start += __TLBI_RANGE_PAGES(num, scale) << PAGE_SHIFT;
@@ -418,7 +445,7 @@ static inline void flush_tlb_kernel_range(unsigned long start, unsigned long end
 		return;
 	}
 
-	start = __TLBI_VADDR(start, 0);
+ 	start = __TLBI_VADDR(start, 0);
 	end = __TLBI_VADDR(end, 0);
 
 	dsb(ishst);
@@ -434,9 +461,9 @@ static inline void flush_tlb_kernel_range(unsigned long start, unsigned long end
  */
 static inline void __flush_tlb_kernel_pgtable(unsigned long kaddr)
 {
-	unsigned long addr = __TLBI_VADDR(kaddr, 0);
-
-	dsb(ishst);
+ 	unsigned long addr = __TLBI_VADDR(kaddr, 0);
+	
+    dsb(ishst);
 	__tlbi(vaae1is, addr);
 	dsb(ish);
 	isb();
diff --git a/arch/arm64/kernel/Makefile b/arch/arm64/kernel/Makefile
index 5b9951b6fb05..ba7ed557b165 100644
--- a/arch/arm64/kernel/Makefile
+++ b/arch/arm64/kernel/Makefile
@@ -30,6 +30,8 @@ OBJCOPYFLAGS := --prefix-symbols=__efistub_
 $(obj)/%.stub.o: $(obj)/%.o FORCE
 	$(call if_changed,objcopy)
 
+obj-y 							+= iee/
+obj-$(CONFIG_KOI) 				+= koi/
 obj-$(CONFIG_AARCH32_EL0)			+= binfmt_elf32.o sys32.o signal32.o			\
 					   sys_compat.o
 ifdef CONFIG_CC_IS_CLANG
diff --git a/arch/arm64/kernel/armv8_deprecated.c b/arch/arm64/kernel/armv8_deprecated.c
index cc736c5309fd..e87c0d977656 100644
--- a/arch/arm64/kernel/armv8_deprecated.c
+++ b/arch/arm64/kernel/armv8_deprecated.c
@@ -312,11 +312,19 @@ static int cp15barrier_handler(struct pt_regs *regs, u32 instr)
 
 static int cp15_barrier_set_hw_mode(bool enable)
 {
+#ifdef CONFIG_IEE
+    if (enable)
+		sysreg_clear_set_iee_si(sctlr_el1, 0, SCTLR_EL1_CP15BEN);
+	else
+		sysreg_clear_set_iee_si(sctlr_el1, SCTLR_EL1_CP15BEN, 0);
+	return 0;
+#else
 	if (enable)
 		sysreg_clear_set(sctlr_el1, 0, SCTLR_EL1_CP15BEN);
 	else
 		sysreg_clear_set(sctlr_el1, SCTLR_EL1_CP15BEN, 0);
 	return 0;
+#endif
 }
 
 static bool try_emulate_cp15_barrier(struct pt_regs *regs, u32 insn)
@@ -347,11 +355,19 @@ static int setend_set_hw_mode(bool enable)
 	if (!cpu_supports_mixed_endian_el0())
 		return -EINVAL;
 
+#ifdef CONFIG_IEE
+    if (enable)
+		sysreg_clear_set_iee_si(sctlr_el1, 0, SCTLR_EL1_CP15BEN);
+	else
+		sysreg_clear_set_iee_si(sctlr_el1, SCTLR_EL1_CP15BEN, 0);
+	return 0;
+#else
 	if (enable)
 		sysreg_clear_set(sctlr_el1, SCTLR_EL1_SED, 0);
 	else
 		sysreg_clear_set(sctlr_el1, 0, SCTLR_EL1_SED);
 	return 0;
+#endif
 }
 
 static int __a32_setend_handler(struct pt_regs *regs, u32 big_endian)
diff --git a/arch/arm64/kernel/asm-offsets.c b/arch/arm64/kernel/asm-offsets.c
index c247e11130db..f00622d9be3d 100644
--- a/arch/arm64/kernel/asm-offsets.c
+++ b/arch/arm64/kernel/asm-offsets.c
@@ -75,6 +75,18 @@ int main(void)
   DEFINE(S_STACKFRAME,		offsetof(struct pt_regs, stackframe));
   DEFINE(S_ORIG_X0,		offsetof(struct pt_regs, orig_x0));
   DEFINE(S_FRAME_SIZE,		sizeof(struct pt_regs));
+#ifdef CONFIG_IEE
+  DEFINE(iee_from_token_offset,		offsetof(struct task_token, iee_stack));
+  DEFINE(tmp_page_from_token_offset,  offsetof(struct task_token, tmp_page));
+  DEFINE(kernel_from_token_offset,		offsetof(struct task_token, kernel_stack));
+  DEFINE(mm_from_task_offset,		offsetof(struct task_struct, mm));
+#endif
+#ifdef CONFIG_KOI
+  DEFINE(koi_kernel_from_token_offset,		offsetof(struct task_token, koi_kernel_stack));
+  DEFINE(koi_from_token_offset,  offsetof(struct task_token, koi_stack));
+  DEFINE(ttbr1_from_token_offset, offsetof(struct task_token, current_ttbr1));
+  DEFINE(koi_stack_base_from_token_offset, offsetof(struct task_token, koi_stack_base));
+#endif
   BLANK();
 #ifdef CONFIG_AARCH32_EL0
   DEFINE(COMPAT_SIGFRAME_REGS_OFFSET,		offsetof(struct a32_sigframe, uc.uc_mcontext.arm_r0));
diff --git a/arch/arm64/kernel/cpu_errata.c b/arch/arm64/kernel/cpu_errata.c
index 7f175b3aac15..2cd625a17ecb 100644
--- a/arch/arm64/kernel/cpu_errata.c
+++ b/arch/arm64/kernel/cpu_errata.c
@@ -81,7 +81,11 @@ hisilicon_1980005_enable(const struct arm64_cpu_capabilities *__unused)
 	cpus_set_cap(ARM64_HAS_CACHE_IDC);
 	arm64_ftr_reg_ctrel0.sys_val |= BIT(CTR_IDC_SHIFT);
 	arm64_ftr_reg_ctrel0.strict_mask &= ~BIT(CTR_IDC_SHIFT);
+#ifdef CONFIG_IEE
+    sysreg_clear_set_iee_si(sctlr_el1, SCTLR_EL1_UCT, 0);
+#else
 	sysreg_clear_set(sctlr_el1, SCTLR_EL1_UCT, 0);
+#endif
 }
 #endif
 
@@ -133,7 +137,11 @@ cpu_enable_trap_ctr_access(const struct arm64_cpu_capabilities *cap)
 		enable_uct_trap = true;
 
 	if (enable_uct_trap)
+#ifdef CONFIG_IEE
+        sysreg_clear_set_iee_si(sctlr_el1, SCTLR_EL1_UCT, 0);
+#else
 		sysreg_clear_set(sctlr_el1, SCTLR_EL1_UCT, 0);
+#endif
 }
 
 #ifdef CONFIG_ARM64_ERRATUM_1463225
@@ -150,7 +158,11 @@ has_cortex_a76_erratum_1463225(const struct arm64_cpu_capabilities *entry,
 static void __maybe_unused
 cpu_enable_cache_maint_trap(const struct arm64_cpu_capabilities *__unused)
 {
+#ifdef CONFIG_IEE
+    sysreg_clear_set_iee_si(sctlr_el1, SCTLR_EL1_UCI, 0);
+#else
 	sysreg_clear_set(sctlr_el1, SCTLR_EL1_UCI, 0);
+#endif
 }
 
 #ifdef CONFIG_HISILICON_ERRATUM_HIP08_RU_PREFETCH
diff --git a/arch/arm64/kernel/cpufeature.c b/arch/arm64/kernel/cpufeature.c
index 9a4193991be5..01194ac94a56 100644
--- a/arch/arm64/kernel/cpufeature.c
+++ b/arch/arm64/kernel/cpufeature.c
@@ -91,6 +91,10 @@
 #include <asm/virt.h>
 #include <asm/setup.h>
 
+#ifdef CONFIG_IEE
+#include <asm/iee-si.h>
+#endif
+
 /* Kernel representation of AT_HWCAP and AT_HWCAP2 */
 static unsigned long elf_hwcap __read_mostly;
 
@@ -1375,7 +1379,11 @@ static void cpu_emulate_effective_ctr(const struct arm64_cpu_capabilities *__unu
 	 * value.
 	 */
 	if (!(read_cpuid_cachetype() & BIT(CTR_IDC_SHIFT)))
+#ifdef CONFIG_IEE
+        sysreg_clear_set_iee_si(sctlr_el1, SCTLR_EL1_UCT, 0);
+#else
 		sysreg_clear_set(sctlr_el1, SCTLR_EL1_UCT, 0);
+#endif
 }
 
 static bool has_cache_dic(const struct arm64_cpu_capabilities *entry,
@@ -1583,7 +1591,11 @@ static inline void __cpu_enable_hw_dbm(void)
 {
 	u64 tcr = read_sysreg(tcr_el1) | TCR_HD;
 
+#ifdef CONFIG_IEE
+    iee_rwx_gate_entry(IEE_WRITE_tcr_el1, tcr);
+#else
 	write_sysreg(tcr, tcr_el1);
+#endif
 	isb();
 	local_flush_tlb_all();
 }
@@ -1963,7 +1975,9 @@ static void cpu_enable_pan(const struct arm64_cpu_capabilities *__unused)
 	 */
 	WARN_ON_ONCE(in_interrupt());
 
+	#ifndef CONFIG_IEE
 	sysreg_clear_set(sctlr_el1, SCTLR_EL1_SPAN, 0);
+	#endif
 	set_pstate_pan(1);
 }
 #endif /* CONFIG_ARM64_PAN */
@@ -2045,7 +2059,11 @@ static bool has_generic_auth(const struct arm64_cpu_capabilities *entry,
 static void cpu_enable_e0pd(struct arm64_cpu_capabilities const *cap)
 {
 	if (this_cpu_has_cap(ARM64_HAS_E0PD))
+#ifdef CONFIG_IEE
+        sysreg_clear_set_iee_si(tcr_el1, 0, TCR_E0PD1);
+#else
 		sysreg_clear_set(tcr_el1, 0, TCR_E0PD1);
+#endif
 }
 #endif /* CONFIG_ARM64_E0PD */
 
@@ -2075,7 +2093,11 @@ static void bti_enable(const struct arm64_cpu_capabilities *__unused)
 	 * So, be strict and forbid other BRs using other registers to
 	 * jump onto a PACIxSP instruction:
 	 */
+#ifdef CONFIG_IEE
+    sysreg_clear_set_iee_si(sctlr_el1, 0, SCTLR_EL1_BT0 | SCTLR_EL1_BT1);
+#else
 	sysreg_clear_set(sctlr_el1, 0, SCTLR_EL1_BT0 | SCTLR_EL1_BT1);
+#endif
 	isb();
 }
 #endif /* CONFIG_ARM64_BTI */
@@ -2983,6 +3005,42 @@ static int cpu_enable_non_boot_scope_capabilities(void *__unused)
 	return 0;
 }
 
+// #ifdef CONFIG_IEE
+
+// atomic_t __initdata iee_si_cpu_cnt;
+
+// static int __init iee_si_enable_cnp_cpu(void *__unused)
+// {
+// 	int total_cpu;
+//     // Enable CNP by setting TTBR1
+// 	phys_addr_t ttbr1 = read_sysreg(ttbr1_el1);
+// 	if (ttbr1 >> 48 == 0){
+// 		ttbr1 |= FIELD_PREP(TTBR_ASID_MASK, ASID(current->active_mm));
+// 	}
+// 	if (system_supports_cnp())
+// 		ttbr1 |= TTBR_CNP_BIT;
+// 	printk("IEE SI: Write ASID to ttbr1:%lx on cpu %d", ttbr1, smp_processor_id());
+// 	write_sysreg(ttbr1, ttbr1_el1);
+
+//     // loop until setting all cpus
+//     atomic_inc(&iee_si_cpu_cnt);
+//     total_cpu = num_online_cpus();
+//     while (atomic_read(&iee_si_cpu_cnt) < total_cpu)
+//         cpu_relax();
+
+//     return 0;
+// }
+
+// /* Replace CNP settings.*/
+// static void __init iee_si_enable_cnp(void)
+// {
+//     atomic_set(&iee_si_cpu_cnt, 0);
+//     stop_machine(iee_si_enable_cnp_cpu, NULL, cpu_online_mask);
+//     pr_info("IEE SI: Enable CNP done.\n");
+// }
+
+// #endif
+
 /*
  * Run through the enabled capabilities and enable() it on all active
  * CPUs
@@ -3021,6 +3079,10 @@ static void __init enable_cpu_capabilities(u16 scope_mask)
 			 */
 			caps->cpu_enable(caps);
 	}
+	// #ifdef CONFIG_IEE
+	// iee_si_enable_cnp();
+	// flush_tlb_all();
+	// #endif
 
 	/*
 	 * For all non-boot scope capabilities, use stop_machine()
@@ -3309,6 +3371,41 @@ static void __init setup_system_capabilities(void)
 	enable_cpu_capabilities(SCOPE_ALL & ~SCOPE_BOOT_CPU);
 }
 
+#ifdef CONFIG_IEE
+
+static void iee_si_test_end(void)
+{
+    pr_info("IEE: testing iee_exec_entry sctlr...\n");
+    iee_rwx_gate_entry(IEE_WRITE_SCTLR, read_sysreg(sctlr_el1)& ~SCTLR_ELx_M);
+    pr_info("IEE: testing iee_exec_entry ttbr0_el1...\n");
+    iee_rwx_gate_entry(IEE_WRITE_TTBR0, read_sysreg(ttbr0_el1));
+    pr_info("IEE: testing iee_exec_entry vbar...\n");
+    iee_rwx_gate_entry(IEE_WRITE_VBAR, read_sysreg(vbar_el1));
+    pr_info("IEE: testing iee_exec_entry tcr...\n");
+    iee_rwx_gate_entry(IEE_WRITE_TCR, read_sysreg(tcr_el1));
+	#ifdef CONFIG_KOI
+	pr_info("IEE: current TTBR1_EL1:%llx, TTBR0:%llx\n", read_sysreg(ttbr1_el1), read_sysreg(ttbr0_el1));
+	pr_info("IEE: testing iee_exec_entry switch to koi...\n");
+    iee_rwx_gate_entry(IEE_SWITCH_TO_KOI, phys_to_ttbr(__pa_symbol(swapper_pg_dir)));
+	pr_info("IEE: current TTBR1_EL1:%llx, TTBR0:%llx\n", read_sysreg(ttbr1_el1), read_sysreg(ttbr0_el1));
+	pr_info("IEE: testing iee_exec_entry switch to kernel...\n");
+    iee_rwx_gate_entry(IEE_SWITCH_TO_KERNEL);
+	flush_tlb_all();
+	#endif
+}
+
+/* Finish iee rwx gate initializations. */
+static void __init iee_si_init_done(void)
+{
+	// Protect idmap functions
+	mark_idmap_vmallc_map_ROU();
+	// Prepare data for iee rwx gate
+	iee_si_prepare_data();
+    // All initialization is done. Do some simple tests.
+    iee_si_test_end();
+}
+#endif
+
 void __init setup_cpu_features(void)
 {
 	u32 cwg;
@@ -3338,6 +3435,10 @@ void __init setup_cpu_features(void)
 	if (!cwg)
 		pr_warn("No Cache Writeback Granule information, assuming %d\n",
 			ARCH_DMA_MINALIGN);
+    
+    #ifdef CONFIG_IEE
+	iee_si_init_done();
+	#endif
 }
 
 static void __maybe_unused cpu_enable_cnp(struct arm64_cpu_capabilities const *cap)
diff --git a/arch/arm64/kernel/debug-monitors.c b/arch/arm64/kernel/debug-monitors.c
index 9e0816d04370..76fe9e121c5c 100644
--- a/arch/arm64/kernel/debug-monitors.c
+++ b/arch/arm64/kernel/debug-monitors.c
@@ -36,10 +36,14 @@ u8 debug_monitors_arch(void)
  */
 static void mdscr_write(u32 mdscr)
 {
+// #ifdef CONFIG_IEE
+//     iee_rwx_gate_entry(IEE_WRITE_mdscr_el1, mdscr);
+// #else
 	unsigned long flags;
 	flags = local_daif_save();
 	write_sysreg(mdscr, mdscr_el1);
 	local_daif_restore(flags);
+// #endif
 }
 NOKPROBE_SYMBOL(mdscr_write);
 
diff --git a/arch/arm64/kernel/entry.S b/arch/arm64/kernel/entry.S
index ab8ed1b62da1..a8d728b9b491 100644
--- a/arch/arm64/kernel/entry.S
+++ b/arch/arm64/kernel/entry.S
@@ -28,6 +28,9 @@
 #include <asm/thread_info.h>
 #include <asm/asm-uaccess.h>
 #include <asm/unistd.h>
+#ifdef CONFIG_IEE
+#include <asm/iee-def.h>
+#endif
 
 /*
  * Context tracking and irqflag tracing need to instrument transitions between
@@ -59,10 +62,395 @@
 #define BAD_IRQ		1
 #define BAD_FIQ		2
 #define BAD_ERROR	3
+#define BAD_IEE		4
+#define BAD_IEE_SI	5
+
+
+#ifdef CONFIG_KOI
+#ifdef CONFIG_IEE
+/*
+ * This function is used to switch to ko stack in glue code
+ */
+SYM_FUNC_START(koi_do_switch_to_ko_stack)
+    sub sp, sp, #48
+    stp x29, x30, [sp]
+    str x2, [sp, #16]
+    stp x0, x1, [sp, #32]
+    
+    // iee_rw_gate(IEE_WRITE_KERNEL_STACK, current, sp)
+    mov x0, #IEE_WRITE_KOI_KERNEL_STACK
+    mrs x1, sp_el0
+    add x2, sp, #48
+
+    bl iee_rw_gate
+
+    // iee_rw_gate(IEE_READ_KOI_STACK, current)
+    mov x0, #IEE_READ_KOI_STACK
+    mrs x1, sp_el0
+    bl iee_rw_gate
+
+    ldp x29, x30, [sp]
+    ldr x2, [sp, #16]
+    add x1, sp, #32
+    mov sp, x0
+    ldp x0, x1, [x1]
+
+    isb
+    ret
+SYM_FUNC_END(koi_do_switch_to_ko_stack)
+
+/*
+ * This fucntion is used to switch to kernel stack in glue code
+ */
+SYM_FUNC_START(koi_do_switch_to_kernel_stack)
+    sub sp, sp, #48
+    stp x29, x30, [sp]
+    str x2, [sp, #16]
+    stp x0, x1, [sp, #32]
+    // iee_rw_gate(IEE_WRITE_KOI_STACK, current, sp)
+    mov x0, #IEE_WRITE_KOI_STACK
+    mrs x1, sp_el0
+    add x2, sp, #48
+    bl iee_rw_gate
+
+    // iee_rw_gate(IEE_READ_KOI_KERNEL_STACK, current)
+    mov x0, #IEE_READ_KOI_KERNEL_STACK
+    mrs x1, sp_el0
+    bl iee_rw_gate
+
+    ldp x29, x30, [sp]
+    ldr x2, [sp, #16]
+    add x1, sp, #32
+	mov sp, x0
+    ldp x0, x1, [x1]
+    isb
+    ret
+SYM_FUNC_END(koi_do_switch_to_kernel_stack)
+
+/*
+ * Before switch to ko's pgtable, we must switch current stack to ko's stack.
+ * We have stored registers to kernel stack, and we need to restore them from ko's stack after switching,
+ * so we need to copy from kernel stack to ko stack
+ * the memory region to copy is [sp, stack_top)
+ * void koi_switch_to_ko_stack(void);
+ */
+SYM_FUNC_START(koi_switch_to_ko_stack)
+    mrs x17, pan
+    msr pan, 0x0
+
+    sub sp, sp, #32
+    str x17, [sp, #16]
+    stp x30, x29, [sp]
+    
+    // current sp stores in x2
+	add x2, x1, #176
+    // current sp_el0 stores in x0
+    mov x1, x0
+    adrp x0, iee_offset
+    ldr x0, [x0, #:lo12:iee_offset]
+    bl _iee_write_koi_kernel_stack
+    
+    adrp x0, iee_offset
+    ldr x0, [x0, #:lo12:iee_offset]
+    mrs x1, sp_el0
+    bl _iee_read_koi_stack
+
+    ldr x17, [sp, #16]
+    ldp x30, x29, [sp]
+    add sp, sp, #32
+
+    msr pan, x17
+
+	sub x0, x0, #176
+    mov x1, sp
+    mov x2, #176    
+
+    // memcpy(current->driver_stack, current->kernel_stack, 176)
+	mov x16, lr
+	bl memcpy
+	mov lr, x16
+
+	mov sp, x0
+    isb
+	ret
+SYM_FUNC_END(koi_switch_to_ko_stack)
+
+SYM_FUNC_START(koi_switch_to_kernel_stack)
+	/* 
+     * current sp belongs to driver stack, and the bottom 160 bytes saves registers when exception occurred, 
+     * so we should add 160 to current sp, and store it in task_struct
+     * also, fetch kernel sp from task_struct, copy the bottom 160 bytes from driver stack to kernel stack
+     */
+    mrs x17, pan
+    msr pan, 0x0
+
+    sub sp, sp, #32
+    stp x30, x29, [sp]
+    str x17, [sp, #16]
+
+    adrp x0, iee_offset
+    ldr x0, [x0, #:lo12:iee_offset]
+    mrs x1, sp_el0
+    add x2, sp, #192
+    bl _iee_write_koi_stack
+
+    adrp x0, iee_offset
+    ldr x0, [x0, #:lo12:iee_offset]
+    mrs x1, sp_el0
+    bl _iee_read_koi_kernel_stack
+
+    ldr x17, [sp, #16]
+    ldp x30, x29, [sp]
+    add sp, sp, #32
+    
+    msr pan, x17
+	
+	// x0 = kernel_stack
+	sub x0, x0, #160
+    mov x1, sp
+	// x2 = 160
+	mov x2, #160
+
+	mov x16, lr
+	bl memcpy
+	mov lr, x16
+
+	mov sp, x0
+    isb
+	ret
+SYM_FUNC_END(koi_switch_to_kernel_stack)
+#else 
+/*
+ * This function is used to switch to ko stack in glue code
+ */
+SYM_FUNC_START(koi_do_switch_to_ko_stack)
+    sub sp, sp, #16
+    stp x16, x17, [sp]
+    mrs x17, sp_el0
+    adrp x16, koi_offset
+    ldr x16, [x16, #:lo12:koi_offset]
+    add x17, x17, x16
+    add x16, sp, #16
+    str x16, [x17, #koi_kernel_from_token_offset]
+    ldr x16, [x17, #koi_from_token_offset]
+    mov x17, sp
+    mov sp, x16
+    ldp x16, x17, [x17]
+    isb
+    ret
+SYM_FUNC_END(koi_do_switch_to_ko_stack)
+
+/*
+ * This fucntion is used to switch to kernel stack in glue code
+ */
+SYM_FUNC_START(koi_do_switch_to_kernel_stack)
+    sub sp, sp, #16
+    stp x16, x17, [sp]
+    mrs x17, sp_el0
+    adrp x16, koi_offset
+    ldr x16, [x16, #:lo12:koi_offset]
+    add x17, x17, x16
+    add x16, sp, #16
+    str x16, [x17, #koi_from_token_offset]
+    ldr x16, [x17, #koi_kernel_from_token_offset]
+    mov x17, sp
+    mov sp, x16
+    ldp x16, x17, [x17]
+    isb
+    ret
+SYM_FUNC_END(koi_do_switch_to_kernel_stack)
+
+/*
+ * Before switch to ko's pgtable, we must switch current stack to ko's stack.
+ * We have stored registers to kernel stack, and we need to restore them from ko's stack after switching,
+ * so we need to copy from kernel stack to ko stack
+ * the memory region to copy is [sp, stack_top)
+ * void koi_switch_to_ko_stack(unsigned long stack_top);
+ */
+SYM_FUNC_START(koi_switch_to_ko_stack)
+    // current sp stores in x1
+	add x3, x1, #176
+    adrp x4, koi_offset
+    ldr x4, [x4, #:lo12:koi_offset]
+    add x4, x0, x4
+    // current sp_el0 stores in x0
+	str x3, [x4, #koi_kernel_from_token_offset]
+    ldr x0, [x4, #koi_from_token_offset]
+	sub x0, x0, #176
+    mov x2, #176    
+
+    // memcpy(current->driver_stack, current->kernel_stack, 176)
+	mov x16, lr
+	bl memcpy
+	mov lr, x16
+
+	mov sp, x0
+    isb
+	ret
+SYM_FUNC_END(koi_switch_to_ko_stack)
+
+SYM_FUNC_START(koi_switch_to_kernel_stack)
+	/* 
+     * current sp belongs to driver stack, and the bottom 176 bytes saves registers when exception occurred, 
+     * so we should add 176 to current sp, and store it in task_struct
+     * also, fetch kernel sp from task_struct, copy the bottom 176 bytes from driver stack to kernel stack
+     */
+	mov x1, sp
+	add x3, sp, #160
+	
+	mrs x16, sp_el0
+    adrp x2, koi_offset
+    ldr x2, [x2, #:lo12:koi_offset]
+    add x16, x16, x2
+	str x3, [x16, #koi_from_token_offset]
+	//  sp points to kernel_stack
+	ldr x0, [x16, #koi_kernel_from_token_offset]
+	
+	// x0 = kernel_stack
+	sub x0, x0, #160
+	// x2 = 160
+	mov x2, #160
+	mov x16, lr
+	// memcpy(kernel_stack, driver_stack, 160)
+	bl memcpy
+	mov lr, x16
+	mov sp, x0
+    isb
+	ret
+SYM_FUNC_END(koi_switch_to_kernel_stack)
+#endif
+
+SYM_FUNC_START(koi_switch_to_ko_pgtbl)
+	stp x0, x1, [sp, #16 * 1]
+	stp x2, x3, [sp, #16 * 2]
+	stp x4, x5, [sp, #16 * 3]
+	stp x6, x7, [sp, #16 * 4]
+	stp x8, x9, [sp, #16 * 5]
+	stp x10, x11, [sp, #16 * 6]
+	stp x12, x13, [sp, #16 * 7]
+	stp x14, x15, [sp, #16 * 8]
+	stp x16, x17, [sp, #16 * 9]
+	stp x18, x30, [sp, #16 * 10]
+
+	adrp x0, koi_swapper_ttbr1
+	ldr x0, [x0, #:lo12:koi_swapper_ttbr1]
+	cbz x0, 0f
+	bl koi_do_switch_to_ko_pgtbl
+    // if x0 == 0, don't need to switch pgtable and stack, jump to 0
+    cbz x0, 0f
+    mov x19, x0
+    // if current on task's kernel stack switch to ko stack
+    mrs x0, sp_el0
+    mov x1, sp
+    ldr x2, [x0, TSK_STACK]
+    eor x2, x2, x1
+    and x2, x2, #~(THREAD_SIZE - 1)
+    cbnz x2, 1f
+
+    bl koi_switch_to_ko_stack
+1:
+#ifndef CONFIG_IEE
+    msr ttbr1_el1, x19
+    isb
+    nop
+    nop
+    nop
+#else
+    mov x0, #IEE_SWITCH_TO_KOI
+    mov x1, x19
+    bl  iee_rwx_gate_entry
+#endif
+0:
+	
+	ldp x0, x1, [sp, #16 * 1]
+	ldp x2, x3, [sp, #16 * 2]
+	ldp x4, x5, [sp, #16 * 3]
+	ldp x6, x7, [sp, #16 * 4]
+	ldp x8, x9, [sp, #16 * 5]
+	ldp x10, x11, [sp, #16 * 6]
+	ldp x12, x13, [sp, #16 * 7]
+	ldp x14, x15, [sp, #16 * 8]
+	ldp x16, x17, [sp, #16 * 9]
+	ldp x18, x30, [sp, #16 * 10]
+	ret
+SYM_FUNC_END(koi_switch_to_ko_pgtbl)
+
+.pushsection ".koi.text", "ax"
+SYM_FUNC_START(koi_switch_to_kernel_pgtbl)
+    sub sp, sp, #160
+    stp x0, x1, [sp, #16 * 0]
+	stp x2, x3, [sp, #16 * 1]
+	stp x4, x5, [sp, #16 * 2]
+	stp x6, x7, [sp, #16 * 3]
+	stp x8, x9, [sp, #16 * 4]
+	stp x10, x11, [sp, #16 * 5]
+
+	stp x12, x13, [sp, #16 * 6]
+	stp x14, x15, [sp, #16 * 7]
+	stp x16, x17, [sp, #16 * 8]
+	stp x18, x30, [sp, #16 * 9]
+    // check whether paging init finished
+	adrp x0, koi_swapper_ttbr1
+	ldr x0, [x0, #:lo12:koi_swapper_ttbr1]
+	cbz x0, 0f
+
+	bl koi_do_switch_to_kernel_pgtbl
+	/*
+     * koi_do_switch_to_kernel_pgtbl return 0 indicates
+     * that when exception occurred, the isolated ko is executing under koi pgtbl, 
+     * so we need to switch stack to kernel stack after switch pgtbl back to koi_swapper_ttbr1. 
+	 */
+	cbz x0, 0f 
+#ifndef CONFIG_IEE
+    mrs x0, sp_el0
+    adrp x1, koi_offset
+    ldr x1, [x1, #:lo12:koi_offset]
+    add x0, x0, x1
+    mov x16, sp
+    ldr x17, [x0, koi_stack_base_from_token_offset]
+    eor x17, x17, x16
+    and x17, x17, #~(THREAD_SIZE - 1)
+    cbnz x17, 0f
+#else
+    // save current pan
+    mrs x17, pan
+    // disable pan
+    msr pan, 0x0
+    adrp x0, iee_offset
+    ldr x0, [x0, #:lo12:iee_offset]
+    mrs x1, sp_el0
+    bl _iee_read_koi_stack_base
+    // restore pan
+    msr pan, x17
+
+    mov x16, sp
+    eor x0, x0, x16
+    and x0, x0, #~(THREAD_SIZE - 1)
+    cbnz x0, 0f
+#endif
+	bl koi_switch_to_kernel_stack
+0:
+	
+	ldp x0, x1, [sp, #16 * 0]
+	ldp x2, x3, [sp, #16 * 1]
+	ldp x4, x5, [sp, #16 * 2]
+	ldp x6, x7, [sp, #16 * 3]
+	ldp x8, x9, [sp, #16 * 4]
+	ldp x10, x11, [sp, #16 * 5]
+	ldp x12, x13, [sp, #16 * 6]
+	ldp x14, x15, [sp, #16 * 7]
+	ldp x16, x17, [sp, #16 * 8]
+	ldp x18, x30, [sp, #16 * 9]
+    add sp, sp, #160
+	ret
+SYM_FUNC_END(koi_switch_to_kernel_pgtbl)
+.popsection
+#endif
 
 	.macro kernel_ventry, el, label, regsize = 64
 	.align 7
 .Lventry_start\@:
+
 	.if	\el == 0
 	/*
 	 * This must be the first instruction of the EL0 vector entries. It is
@@ -78,6 +466,15 @@
 .Lskip_tramp_vectors_cleanup\@:
 	.endif
 
+#ifdef CONFIG_KOI
+	.if \el == 1
+    msr tpidrro_el0, x30
+	bl koi_switch_to_kernel_pgtbl
+    mrs x30, tpidrro_el0
+    msr	tpidrro_el0, xzr
+	.endif
+#endif
+
 	sub	sp, sp, #S_FRAME_SIZE
 #ifdef CONFIG_VMAP_STACK
 	/*
@@ -182,6 +579,7 @@ alternative_else_nop_endif
 #endif
 	.endm
 
+
 	.macro	kernel_entry, el, regsize = 64
 	.if	\regsize == 32
 	mov	w0, w0				// zero upper 32 bits of x0
@@ -271,6 +669,17 @@ alternative_else_nop_endif
 alternative_if ARM64_MTE
 	SET_PSTATE_TCO(0)
 alternative_else_nop_endif
+#endif
+
+#ifndef CONFIG_IEE
+#ifdef CONFIG_KOI
+	// set tcr_el1 to choose asid from ttbr1_el1 or ttbr0_el1
+	.if	\el == 0
+	mrs x0, tcr_el1
+	orr x0, x0 ,#0x0000000000400000 
+	msr tcr_el1,x0
+	.endif
+#endif
 #endif
 
 	/*
@@ -284,9 +693,11 @@ alternative_else_nop_endif
 	.endm
 
 	.macro	kernel_exit, el
+	#ifndef CONFIG_IEE
 	.if	\el != 0
 	disable_daif
 	.endif
+	#endif
 
 #ifdef CONFIG_ARM64_PSEUDO_NMI
 	/* Restore pmr */
@@ -335,6 +746,50 @@ alternative_else_nop_endif
 
 	msr	elr_el1, x21			// set up the return data
 	msr	spsr_el1, x22
+
+#ifdef CONFIG_IEE
+
+	.if	\el == 0
+
+	#ifndef CONFIG_UNMAP_KERNEL_AT_EL0
+	// SET hpd1 = 0 start
+	mrs x0, tcr_el1
+	and x0, x0, #0xFFFFFBFFFFFFFFFF
+	and x0, x0, #0xFFFFFFFFFFBFFFFF
+	msr tcr_el1, x0
+	// SET hpd1 = 0 end
+
+	disable_daif
+
+	// Check ELR_EL1
+	mrs x0, elr_el1
+	lsr x0, x0, #48
+	tst x0, #0xffff
+	b.ne 5f
+	#endif
+
+	// write dbg ctrl registers for breakpoint 0 to serve user ptrace.
+    //mrs x5, afsr0_el1
+    //cbz x5, 1145f           // skip if not used by user
+    //ldr_this_cpu x1, iee_si_user_bvr0, x2
+    //ldr_this_cpu x3, iee_si_user_bcr0, x4
+    //msr dbgbvr0_el1, x1
+    //msr dbgbcr0_el1, x3
+1145:
+
+	.endif
+
+#else
+#ifdef CONFIG_KOI
+	.if \el==0
+	mrs x0, tcr_el1
+	and x0, x0, #0xFFFFFFFFFFBFFFFF
+	msr tcr_el1,x0
+	.endif
+#endif
+
+#endif
+
 	ldp	x0, x1, [sp, #16 * 0]
 	ldp	x2, x3, [sp, #16 * 1]
 	ldp	x4, x5, [sp, #16 * 2]
@@ -366,13 +821,30 @@ alternative_else_nop_endif
 	tramp_alias	x30, tramp_exit_compat, x29
 	br	x30
 #endif
+
+#ifdef CONFIG_IEE
+5:
+	// ELR_EL1 check fail
+	mov	x0, sp
+	mov	x1, #BAD_IEE
+	mrs	x2, esr_el1
+	bl	bad_mode
+	ASM_BUG()
+#endif
+
 	.else
 	ldr	lr, [sp, #S_LR]
 	add	sp, sp, #S_FRAME_SIZE		// restore sp
 
 	/* Ensure any device/NC reads complete */
 	alternative_insn nop, "dmb sy", ARM64_WORKAROUND_1508412
-
+#ifdef CONFIG_KOI
+    sub sp, sp, #176
+	stp x30, x19, [sp, #16 * 0]
+	bl koi_switch_to_ko_pgtbl
+	ldp	x30, x19, [sp, #16 * 0]
+	add sp, sp, #176
+#endif
 	eret
 	.endif
 	sb
@@ -651,21 +1123,227 @@ SYM_CODE_START_LOCAL(el1_error_invalid)
 	inv_entry 1, BAD_ERROR
 SYM_CODE_END(el1_error_invalid)
 
+/*
+ * iee exception entry 
+ */
+	.macro	iee_exception_entry, el
+
+	/* Check whether exception is permmited. */
+	//ldr x1, =__iee_si_start
+	//cmp x1, x22
+	//b.hi 1148f
+	//ldr x1, =__iee_si_end
+	//cmp x1, x22
+	//b.lo 1148f
+	/* ELR check fail */
+	//mov	x0, sp
+	//mov	x1, #BAD_IEE_SI
+	//mrs	x2, esr_el1
+	//bl	bad_mode
+	//ASM_BUG()
+
+    /* skip setting breakpoint 0 if user hasn't change it. */
+    //.if \el == 0
+    //mrs x0, afsr0_el1
+    //cbz x0, 1148f
+    //.endif
+
+	//b 1147f
+    /* enable breakpoint 0 to proctect iee rwx gate */
+    //adrp x1, iee_rwx_gate_entry
+	//add x1, x1, #:lo12:iee_rwx_gate_entry
+#ifdef CONFIG_KOI
+	//add x1, x1, #120
+#else
+    //add x1, x1, #36
+#endif
+1145:
+    //msr dbgbvr0_el1, x1
+    //mov x2, 0x21e7
+1146:
+    //msr dbgbcr0_el1, x2
+	//isb
+
+1147:
+    /* check val of dbg ctrl registers */
+    //mrs x3, dbgbvr0_el1
+    //adrp x1, iee_rwx_gate_entry
+	//add x1, x1, #:lo12:iee_rwx_gate_entry
+#ifdef CONFIG_KOI
+	//add x1, x1, #120
+#else
+    //add x1, x1, #36
+#endif
+    //cmp x1, x3
+    //bne 1145b
+    //mov x2, 0x21e7
+    //mrs x0, dbgbcr0_el1
+    //cmp x2, x0
+    //bne 1146b
+    //enable_dbg
+1148:
+
+	/* el0 set hpds */
+	.if	\el == 0
+
+	#ifndef CONFIG_UNMAP_KERNEL_AT_EL0
+	/* SET hpd1 = 1 start */
+	mrs x0, tcr_el1
+	orr x0, x0, #0x0000040000000000
+	orr x0, x0, #0x0000000000400000
+	msr tcr_el1, x0
+	/* SET hpd1 = 1 end */
+
+	disable_daif
+
+	/* Check TCR_EL1 */
+	mrs x0, tcr_el1
+	tst x0, #0x0000040000000000
+	b.eq 5f
+	tst x0, #0x0000000000400000
+	b.ne 6f
+
+5:
+	/* TCR_EL1 check fail */
+	mov	x0, sp
+	mov	x1, #BAD_IEE
+	mrs	x2, esr_el1
+	bl	bad_mode
+	ASM_BUG()
+
+6:
+	nop
+	#endif
+
+	.else
+#ifdef CONFIG_IEE_INTERRUPTABLE
+	/* el1 save elr_el1 and set pan */
+	/* Check ELR_EL1 */
+	ldr x1, =__iee_code_start
+	cmp x1, x22
+	b.hi 7f
+	ldr x1, =__iee_code_end
+	cmp x1, x22
+	b.lo 7f
+	/* Exception from iee code */
+	/* Switch to kernel stack */
+	mrs x0, sp_el0 /* x0 -> task_struct(VA) */
+	adrp x2, iee_offset
+	ldr x2, [x2, #:lo12:iee_offset]
+	add x1, x0, x2 /* x1 -> task_token(IEE) */
+	// store iee stack
+	mov x3, sp
+	str x3, [x1, #iee_from_token_offset]
+	// load kernel stack
+	ldr x3, [x1, #kernel_from_token_offset]
+	mov sp, x3
+	sub	sp, sp, #S_FRAME_SIZE
+	/* Enable PAN */
+	msr pan, #0x1
+
+7:
+	/* Exception from kernel code */
+	mov x0, #0x0
+	mov x1, #0x0
+	mov x2, #0x0
+	mov x3, #0x0
+#endif
+	.endif
+	.endm
+
+/*
+ * iee exception exit
+ */
+	.macro	iee_exception_exit, el
+	// Disable daif
+	disable_daif
+	
+	.if	\el == 1
+#ifdef CONFIG_IEE_INTERRUPTABLE
+	/* el1 pop elr_el1 and set pan */
+	/* Check ELR_EL1 */
+	ldr x1, =__iee_code_start
+	cmp x1, x22
+	b.hi 9f
+	ldr x1, =__iee_code_end
+	cmp x1, x22
+	b.lo 9f
+	/* Eret iee code */
+	/* Disable PAN */
+	msr pan, #0x0
+	/* Switch to iee stack */
+	add	sp, sp, #S_FRAME_SIZE
+	mrs x0, sp_el0 /* x0 -> task_struct */
+	adrp x2, iee_offset
+	ldr x2, [x2, #:lo12:iee_offset]
+	add x1, x0, x2 /* x1 -> task_token(IEE) */
+	// store kernel stack
+	mov x3, sp
+	str x3, [x1, #kernel_from_token_offset]
+	// load iee stack
+	ldr x2, [x1, #iee_from_token_offset]
+	mov sp, x2
+	/* Load ELR_EL1 from iee stack */
+	ldr	x21, [sp, #S_PC]
+	/* Check the modify of ELR_EL1 */
+	cmp x21, x22
+	b.ne 8f
+	/* ELR_EL1 not modified */
+	b 9f
+
+8:
+	// ELR_EL1 modified
+	mov	x0, sp
+	mov	x1, #BAD_IEE
+	mrs	x2, esr_el1
+	bl	bad_mode
+	ASM_BUG()
+
+9:
+	// Eret kernel code
+	mov x0, #0x0
+	mov x1, #0x0
+	mov x2, #0x0
+	mov x3, #0x0
+#endif
+	.endif
+	.endm
+
 /*
  * EL1 mode handlers.
  */
 	.align	6
 SYM_CODE_START_LOCAL_NOALIGN(el1_sync)
 	kernel_entry 1
+
+	#ifdef CONFIG_IEE
+	iee_exception_entry 1
+	#endif
+
 	mov	x0, sp
 	bl	el1_sync_handler
+
+	#ifdef CONFIG_IEE
+	iee_exception_exit 1
+	#endif
+
 	kernel_exit 1
 SYM_CODE_END(el1_sync)
 
 	.align	6
 SYM_CODE_START_LOCAL_NOALIGN(el1_irq)
 	kernel_entry 1
+
+	#ifdef CONFIG_IEE
+	iee_exception_entry 1
+	#endif
+
 	el1_interrupt_handler handle_arch_irq
+
+	#ifdef CONFIG_IEE
+	iee_exception_exit  1
+	#endif
+
 	kernel_exit 1
 SYM_CODE_END(el1_irq)
 
@@ -675,8 +1353,18 @@ SYM_CODE_END(el1_irq)
 	.align	6
 SYM_CODE_START_LOCAL_NOALIGN(el0_sync)
 	kernel_entry 0
+
+	#ifdef CONFIG_IEE
+	iee_exception_entry 0
+	#endif
+
 	mov	x0, sp
 	bl	el0_sync_handler
+
+	#ifdef CONFIG_IEE
+	iee_exception_exit 0
+	#endif
+
 	b	ret_to_user
 SYM_CODE_END(el0_sync)
 
@@ -684,8 +1372,18 @@ SYM_CODE_END(el0_sync)
 	.align	6
 SYM_CODE_START_LOCAL_NOALIGN(el0_sync_compat)
 	kernel_entry 0, 32
+
+	#ifdef CONFIG_IEE
+	iee_exception_entry 0
+	#endif
+
 	mov	x0, sp
 	bl	el0_sync_compat_handler
+
+	#ifdef CONFIG_IEE
+	iee_exception_exit 0
+	#endif
+
 	b	ret_to_user
 SYM_CODE_END(el0_sync_compat)
 
@@ -705,22 +1403,47 @@ SYM_CODE_END(el0_error_compat)
 SYM_CODE_START_LOCAL_NOALIGN(el0_irq)
 	kernel_entry 0
 el0_irq_naked:
+
+	#ifdef CONFIG_IEE
+	iee_exception_entry 0
+	#endif
+
 	el0_interrupt_handler handle_arch_irq
+
+	#ifdef CONFIG_IEE
+	iee_exception_exit 0
+	#endif
+
 	b	ret_to_user
 SYM_CODE_END(el0_irq)
 
 SYM_CODE_START_LOCAL(el1_error)
 	kernel_entry 1
+
+	#ifdef CONFIG_IEE
+	iee_exception_entry 1
+	#endif
+
 	mrs	x1, esr_el1
 	enable_dbg
 	mov	x0, sp
 	bl	do_serror
+
+	#ifdef CONFIG_IEE
+	iee_exception_exit 1
+	#endif
+
 	kernel_exit 1
 SYM_CODE_END(el1_error)
 
 SYM_CODE_START_LOCAL(el0_error)
 	kernel_entry 0
 el0_error_naked:
+
+	#ifdef CONFIG_IEE
+	iee_exception_entry 0
+	#endif
+
 	mrs	x25, esr_el1
 	user_exit_irqoff
 	enable_dbg
@@ -728,6 +1451,11 @@ el0_error_naked:
 	mov	x1, x25
 	bl	do_serror
 	enable_da_f
+
+	#ifdef CONFIG_IEE
+	iee_exception_exit 0
+	#endif
+	
 	b	ret_to_user
 SYM_CODE_END(el0_error)
 
@@ -751,6 +1479,8 @@ finish_ret_to_user:
 #ifdef CONFIG_GCC_PLUGIN_STACKLEAK
 	bl	stackleak_erase
 #endif
+
+
 	kernel_exit 0
 
 /*
diff --git a/arch/arm64/kernel/head.S b/arch/arm64/kernel/head.S
index 91890de6cefa..a964a5502311 100644
--- a/arch/arm64/kernel/head.S
+++ b/arch/arm64/kernel/head.S
@@ -300,7 +300,11 @@ SYM_FUNC_START_LOCAL(__create_page_tables)
 	subs	x1, x1, #64
 	b.ne	1b
 
+#ifdef CONFIG_IEE
+    mov	x7, SWAPPER_MM_MMUFLAGS_IDMAP
+#else
 	mov	x7, SWAPPER_MM_MMUFLAGS
+#endif
 
 	/*
 	 * Create the identity mapping.
@@ -375,6 +379,10 @@ SYM_FUNC_START_LOCAL(__create_page_tables)
 
 	map_memory x0, x1, x3, x6, x7, x3, x4, x10, x11, x12, x13, x14
 
+#ifdef CONFIG_IEE
+    mov	x7, SWAPPER_MM_MMUFLAGS
+#endif
+
 	/*
 	 * Map the kernel image (starting with PHYS_OFFSET).
 	 */
@@ -950,6 +958,10 @@ SYM_FUNC_START(__enable_mmu)
 	adrp	x2, idmap_pg_dir
 	phys_to_ttbr x1, x1
 	phys_to_ttbr x2, x2
+#ifdef CONFIG_IEE
+	mov x3, #1
+	bfi x2, x3, #48, #16      	// ASID 1 is used by IEE rwx gate.
+#endif
 	msr	ttbr0_el1, x2			// load TTBR0
 	offset_ttbr1 x1, x3
 	msr	ttbr1_el1, x1			// load TTBR1
diff --git a/arch/arm64/kernel/hibernate.c b/arch/arm64/kernel/hibernate.c
index 42003774d261..26fc494b5524 100644
--- a/arch/arm64/kernel/hibernate.c
+++ b/arch/arm64/kernel/hibernate.c
@@ -40,6 +40,10 @@
 #include <asm/sysreg.h>
 #include <asm/virt.h>
 
+#ifdef CONFIG_PTP
+#include <linux/iee-func.h>
+#endif
+
 /*
  * Hibernate core relies on this value being 0 on resume, and marks it
  * __nosavedata assuming it will keep the resume kernel's '0' value. This
@@ -193,6 +197,9 @@ static int trans_pgd_map_page(pgd_t *trans_pgd, void *page,
 		pudp = (void *)get_safe_page(GFP_ATOMIC);
 		if (!pudp)
 			return -ENOMEM;
+		#ifdef CONFIG_PTP
+		set_iee_page((unsigned long)pudp, 0);
+		#endif
 		pgd_populate(&init_mm, pgdp, pudp);
 	}
 
@@ -201,6 +208,9 @@ static int trans_pgd_map_page(pgd_t *trans_pgd, void *page,
 		pudp = (void *)get_safe_page(GFP_ATOMIC);
 		if (!pudp)
 			return -ENOMEM;
+		#ifdef CONFIG_PTP
+		set_iee_page((unsigned long)pudp, 0);
+		#endif
 		p4d_populate(&init_mm, p4dp, pudp);
 	}
 
@@ -209,6 +219,9 @@ static int trans_pgd_map_page(pgd_t *trans_pgd, void *page,
 		pmdp = (void *)get_safe_page(GFP_ATOMIC);
 		if (!pmdp)
 			return -ENOMEM;
+		#ifdef CONFIG_PTP
+		set_iee_page((unsigned long)pmdp, 0);
+		#endif
 		pud_populate(&init_mm, pudp, pmdp);
 	}
 
@@ -217,6 +230,9 @@ static int trans_pgd_map_page(pgd_t *trans_pgd, void *page,
 		ptep = (void *)get_safe_page(GFP_ATOMIC);
 		if (!ptep)
 			return -ENOMEM;
+		#ifdef CONFIG_PTP
+		set_iee_page((unsigned long)ptep, 0);
+		#endif
 		pmd_populate_kernel(&init_mm, pmdp, ptep);
 	}
 
@@ -255,6 +271,9 @@ static int create_safe_exec_page(void *src_start, size_t length,
 	trans_pgd = (void *)get_safe_page(GFP_ATOMIC);
 	if (!trans_pgd)
 		return -ENOMEM;
+	#ifdef CONFIG_PTP
+	set_iee_page((unsigned long)trans_pgd, 0);
+	#endif
 
 	rc = trans_pgd_map_page(trans_pgd, page, dst_addr,
 				PAGE_KERNEL_EXEC);
@@ -275,7 +294,11 @@ static int create_safe_exec_page(void *src_start, size_t length,
 	 */
 	cpu_set_reserved_ttbr0();
 	local_flush_tlb_all();
+#ifdef CONFIG_IEE
+    iee_rwx_gate_entry(IEE_WRITE_ttbr0_el1, phys_to_ttbr(virt_to_phys(trans_pgd)));
+#else
 	write_sysreg(phys_to_ttbr(virt_to_phys(trans_pgd)), ttbr0_el1);
+#endif
 	isb();
 
 	*phys_dst_addr = virt_to_phys(page);
@@ -494,6 +517,9 @@ static int copy_pte(pmd_t *dst_pmdp, pmd_t *src_pmdp, unsigned long start,
 	dst_ptep = (pte_t *)get_safe_page(GFP_ATOMIC);
 	if (!dst_ptep)
 		return -ENOMEM;
+	#ifdef CONFIG_PTP
+	set_iee_page((unsigned long)dst_ptep, 0);
+	#endif
 	pmd_populate_kernel(&init_mm, dst_pmdp, dst_ptep);
 	dst_ptep = pte_offset_kernel(dst_pmdp, start);
 
@@ -517,6 +543,9 @@ static int copy_pmd(pud_t *dst_pudp, pud_t *src_pudp, unsigned long start,
 		dst_pmdp = (pmd_t *)get_safe_page(GFP_ATOMIC);
 		if (!dst_pmdp)
 			return -ENOMEM;
+		#ifdef CONFIG_PTP
+		set_iee_page((unsigned long)dst_pmdp, 0);
+		#endif
 		pud_populate(&init_mm, dst_pudp, dst_pmdp);
 	}
 	dst_pmdp = pmd_offset(dst_pudp, start);
@@ -552,6 +581,9 @@ static int copy_pud(p4d_t *dst_p4dp, p4d_t *src_p4dp, unsigned long start,
 		dst_pudp = (pud_t *)get_safe_page(GFP_ATOMIC);
 		if (!dst_pudp)
 			return -ENOMEM;
+		#ifdef CONFIG_PTP
+		set_iee_page((unsigned long)dst_pudp, 0);
+		#endif
 		p4d_populate(&init_mm, dst_p4dp, dst_pudp);
 	}
 	dst_pudp = pud_offset(dst_p4dp, start);
@@ -620,6 +652,9 @@ static int trans_pgd_create_copy(pgd_t **dst_pgdp, unsigned long start,
 {
 	int rc;
 	pgd_t *trans_pgd = (pgd_t *)get_safe_page(GFP_ATOMIC);
+	#ifdef CONFIG_PTP
+	set_iee_page((unsigned long)trans_pgd, 0);
+	#endif
 
 	if (!trans_pgd) {
 		pr_err("Failed to allocate memory for temporary page tables.\n");
diff --git a/arch/arm64/kernel/hw_breakpoint.c b/arch/arm64/kernel/hw_breakpoint.c
index b152e69c0401..2a2df3087956 100644
--- a/arch/arm64/kernel/hw_breakpoint.c
+++ b/arch/arm64/kernel/hw_breakpoint.c
@@ -26,6 +26,10 @@
 #include <asm/cputype.h>
 #include <asm/system_misc.h>
 
+#ifdef CONFIG_IEE
+#include <asm/iee-si.h>
+#endif
+
 /* Breakpoint currently in use for each BRP. */
 static DEFINE_PER_CPU(struct perf_event *, bp_on_reg[ARM_MAX_BRP]);
 
@@ -102,13 +106,68 @@ int hw_breakpoint_slots(int type)
 	WRITE_WB_REG_CASE(OFF, 14, REG, VAL);	\
 	WRITE_WB_REG_CASE(OFF, 15, REG, VAL)
 
+#ifdef CONFIG_IEE
+
+#define IEE_SI_READ_WB_REG_CASE(OFF, N, REG, VAL)	\
+	case (OFF + N):				\
+		IEE_SI_AARCH64_DBG_READ(N, REG, VAL);	\
+		break
+
+#define IEE_SI_WRITE_WB_REG_CASE(OFF, N, REG, VAL)	\
+	case (OFF + N):				\
+		IEE_SI_AARCH64_DBG_WRITE(N, REG, VAL);	\
+		break
+
+#define IEE_SI_GEN_READ_REG_CASES(OFF, REG, VAL)	\
+	IEE_SI_READ_WB_REG_CASE(OFF, 0, REG, VAL);  \
+	WRITE_WB_REG_CASE(OFF,  1, REG, VAL);	\
+	WRITE_WB_REG_CASE(OFF,  2, REG, VAL);	\
+	WRITE_WB_REG_CASE(OFF,  3, REG, VAL);	\
+	WRITE_WB_REG_CASE(OFF,  4, REG, VAL);	\
+	WRITE_WB_REG_CASE(OFF,  5, REG, VAL);	\
+	WRITE_WB_REG_CASE(OFF,  6, REG, VAL);	\
+	WRITE_WB_REG_CASE(OFF,  7, REG, VAL);	\
+	WRITE_WB_REG_CASE(OFF,  8, REG, VAL);	\
+	WRITE_WB_REG_CASE(OFF,  9, REG, VAL);	\
+	WRITE_WB_REG_CASE(OFF, 10, REG, VAL);	\
+	WRITE_WB_REG_CASE(OFF, 11, REG, VAL);	\
+	WRITE_WB_REG_CASE(OFF, 12, REG, VAL);	\
+	WRITE_WB_REG_CASE(OFF, 13, REG, VAL);	\
+	WRITE_WB_REG_CASE(OFF, 14, REG, VAL);	\
+	WRITE_WB_REG_CASE(OFF, 15, REG, VAL)
+
+#define IEE_SI_GEN_WRITE_REG_CASES(OFF, REG, VAL)	\
+	IEE_SI_WRITE_WB_REG_CASE(OFF, 0, REG, VAL);  \
+	WRITE_WB_REG_CASE(OFF,  1, REG, VAL);	\
+	WRITE_WB_REG_CASE(OFF,  2, REG, VAL);	\
+	WRITE_WB_REG_CASE(OFF,  3, REG, VAL);	\
+	WRITE_WB_REG_CASE(OFF,  4, REG, VAL);	\
+	WRITE_WB_REG_CASE(OFF,  5, REG, VAL);	\
+	WRITE_WB_REG_CASE(OFF,  6, REG, VAL);	\
+	WRITE_WB_REG_CASE(OFF,  7, REG, VAL);	\
+	WRITE_WB_REG_CASE(OFF,  8, REG, VAL);	\
+	WRITE_WB_REG_CASE(OFF,  9, REG, VAL);	\
+	WRITE_WB_REG_CASE(OFF, 10, REG, VAL);	\
+	WRITE_WB_REG_CASE(OFF, 11, REG, VAL);	\
+	WRITE_WB_REG_CASE(OFF, 12, REG, VAL);	\
+	WRITE_WB_REG_CASE(OFF, 13, REG, VAL);	\
+	WRITE_WB_REG_CASE(OFF, 14, REG, VAL);	\
+	WRITE_WB_REG_CASE(OFF, 15, REG, VAL)
+
+#endif
+
 static u64 read_wb_reg(int reg, int n)
 {
 	u64 val = 0;
 
 	switch (reg + n) {
+// #ifdef CONFIG_IEE
+//     IEE_SI_GEN_READ_REG_CASES(AARCH64_DBG_REG_BVR, AARCH64_DBG_REG_NAME_BVR, val);
+// 	IEE_SI_GEN_READ_REG_CASES(AARCH64_DBG_REG_BCR, AARCH64_DBG_REG_NAME_BCR, val);
+// #else
 	GEN_READ_WB_REG_CASES(AARCH64_DBG_REG_BVR, AARCH64_DBG_REG_NAME_BVR, val);
 	GEN_READ_WB_REG_CASES(AARCH64_DBG_REG_BCR, AARCH64_DBG_REG_NAME_BCR, val);
+// #endif
 	GEN_READ_WB_REG_CASES(AARCH64_DBG_REG_WVR, AARCH64_DBG_REG_NAME_WVR, val);
 	GEN_READ_WB_REG_CASES(AARCH64_DBG_REG_WCR, AARCH64_DBG_REG_NAME_WCR, val);
 	default:
@@ -122,8 +181,13 @@ NOKPROBE_SYMBOL(read_wb_reg);
 static void write_wb_reg(int reg, int n, u64 val)
 {
 	switch (reg + n) {
+// #ifdef CONFIG_IEE
+//     IEE_SI_GEN_WRITE_REG_CASES(AARCH64_DBG_REG_BVR, AARCH64_DBG_REG_NAME_BVR, val);
+// 	IEE_SI_GEN_WRITE_REG_CASES(AARCH64_DBG_REG_BCR, AARCH64_DBG_REG_NAME_BCR, val);
+// #else
 	GEN_WRITE_WB_REG_CASES(AARCH64_DBG_REG_BVR, AARCH64_DBG_REG_NAME_BVR, val);
 	GEN_WRITE_WB_REG_CASES(AARCH64_DBG_REG_BCR, AARCH64_DBG_REG_NAME_BCR, val);
+// #endif
 	GEN_WRITE_WB_REG_CASES(AARCH64_DBG_REG_WVR, AARCH64_DBG_REG_NAME_WVR, val);
 	GEN_WRITE_WB_REG_CASES(AARCH64_DBG_REG_WCR, AARCH64_DBG_REG_NAME_WCR, val);
 	default:
@@ -171,6 +235,10 @@ static int is_a32_compat_bp(struct perf_event *bp)
 	return tsk && is_a32_compat_thread(task_thread_info(tsk));
 }
 
+#ifdef CONFIG_IEE
+int arch_check_bp_in_kernelspace(struct arch_hw_breakpoint *hw);
+#endif
+
 /**
  * hw_breakpoint_slot_setup - Find and setup a perf slot according to
  *			      operations
@@ -191,6 +259,37 @@ static int hw_breakpoint_slot_setup(struct perf_event **slots, int max_slots,
 {
 	int i;
 	struct perf_event **slot;
+// reserve hw breakpoint 0 for iee rwx gate in kernel sapce.
+// #ifdef CONFIG_IEE
+//     struct arch_hw_breakpoint *info = counter_arch_bp(bp);
+//     if (arch_check_bp_in_kernelspace(info)){
+//         for (i = 1; i < max_slots; ++i) {   // search from hw breakpoint 1
+//             slot = &slots[i];
+//             switch (ops) {
+//             case HW_BREAKPOINT_INSTALL:
+//                 if (!*slot) {
+//                     *slot = bp;
+//                     return i;
+//                 }
+//                 break;
+//             case HW_BREAKPOINT_UNINSTALL:
+//                 if (*slot == bp) {
+//                     *slot = NULL;
+//                     return i;
+//                 }
+//                 break;
+//             case HW_BREAKPOINT_RESTORE:
+//                 if (*slot == bp)
+//                     return i;
+//                 break;
+//             default:
+//                 pr_warn_once("Unhandled hw breakpoint ops %d\n", ops);
+//                 return -EINVAL;
+//             }
+//         }
+//         return -ENOSPC;
+//     }
+// #endif
 
 	for (i = 0; i < max_slots; ++i) {
 		slot = &slots[i];
diff --git a/arch/arm64/kernel/iee/Makefile b/arch/arm64/kernel/iee/Makefile
new file mode 100644
index 000000000000..db138c53b8e4
--- /dev/null
+++ b/arch/arm64/kernel/iee/Makefile
@@ -0,0 +1 @@
+obj-$(CONFIG_IEE) += iee.o iee-gate.o iee-func.o iee-pgtable.o pgtable_slab.o
\ No newline at end of file
diff --git a/arch/arm64/kernel/iee/iee-func.c b/arch/arm64/kernel/iee/iee-func.c
new file mode 100644
index 000000000000..e872d41da86f
--- /dev/null
+++ b/arch/arm64/kernel/iee/iee-func.c
@@ -0,0 +1,883 @@
+#include "asm/pgtable.h"
+#include <linux/memory.h>
+#include <linux/mm.h>
+#include <asm/tlb.h>
+#include <asm/tlbflush.h>
+#include <asm/pgalloc.h>
+
+extern s64			iee_offset;
+extern void iee_memset(void *ptr, int data, size_t n);
+extern void iee_split_huge_pmd(pmd_t *pmdp, pte_t *pgtable);
+#ifdef CONFIG_PTP
+extern phys_addr_t __init early_pgtable_alloc(int shift);
+#endif
+
+static inline void iee_set_token(pte_t *ptep, void *new, unsigned long order)
+{
+#ifdef CONFIG_PTP
+	pgd_t *pgdir;
+	pgd_t *pgdp;
+	p4d_t *p4dp;
+	pud_t *pudp;
+	pmd_t *pmdp;
+	int use_block_pmd = 0;
+
+	pgdir = swapper_pg_dir;
+	pgdp = pgd_offset_pgd(pgdir, (unsigned long)new);
+	p4dp = p4d_offset(pgdp, (unsigned long)new);
+	pudp = pud_offset(p4dp, (unsigned long)new);
+	pmdp = pmd_offset(pudp, (unsigned long)new);
+
+	// Handling cont mapping.
+	if(pmd_val(*pmdp) & PTE_CONT)
+	{
+		// The beginning of cont mapping.
+		int i;
+		pmd_t *pmdp = pmd_offset(pudp, (unsigned long)new & CONT_PMD_MASK);
+		for(i = 0; i < CONT_PMDS; i++)
+		{
+			set_pmd(pmdp,__pmd(pmd_val(*pmdp) & ~PTE_CONT));
+			pmdp++;
+		}
+	}
+
+	// Use Block Descriptor.
+	if(pmd_leaf(*pmdp))
+	{
+		#ifndef CONFIG_PTP
+		struct page *page = pmd_page(*pmdp);
+		#endif
+		pte_t *pgtable = pte_alloc_one_kernel(&init_mm);
+
+		if (!pgtable)
+			panic("Alloc pgtable error.\n");
+
+		iee_split_huge_pmd(pmdp, pgtable);
+
+		spin_lock(&init_mm.page_table_lock);
+		if(pmd_leaf(READ_ONCE(*pmdp)))
+		{
+			smp_wmb();
+			pmd_populate_kernel(&init_mm, pmdp, pgtable);
+			pgtable = NULL;
+		}
+		spin_unlock(&init_mm.page_table_lock);
+
+		if(pgtable)
+		{
+			iee_memset(pgtable, 0, PAGE_SIZE);
+			pte_free_kernel(&init_mm, pgtable);
+		}
+	}
+	else if(pmd_leaf(*pmdp))
+	{
+		use_block_pmd = 1;
+	}
+
+	iee_rw_gate(IEE_SET_TOKEN, ptep, new, order, use_block_pmd);
+#else
+	int i;
+	pgd_t *pgdir = swapper_pg_dir;
+	pgd_t *pgdp = pgd_offset_pgd(pgdir, new);
+	p4d_t *p4dp = p4d_offset(pgdp, new);
+	pud_t *pudp = pud_offset(p4dp, new);
+	pmd_t *pmdp;
+	pte_t *lm_ptep;
+	pte_t *iee_ptep;
+	unsigned long iee_addr;
+	int use_block_pmd = 0;
+
+	pmdp = pmd_offset(pudp, new);
+
+	// Handling cont mapping.
+	if(pmd_val(*pmdp) & PTE_CONT)
+	{
+		// The beginning of cont mapping.
+		int i;
+		pmd_t *pmdp = pmd_offset(pudp, (unsigned long)new & CONT_PMD_MASK);
+		for(i = 0; i < CONT_PMDS; i++)
+		{
+			set_pmd(pmdp,__pmd(pmd_val(*pmdp) & ~PTE_CONT));
+			pmdp++;
+		}
+	}
+
+	// Use Block Descriptor.
+	if(pmd_leaf(*pmdp) && order < 9)
+	{
+		struct page *page = pmd_page(*pmdp);
+		pte_t *pgtable = pte_alloc_one_kernel(&init_mm);
+		int i;
+		pte_t *ptep = pgtable;
+
+		if (!pgtable)
+			panic("Alloc pgtable error.\n");
+
+		for (i = 0; i < PMD_SIZE / PAGE_SIZE; i++, ptep++) {
+			pte_t entry;
+			pgprot_t pgprot = PAGE_KERNEL;
+			pgprot = __pgprot(pgprot_val(pgprot) | PTE_CONT);
+
+			entry = mk_pte(page + i, pgprot);
+			set_pte(ptep, entry);
+		}
+
+		spin_lock(&init_mm.page_table_lock);
+		if(pmd_leaf(READ_ONCE(*pmdp)))
+		{
+			smp_wmb();
+			pmd_populate_kernel(&init_mm, pmdp, pgtable);
+			pgtable = NULL;
+		}
+		spin_unlock(&init_mm.page_table_lock);
+
+		if(pgtable)
+		{
+			pte_free_kernel(&init_mm, pgtable);
+		}
+	}
+	else if(pmd_leaf(*pmdp))
+	{
+		use_block_pmd = 1;
+	}
+
+	if(use_block_pmd)
+		lm_ptep = (pte_t *)pmdp;
+	else
+		lm_ptep = pte_offset_kernel(pmdp, new);
+
+	// Handling cont mapping.
+	if(pte_val(*lm_ptep) & PTE_CONT)
+	{
+		// The beginning of cont mapping.
+		int i;
+		pte_t *ptep = pte_offset_kernel(pmdp, (unsigned long)new & CONT_PTE_MASK);
+		if(order < CONFIG_ARM64_CONT_PTE_SHIFT)
+		{
+			for(i = 0; i < CONT_PTES; i++)
+			{
+				set_pte(ptep,__pte(pte_val(*ptep) & ~PTE_CONT));
+				ptep++;
+			}
+		}
+	}
+	
+	iee_addr = ((unsigned long)new + (unsigned long)iee_offset);
+	pgdp = pgd_offset_pgd(pgdir, iee_addr);
+	p4dp = p4d_offset(pgdp, iee_addr);
+	pudp = pud_offset(p4dp, iee_addr);
+	pmdp = pmd_offset(pudp, iee_addr);
+	iee_ptep = pte_offset_kernel(pmdp, iee_addr);
+
+	if(use_block_pmd)
+	{
+		pmd_t *pmdp = (pmd_t *)lm_ptep;
+		pmd_t pmd = READ_ONCE(*pmdp);
+		pmd = __pmd((pmd_val(pmd) | PMD_SECT_RDONLY) & ~PTE_DBM);
+        #ifdef CONFIG_KOI
+        if (pmd_valid(pmd) && !(pmd_val(pmd) & PMD_TABLE_BIT)) {
+            pmd = __pmd(pmd_val(pmd) | PMD_SECT_NG);
+        }
+        #endif
+		WRITE_ONCE(*pmdp, pmd);
+		for(i = 0; i < (0x1 << order); i++)
+		{
+			pte_t pte = READ_ONCE(*ptep);
+			pte = __pte(((pte_val(pte) | 0x1) & ~PTE_ADDR_MASK) | __phys_to_pte_val(__pa(new)));
+            #ifdef CONFIG_KOI
+            if (pte_valid(pte)) {
+		        pte = __pte(pte_val(pte) | PTE_NG);
+            }
+            #endif
+			WRITE_ONCE(*ptep, pte);
+			pte = READ_ONCE(*iee_ptep);
+			pte = __pte(pte_val(pte) | 0x1);
+            #ifdef CONFIG_KOI
+            if (pte_valid(pte)) {
+		        pte = __pte(pte_val(pte) | PTE_NG);
+            }
+            #endif
+			WRITE_ONCE(*iee_ptep, pte);
+			ptep++;
+			iee_ptep++;
+			new += PAGE_SIZE;
+		}
+	}
+	else
+	{
+		for(i = 0; i < (0x1 << order); i++)
+		{
+			pte_t pte = READ_ONCE(*ptep);
+			pte = __pte(((pte_val(pte) | 0x1) & ~PTE_ADDR_MASK) | __phys_to_pte_val(__pa(new)));
+			#ifdef CONFIG_KOI
+        	if (pte_valid(pte))
+		        pte = __pte(pte_val(pte) | PTE_NG);
+        	#endif
+			WRITE_ONCE(*ptep, pte);
+			pte = READ_ONCE(*lm_ptep);
+			pte = __pte((pte_val(pte) | PTE_RDONLY) & ~PTE_DBM);
+			#ifdef CONFIG_KOI
+        	if (pte_valid(pte))
+		        pte = __pte(pte_val(pte) | PTE_NG);
+        	#endif
+			WRITE_ONCE(*lm_ptep, pte);
+			pte = READ_ONCE(*iee_ptep);
+			pte = __pte(pte_val(pte) | 0x1);
+			#ifdef CONFIG_KOI
+            if (pte_valid(pte))
+            	pte = __pte(pte_val(pte) | PTE_NG);
+        	#endif
+			WRITE_ONCE(*iee_ptep, pte);
+			ptep++;
+			lm_ptep++;
+			iee_ptep++;
+			new += PAGE_SIZE;
+		}
+	}
+#endif
+	dsb(ishst);
+	isb();
+}
+
+static inline void iee_unset_token(pte_t *ptep, void *token_addr, void *token_page, unsigned long order)
+{
+#ifdef CONFIG_PTP
+	iee_rw_gate(IEE_UNSET_TOKEN, ptep, token_addr, token_page, order);
+#else
+	int i;
+	pgd_t *pgdir = swapper_pg_dir;
+
+	pgd_t *pgdp = pgd_offset_pgd(pgdir, token_page);
+	p4d_t *p4dp = p4d_offset(pgdp, token_page);
+	pud_t *pudp = pud_offset(p4dp, token_page);
+	pmd_t *pmdp = pmd_offset(pudp, token_page);
+	pte_t *lm_ptep;
+	pte_t *iee_ptep;
+	unsigned long iee_addr;
+	int use_block_pmd = 0;
+
+	// Use Block Descriptor.
+	if(pmd_leaf(*pmdp))
+	{
+		use_block_pmd = 1;
+		lm_ptep = (pte_t *)pmdp;
+	}
+	else
+		lm_ptep = pte_offset_kernel(pmdp, token_page);
+	
+	iee_addr = ((unsigned long)token_page + (unsigned long)iee_offset);
+	pgdp = pgd_offset_pgd(pgdir, iee_addr);
+	p4dp = p4d_offset(pgdp, iee_addr);
+	pudp = pud_offset(p4dp, iee_addr);
+	pmdp = pmd_offset(pudp, iee_addr);
+	iee_ptep = pte_offset_kernel(pmdp, iee_addr);
+
+	if(use_block_pmd)
+	{
+		pmd_t *pmdp = (pmd_t *)lm_ptep;
+		pmd_t pmd = READ_ONCE(*pmdp);
+		pmd = __pmd(pmd_val(pmd) | PTE_DBM);
+        #ifdef CONFIG_KOI
+        if (pmd_valid(pmd) && !(pmd_val(pmd) & PMD_TABLE_BIT)) {
+            pmd = __pmd(pmd_val(pmd) | PMD_SECT_NG);
+        }
+        #endif
+		WRITE_ONCE(*pmdp, pmd);
+		for(i = 0; i < (0x1 << order); i++)
+		{
+			pte_t pte = READ_ONCE(*ptep);
+			pte = __pte(((pte_val(pte) & ~((unsigned long)0x1)) & ~PTE_ADDR_MASK) | __phys_to_pte_val(__pa(token_addr - IEE_OFFSET)));
+			#ifdef CONFIG_KOI
+            if (pte_valid(pte)) {
+		        pte = __pte(pte_val(pte) | PTE_NG);
+            }
+            #endif
+            WRITE_ONCE(*ptep, pte);
+			pte = READ_ONCE(*iee_ptep);
+			pte = __pte(pte_val(pte) & ~0x1);
+            #ifdef CONFIG_KOI
+            if (pte_valid(pte)) {
+		        pte = __pte(pte_val(pte) | PTE_NG);
+            }
+            #endif
+			WRITE_ONCE(*iee_ptep, pte);
+			ptep++;
+			iee_ptep++;
+			token_addr += PAGE_SIZE;
+			token_page += PAGE_SIZE;
+		}
+	}
+	else
+	{
+		for(i = 0; i < (0x1 << order); i++)
+		{
+			pte_t pte = READ_ONCE(*ptep);
+			pte = __pte(((pte_val(pte) & ~((unsigned long)0x1)) & ~PTE_ADDR_MASK) | __phys_to_pte_val(__pa(token_addr - IEE_OFFSET)));
+			#ifdef CONFIG_KOI
+            if (pte_valid(pte)) {
+		        pte = __pte(pte_val(pte) | PTE_NG);
+            }
+            #endif
+            WRITE_ONCE(*ptep, pte);
+			pte = READ_ONCE(*lm_ptep);
+			pte = __pte(pte_val(pte) | PTE_DBM);
+			#ifdef CONFIG_KOI
+            if (pte_valid(pte)) {
+		        pte = __pte(pte_val(pte) | PTE_NG);
+            }
+            #endif
+            WRITE_ONCE(*lm_ptep, pte);
+			pte = READ_ONCE(*iee_ptep);
+			pte = __pte(pte_val(pte) & ~0x1);
+			#ifdef CONFIG_KOI
+            if (pte_valid(pte)) {
+		        pte = __pte(pte_val(pte) | PTE_NG);
+            }
+            #endif
+            WRITE_ONCE(*iee_ptep, pte);
+			ptep++;
+			lm_ptep++;
+			iee_ptep++;
+			token_addr += PAGE_SIZE;
+			token_page += PAGE_SIZE;
+		}
+	}
+#endif
+	dsb(ishst);
+	isb();
+}
+
+// Input is the lm vaddr of sensitive data.
+void set_iee_page(unsigned long addr, int order)
+{
+	pgd_t *pgdir = swapper_pg_dir;
+	pgd_t *pgdp = pgd_offset_pgd(pgdir, addr);
+	p4d_t *p4dp = p4d_offset(pgdp, addr);
+	pud_t *pudp = pud_offset(p4dp, addr);
+	pmd_t *pmdp;
+	pte_t *lm_ptep;
+	pte_t *iee_ptep;
+	unsigned long iee_addr;
+	int use_block_pmd = 0;
+
+	pmdp = pmd_offset(pudp, addr);
+
+	// Handling cont mapping.
+	if(pmd_val(*pmdp) & PTE_CONT)
+	{
+		// The beginning of cont mapping.
+		int i;
+		pmd_t *pmdp = pmd_offset(pudp, addr & CONT_PMD_MASK);
+		for(i = 0; i < CONT_PMDS; i++)
+		{
+			set_pmd(pmdp,__pmd(pmd_val(*pmdp) & ~PTE_CONT));
+			pmdp++;
+		}
+	}
+
+	// Use Block Descriptor.
+	if(pmd_leaf(*pmdp) && order < 9)
+	{
+		#ifndef CONFIG_PTP
+		struct page *page = pmd_page(*pmdp);
+		#endif
+		pte_t *pgtable = pte_alloc_one_kernel(&init_mm);
+
+		if (!pgtable)
+			panic("Alloc pgtable error.\n");
+
+		#ifdef CONFIG_PTP
+		iee_split_huge_pmd(pmdp, pgtable);
+		#else
+		{
+			int i;
+			pte_t *ptep = pgtable;
+			for (i = 0; i < PMD_SIZE / PAGE_SIZE; i++, ptep++) {
+				pte_t entry;
+				pgprot_t pgprot = PAGE_KERNEL;
+				pgprot = __pgprot(pgprot_val(pgprot) | PTE_CONT);
+
+				entry = mk_pte(page + i, pgprot);
+				set_pte(ptep, entry);
+			}
+		}
+		#endif
+
+		spin_lock(&init_mm.page_table_lock);
+		if(pmd_leaf(READ_ONCE(*pmdp)))
+		{
+			smp_wmb();
+			pmd_populate_kernel(&init_mm, pmdp, pgtable);
+			pgtable = NULL;
+		}
+		spin_unlock(&init_mm.page_table_lock);
+
+		if(pgtable)
+		{
+			#ifdef CONFIG_PTP
+			iee_memset(pgtable, 0, PAGE_SIZE);
+			#endif
+			pte_free_kernel(&init_mm, pgtable);
+		}
+	}
+	else if(pmd_leaf(*pmdp))
+	{
+		use_block_pmd = 1;
+	}
+
+	if(use_block_pmd)
+		lm_ptep = (pte_t *)pmdp;
+	else
+		lm_ptep = pte_offset_kernel(pmdp, addr);
+
+	// Handling cont mapping.
+	if(pte_val(*lm_ptep) & PTE_CONT)
+	{
+		// The beginning of cont mapping.
+		int i;
+		pte_t *ptep = pte_offset_kernel(pmdp, addr & CONT_PTE_MASK);
+		if(order < CONFIG_ARM64_CONT_PTE_SHIFT)
+		{
+			for(i = 0; i < CONT_PTES; i++)
+			{
+				set_pte(ptep,__pte(pte_val(*ptep) & ~PTE_CONT));
+				ptep++;
+			}
+		}
+	}
+	
+	iee_addr = ((unsigned long)addr + (unsigned long)iee_offset);
+	pgdp = pgd_offset_pgd(pgdir, iee_addr);
+	p4dp = p4d_offset(pgdp, iee_addr);
+	pudp = pud_offset(p4dp, iee_addr);
+	pmdp = pmd_offset(pudp, iee_addr);
+	iee_ptep = pte_offset_kernel(pmdp, iee_addr);
+
+	iee_set_sensitive_pte(lm_ptep, iee_ptep, order, use_block_pmd);
+
+	flush_tlb_kernel_range(addr, addr+PAGE_SIZE*(1 << order));
+	isb();
+}
+
+// Input is the lm vaddr of sensitive data.
+void unset_iee_page(unsigned long addr, int order)
+{
+	pgd_t *pgdir = swapper_pg_dir;
+	pgd_t *pgdp = pgd_offset_pgd(pgdir, addr);
+	p4d_t *p4dp = p4d_offset(pgdp, addr);
+	pud_t *pudp = pud_offset(p4dp, addr);
+	pmd_t *pmdp = pmd_offset(pudp, addr);
+	pte_t *lm_ptep;
+	pte_t *iee_ptep;
+	unsigned long iee_addr;
+	int use_block_pmd = 0;
+
+	// Use Block Descriptor.
+	if(pmd_leaf(*pmdp))
+	{
+		use_block_pmd = 1;
+		lm_ptep = (pte_t *)pmdp;
+	}
+	else
+		lm_ptep = pte_offset_kernel(pmdp, addr);
+	
+	iee_addr = ((unsigned long)addr + (unsigned long)iee_offset);
+	pgdp = pgd_offset_pgd(pgdir, iee_addr);
+	p4dp = p4d_offset(pgdp, iee_addr);
+	pudp = pud_offset(p4dp, iee_addr);
+	pmdp = pmd_offset(pudp, iee_addr);
+	iee_ptep = pte_offset_kernel(pmdp, iee_addr);
+
+	iee_unset_sensitive_pte(lm_ptep, iee_ptep, order, use_block_pmd);
+
+	flush_tlb_kernel_range(addr, addr+PAGE_SIZE*(1 << order));
+	flush_tlb_kernel_range(iee_addr, iee_addr+PAGE_SIZE*(1 << order));
+	isb();
+}
+
+void set_iee_page_valid(unsigned long addr)
+{
+	pgd_t *pgdir = swapper_pg_dir;
+	pgd_t *pgdp = pgd_offset_pgd(pgdir, addr);
+
+	p4d_t *p4dp = p4d_offset(pgdp, addr);
+
+	pud_t *pudp = pud_offset(p4dp, addr);
+
+	pmd_t *pmdp = pmd_offset(pudp, addr);
+
+	pte_t *ptep = pte_offset_kernel(pmdp, addr);
+	pte_t pte = READ_ONCE(*ptep);
+
+    if((addr < (PAGE_OFFSET + IEE_OFFSET)) | (addr > (PAGE_OFFSET + BIT(vabits_actual - 1))))
+		return;
+
+	pte = __pte(pte_val(pte) | 0x1);
+	set_pte(ptep, pte);
+}
+
+void iee_set_logical_mem_ro(unsigned long addr)
+{
+	pgd_t *pgdir = swapper_pg_dir;
+	pgd_t *pgdp = pgd_offset_pgd(pgdir, addr);
+	p4d_t *p4dp = p4d_offset(pgdp, addr);
+	pud_t *pudp = pud_offset(p4dp, addr);
+	pmd_t *pmdp;
+	pte_t *ptep;
+	pte_t pte;
+
+	pmdp = pmd_offset(pudp, addr);
+
+	// Handling cont mapping.
+	if(pmd_val(*pmdp) & PTE_CONT)
+	{
+		// The beginning of cont mapping.
+		int i;
+		pmd_t *pmdp = pmd_offset(pudp, addr & CONT_PMD_MASK);
+		for(i = 0; i < CONT_PMDS; i++)
+		{
+			set_pmd(pmdp,__pmd(pmd_val(*pmdp) & ~PTE_CONT));
+			pmdp++;
+		}
+	}
+
+	// Use Block Descriptor.
+	if(pmd_leaf(*pmdp))
+	{
+		#ifndef CONFIG_PTP
+		struct page *page = pmd_page(*pmdp);
+		#endif
+		pte_t *pgtable = pte_alloc_one_kernel(&init_mm);
+
+		if (!pgtable)
+			panic("Alloc pgtable error.\n");
+
+		#ifdef CONFIG_PTP
+		iee_split_huge_pmd(pmdp, pgtable);
+		#else
+		{
+			int i;
+			pte_t *ptep = pgtable;
+			for (i = 0; i < PMD_SIZE / PAGE_SIZE; i++, ptep++) {
+				pte_t entry;
+				pgprot_t pgprot = PAGE_KERNEL;
+				pgprot = __pgprot(pgprot_val(pgprot) | PTE_CONT);
+
+				entry = mk_pte(page + i, pgprot);
+				set_pte(ptep, entry);
+			}
+		}
+		#endif
+
+		spin_lock(&init_mm.page_table_lock);
+		if(pmd_leaf(READ_ONCE(*pmdp)))
+		{
+			smp_wmb();
+			pmd_populate_kernel(&init_mm, pmdp, pgtable);
+			pgtable = NULL;
+		}
+		spin_unlock(&init_mm.page_table_lock);
+
+		if(pgtable)
+		{
+			#ifdef CONFIG_PTP
+			iee_memset(pgtable, 0, PAGE_SIZE);
+			#endif
+			pte_free_kernel(&init_mm, pgtable);
+		}
+	}
+
+	ptep = pte_offset_kernel(pmdp, addr);
+
+	// Handling cont mapping.
+	if(pte_val(*ptep) & PTE_CONT)
+	{
+		// The beginning of cont mapping.
+		int i;
+		pte_t *ptep = pte_offset_kernel(pmdp, addr & CONT_PTE_MASK);
+		for(i = 0; i < CONT_PTES; i++)
+		{
+			set_pte(ptep,__pte(pte_val(*ptep) & ~PTE_CONT));
+			ptep++;
+		}
+	}
+
+	pte = READ_ONCE(*ptep);
+
+    if(addr < PAGE_OFFSET)
+		return;
+
+	pte = __pte((pte_val(pte) | PTE_RDONLY) & ~PTE_DBM);
+	set_pte(ptep, pte);
+	flush_tlb_kernel_range(addr, addr+PAGE_SIZE);
+	isb();
+}
+
+void iee_set_token_page_valid(void *token, void *new, unsigned int order)
+{
+	pgd_t *pgdir = swapper_pg_dir;
+	pgd_t *pgdp = pgd_offset_pgd(pgdir, (unsigned long)token);
+	p4d_t *p4dp = p4d_offset(pgdp, (unsigned long)token);
+	pud_t *pudp = pud_offset(p4dp, (unsigned long)token);
+	pmd_t *pmdp = pmd_offset(pudp, (unsigned long)token);
+	pte_t *ptep = pte_offset_kernel(pmdp, (unsigned long)token);
+
+	iee_set_token(ptep, new, order);
+
+	flush_tlb_kernel_range((unsigned long)token, (unsigned long)(token + (PAGE_SIZE * (1 << order))));
+	flush_tlb_kernel_range((unsigned long)new, (unsigned long)(new + (PAGE_SIZE * (1 << order))));
+	isb();
+}
+
+void iee_set_token_page_invalid(void *token_addr, void *token_page, unsigned long order)
+{
+	unsigned long iee_addr = ((unsigned long)token_page + (unsigned long)iee_offset);
+	pgd_t *pgdir = swapper_pg_dir;
+	pgd_t *pgdp = pgd_offset_pgd(pgdir, (unsigned long)token_addr);
+	p4d_t *p4dp = p4d_offset(pgdp, (unsigned long)token_addr);
+	pud_t *pudp = pud_offset(p4dp, (unsigned long)token_addr);
+	pmd_t *pmdp = pmd_offset(pudp, (unsigned long)token_addr);
+	pte_t *ptep = pte_offset_kernel(pmdp, (unsigned long)token_addr);
+
+	if(token_page == NULL)
+		panic("Token of task_struct was unset.\n");
+
+	iee_unset_token(ptep, token_addr, token_page, order);
+
+	flush_tlb_kernel_range((unsigned long)token_addr, (unsigned long)(token_addr + (PAGE_SIZE * (1 << order))));
+	flush_tlb_kernel_range((unsigned long)token_page, (unsigned long)(token_page + (PAGE_SIZE * (1 << order))));
+	flush_tlb_kernel_range(iee_addr, iee_addr + (PAGE_SIZE * (1 << order)));
+	isb();
+}
+
+void iee_set_kernel_ppage(unsigned long addr, int order)
+{
+	pgd_t *pgdir = swapper_pg_dir;
+	pgd_t *pgdp = pgd_offset_pgd(pgdir, addr);
+	p4d_t *p4dp = p4d_offset(pgdp, addr);
+	pud_t *pudp = pud_offset(p4dp, addr);
+	pmd_t *pmdp = pmd_offset(pudp, addr);
+	pte_t *ptep;
+	int use_block_pmd = 0;
+
+	// Use Block Descriptor.
+	if(pmd_leaf(*pmdp))
+	{
+		use_block_pmd = 1;
+		ptep = (pte_t *)pmdp;
+	}
+	else
+		ptep = pte_offset_kernel(pmdp, addr);
+
+	iee_set_pte_ppage(ptep, order, use_block_pmd);
+
+	flush_tlb_kernel_range(addr, addr+(1 << order)*PAGE_SIZE);
+	isb();
+}
+
+void __init iee_set_kernel_upage_early(unsigned long addr, int order)
+{
+	pgd_t *pgdir = swapper_pg_dir;
+	pgd_t *pgdp = pgd_offset_pgd(pgdir, addr);
+	p4d_t *p4dp = p4d_offset(pgdp, addr);
+	pud_t *pudp = pud_offset(p4dp, addr);
+	pmd_t *pmdp;
+	pte_t *ptep;
+	int use_block_pmd = 0;
+
+	pmdp = pmd_offset(pudp, addr);
+
+	// Handling cont mapping.
+	if(pmd_val(*pmdp) & PTE_CONT)
+	{
+		// The beginning of cont mapping.
+		int i;
+		pmd_t *pmdp = pmd_offset(pudp, addr & CONT_PMD_MASK);
+		for(i = 0; i < CONT_PMDS; i++)
+		{
+			set_pmd(pmdp,__pmd(pmd_val(*pmdp) & ~PTE_CONT));
+			pmdp++;
+		}
+	}
+
+	// Use Block Descriptor.
+	if(pmd_leaf(*pmdp) && order < 9)
+	{
+		#ifdef CONFIG_PTP
+		pte_t *pgtable = __va(early_pgtable_alloc(PAGE_SHIFT));
+		set_iee_page_valid(__phys_to_iee(__pa(pgtable)));
+		#else
+		struct page *page = pmd_page(*pmdp);
+		pte_t *pgtable = pte_alloc_one_kernel(&init_mm);
+		#endif
+
+		if (!pgtable)
+			panic("Alloc pgtable error.\n");
+
+		#ifdef CONFIG_PTP
+		iee_split_huge_pmd(pmdp, pgtable);
+		#else
+		{
+			int i;
+			pte_t *ptep = pgtable;
+			for (i = 0; i < PMD_SIZE / PAGE_SIZE; i++, ptep++) {
+				pte_t entry;
+				pgprot_t pgprot = PAGE_KERNEL;
+				pgprot = __pgprot(pgprot_val(pgprot) | PTE_CONT);
+
+				entry = mk_pte(page + i, pgprot);
+				set_pte(ptep, entry);
+			}
+		}
+		#endif
+
+		spin_lock(&init_mm.page_table_lock);
+		if(pmd_leaf(READ_ONCE(*pmdp)))
+		{
+			smp_wmb();
+			pmd_populate_kernel(&init_mm, pmdp, pgtable);
+			pgtable = NULL;
+		}
+		spin_unlock(&init_mm.page_table_lock);
+
+		if(pgtable)
+		{
+			#ifdef CONFIG_PTP
+			iee_memset(pgtable, 0, PAGE_SIZE);
+			#endif
+			pte_free_kernel(&init_mm, pgtable);
+		}
+	}
+	else if(pmd_leaf(*pmdp))
+	{
+		use_block_pmd = 1;
+	}
+
+	if(use_block_pmd)
+		ptep = (pte_t *)pmdp;
+	else
+		ptep = pte_offset_kernel(pmdp, addr);
+
+	// Handling cont mapping.
+	if(pte_val(*ptep) & PTE_CONT)
+	{
+		// The beginning of cont mapping.
+		int i;
+		pte_t *ptep = pte_offset_kernel(pmdp, addr & CONT_PTE_MASK);
+		if(order < CONFIG_ARM64_CONT_PTE_SHIFT)
+		{
+			for(i = 0; i < CONT_PTES; i++)
+			{
+				set_pte(ptep,__pte(pte_val(*ptep) & ~PTE_CONT));
+				ptep++;
+			}
+		}
+	}
+
+	iee_set_pte_upage(ptep, order, use_block_pmd);
+
+	flush_tlb_kernel_range(addr, addr+(1 << order)*PAGE_SIZE);
+	isb();
+}
+
+void iee_set_kernel_upage(unsigned long addr, int order)
+{
+	pgd_t *pgdir = swapper_pg_dir;
+	pgd_t *pgdp = pgd_offset_pgd(pgdir, addr);
+	p4d_t *p4dp = p4d_offset(pgdp, addr);
+	pud_t *pudp = pud_offset(p4dp, addr);
+	pmd_t *pmdp;
+	pte_t *ptep;
+	int use_block_pmd = 0;
+
+	pmdp = pmd_offset(pudp, addr);
+
+	// Handling cont mapping.
+	if(pmd_val(*pmdp) & PTE_CONT)
+	{
+		// The beginning of cont mapping.
+		int i;
+		pmd_t *pmdp = pmd_offset(pudp, addr & CONT_PMD_MASK);
+		for(i = 0; i < CONT_PMDS; i++)
+		{
+			set_pmd(pmdp,__pmd(pmd_val(*pmdp) & ~PTE_CONT));
+			pmdp++;
+		}
+	}
+
+	// Use Block Descriptor.
+	if(pmd_leaf(*pmdp) && order < 9)
+	{
+		#ifndef CONFIG_PTP
+		struct page *page = pmd_page(*pmdp);
+		#endif
+		pte_t *pgtable = pte_alloc_one_kernel(&init_mm);
+
+		if (!pgtable)
+			panic("Alloc pgtable error.\n");
+
+		#ifdef CONFIG_PTP
+		iee_split_huge_pmd(pmdp, pgtable);
+		#else
+		{
+			int i;
+			pte_t *ptep = pgtable;
+			for (i = 0; i < PMD_SIZE / PAGE_SIZE; i++, ptep++) {
+				pte_t entry;
+				pgprot_t pgprot = PAGE_KERNEL;
+				pgprot = __pgprot(pgprot_val(pgprot) | PTE_CONT);
+
+				entry = mk_pte(page + i, pgprot);
+				set_pte(ptep, entry);
+			}
+		}
+		#endif
+
+		spin_lock(&init_mm.page_table_lock);
+		if(pmd_leaf(READ_ONCE(*pmdp)))
+		{
+			smp_wmb();
+			pmd_populate_kernel(&init_mm, pmdp, pgtable);
+			pgtable = NULL;
+		}
+		spin_unlock(&init_mm.page_table_lock);
+
+		if(pgtable)
+		{
+			#ifdef CONFIG_PTP
+			iee_memset(pgtable, 0, PAGE_SIZE);
+			#endif
+			pte_free_kernel(&init_mm, pgtable);
+		}
+	}
+	else if(pmd_leaf(*pmdp))
+	{
+		use_block_pmd = 1;
+	}
+
+	if(use_block_pmd)
+		ptep = (pte_t *)pmdp;
+	else
+		ptep = pte_offset_kernel(pmdp, addr);
+
+	// Handling cont mapping.
+	if(pte_val(*ptep) & PTE_CONT)
+	{
+		// The beginning of cont mapping.
+		int i;
+		pte_t *ptep = pte_offset_kernel(pmdp, addr & CONT_PTE_MASK);
+		if(order < CONFIG_ARM64_CONT_PTE_SHIFT)
+		{
+			for(i = 0; i < CONT_PTES; i++)
+			{
+				set_pte(ptep,__pte(pte_val(*ptep) & ~PTE_CONT));
+				ptep++;
+			}
+		}
+	}
+
+	iee_set_pte_upage(ptep, order, use_block_pmd);
+
+	flush_tlb_kernel_range(addr, addr+(1 << order)*PAGE_SIZE);
+	isb();
+}
\ No newline at end of file
diff --git a/arch/arm64/kernel/iee/iee-gate.S b/arch/arm64/kernel/iee/iee-gate.S
new file mode 100644
index 000000000000..2a24cac0b97b
--- /dev/null
+++ b/arch/arm64/kernel/iee/iee-gate.S
@@ -0,0 +1,326 @@
+#include <asm/asm-offsets.h>
+#include <linux/linkage.h>
+#include <asm/bug.h>
+#include <asm-generic/export.h>
+#include <asm/sysreg.h>
+#include <asm/assembler.h>
+#include <asm/iee-def.h>
+
+#ifdef CONFIG_IEE
+
+SYM_FUNC_START(iee_read_tmp_page)
+    /* save daif, close irq */
+    mrs x13, daif
+	msr daifset, #0x2
+    isb
+    /* disable PAN */
+	msr pan, #0x0
+    adrp x12, iee_offset
+    ldr x12, [x12, #:lo12:iee_offset]
+    add x11, x0, x12 /* x11 -> task_token(IEE) */
+    ldr x0, [x11, #tmp_page_from_token_offset]
+    /* enable PAN */
+	msr pan, #0x1
+    /* restore daif */
+	msr daif, x13
+    ret
+SYM_FUNC_END(iee_read_tmp_page)
+
+SYM_FUNC_START(iee_read_freeptr)
+    /* save daif, close irq */
+    mrs x13, daif
+	msr daifset, #0x2
+    isb
+    /* disable PAN */
+	msr pan, #0x0
+    ldr x0, [x0]
+    /* enable PAN */
+	msr pan, #0x1
+    /* restore daif */
+	msr daif, x13
+    ret
+SYM_FUNC_END(iee_read_freeptr)
+
+SYM_FUNC_START(iee_set_stack_freeptr)
+    /* save daif, close irq */
+    mrs x13, daif
+	msr daifset, #0x2
+    isb
+    /* disable PAN */
+	msr pan, #0x0
+    str x1, [x0]
+    /* enable PAN */
+	msr pan, #0x1
+    /* restore daif */
+	msr daif, x13
+    ret
+SYM_FUNC_END(iee_set_stack_freeptr)
+
+SYM_FUNC_START(iee_read_token_stack)
+    /* save daif, close irq */
+    mrs x13, daif
+	msr daifset, #0x2
+    isb
+    /* disable PAN */
+	msr pan, #0x0
+    adrp x12, iee_offset
+    ldr x12, [x12, #:lo12:iee_offset]
+    add x11, x0, x12 /* x11 -> task_token(IEE) */
+    ldr x0, [x11, #iee_from_token_offset]
+    /* enable PAN */
+	msr pan, #0x1
+    /* restore daif */
+	msr daif, x13
+    ret
+SYM_FUNC_END(iee_read_token_stack)
+
+SYM_FUNC_START(iee_set_xchg_relaxed)
+    /* save daif, close irq */
+    mrs x13, daif
+	msr daifset, #0x2
+    isb
+    /* disable PAN */
+	msr pan, #0x0
+    /* begin */
+    adrp x2, iee_offset
+    ldr x2, [x2, #:lo12:iee_offset]
+    add x0, x0, x2
+    prfm pstl1strm, [x0]
+12:
+    ldxr x3, [x0]
+    stxr w4, x1, [x0]
+    cbnz w4, 12b
+    mov x0, x3    
+    /* end */
+    /* enable PAN */
+	msr pan, #0x1
+    /* restore daif */
+	msr daif, x13
+    ret
+SYM_FUNC_END(iee_set_xchg_relaxed)
+
+SYM_FUNC_START(iee_set_cmpxchg_relaxed)
+    /* save daif, close irq */
+    mrs x13, daif
+	msr daifset, #0x2
+    isb
+    /* disable PAN */
+	msr pan, #0x0
+    /* begin */
+    adrp x9, iee_offset
+    ldr x9, [x9, #:lo12:iee_offset]
+    add x3, x0, x9
+    prfm pstl1strm, [x3]
+11:
+    ldxr x0, [x3]
+    eor x4, x0, x1
+    cbnz w4, 13f
+    stxr w4, x2, [x3]
+    cbnz w4, 11b
+13:
+    /* end */
+    /* enable PAN */
+	msr pan, #0x1
+    /* restore daif */
+	msr daif, x13
+    ret
+SYM_FUNC_END(iee_set_cmpxchg_relaxed)
+
+SYM_FUNC_START(iee_rw_gate)
+    /* save daif, close irq  */
+    mrs x13, daif
+	msr daifset, #0x2
+    isb
+    /* save lr */
+    sub	sp, sp, #16
+	stp	x29, x30, [sp]
+	bl iee_protected_rw_gate
+    /* restore lr */
+    ldp	x29, x30, [sp]
+	add	sp, sp, #16
+    /* restore daif */
+	msr daif, x13
+    ret
+SYM_FUNC_END(iee_rw_gate)
+#if defined(CONFIG_CREDP) || defined(CONFIG_KOI)
+EXPORT_SYMBOL(iee_rw_gate)
+#endif
+
+	.pushsection ".iee.text.header", "ax"
+
+SYM_FUNC_START(iee_protected_rw_gate)
+	/* disable PAN */
+	msr pan, #0x0
+	/* switch to iee stack */
+    mrs x9, sp_el0  /* x9 -> task_struct */
+    adrp x7, iee_offset
+    ldr x7, [x7, #:lo12:iee_offset]
+    add x11, x9, x7 /* x11 -> task_token(IEE) */
+    // store kernel stack
+    mov x10, sp
+    str x10, [x11, #kernel_from_token_offset]
+    // load iee stack
+    ldr x10, [x11, #iee_from_token_offset]
+    mov sp, x10
+#ifdef CONFIG_IEE_INTERRUPTABLE
+	isb
+	/* restore daif */
+	msr	daif, x13
+	sub	sp, sp, #16
+	stp	x11, x30, [sp]
+#else
+    sub	sp, sp, #32
+    stp x11, x7, [sp, #16]
+    stp	x13, x30, [sp]
+#endif
+	/* call iee func */
+	adrp x12, iee_funcs
+    add x12, x12, x0, lsl #3
+    ldr x12, [x12, #:lo12:iee_funcs]
+    mov x0, x7
+    blr x12
+#ifdef CONFIG_IEE_INTERRUPTABLE
+	ldp	x11, x30, [sp]
+	add	sp, sp, #16
+	/* store and disable daif */
+	mrs	x13, daif
+	msr	daifset, #0x2
+	isb
+#else
+    ldp	x13, x30, [sp]
+    ldp x11, x7, [sp, #16]
+    add	sp, sp, #32
+#endif
+	/* switch to kernel stack */
+    // load kernel stack
+    ldr x10, [x11, #kernel_from_token_offset]
+    mov sp, x10
+	/* enable PAN */
+	msr pan, #0x1
+	ret
+SYM_FUNC_END(iee_protected_rw_gate)
+
+	.popsection
+
+#include <asm/asm-bug.h>
+#define BAD_IEE		4
+#define BAD_IEE_SI		5
+
+#define SYS_TCR_EL1_HPD1    0x40000000000
+#define SYS_TCR_EL1_A1      0x400000
+
+    .pushsection ".iee.exec_entry", "ax"
+
+SYM_FUNC_START(iee_rwx_gate_entry)
+    /* Disable irq first. */
+    mrs x15, daif           // use x15 to restore daif
+    msr DAIFSet, #0x2
+    
+    /* Set HPD1 = 1 to exec follwing codes in U RWX page */
+    mrs x9, tcr_el1
+    bic x9, x9, #SYS_TCR_EL1_HPD1
+    bic x9, x9, #SYS_TCR_EL1_A1
+    msr tcr_el1, x9
+    isb
+
+    b iee_rwx_gate_tramp
+SYM_FUNC_END(iee_rwx_gate_entry)
+EXPORT_SYMBOL(iee_rwx_gate_entry)
+    .popsection
+
+#define IEE_TCR_MASK_0  0x3F
+#define IEE_TCR_MASK_32  0x100
+#define IEE_TCR_MASK_48  0x100
+#define USER_ASID_FLAG	(UL(1) << 48)
+
+    .pushsection ".iee.si_text", "awx"
+
+SYM_FUNC_START(iee_rwx_gate_tramp)
+    /* Check tcr val. */
+    mrs x10, tcr_el1
+    adrp x12, iee_si_tcr        // tcr val shall be const after init
+    ldr x12, [x12, #:lo12:iee_si_tcr]
+    cbz x12, 1f
+    cmp x12, x10
+    b.ne 3f
+1:
+    mov x13, sp
+    /* if called by koi, skip stack switch */
+#ifdef CONFIG_KOI
+    cmp x0, #IEE_SWITCH_TO_KERNEL
+    b.eq 4f
+    cmp x0, #IEE_SWITCH_TO_KOI
+    b.eq 5f
+#endif
+
+    /* If iee hasn't been initialized, skip stack switch. */
+    adrp x11, iee_init_done
+    ldr x10, [x11, #:lo12:iee_init_done]
+    cbz x10, 2f
+
+    /* Switch to iee stack */
+    mrs x9, sp_el0              // x9 -> task_struct
+    adrp x12, iee_si_offset
+    ldr x12, [x12, #:lo12:iee_si_offset]
+    add x11, x9, x12            // x11 -> task_token(IEE)
+    // load iee stack
+    ldr x10, [x11, #iee_from_token_offset]
+    mov sp, x10
+
+    /* x15 stores daif and x13 stores previous sp */
+2:
+    stp x15, x13, [sp, #-32]!
+    stp x29, x30, [sp, #16]
+    bl iee_si_handler           // enter actual handler
+    ldp x29, x30, [sp, #16]
+
+    b iee_rwx_gate_exit         // jump to iee exit
+3:
+	mov	x0, sp
+	mov	x1, #BAD_IEE_SI
+	mrs	x2, esr_el1
+	bl	bad_mode
+	ASM_BUG()
+#ifdef CONFIG_KOI
+/* Handle KOI switch gates. */
+4:
+    /* IEE_SWITCH_TO_KERNEL */
+    mrs x9, ttbr1_el1
+    bic x9, x9, #USER_ASID_FLAG     // Set new ASID to even
+    adrp x11, iee_base_swapper_pg_dir
+    ldr x11, [x11, #:lo12:iee_base_swapper_pg_dir]
+    b 6f
+5:
+    /* IEE_SWITCH_TO_KOI */
+    mov x11, x1
+6:
+    ubfx x10, x9, #48, #16      // x10 -> new TTBR1 ASID
+    bfi x11, x10, #48, #16
+    msr ttbr1_el1, x11
+    isb
+    stp x15, x13, [sp, #-32]!
+    b iee_rwx_gate_exit
+#endif
+SYM_FUNC_END(iee_rwx_gate_tramp)
+    
+    .popsection
+
+    .pushsection ".iee.exec_exit", "ax"
+
+SYM_FUNC_START(iee_rwx_gate_exit)
+    ldp x15, x13, [sp], #32
+    mov sp, x13                 // switch to kernel stack
+    mrs x9, tcr_el1
+    orr x9, x9, #SYS_TCR_EL1_HPD1
+    orr x9, x9, #SYS_TCR_EL1_A1
+    msr tcr_el1, x9
+/* --------Page boundary-------- */
+    isb
+    msr daif, x15
+    isb
+    ret 
+SYM_FUNC_END(iee_rwx_gate_exit)
+
+    .popsection
+
+#endif
diff --git a/arch/arm64/kernel/iee/iee-pgtable.c b/arch/arm64/kernel/iee/iee-pgtable.c
new file mode 100644
index 000000000000..7ebbf247ad4d
--- /dev/null
+++ b/arch/arm64/kernel/iee/iee-pgtable.c
@@ -0,0 +1,356 @@
+#include <asm/pgtable.h>
+#include <linux/iee-flag.h>
+#include <asm/iee.h>
+
+#ifdef CONFIG_PTP
+void iee_set_tramp_pgd_pre_init(pgd_t *pgdp, pgd_t pgd)
+{
+	iee_rw_gate(IEE_OP_SET_TRAMP_PGD, pgdp, pgd);
+}
+
+inline void iee_set_bm_pte(pte_t *ptep, pte_t pte)
+{
+	#ifdef CONFIG_KOI
+    if (pte_valid(pte))
+        pte = __pte(pte_val(pte) | PTE_NG);
+    #endif
+
+	// If it is pre init, write once.
+	// Else, write once will cause exception. So it is safe.
+	iee_rw_gate(IEE_OP_SET_BM_PTE, ptep, pte);
+
+	/*
+	 * Only if the new pte is valid and kernel, otherwise TLB maintenance
+	 * or update_mmu_cache() have the necessary barriers.
+	 */
+	if (pte_valid_not_user(pte)) {
+		dsb(ishst);
+		isb();
+	}
+}
+
+inline void iee_set_fixmap_pte_pre_init(pte_t *ptep, pte_t pte)
+{
+#ifdef CONFIG_KOI
+    if (pte_valid(pte)) {
+        pte = __pte(pte_val(pte) | PTE_NG);
+    }
+#endif
+	WRITE_ONCE(*ptep, pte);
+
+	/*
+	 * Only if the new pte is valid and kernel, otherwise TLB maintenance
+	 * or update_mmu_cache() have the necessary barriers.
+	 */
+	if (pte_valid_not_user(pte)) {
+		dsb(ishst);
+		isb();
+	}
+}
+
+inline void iee_set_pte_at(struct mm_struct *mm, unsigned long addr,
+			      pte_t *ptep, pte_t pte)
+{
+	if (pte_present(pte) && pte_user_exec(pte) && !pte_special(pte))
+		__sync_icache_dcache(pte);
+
+	if (system_supports_mte() &&
+	    pte_present(pte) && pte_tagged(pte) && !pte_special(pte))
+		mte_sync_tags(ptep, pte);
+
+	__check_racy_pte_update(mm, ptep, pte);
+
+	iee_set_pte_pre_init(ptep, pte);
+}
+
+inline void iee_set_pte_at_delayed(struct mm_struct *mm, unsigned long addr,
+			      pte_t *ptep, pte_t pte)
+{
+	if (pte_present(pte) && pte_user_exec(pte) && !pte_special(pte))
+		__sync_icache_dcache(pte);
+
+	if (system_supports_mte() &&
+	    pte_present(pte) && pte_tagged(pte) && !pte_special(pte))
+		mte_sync_tags(ptep, pte);
+
+	__check_racy_pte_update(mm, ptep, pte);
+}
+
+inline bool in_tramp_pgdir(void *addr)
+{
+	return ((unsigned long)addr & PAGE_MASK) ==
+	        ((unsigned long)tramp_pg_dir & PAGE_MASK);
+}
+
+inline void iee_set_fixmap_pmd_pre_init(pmd_t *pmdp, pmd_t pmd)
+{
+#ifdef __PAGETABLE_PMD_FOLDED
+	if (in_swapper_pgdir(pmdp)) {
+		set_swapper_pgd((pgd_t *)pmdp, __pgd(pmd_val(pmd)));
+		return;
+	}
+#endif /* __PAGETABLE_PMD_FOLDED */
+	WRITE_ONCE(*pmdp, pmd);
+
+	if (pmd_valid(pmd)) {
+		dsb(ishst);
+		isb();
+	}
+}
+
+inline void iee_set_fixmap_pud_pre_init(pud_t *pudp, pud_t pud)
+{
+#ifdef __PAGETABLE_PUD_FOLDED
+	if (in_swapper_pgdir(pudp)) {
+		set_swapper_pgd((pgd_t *)pudp, __pgd(pud_val(pud)));
+		return;
+	}
+#endif /* __PAGETABLE_PUD_FOLDED */
+	WRITE_ONCE(*pudp, pud);
+
+	if (pud_valid(pud)) {
+		dsb(ishst);
+		isb();
+	}
+}
+
+#endif //#ifdef CONFIG_PTP
+
+inline void set_pte(pte_t *ptep, pte_t pte)
+{
+#ifdef CONFIG_KOI
+    if (pte_valid(pte)) {
+		pte = __pte(pte_val(pte) | PTE_NG);
+    }
+#endif
+#ifdef CONFIG_PTP
+	iee_rw_gate(IEE_OP_SET_PTE, ptep, pte);
+	dsb(ishst);
+	isb();
+#else
+	WRITE_ONCE(*ptep, pte);
+	if (pte_valid_not_user(pte)) {
+		dsb(ishst);
+		isb();
+	}
+#endif
+}
+
+inline void set_pmd(pmd_t *pmdp, pmd_t pmd)
+{
+#ifdef __PAGETABLE_PMD_FOLDED
+	if (in_swapper_pgdir(pmdp)) {
+		set_swapper_pgd((pgd_t *)pmdp, __pgd(pmd_val(pmd)));
+		return;
+	}
+#endif /* __PAGETABLE_PMD_FOLDED */
+#ifdef CONFIG_KOI
+    pmdval_t val = pmd_val(pmd);
+    if (pmd_valid(pmd) && !(val & PMD_TABLE_BIT)) {
+        pmd = __pmd(val | PMD_SECT_NG);
+    }
+#endif
+#ifdef CONFIG_PTP
+	iee_rw_gate(IEE_OP_SET_PMD, pmdp, pmd);
+#else
+	WRITE_ONCE(*pmdp, pmd);
+#endif
+	if (pmd_valid(pmd)) {
+		dsb(ishst);
+		isb();
+	}
+}
+
+inline void set_pud(pud_t *pudp, pud_t pud)
+{
+#ifdef __PAGETABLE_PUD_FOLDED
+	if (in_swapper_pgdir(pudp)) {
+		set_swapper_pgd((pgd_t *)pudp, __pgd(pud_val(pud)));
+		return;
+	}
+#endif /* __PAGETABLE_PUD_FOLDED */
+#ifdef CONFIG_KOI
+    pudval_t val = pud_val(pud);
+    if (pud_valid(pud) && !(val & PUD_TABLE_BIT)) {
+        // There is no PUD_SEC_NG, so we use PMD_SECT_NG instead.
+        pud = __pud(val | PMD_SECT_NG);
+    }
+#endif
+#ifdef CONFIG_PTP
+	iee_rw_gate(IEE_OP_SET_PUD, pudp, pud);
+#else
+	WRITE_ONCE(*pudp, pud);
+#endif
+	if (pud_valid(pud)) {
+		dsb(ishst);
+		isb();
+	}
+}
+
+inline void set_p4d(p4d_t *p4dp, p4d_t p4d)
+{
+	if (in_swapper_pgdir(p4dp))
+	{
+		set_swapper_pgd((pgd_t *)p4dp, __pgd(p4d_val(p4d)));
+		return;
+	}
+
+#ifdef CONFIG_PTP
+	if(in_tramp_pgdir(p4dp))
+	{
+		iee_set_tramp_pgd_pre_init((pgd_t *)p4dp, __pgd(p4d_val(p4d)));
+		return;
+	}
+	iee_rw_gate(IEE_OP_SET_P4D, p4dp, p4d);
+#else
+	WRITE_ONCE(*p4dp, p4d);
+#endif
+	dsb(ishst);
+	isb();
+}
+
+#ifdef CONFIG_IEE
+inline void iee_set_pte_upage(pte_t *ptep, int order, int use_block_pmd)
+{
+#ifdef CONFIG_PTP
+	iee_rw_gate(IEE_OP_SET_PTE_U, ptep, order, use_block_pmd);
+#else
+	int i;
+	if(use_block_pmd)
+	{
+		pmd_t *pmdp = (pmd_t *)ptep;
+		pmd_t pmd = READ_ONCE(*pmdp);
+		pmd = __pmd(pmd_val(pmd) | PMD_SECT_USER | PMD_SECT_NG);
+		WRITE_ONCE(*pmdp, pmd);
+	}
+	else
+	{
+		for(i = 0; i < (1 << order); i++)
+		{
+			pte_t pte = READ_ONCE(*ptep);
+			pte = __pte(pte_val(pte) | PTE_USER | PTE_NG);
+			WRITE_ONCE(*ptep, pte);
+			ptep++;
+		}
+	}
+#endif
+	dsb(ishst);
+	isb();
+}
+
+inline void iee_set_pte_ppage(pte_t *ptep, int order, int use_block_pmd)
+{
+#ifdef CONFIG_PTP
+	iee_rw_gate(IEE_OP_SET_PTE_P, ptep, order, use_block_pmd);
+#else
+	int i;
+	if(use_block_pmd)
+	{
+		pmd_t *pmdp = (pmd_t *)ptep;
+		pmd_t pmd = READ_ONCE(*pmdp);
+		pmd = __pmd(pmd_val(pmd) & ~PMD_SECT_USER & ~PMD_SECT_NG);
+		WRITE_ONCE(*pmdp, pmd);
+	}
+	else
+	{
+		for(i = 0; i < (1 << order); i++)
+		{
+			pte_t pte = READ_ONCE(*ptep);
+			pte = __pte(pte_val(pte) & ~PTE_USER & ~PTE_NG);
+			#ifdef CONFIG_KOI
+        	if (pte_valid(pte))
+            	pte = __pte(pte_val(pte) | PTE_NG);
+        	#endif
+			WRITE_ONCE(*ptep, pte);
+			ptep++;
+		}
+	}
+#endif
+	dsb(ishst);
+	isb();
+}
+
+inline void iee_set_sensitive_pte(pte_t *lm_ptep, pte_t *iee_ptep, int order, int use_block_pmd)
+{
+#ifdef CONFIG_PTP
+	iee_rw_gate(IEE_SET_SENSITIVE_PTE, lm_ptep, iee_ptep, order, use_block_pmd);
+#else
+	int i;
+	if(use_block_pmd)
+	{
+		pmd_t pmd = __pmd(pte_val(READ_ONCE(*lm_ptep)));
+		pmd = __pmd((pmd_val(pmd) | PMD_SECT_RDONLY) & ~PTE_DBM);
+		WRITE_ONCE(*lm_ptep, __pte(pmd_val(pmd)));
+		for(i = 0; i < (1 << order); i++)
+		{
+			pte_t pte = READ_ONCE(*iee_ptep);
+			pte = __pte(pte_val(pte) | PTE_VALID);
+			WRITE_ONCE(*iee_ptep, pte);
+			iee_ptep++;
+		}
+	}
+	else
+	{
+		for(i = 0; i < (1 << order); i++)
+		{
+			pte_t pte = READ_ONCE(*lm_ptep);
+			pte = __pte((pte_val(pte) | PTE_RDONLY) & ~PTE_DBM);
+			#ifdef CONFIG_KOI
+            if (pte_valid(pte))
+        		pte = __pte(pte_val(pte) | PTE_NG);
+    		#endif
+			WRITE_ONCE(*lm_ptep, pte);
+			pte = READ_ONCE(*iee_ptep);
+			pte = __pte(pte_val(pte) | PTE_VALID);
+			#ifdef CONFIG_KOI
+            if (pte_valid(pte))
+        		pte = __pte(pte_val(pte) | PTE_NG);
+    		#endif
+			WRITE_ONCE(*iee_ptep, pte);
+			lm_ptep++;
+			iee_ptep++;
+		}
+	}
+#endif
+	dsb(ishst);
+	isb();
+}
+
+inline void iee_unset_sensitive_pte(pte_t *lm_ptep, pte_t *iee_ptep, int order, int use_block_pmd)
+{
+#ifdef CONFIG_PTP
+	iee_rw_gate(IEE_UNSET_SENSITIVE_PTE, lm_ptep, iee_ptep, order, use_block_pmd);
+#else
+	int i;
+	if(use_block_pmd)
+	{
+		pmd_t pmd = __pmd(pte_val(READ_ONCE(*lm_ptep)));
+		pmd = __pmd(pmd_val(pmd) | PTE_DBM);
+		WRITE_ONCE(*lm_ptep, __pte(pmd_val(pmd)));
+		for(i = 0; i < (1 << order); i++)
+		{
+			pte_t pte = READ_ONCE(*iee_ptep);
+			pte = __pte(pte_val(pte) & ~PTE_VALID);
+			WRITE_ONCE(*iee_ptep, pte);
+			iee_ptep++;
+		}
+	}
+	else
+	{
+		for(i = 0; i < (1 << order); i++)
+		{
+			pte_t pte = READ_ONCE(*lm_ptep);
+			pte = __pte(pte_val(pte) | PTE_DBM);
+			WRITE_ONCE(*lm_ptep, pte);
+			pte = READ_ONCE(*iee_ptep);
+			pte = __pte(pte_val(pte) & ~PTE_VALID);
+			WRITE_ONCE(*iee_ptep, pte);
+			lm_ptep++;
+			iee_ptep++;
+		}
+	}
+#endif
+	dsb(ishst);
+	isb();
+}
+#endif //#ifdef CONFIG_IEE
diff --git a/arch/arm64/kernel/iee/iee.c b/arch/arm64/kernel/iee/iee.c
new file mode 100644
index 000000000000..b27b9451dd5d
--- /dev/null
+++ b/arch/arm64/kernel/iee/iee.c
@@ -0,0 +1,1427 @@
+#include "linux/sched.h"
+#include <stdarg.h>
+#include <asm/pgtable-types.h>
+#include <asm/iee.h>
+#include <asm/iee-si.h>
+#include <asm/sysreg.h>
+#include <linux/pgtable.h>
+#include <linux/cred.h>
+#include <asm/iee-slab.h>
+#include <asm/percpu.h>
+#include <linux/swap.h>
+#include <linux/swapops.h>
+#include <linux/iee-flag.h>
+#include <linux/mm.h>
+#ifdef CONFIG_IEE
+#include <linux/fs.h>
+#endif
+
+#ifdef CONFIG_CREDP
+#include <asm/iee-cred.h>
+#endif
+
+#define is_cow_mapping(flags) (((flags) & (VM_SHARED | VM_MAYWRITE)) == VM_MAYWRITE)
+
+#ifdef CONFIG_IEE
+extern struct cred init_cred;
+extern s64			memstart_addr;
+extern unsigned long highest_memmap_pfn;
+
+void __iee_code _iee_set_swapper_pgd(unsigned long iee_offset, pgd_t *pgdp, pgd_t pgd);
+void __iee_code _iee_set_tramp_pgd(unsigned long iee_offset, pgd_t *pgdp, pgd_t pgd);
+void __iee_code _iee_set_pte(unsigned long iee_offset, pte_t *ptep, pte_t pte);
+void __iee_code _iee_set_pmd(unsigned long iee_offset, pmd_t *pmdp, pmd_t pmd);
+void __iee_code _iee_set_pud(unsigned long iee_offset, pud_t *pudp, pud_t pud);
+void __iee_code _iee_set_p4d(unsigned long iee_offset, p4d_t *p4dp, p4d_t p4d);
+void __iee_code _iee_set_bm_pte(unsigned long iee_offset, pte_t *ptep, pte_t pte);
+void __iee_code _iee_write_in_byte(unsigned long iee_offset, void *ptr, __u64 data, int length);
+void __iee_code _iee_set_cred_uid(unsigned long iee_offset, struct cred *cred, kuid_t uid);
+void __iee_code _iee_set_cred_gid(unsigned long iee_offset, struct cred *cred, kgid_t gid);
+void __iee_code _iee_copy_cred(unsigned long iee_offset, struct cred *old, struct cred *new);
+void __iee_code _iee_set_cred_suid(unsigned long iee_offset, struct cred *cred, kuid_t suid);
+void __iee_code _iee_set_cred_sgid(unsigned long iee_offset, struct cred *cred, kgid_t sgid);
+void __iee_code _iee_set_cred_euid(unsigned long iee_offset, struct cred *cred, kuid_t euid);
+void __iee_code _iee_set_cred_egid(unsigned long iee_offset, struct cred *cred, kgid_t egid);
+void __iee_code _iee_set_cred_fsuid(unsigned long iee_offset, struct cred *cred, kuid_t fsuid);
+void __iee_code _iee_set_cred_fsgid(unsigned long iee_offset, struct cred *cred, kgid_t fsgid);
+void __iee_code _iee_set_cred_user(unsigned long iee_offset, struct cred *cred, struct user_struct *user);
+void __iee_code _iee_set_cred_user_ns(unsigned long iee_offset, struct cred *cred, struct user_namespace *user_ns);
+void __iee_code _iee_set_cred_group_info(unsigned long iee_offset, struct cred *cred, struct group_info *group_info);
+void __iee_code _iee_set_cred_securebits(unsigned long iee_offset, struct cred *cred, unsigned securebits);
+void __iee_code _iee_set_cred_cap_inheritable(unsigned long iee_offset, struct cred *cred, kernel_cap_t cap_inheritable);
+void __iee_code _iee_set_cred_cap_permitted(unsigned long iee_offset, struct cred *cred, kernel_cap_t cap_permitted);
+void __iee_code _iee_set_cred_cap_effective(unsigned long iee_offset, struct cred *cred, kernel_cap_t cap_effective);
+void __iee_code _iee_set_cred_cap_bset(unsigned long iee_offset, struct cred *cred, kernel_cap_t cap_bset);
+void __iee_code _iee_set_cred_cap_ambient(unsigned long iee_offset, struct cred *cred, kernel_cap_t cap_ambient);
+void __iee_code _iee_set_cred_jit_keyring(unsigned long iee_offset, struct cred *cred, unsigned char jit_keyring);
+void __iee_code _iee_set_cred_session_keyring(unsigned long iee_offset, struct cred *cred, struct key *session_keyring);
+void __iee_code _iee_set_cred_process_keyring(unsigned long iee_offset, struct cred *cred, struct key *process_keyring);
+void __iee_code _iee_set_cred_thread_keyring(unsigned long iee_offset, struct cred *cred, struct key *thread_keyring);
+void __iee_code _iee_set_cred_request_key_auth(unsigned long iee_offset, struct cred *cred, struct key *request_key_auth);
+void __iee_code _iee_set_cred_non_rcu(unsigned long iee_offset, struct cred *cred, int non_rcu);
+void __iee_code _iee_set_cred_atomic_set_usage(unsigned long iee_offset, struct cred *cred, int i);
+bool __iee_code _iee_set_cred_atomic_op_usage(unsigned long iee_offset, struct cred *cred, int flag);
+void __iee_code _iee_set_cred_security(unsigned long iee_offset, struct cred *cred, void *security);
+void __iee_code _iee_set_cred_rcu(unsigned long iee_offset, struct cred *cred, struct rcu_head *rcu);
+void __iee_code _iee_memset(unsigned long iee_offset, void *ptr, int data, size_t n);
+void __iee_code _iee_set_track(unsigned long iee_offset, struct track *ptr, struct track *data);
+void __iee_code _iee_set_freeptr(unsigned long iee_offset, void **pptr, void *ptr);
+void __iee_code _iee_set_pte_upage(unsigned long iee_offset, pte_t *ptep, int order, int use_block_pmd);
+void __iee_code _iee_set_pte_ppage(unsigned long iee_offset, pte_t *ptep, int order, int use_block_pmd);
+void __iee_code _iee_set_token_pgd(unsigned long iee_offset, struct task_struct *tsk, pgd_t *pgd);
+void __iee_code _iee_init_token(unsigned long iee_offset, struct task_struct *tsk, void *iee_stack, void *tmp_page);
+void __iee_code _iee_invalidate_token(unsigned long iee_offset, struct task_struct *tsk);
+void __iee_code _iee_validate_token(unsigned long iee_offset, struct task_struct *tsk);
+void __iee_code _iee_set_sensitive_pte(unsigned long iee_offset, pte_t *lm_ptep, pte_t *iee_ptep, int order, int use_block_pmd);
+void __iee_code _iee_unset_sensitive_pte(unsigned long iee_offset, pte_t *lm_ptep, pte_t *iee_ptep, int order, int use_block_pmd);
+void __iee_code _iee_set_token(unsigned long iee_offset, pte_t *ptep, void *new, unsigned long order, int use_block_pmd);
+void __iee_code _iee_unset_token(unsigned long iee_offset, pte_t *ptep, void *token_addr, void *token_page, unsigned long order);
+void __iee_code _iee_copy_pte_range(unsigned long iee_offset, pte_t *new_dst, pte_t *old_dst, pte_t *src_pte, struct vm_area_struct *src_vma, unsigned long dst_vm_flags, pte_t *end_pte);
+void __iee_code _iee_split_huge_pmd(unsigned long iee_offset, pmd_t *pmdp, pte_t *pgtable);
+#ifdef CONFIG_CREDP
+void __iee_code _iee_commit_cred(unsigned long iee_offset, struct cred *new);
+void __iee_code _iee_copy_cred_kernel(unsigned long iee_offset, struct cred *old, struct cred *new);
+#endif
+#ifdef CONFIG_KOI
+unsigned long __iee_code _iee_read_koi_stack(unsigned long iee_offset, struct task_struct *tsk);
+void __iee_code _iee_write_koi_stack(unsigned long iee_offset, struct task_struct *tsk, unsigned long koi_stack); 
+unsigned long __iee_code _iee_read_token_ttbr1(unsigned long iee_offset, struct task_struct *tsk);
+void __iee_code _iee_write_token_ttbr1(unsigned long iee_offset, struct task_struct *tsk, unsigned long current_ttbr1);
+unsigned long __iee_code _iee_read_koi_kernel_stack(unsigned long iee_offset, struct task_struct *tsk);
+void __iee_code _iee_write_koi_kernel_stack(unsigned long iee_offset, struct task_struct *tsk, unsigned long kernel_stack);
+unsigned long __iee_code _iee_read_koi_stack_base(unsigned long iee_offset, struct task_struct *tsk);
+void __iee_code _iee_write_koi_stack_base(unsigned long iee_offset, struct task_struct *tsk, unsigned long koi_stack_base);
+void __iee_code _iee_set_koi_pgd(unsigned long iee_offset, unsigned long koi_pgd_addr);
+#endif
+
+static void inline _iee_set_pte_single(pte_t *ptep, pte_t pte, unsigned long iee_offset);
+static pteval_t inline _iee_set_cmpxchg_relaxed(pte_t *ptep, pteval_t old_pteval, pteval_t new_pteval, unsigned long iee_offset);
+
+// Define the function pointer type for wrapper functions.
+// Each function pointer conforms to a standardized calling convention
+// using a variable argument list (va_list) as its parameter. 
+// This allows dynamic invocation of different functions with various arguments.
+
+typedef void (*iee_func)(void);
+iee_func iee_funcs[] = {
+    (iee_func)_iee_write_in_byte,
+    (iee_func)_iee_set_pte,
+    (iee_func)_iee_set_pmd,
+	(iee_func)_iee_set_pud,
+    (iee_func)_iee_set_p4d,
+    (iee_func)_iee_set_bm_pte,
+    (iee_func)_iee_set_swapper_pgd,
+    (iee_func)_iee_set_tramp_pgd,
+	(iee_func)_iee_copy_cred,
+    (iee_func)_iee_set_cred_uid,
+    (iee_func)_iee_set_cred_gid,
+    (iee_func)_iee_set_cred_suid,
+    (iee_func)_iee_set_cred_sgid,
+    (iee_func)_iee_set_cred_euid,
+    (iee_func)_iee_set_cred_egid,
+    (iee_func)_iee_set_cred_fsuid,
+    (iee_func)_iee_set_cred_fsgid,
+    (iee_func)_iee_set_cred_user,
+    (iee_func)_iee_set_cred_user_ns,
+    (iee_func)_iee_set_cred_group_info,
+    (iee_func)_iee_set_cred_securebits,
+    (iee_func)_iee_set_cred_cap_inheritable,
+    (iee_func)_iee_set_cred_cap_permitted,
+    (iee_func)_iee_set_cred_cap_effective,
+    (iee_func)_iee_set_cred_cap_bset,
+    (iee_func)_iee_set_cred_cap_ambient,
+    (iee_func)_iee_set_cred_jit_keyring,
+    (iee_func)_iee_set_cred_session_keyring,
+    (iee_func)_iee_set_cred_process_keyring,
+    (iee_func)_iee_set_cred_thread_keyring,
+    (iee_func)_iee_set_cred_request_key_auth,
+    (iee_func)_iee_set_cred_non_rcu,
+    (iee_func)_iee_set_cred_atomic_set_usage,
+    (iee_func)_iee_set_cred_atomic_op_usage,
+    (iee_func)_iee_set_cred_security,
+    (iee_func)_iee_set_cred_rcu,
+    (iee_func)_iee_memset,
+    (iee_func)_iee_set_track,
+    (iee_func)_iee_set_freeptr,
+	(iee_func)_iee_set_pte_upage,
+	(iee_func)_iee_set_pte_ppage,
+	(iee_func)_iee_set_token_pgd,
+	(iee_func)_iee_init_token,
+	(iee_func)_iee_invalidate_token,
+	(iee_func)_iee_set_sensitive_pte,
+	(iee_func)_iee_unset_sensitive_pte,
+	(iee_func)_iee_set_token,
+	(iee_func)_iee_unset_token,
+	(iee_func)_iee_copy_pte_range,
+	(iee_func)_iee_split_huge_pmd,
+	(iee_func)_iee_validate_token,
+#ifdef CONFIG_KOI
+    (iee_func)_iee_read_koi_stack,
+    (iee_func)_iee_write_koi_stack,
+    (iee_func)_iee_read_token_ttbr1,
+    (iee_func)_iee_write_token_ttbr1,
+    (iee_func)_iee_read_koi_kernel_stack,
+    (iee_func)_iee_write_koi_kernel_stack,
+    (iee_func)_iee_read_koi_stack_base,
+    (iee_func)_iee_write_koi_stack_base,
+	(iee_func)_iee_set_koi_pgd,
+#endif
+#ifdef CONFIG_CREDP
+    (iee_func)_iee_commit_cred,
+    (iee_func)_iee_copy_cred_kernel,
+#endif
+    NULL
+};
+
+#ifdef CONFIG_KOI
+unsigned long __iee_code _iee_read_koi_stack(unsigned long iee_offset, struct task_struct *tsk) 
+{
+    struct task_token *token = (struct task_token *)__phys_to_iee(__pa(tsk));
+    return (unsigned long)token->koi_stack;
+}
+
+void __iee_code _iee_write_koi_stack(unsigned long iee_offset, struct task_struct *tsk, unsigned long koi_stack) 
+{
+    struct task_token *token = (struct task_token *)__phys_to_iee(__pa(tsk));
+    token->koi_stack = (void *)koi_stack;
+}
+
+unsigned long __iee_code _iee_read_token_ttbr1(unsigned long iee_offset, struct task_struct *tsk)
+{
+    struct task_token *token = (struct task_token *)__phys_to_iee(__pa(tsk));
+    return token->current_ttbr1;
+}
+
+void __iee_code _iee_write_token_ttbr1(unsigned long iee_offset, struct task_struct *tsk, unsigned long current_ttbr1)
+{
+    struct task_token *token = (struct task_token *)__phys_to_iee(__pa(tsk));
+    token->current_ttbr1 = current_ttbr1;
+}
+
+unsigned long __iee_code _iee_read_koi_kernel_stack(unsigned long iee_offset, struct task_struct *tsk)
+{
+    struct task_token *token = (struct task_token *)__phys_to_iee(__pa(tsk));
+    return (unsigned long)token->koi_kernel_stack;
+}
+
+void __iee_code _iee_write_koi_kernel_stack(unsigned long iee_offset, struct task_struct *tsk, unsigned long kernel_stack) 
+{
+    struct task_token *token = (struct task_token *)__phys_to_iee(__pa(tsk));
+    token->koi_kernel_stack = (void *)kernel_stack;
+}
+
+unsigned long __iee_code _iee_read_koi_stack_base(unsigned long iee_offset, struct task_struct *tsk) 
+{
+    struct task_token *token = (struct task_token *)__phys_to_iee(__pa(tsk));
+    return (unsigned long)token->koi_stack_base;
+}
+
+void __iee_code _iee_write_koi_stack_base(unsigned long iee_offset, struct task_struct *tsk, unsigned long koi_stack_base) 
+{
+    struct task_token *token = (struct task_token *)__phys_to_iee(__pa(tsk));
+    token->koi_stack_base = (void *)koi_stack_base;
+}
+
+static inline void iee_set_koi_pgd_writeable(unsigned long koi_pgd_addr, unsigned long iee_si_addr)
+{
+	pgd_t *pgdir = (pgd_t *)koi_pgd_addr;
+	pgd_t *pgdp = pgd_offset_pgd(pgdir, iee_si_addr);
+	p4d_t *p4dp = p4d_offset(pgdp, iee_si_addr);
+	pud_t *pudp = pud_offset(p4dp, iee_si_addr);
+	pmd_t *pmdp = pmd_offset(pudp, iee_si_addr);
+	pte_t *ptep = pte_offset_kernel(pmdp, iee_si_addr);
+    pte_t pte = READ_ONCE(*ptep);
+	pte = __pte(pte_val(pte) | PTE_DBM);
+	WRITE_ONCE(*((pte_t *)(__phys_to_iee(__pa(ptep)))), pte);
+}
+/*
+ * Set IEE SI codes U RWX here to avoid IEE DEP checking fault. 
+ * Mark koi pgd in the same time.
+ */
+void __iee_code _iee_set_koi_pgd(unsigned long iee_offset, unsigned long koi_pgd_addr)
+{
+	// IEE SI codes are 2 pages starting at __iee_si_start.
+	unsigned long iee_si_addr = (unsigned long)__iee_si_start;
+	iee_set_koi_pgd_writeable(koi_pgd_addr, iee_si_addr);
+	iee_si_addr += PAGE_SIZE;
+	iee_set_koi_pgd_writeable(koi_pgd_addr, iee_si_addr);
+	// Use DBM=0, AP[7]=0 to mark this page as a koi pgd in IEE.
+}
+#endif
+
+void __iee_code _iee_split_huge_pmd(unsigned long iee_offset, pmd_t *pmdp, pte_t *pgtable)
+{
+	int i;
+	struct page *page = pmd_page(*pmdp);
+	pte_t *ptep = (pte_t *)((unsigned long)pgtable + (unsigned long)iee_offset);
+
+	if(pmd_val(*pmdp) & PMD_TABLE_BIT)
+		panic("Error: split a pgtable which is not a huge one.\n");
+
+	for (i = 0; i < PMD_SIZE / PAGE_SIZE; i++, ptep++) {
+		pte_t entry;
+		pgprot_t pgprot = PAGE_KERNEL;
+		pgprot = __pgprot(pgprot_val(pgprot) | PTE_CONT);
+
+		entry = mk_pte(page + i, pgprot);
+		WRITE_ONCE(*ptep, entry);
+	}
+}
+
+void __iee_code _iee_copy_pte_range(unsigned long iee_offset, pte_t *new_dst, pte_t *old_dst, pte_t *src_pte, struct vm_area_struct *src_vma, unsigned long dst_vm_flags, pte_t *end_pte)
+{
+	pte_t pte, tmp;
+	swp_entry_t entry;
+	tmp = __pte(0);
+	while(src_pte < end_pte)
+	{
+		if (!pte_none(*src_pte) && unlikely(!pte_present(*src_pte)))
+		{
+			pte = *src_pte;
+			entry = pte_to_swp_entry(pte);
+			if (likely(!non_swap_entry(entry)))
+				;
+			else if(is_migration_entry(entry))
+			{
+				if (is_write_migration_entry(entry) &&
+				is_cow_mapping(dst_vm_flags))
+				{
+					make_migration_entry_read(&entry);
+					pte = swp_entry_to_pte(entry);
+					if (pte_swp_soft_dirty(*src_pte))
+						pte = pte_swp_mksoft_dirty(pte);
+					if (pte_swp_uffd_wp(*src_pte))
+						pte = pte_swp_mkuffd_wp(pte);
+					_iee_set_pte_single(src_pte, pte, iee_offset);
+				}
+			}
+			else
+			{
+				if (is_write_device_private_entry(entry) &&
+		    		is_cow_mapping(dst_vm_flags)) {
+					make_device_private_entry_read(&entry);
+					pte = swp_entry_to_pte(entry);
+					if (pte_swp_uffd_wp(*src_pte))
+						pte = pte_swp_mkuffd_wp(pte);
+					_iee_set_pte_single(src_pte, pte, iee_offset);
+				}
+			}
+		}
+		else if(!pte_none(*src_pte) && likely(pte_present(*src_pte)))
+		{
+			struct page *page = NULL;
+			#ifdef CONFIG_ARCH_HAS_PTE_SPECIAL
+			if (likely(!pte_special(*src_pte)))
+			{
+				if (unlikely(pte_pfn(*src_pte) > highest_memmap_pfn))
+					page = NULL;
+				else
+					page = pte_page(*src_pte);
+			}
+			#else
+			if((!unlikely(src_vma->vm_flags & (VM_PFNMAP|VM_MIXEDMAP)) || ((src_vma->vm_flags & VM_MIXEDMAP) && pfn_valid(pte_pfn(*src_pte))) || (!(src_vma->vm_flags & VM_MIXEDMAP) && !(pfn == src_vma->vm_pgoff + off) && is_cow_mapping(src_vma->vm_flags))) && !is_zero_pfn(pte_pfn(*src_pte)) && !unlikely(pte_pfn(*src_pte) > highest_memmap_pfn))
+				page = pte_page(*src_pte);
+			#endif
+			if(!(page) || (likely(!atomic_read(&(src_vma->vm_mm)->has_pinned))) || (likely(!page_maybe_dma_pinned(page))) || (!PageAnon(page)))
+			{
+				if (is_cow_mapping(src_vma->vm_flags) && pte_write(*src_pte))
+				{
+					pte_t old_pte, new_pte;
+
+					new_pte = READ_ONCE(*src_pte);
+					do {
+						old_pte = new_pte;
+						new_pte = pte_wrprotect(new_pte);
+						#ifdef CONFIG_KOI
+                        if (pte_valid(old_pte))
+                            old_pte = __pte(pte_val(old_pte) | PTE_NG);
+                        if (pte_valid(new_pte)) 
+                            new_pte = __pte(pte_val(new_pte) | PTE_NG);
+                        #endif
+						_iee_set_cmpxchg_relaxed(src_pte, pte_val(old_pte), pte_val(new_pte), iee_offset);
+					} while (pte_val(new_pte) != pte_val(old_pte));
+				}
+			}
+		}
+		if(!pte_none(*new_dst))
+		{
+			_iee_set_pte_single(old_dst, *new_dst, iee_offset);
+			WRITE_ONCE(*new_dst, __pte(0));
+		}
+		old_dst++;
+		src_pte++;
+		new_dst++;
+	}
+}
+
+void __iee_code _iee_set_sensitive_pte(unsigned long iee_offset, pte_t *lm_ptep, pte_t *iee_ptep, int order, int use_block_pmd)
+{
+	int i;
+
+	lm_ptep = (pte_t *)((unsigned long)lm_ptep + iee_offset);
+	iee_ptep = (pte_t *)((unsigned long)iee_ptep + iee_offset);
+	if(use_block_pmd)
+	{
+		pmd_t pmd = __pmd(pte_val(READ_ONCE(*lm_ptep)));
+		pmd = __pmd((pmd_val(pmd) | PMD_SECT_RDONLY) & ~PTE_DBM);
+		WRITE_ONCE(*lm_ptep, __pte(pmd_val(pmd)));
+		for(i = 0; i < (1 << order); i++)
+		{
+			pte_t pte = READ_ONCE(*iee_ptep);
+			pte = __pte(pte_val(pte) | PTE_VALID);
+			WRITE_ONCE(*iee_ptep, pte);
+			iee_ptep++;
+		}
+	}
+	else
+	{
+		for(i = 0; i < (1 << order); i++)
+		{
+			pte_t pte = READ_ONCE(*lm_ptep);
+			pte = __pte((pte_val(pte) | PTE_RDONLY) & ~PTE_DBM);
+			WRITE_ONCE(*lm_ptep, pte);
+			pte = READ_ONCE(*iee_ptep);
+			pte = __pte(pte_val(pte) | PTE_VALID);
+			WRITE_ONCE(*iee_ptep, pte);
+			lm_ptep++;
+			iee_ptep++;
+		}
+	}
+}
+
+void __iee_code _iee_unset_sensitive_pte(unsigned long iee_offset, pte_t *lm_ptep, pte_t *iee_ptep, int order, int use_block_pmd)
+{
+	int i;
+
+	lm_ptep = (pte_t *)((unsigned long)lm_ptep + iee_offset);
+	iee_ptep = (pte_t *)((unsigned long)iee_ptep + iee_offset);
+	if(use_block_pmd)
+	{
+		pmd_t pmd = __pmd(pte_val(READ_ONCE(*lm_ptep)));
+		pmd = __pmd(pmd_val(pmd) | PTE_DBM);
+		WRITE_ONCE(*lm_ptep, __pte(pmd_val(pmd)));
+		for(i = 0; i < (1 << order); i++)
+		{
+			pte_t pte = READ_ONCE(*iee_ptep);
+			pte = __pte(pte_val(pte) & ~PTE_VALID);
+			WRITE_ONCE(*iee_ptep, pte);
+			iee_ptep++;
+		}
+	}
+	else
+	{
+		for(i = 0; i < (1 << order); i++)
+		{
+			pte_t pte = READ_ONCE(*lm_ptep);
+			pte = __pte(pte_val(pte) | PTE_DBM);
+			WRITE_ONCE(*lm_ptep, pte);
+			pte = READ_ONCE(*iee_ptep);
+			pte = __pte(pte_val(pte) & ~PTE_VALID);
+			WRITE_ONCE(*iee_ptep, pte);
+			lm_ptep++;
+			iee_ptep++;
+		}
+	}
+}
+
+void __iee_code _iee_set_token(unsigned long iee_offset, pte_t *ptep, void *new, unsigned long order, int use_block_pmd)
+{
+	int i;
+	pgd_t *pgdir;
+	pgd_t *pgdp;
+	p4d_t *p4dp;
+	pud_t *pudp;
+	pmd_t *pmdp;
+	pte_t *lm_ptep;
+	pte_t *iee_ptep;
+	unsigned long iee_addr;
+
+	pgdir = swapper_pg_dir;
+
+	pgdp = pgd_offset_pgd(pgdir, (unsigned long)new);
+	p4dp = p4d_offset(pgdp, (unsigned long)new);
+	pudp = pud_offset(p4dp, (unsigned long)new);
+	pmdp = pmd_offset(pudp, (unsigned long)new);
+	if(use_block_pmd)
+		lm_ptep = (pte_t *)pmdp;
+	else
+		lm_ptep = pte_offset_kernel(pmdp, (unsigned long)new);
+	// Handling cont mapping.
+	if(pte_val(*lm_ptep) & PTE_CONT)
+	{
+		// The beginning of cont mapping.
+		int i;
+		pte_t *ptep = (pte_t *)((unsigned long)pte_offset_kernel(pmdp, (unsigned long)new & CONT_PTE_MASK) + iee_offset);
+		if(order < CONFIG_ARM64_CONT_PTE_SHIFT)
+		{
+			for(i = 0; i < CONT_PTES; i++)
+			{
+				WRITE_ONCE(*ptep,__pte(pte_val(*ptep) & ~PTE_CONT));
+				ptep++;
+			}
+		}
+	}
+	
+	iee_addr = ((unsigned long)new + (unsigned long)iee_offset);
+	pgdp = pgd_offset_pgd(pgdir, iee_addr);
+	p4dp = p4d_offset(pgdp, iee_addr);
+	pudp = pud_offset(p4dp, iee_addr);
+	pmdp = pmd_offset(pudp, iee_addr);
+	iee_ptep = pte_offset_kernel(pmdp, iee_addr);
+
+	ptep = (pte_t *)((unsigned long)ptep + iee_offset);
+	lm_ptep = (pte_t *)((unsigned long)lm_ptep + iee_offset);
+	iee_ptep = (pte_t *)((unsigned long)iee_ptep + iee_offset);
+	if(use_block_pmd)
+	{
+		pmd_t *pmdp = (pmd_t *)lm_ptep;
+		pmd_t pmd = READ_ONCE(*pmdp);
+		pmd = __pmd((pmd_val(pmd) | PMD_SECT_RDONLY) & ~PTE_DBM);
+		WRITE_ONCE(*pmdp, pmd);
+		for(i = 0; i < (0x1 << order); i++)
+		{
+			pte_t pte = READ_ONCE(*ptep);
+			pte = __pte(((pte_val(pte) | PTE_VALID) & ~PTE_ADDR_MASK) | __phys_to_pte_val(__pa(new)));
+			WRITE_ONCE(*ptep, pte);
+			pte = READ_ONCE(*iee_ptep);
+			pte = __pte(pte_val(pte) | PTE_VALID);
+			WRITE_ONCE(*iee_ptep, pte);
+			ptep++;
+			iee_ptep++;
+			new += PAGE_SIZE;
+		}
+	}
+	else
+	{
+		for(i = 0; i < (0x1 << order); i++)
+		{
+			pte_t pte = READ_ONCE(*ptep);
+			pte = __pte(((pte_val(pte) | PTE_VALID) & ~PTE_ADDR_MASK) | __phys_to_pte_val(__pa(new)));
+			WRITE_ONCE(*ptep, pte);
+			pte = READ_ONCE(*lm_ptep);
+			pte = __pte((pte_val(pte) | PTE_RDONLY) & ~PTE_DBM);
+			WRITE_ONCE(*lm_ptep, pte);
+			pte = READ_ONCE(*iee_ptep);
+			pte = __pte(pte_val(pte) | PTE_VALID);
+			WRITE_ONCE(*iee_ptep, pte);
+			ptep++;
+			lm_ptep++;
+			iee_ptep++;
+			new += PAGE_SIZE;
+		}
+	}
+}
+
+void __iee_code _iee_unset_token(unsigned long iee_offset, pte_t *ptep, void *token_addr, void *token_page, unsigned long order)
+{
+	int i;
+	pgd_t *pgdir;
+	pgd_t *pgdp;
+	p4d_t *p4dp;
+	pud_t *pudp;
+	pmd_t *pmdp;
+	pte_t *lm_ptep;
+	pte_t *iee_ptep;
+	unsigned long iee_addr;
+	int use_block_pmd = 0;
+
+	pgdir = swapper_pg_dir;
+
+	pgdp = pgd_offset_pgd(pgdir, (unsigned long)token_page);
+	p4dp = p4d_offset(pgdp, (unsigned long)token_page);
+	pudp = pud_offset(p4dp, (unsigned long)token_page);
+	pmdp = pmd_offset(pudp, (unsigned long)token_page);
+	// Use Block Descriptor.
+	if(pmd_leaf(*pmdp))
+	{
+		use_block_pmd = 1;
+		lm_ptep = (pte_t *)pmdp;
+	}
+	else
+		lm_ptep = pte_offset_kernel(pmdp, (unsigned long)token_page);
+	
+	iee_addr = ((unsigned long)token_page + (unsigned long)iee_offset);
+	pgdp = pgd_offset_pgd(pgdir, iee_addr);
+	p4dp = p4d_offset(pgdp, iee_addr);
+	pudp = pud_offset(p4dp, iee_addr);
+	pmdp = pmd_offset(pudp, iee_addr);
+	iee_ptep = pte_offset_kernel(pmdp, iee_addr);
+
+	ptep = (pte_t *)((unsigned long)ptep + iee_offset);
+	lm_ptep = (pte_t *)((unsigned long)lm_ptep + iee_offset);
+	iee_ptep = (pte_t *)((unsigned long)iee_ptep + iee_offset);
+	if(use_block_pmd)
+	{
+		pmd_t *pmdp = (pmd_t *)lm_ptep;
+		pmd_t pmd = READ_ONCE(*pmdp);
+		pmd = __pmd(pmd_val(pmd) | PTE_DBM);
+		WRITE_ONCE(*pmdp, pmd);
+		for(i = 0; i < (0x1 << order); i++)
+		{
+			pte_t pte = READ_ONCE(*ptep);
+			pte = __pte(((pte_val(pte) & ~PTE_VALID) & ~PTE_ADDR_MASK) | __phys_to_pte_val(__pa(token_addr - IEE_OFFSET)));
+			WRITE_ONCE(*ptep, pte);
+			pte = READ_ONCE(*iee_ptep);
+			pte = __pte(pte_val(pte) & ~PTE_VALID);
+			WRITE_ONCE(*iee_ptep, pte);
+			ptep++;
+			iee_ptep++;
+			token_addr += PAGE_SIZE;
+			token_page += PAGE_SIZE;
+		}
+	}
+	else
+	{
+		for(i = 0; i < (0x1 << order); i++)
+		{
+			pte_t pte = READ_ONCE(*ptep);
+			pte = __pte(((pte_val(pte) & ~PTE_VALID) & ~PTE_ADDR_MASK) | __phys_to_pte_val(__pa(token_addr - IEE_OFFSET)));
+			WRITE_ONCE(*ptep, pte);
+			pte = READ_ONCE(*lm_ptep);
+			pte = __pte(pte_val(pte) | PTE_DBM);
+			WRITE_ONCE(*lm_ptep, pte);
+			pte = READ_ONCE(*iee_ptep);
+			pte = __pte(pte_val(pte) & ~PTE_VALID);
+			WRITE_ONCE(*iee_ptep, pte);
+			ptep++;
+			lm_ptep++;
+			iee_ptep++;
+			token_addr += PAGE_SIZE;
+			token_page += PAGE_SIZE;
+		}
+	}
+}
+
+void __iee_code _iee_invalidate_token(unsigned long iee_offset, struct task_struct *tsk)
+{
+	struct task_token *token = (struct task_token *)((unsigned long)tsk + (unsigned long)iee_offset);
+	token->pgd = NULL;
+	token->valid = false;
+	token->kernel_stack = NULL;
+#ifdef CONFIG_KOI
+    token->koi_kernel_stack = NULL;
+    token->koi_stack = NULL;
+    token->koi_stack_base = NULL;
+    token->current_ttbr1 = 0;
+#endif
+}
+
+void __iee_code _iee_validate_token(unsigned long iee_offset, struct task_struct *tsk)
+{
+	struct task_token *token = (struct task_token *)((unsigned long)tsk + (unsigned long)iee_offset);
+	token->valid = true;
+}
+
+#ifdef CONFIG_KOI
+extern unsigned long koi_swapper_ttbr1;
+#endif
+void __iee_code _iee_init_token(unsigned long iee_offset, struct task_struct *tsk, void *iee_stack, void *tmp_page)
+{
+	struct task_token *token;
+
+	token = (struct task_token *)((unsigned long)tsk + (unsigned long)iee_offset);
+	token->iee_stack = iee_stack;
+	token->tmp_page = tmp_page;
+#ifdef CONFIG_KOI
+    token->koi_kernel_stack = NULL;
+    token->koi_stack = NULL;
+    token->koi_stack_base = NULL;
+    token->current_ttbr1 = 0;
+#endif
+}
+
+void __iee_code _iee_set_token_pgd(unsigned long iee_offset, struct task_struct *tsk, pgd_t *pgd)
+{
+	struct task_token *token;
+
+	token = (struct task_token *)((unsigned long)tsk + (unsigned long)iee_offset);
+	token->pgd = pgd;
+}
+
+void __iee_code _iee_set_freeptr(unsigned long iee_offset, void **pptr, void *ptr)
+{
+	pptr = (void **)((unsigned long)pptr + (unsigned long)iee_offset);
+	*pptr = ptr;
+}
+
+#pragma GCC push_options
+#pragma GCC optimize("O0")
+void __iee_code _iee_memset(unsigned long iee_offset, void *ptr, int data, size_t n)
+{
+	char *_ptr;
+
+	_ptr = (char *)((unsigned long)ptr + (unsigned long)iee_offset);
+
+	while (n--)
+		*_ptr++ = data;
+}
+
+void __iee_code _iee_memcpy(unsigned long iee_offset, void *dst, void *src, size_t n)
+{
+	char *_dst, *_src;
+
+	_dst = (char *)((unsigned long)dst + (unsigned long)iee_offset);
+	_src = (char *)src;
+
+	while(n--)
+		*_dst++ = *_src++;
+}
+#pragma GCC pop_options
+
+void __iee_code _iee_set_track(unsigned long iee_offset, struct track *ptr, struct track *data)
+{
+	_iee_memcpy(iee_offset, ptr, data, sizeof(struct track));
+}
+
+void __iee_code _iee_set_cred_rcu(unsigned long iee_offset, struct cred *cred, struct rcu_head *rcu)
+{
+	if(cred == &init_cred)
+		cred = (struct cred *)__phys_to_iee(__pa_symbol(cred));
+	else
+		cred = (struct cred *)((unsigned long)cred + (unsigned long)iee_offset);
+	#ifdef CONFIG_CREDP
+	*((struct rcu_head **)(&(cred->rcu.func))) = rcu;
+	#endif
+}
+
+void __iee_code _iee_set_cred_security(unsigned long iee_offset, struct cred *cred, void *security)
+{
+	if(cred == &init_cred)
+		cred = (struct cred *)__phys_to_iee(__pa_symbol(cred));
+	else
+		cred = (struct cred *)((unsigned long)cred + (unsigned long)iee_offset);
+	cred->security = security;
+}
+
+bool __iee_code _iee_set_cred_atomic_op_usage(unsigned long iee_offset, struct cred *cred, int flag)
+{
+	cred = (struct cred *)__phys_to_iee(__pa(cred));
+	switch (flag)
+	{
+	case AT_INC: {
+		atomic_inc(&cred->usage);
+		return 0;
+	}
+	case AT_INC_NOT_ZERO: {
+		return atomic_inc_not_zero(&cred->usage);
+	}
+	case AT_DEC_AND_TEST: {
+		return atomic_dec_and_test(&cred->usage);
+	}
+	}
+	return 0;
+}
+
+void __iee_code _iee_set_cred_atomic_set_usage(unsigned long iee_offset, struct cred *cred, int i)
+{
+	cred = (struct cred *)__phys_to_iee(__pa(cred));
+	atomic_set(&cred->usage,i);
+}
+
+void __iee_code _iee_set_cred_non_rcu(unsigned long iee_offset, struct cred *cred, int non_rcu)
+{
+	cred = (struct cred *)__phys_to_iee(__pa(cred));
+	cred->non_rcu = non_rcu;
+}
+
+void __iee_code _iee_set_cred_session_keyring(unsigned long iee_offset, struct cred *cred, struct key *session_keyring)
+{
+	cred = (struct cred *)__phys_to_iee(__pa(cred));
+	cred->session_keyring = session_keyring;
+}
+
+void __iee_code _iee_set_cred_process_keyring(unsigned long iee_offset, struct cred *cred, struct key *process_keyring)
+{
+	cred = (struct cred *)__phys_to_iee(__pa(cred));
+	cred->process_keyring = process_keyring;
+}
+
+void __iee_code _iee_set_cred_thread_keyring(unsigned long iee_offset, struct cred *cred, struct key *thread_keyring)
+{
+	cred = (struct cred *)__phys_to_iee(__pa(cred));
+	cred->thread_keyring = thread_keyring;
+}
+
+void __iee_code _iee_set_cred_request_key_auth(unsigned long iee_offset, struct cred *cred, struct key *request_key_auth)
+{
+	cred = (struct cred *)__phys_to_iee(__pa(cred));
+	cred->request_key_auth = request_key_auth;
+}
+
+void __iee_code _iee_set_cred_jit_keyring(unsigned long iee_offset, struct cred *cred, unsigned char jit_keyring)
+{
+	cred = (struct cred *)__phys_to_iee(__pa(cred));
+	cred->jit_keyring = jit_keyring;
+}
+
+void __iee_code _iee_set_cred_cap_inheritable(unsigned long iee_offset, struct cred *cred, kernel_cap_t cap_inheritable)
+{
+	cred = (struct cred *)__phys_to_iee(__pa(cred));
+	cred->cap_inheritable = cap_inheritable;
+}
+
+void __iee_code _iee_set_cred_cap_permitted(unsigned long iee_offset, struct cred *cred, kernel_cap_t cap_permitted)
+{
+	cred = (struct cred *)__phys_to_iee(__pa(cred));
+	cred->cap_permitted = cap_permitted;
+}
+
+void __iee_code _iee_set_cred_cap_effective(unsigned long iee_offset, struct cred *cred, kernel_cap_t cap_effective)
+{
+	cred = (struct cred *)__phys_to_iee(__pa(cred));
+	cred->cap_effective = cap_effective;
+}
+
+void __iee_code _iee_set_cred_cap_bset(unsigned long iee_offset, struct cred *cred, kernel_cap_t cap_bset)
+{
+	cred = (struct cred *)__phys_to_iee(__pa(cred));
+	cred->cap_bset = cap_bset;
+}
+
+void __iee_code _iee_set_cred_cap_ambient(unsigned long iee_offset, struct cred *cred, kernel_cap_t cap_ambient)
+{
+	cred = (struct cred *)__phys_to_iee(__pa(cred));
+	cred->cap_ambient = cap_ambient;
+}
+
+void __iee_code _iee_set_cred_securebits(unsigned long iee_offset, struct cred *cred, unsigned securebits)
+{
+	cred = (struct cred *)__phys_to_iee(__pa(cred));
+	cred->securebits = securebits;
+}
+
+void __iee_code _iee_set_cred_group_info(unsigned long iee_offset, struct cred *cred, struct group_info *group_info)
+{
+	cred = (struct cred *)__phys_to_iee(__pa(cred));
+	cred->group_info = group_info;
+}
+
+void __iee_code _iee_set_cred_user_ns(unsigned long iee_offset, struct cred *cred, struct user_namespace *user_ns)
+{
+	cred = (struct cred *)__phys_to_iee(__pa(cred));
+	cred->user_ns = user_ns;
+}
+
+void __iee_code _iee_set_cred_user(unsigned long iee_offset, struct cred *cred, struct user_struct *user)
+{
+	cred = (struct cred *)__phys_to_iee(__pa(cred));
+	cred->user = user;
+}
+
+void __iee_code _iee_set_cred_fsgid(unsigned long iee_offset, struct cred *cred, kgid_t fsgid)
+{
+	cred = (struct cred *)__phys_to_iee(__pa(cred));
+	cred->fsgid = fsgid;
+}
+
+void __iee_code _iee_set_cred_fsuid(unsigned long iee_offset, struct cred *cred, kuid_t fsuid)
+{
+	cred = (struct cred *)__phys_to_iee(__pa(cred));
+	cred->fsuid = fsuid;
+}
+
+void __iee_code _iee_set_cred_egid(unsigned long iee_offset, struct cred *cred, kgid_t egid)
+{
+	cred = (struct cred *)__phys_to_iee(__pa(cred));
+	cred->egid = egid;
+}
+
+void __iee_code _iee_set_cred_euid(unsigned long iee_offset, struct cred *cred, kuid_t euid)
+{
+	cred = (struct cred *)__phys_to_iee(__pa(cred));
+	cred->euid = euid;
+}
+
+void __iee_code _iee_set_cred_sgid(unsigned long iee_offset, struct cred *cred, kgid_t sgid)
+{
+	cred = (struct cred *)__phys_to_iee(__pa(cred));
+	cred->sgid = sgid;
+}
+
+void __iee_code _iee_set_cred_suid(unsigned long iee_offset, struct cred *cred, kuid_t suid)
+{
+	cred = (struct cred *)__phys_to_iee(__pa(cred));
+	cred->suid = suid;
+}
+
+/* Only permits new_cred in task_token to be used. */
+void __iee_code _iee_commit_cred(unsigned long iee_offset, struct cred *new)
+{
+    #ifdef CONFIG_CREDP
+    _iee_do_commit_cred(iee_offset, new);
+    #endif
+}
+
+/* Copy from current cred and set task_token->new_cred to mark this as legal modification target. */
+void __iee_code _iee_copy_cred(unsigned long iee_offset, struct cred *old, struct cred *new)
+{
+	#ifdef CONFIG_CREDP
+	struct task_struct *tsk = current;
+	struct task_token *token = (struct task_token *)__phys_to_iee(__pa(tsk));
+	struct rcu_head *rcu = (struct rcu_head *)(new->rcu.func);
+	struct cred *_new = (struct cred *)__phys_to_iee(__pa(new));
+
+	 // Get old cred from current task directly is safer.
+    old = tsk->cred;
+    token->new_cred = new;
+
+	_iee_memcpy(iee_offset, new, old, sizeof(struct cred));
+	*(struct rcu_head **)(&(_new->rcu.func)) = rcu;
+	*(struct rcu_head *)(_new->rcu.func) = *(struct rcu_head *)(old->rcu.func);
+	#endif
+}
+
+/* Can only be called by root tasks as it would copy privileged cred. */
+void __iee_code _iee_copy_cred_kernel(unsigned long iee_offset, struct cred *old, struct cred *new)
+{
+	#ifdef CONFIG_CREDP
+	struct rcu_head *rcu = (struct rcu_head *)(new->rcu.func);
+	struct cred *_new = (struct cred *)__phys_to_iee(__pa(new));
+	_iee_memcpy(iee_offset, new, old, sizeof(struct cred));
+	*(struct rcu_head **)(&(_new->rcu.func)) = rcu;
+	*(struct rcu_head *)(_new->rcu.func) = *(struct rcu_head *)(old->rcu.func);
+	#endif
+}
+
+void __iee_code _iee_set_cred_gid(unsigned long iee_offset, struct cred *cred, kgid_t gid)
+{
+	cred = (struct cred *)__phys_to_iee(__pa(cred));
+	cred->gid = gid;
+}
+
+void __iee_code _iee_set_cred_uid(unsigned long iee_offset, struct cred *cred, kuid_t uid)
+{
+	cred = (struct cred *)__phys_to_iee(__pa(cred));
+	cred->uid = uid;
+}
+
+void __iee_code _iee_write_in_byte(unsigned long iee_offset, void *ptr, __u64 data, int length)
+{
+	ptr = (void *)((unsigned long)ptr + (unsigned long)iee_offset);
+	switch(length) {
+		case 8: {
+			*(__u64 *)ptr = data;
+			break;
+		}
+		case 4: {
+			*(__u32 *)ptr = (__u32)data;
+			break;
+		}
+		case 2: {
+			*(__u16 *)ptr = (__u16)data;
+			break;
+		}
+		case 1: {
+			*(__u8 *)ptr = (__u8)data;
+			break;
+		}
+	}
+}
+
+static pteval_t inline _iee_set_cmpxchg_relaxed(pte_t *ptep, pteval_t old_pteval, pteval_t new_pteval, unsigned long iee_offset)
+{
+	pteval_t pteval = cmpxchg_relaxed((pteval_t *)((unsigned long)ptep + iee_offset), old_pteval, new_pteval);
+	return pteval;
+}
+
+/* Check if addr is allocated in IEE page */
+static inline bool check_addr_in_iee_valid(unsigned long addr) 
+{
+	pgd_t *pgdir = swapper_pg_dir;
+
+	pgd_t *pgdp = pgd_offset_pgd(pgdir, addr);
+	p4d_t *p4dp = p4d_offset(pgdp, addr);
+	pud_t *pudp;
+	pmd_t *pmdp;
+	pte_t *ptep;
+
+	if(!(p4d_val(READ_ONCE(*p4dp)) & PTE_VALID))
+		return false;
+
+	pudp = pud_offset(p4dp, addr);
+
+	if(!(pud_val(READ_ONCE(*pudp)) & PTE_VALID))
+		return false;
+
+	pmdp = pmd_offset(pudp, addr);
+
+	if(!(pmd_val(READ_ONCE(*pmdp)) & PTE_VALID))
+		return false;
+
+	ptep = pte_offset_kernel(pmdp, addr);
+
+	return (pte_val(READ_ONCE(*ptep)) & PTE_VALID);
+}
+
+void __iee_code _iee_set_tramp_pgd(unsigned long iee_offset, pgd_t *pgdp, pgd_t pgd)
+{
+	WRITE_ONCE(*((pgd_t *)(__phys_to_iee(__pa_symbol(pgdp)))), pgd);
+}
+
+void __iee_code _iee_set_swapper_pgd(unsigned long iee_offset, pgd_t *pgdp, pgd_t pgd)
+{
+	if(!(pgd_val(pgd) & PMD_SECT_VALID))
+	{
+		WRITE_ONCE(*((pgd_t *)(__phys_to_iee(__pa_symbol(pgdp)))), pgd);
+		return;
+	}
+
+	if ((pgd_val(pgd) & PMD_TABLE_BIT) && !check_addr_in_iee_valid(__phys_to_iee(__pgd_to_phys(pgd))))
+		panic("You can't use non-iee-pgtable\n");
+
+	if((pgdp >= pgd_offset_pgd((pgd_t *)swapper_pg_dir, PAGE_OFFSET + BIT(vabits_actual - 2))) && (pgdp < pgd_offset_pgd((pgd_t *)swapper_pg_dir, PAGE_OFFSET + BIT(vabits_actual - 1))) && !(pgd_val(pgd) & PGD_APT))
+		panic("Set IEE pgd U page.\n");
+
+	WRITE_ONCE(*((pgd_t *)(__phys_to_iee(__pa_symbol(pgdp)))), pgd);
+}
+
+void __iee_code _iee_set_p4d(unsigned long iee_offset, p4d_t *p4dp, p4d_t p4d)
+{
+	if(!(p4d_val(p4d) & PMD_SECT_VALID))
+	{
+		WRITE_ONCE(*((p4d_t *)((unsigned long)p4dp + (unsigned long)iee_offset)), p4d);
+		return;
+	}
+
+	if ((p4d_val(p4d) & PMD_TABLE_BIT) && !check_addr_in_iee_valid(__phys_to_iee(__p4d_to_phys(p4d))))
+		panic("You can't use non-iee-pgtable\n");
+
+	WRITE_ONCE(*((p4d_t *)((unsigned long)p4dp + (unsigned long)iee_offset)), p4d);
+}
+
+void __iee_code _iee_set_pud(unsigned long iee_offset, pud_t *pudp, pud_t pud)
+{
+	if(!(pud_val(pud) & PMD_SECT_VALID))
+	{
+		WRITE_ONCE(*((pud_t *)((unsigned long)pudp + (unsigned long)iee_offset)), pud);
+		return;
+	}
+
+	if ((pud_val(pud) & PMD_TABLE_BIT) && !check_addr_in_iee_valid(__phys_to_iee(__pud_to_phys(pud))))
+		panic("You can't use non-iee-pgtable\n");
+
+	WRITE_ONCE(*((pud_t *)((unsigned long)pudp + (unsigned long)iee_offset)), pud);
+}
+
+// Return true if the modify does not break DEP.
+static inline bool check_pmd_dep(char *addr, pmd_t pmd)
+{
+	// DEP for kernel code and readonly data
+	// _text: .text start addr, __init_begin: .rodata end addr
+	if (addr >= _text && addr < _etext)
+	{
+		if ((PTE_WRITE & pmd_val(pmd)) || // DBM == 1 --> writable
+			!(PTE_RDONLY & pmd_val(pmd))) // DBM == 0 && AP[2] = 0 --> writable
+		{
+			panic("Can't make kernel's text/readonly page as writable!\n"
+					   "addr = 0x%16llx, pmd_val = 0x%16llx",
+				  (u64)addr, pmd_val(pmd));
+		}
+	}
+	return true;
+}
+
+// Return true if the pmd table is a part of kernel page table.
+// TODO : Optimize to get lower overhead.
+static inline bool is_kernel_pmd_table(pmd_t *pmdp, pmd_t pmd)
+{
+	int i = 0,j = 0;
+	for(i = 0; i < PAGE_SIZE/sizeof(pgd_t); i++)
+	{
+		pgd_t *pgdp = (pgd_t *)swapper_pg_dir + i;
+		if((pgd_val(*pgdp) & PMD_SECT_VALID) && (pgd_val(*pgdp) & PMD_TABLE_BIT))
+		{
+			for(j = 0; j < PAGE_SIZE/sizeof(pud_t); j++)
+			{
+				pud_t *pudp = (pud_t *)__va(__pgd_to_phys(*pgdp)) + i;
+				if((pud_val(*pudp) & PMD_SECT_VALID) && (pud_val(*pudp) & PMD_TABLE_BIT))
+				{
+					pmd_t *current_pmdp = __va(__pud_to_phys(*pudp));
+					if((unsigned long)current_pmdp == ((unsigned long)pmdp & PAGE_MASK))
+						return true;
+				}
+			}
+		}
+	}
+	return false;
+}
+
+// Return true if it is mapped to a physical range containing IEE page.
+// TODO : Optimize to get lower overhead.
+static inline bool check_addr_range_in_iee_valid(pmd_t pmd)
+{
+	int i = 0;
+	unsigned long addr = __phys_to_iee(__pmd_to_phys(pmd));
+
+	pgd_t *pgdir = swapper_pg_dir;
+
+	pgd_t *pgdp = pgd_offset_pgd(pgdir, addr);
+	p4d_t *p4dp = p4d_offset(pgdp, addr);
+	pud_t *pudp;
+	pmd_t *pmdp;
+	pte_t *ptep;
+
+	if(!(p4d_val(READ_ONCE(*p4dp)) & PTE_VALID))
+		return false;
+
+	pudp = pud_offset(p4dp, addr);
+
+	if(!(pud_val(READ_ONCE(*pudp)) & PTE_VALID))
+		return false;
+
+	pmdp = pmd_offset(pudp, addr);
+
+	if(!(pmd_val(READ_ONCE(*pmdp)) & PTE_VALID))
+		return false;
+
+	ptep = pte_offset_kernel(pmdp, addr);
+
+	for(i = 0; i < PAGE_SIZE/sizeof(pte_t); i++)
+	{
+		if(pte_val(READ_ONCE(*ptep)) & PTE_VALID)
+			return true;
+		ptep++;
+	}
+	return false;
+}
+
+void __iee_code _iee_set_pmd(unsigned long iee_offset, pmd_t *pmdp, pmd_t pmd)
+{
+	char * addr = (char *)__phys_to_kimg(__pmd_to_phys(pmd));
+
+	if(!(pmd_val(pmd) & PMD_SECT_VALID))
+	{
+		WRITE_ONCE(*((pmd_t *)((unsigned long)pmdp + (unsigned long)iee_offset)), pmd);
+		return;
+	}
+
+	// Check if the pte table is legally allocated.
+	if ((pmd_val(pmd) & PMD_TABLE_BIT) && !check_addr_in_iee_valid(__phys_to_iee(__pmd_to_phys(pmd))))
+		panic("You can't use non-iee-pgtable\n");
+
+	// // Avoid mapping a huge pmd as U page.
+	// if(!(pmd_val(pmd) & PMD_TABLE_BIT) && (pmd_val(pmd) & PMD_SECT_USER) && is_kernel_pmd_table(pmdp, pmd))
+	// 	panic("Set a block descriptor in kernel space U page.\n");
+
+	// // Avoid mapping a huge pmd to IEE physical page.
+	// if(!(pmd_val(pmd) & PMD_TABLE_BIT) && check_addr_range_in_iee_valid(pmd))
+	// 	panic("Mapping IEE physical page to a huge pmd.\n");
+
+	if(!check_pmd_dep(addr, pmd))
+		return;
+
+	WRITE_ONCE(*((pmd_t *)((unsigned long)pmdp + (unsigned long)iee_offset)), pmd);
+}
+
+// Return true if the pte table is a part of kernel page table.
+// TODO : Optimize to get lower overhead.
+static inline bool is_kernel_pte_table(pte_t *ptep, pte_t pte)
+{
+	return false;
+}
+
+// Return true if it does not change the privilage or add new U page in kernel.
+static inline bool check_privilage_safe(pte_t *ptep, pte_t pte)
+{
+	if(!(pte_val(pte) & PTE_VALID))
+		return true;
+	
+	if((pte_val(*ptep) & PTE_VALID))
+	{
+		if((pte_val(*ptep) & PTE_USER) != (pte_val(pte) & PTE_USER))
+			panic("Incorrectly change privilage.\n");
+	}
+	else
+	{
+		if((pte_val(pte) & PTE_USER) && is_kernel_pte_table(ptep, pte))
+			panic("Add new U page in kernel space.\n");
+	}
+	return true;
+}
+
+// TODO : When adding a new executable page, check it for DEP.
+static inline bool safely_adding_new_exec_page(pte_t *ptep, pte_t pte)
+{
+	return true;
+}
+
+// Return true if it is only changing prot of a pte.
+static inline bool is_changing_pte_prot(pte_t *ptep, pte_t pte)
+{
+	if(((pte_val(*ptep) ^ pte_val(pte)) & PTE_ADDR_MASK) == 0)
+		return true;
+	else
+		return false;
+}
+
+// Return true if the modify does not break DEP.
+static inline bool check_pte_dep(char *addr, pte_t pte)
+{
+	// DEP for kernel code and readonly data
+	// _text: .text start addr, __init_begin: .rodata end addr
+	if (addr >= _text && addr < _etext)
+	{
+		if ((PTE_WRITE & pte_val(pte)) // DBM == 1 --> writable
+			|| !(PTE_RDONLY & pte_val(pte))) // DBM == 0 && AP[2] = 0 --> writable
+		{
+			panic("Can't make kernel's text/readonly page as writable!\n"
+					   "addr = 0x%16llx, pte_val = 0x%16llx",
+				  (u64)addr, pte_val(pte));
+		}
+	}
+	return true;
+}
+
+void __iee_code _iee_set_pte(unsigned long iee_offset, pte_t *ptep, pte_t pte)
+{
+	char * addr = (char *)__phys_to_kimg(__pte_to_phys(pte));
+
+	if(!(pte_val(pte) & PTE_VALID))
+	{
+		#ifdef CONFIG_KOI
+        if (pte_valid(pte))
+            pte = __pte(pte_val(pte) | PTE_NG);
+        #endif
+		WRITE_ONCE(*((pte_t *)((unsigned long)ptep + (unsigned long)iee_offset)), pte);
+		return;
+	}
+
+	// Avoid modify privilage unsafely.
+	if(!check_privilage_safe(ptep, pte))
+		panic("You are modify privilage unsafely.\n");
+
+	// Avoid mapping a new executable page.
+	if(!safely_adding_new_exec_page(ptep, pte))
+		panic("You are adding a new executable page unsafely.\n");
+
+	// Avoid mapping a new VA to IEE PA.
+	if(!is_changing_pte_prot(ptep, pte) && 
+	   check_addr_in_iee_valid(__phys_to_iee(__pte_to_phys(pte))))
+		panic("You are remmaping IEE page to other VA.\n");
+
+	// Avoid mapping a writable VA to kernel code PA.
+	if(!check_pte_dep(addr, pte))
+		return;
+
+	WRITE_ONCE(*((pte_t *)((unsigned long)ptep + (unsigned long)iee_offset)), pte);
+}
+
+static void inline _iee_set_pte_single(pte_t *ptep, pte_t pte, unsigned long iee_offset)
+{
+	char * addr = (char *)__phys_to_kimg(__pte_to_phys(pte));
+
+	if(!(pte_val(pte) & PTE_VALID))
+	{
+		WRITE_ONCE(*((pte_t *)((unsigned long)ptep + (unsigned long)iee_offset)), pte);
+		return;
+	}
+
+	// Avoid modify privilage unsafely.
+	if(!check_privilage_safe(ptep, pte))
+		panic("You are modify privilage unsafely.\n");
+
+	// Avoid mapping a new executable page.
+	if(!safely_adding_new_exec_page(ptep, pte))
+		panic("You are adding a new executable page unsafely.\n");
+
+	// Avoid mapping a new VA to IEE PA.
+	if(!is_changing_pte_prot(ptep, pte) && 
+	   check_addr_in_iee_valid(__phys_to_iee(__pte_to_phys(pte))))
+		panic("You are remmaping IEE page to other VA.\n");
+
+	// Avoid mapping a writable VA to kernel code PA.
+	if(!check_pte_dep(addr, pte))
+		return;
+
+	#ifdef CONFIG_KOI
+    if (pte_valid(pte))
+        pte = __pte(pte_val(pte) | PTE_NG);
+    #endif
+	WRITE_ONCE(*((pte_t *)((unsigned long)ptep + (unsigned long)iee_offset)), pte);
+}
+
+void __iee_code _iee_set_pte_upage(unsigned long iee_offset, pte_t *ptep, int order, int use_block_pmd)
+{
+	int i;
+
+	ptep = (pte_t *)((unsigned long)ptep + iee_offset);
+	if(use_block_pmd)
+	{
+		pmd_t *pmdp = (pmd_t *)ptep;
+		pmd_t pmd = READ_ONCE(*pmdp);
+		pmd = __pmd(pmd_val(pmd) | PMD_SECT_USER | PMD_SECT_NG);
+		WRITE_ONCE(*pmdp, pmd);
+	}
+	else
+	{
+		for(i = 0; i < (1 << order); i++)
+		{
+			pte_t pte = READ_ONCE(*ptep);
+			pte = __pte(pte_val(pte) | PTE_USER | PTE_NG);
+			WRITE_ONCE(*ptep, pte);
+			ptep++;
+		}
+	}
+}
+
+void __iee_code _iee_set_pte_ppage(unsigned long iee_offset, pte_t *ptep, int order, int use_block_pmd)
+{
+	int i;
+
+	ptep = (pte_t *)((unsigned long)ptep + iee_offset);
+	if(use_block_pmd)
+	{
+		pmd_t *pmdp = (pmd_t *)ptep;
+		pmd_t pmd = READ_ONCE(*pmdp);
+		pmd = __pmd(pmd_val(pmd) & ~PMD_SECT_USER & ~PMD_SECT_NG);
+		WRITE_ONCE(*pmdp, pmd);
+	}
+	else
+	{
+		for(i = 0; i < (1 << order); i++)
+		{
+			pte_t pte = READ_ONCE(*ptep);
+			pte = __pte(pte_val(pte) & ~PTE_USER & ~PTE_NG);
+			#ifdef CONFIG_KOI
+        	if (pte_valid(pte))
+            	pte = __pte(pte_val(pte) | PTE_NG);
+        	#endif
+			WRITE_ONCE(*ptep, pte);
+			ptep++;
+		}
+	}
+}
+
+void __iee_code _iee_set_bm_pte(unsigned long iee_offset, pte_t *ptep, pte_t pte)
+{
+    #ifdef CONFIG_KOI
+    if (pte_valid(pte))
+        pte = __pte(pte_val(pte) | PTE_NG);
+    #endif
+	WRITE_ONCE(*((pte_t *)(__phys_to_iee(__pa_symbol(ptep)))), pte);
+}
+
+/* Data in iee_si_base is visible to all pgd while iee_si_data is private. */
+unsigned long iee_base_swapper_pg_dir __iee_si_data;
+unsigned long iee_base_idmap_pg_dir __iee_si_data;
+unsigned long iee_base_reserved_pg_dir __iee_si_data;
+unsigned long iee_base__bp_harden_el1_vectors __iee_si_data;
+bool iee_init_done __iee_si_data;
+unsigned long iee_si_tcr __iee_si_data;
+unsigned long iee_si_tcr_outside __iee_si_data;
+unsigned long iee_si_tcr_inside __iee_si_data;
+s64 iee_si_offset __iee_si_data;
+
+DEFINE_PER_CPU(unsigned long, iee_si_user_bvr0);
+DEFINE_PER_CPU(unsigned long, iee_si_user_bcr0);
+EXPORT_SYMBOL(iee_si_user_bvr0);
+EXPORT_SYMBOL(iee_si_user_bcr0);
+
+static u64 inline iee_si_mask(unsigned long mask, unsigned long new_val, unsigned long old_val)
+{
+    return (new_val & mask) | (old_val & ~mask);
+}
+/* 
+ * Handler function for requests of executing sensitive instrutions. 
+ */
+u64 __iee_si_code notrace iee_si_handler(int flag, ...)
+{
+    va_list pArgs;
+    u64 old_val, new_val;
+
+	va_start(pArgs, flag);
+    switch (flag) {
+		case IEE_SI_TEST:
+			break;
+        case IEE_WRITE_SCTLR: {
+            old_val = read_sysreg(sctlr_el1);
+            new_val = va_arg(pArgs, u64);
+            new_val = iee_si_mask(IEE_SCTLR_MASK, new_val, old_val);
+            write_sysreg(new_val, sctlr_el1);
+            break;
+        }
+        case IEE_WRITE_TTBR0: 
+        case IEE_CONTEXT_SWITCH: {
+            u64 new_asid, new_phys, old_phys, token_phys;
+            struct task_struct *tsk;
+	        struct task_token *token;
+            new_val = va_arg(pArgs, u64);
+            new_phys = (new_val & PAGE_MASK) & ~TTBR_ASID_MASK;
+            new_asid = new_val >> 48;
+
+            // Check ASID first
+            if (new_phys == iee_base_reserved_pg_dir){
+				if (new_asid != 1)
+					panic("IEE SI warning: reserved_pg_dir ASID invalid: %llx:%llx", new_asid, new_val);
+			}
+			// Already reserved asid 1 for iee rwx gate.
+			else if (new_asid == 0){
+				new_val |= FIELD_PREP(TTBR_ASID_MASK, 1);
+				printk("IEE SI: Modify ASID of %llx to 1.", new_val);
+			}
+            // TO DO: operations to protect idmap_pg_dir
+            else if (new_phys == iee_base_idmap_pg_dir)
+            {
+				// printk("IEE SI: switch to idmap_pg_dir.);
+            }
+            else if (new_asid % 2 ==0)
+                panic("IEE SI warning: TTBR0 ASID invalid: %llx:%llx", new_asid, new_val);
+
+            /* Skip verification if iee hasn't been initialized. */
+            if (iee_init_done){
+                // Verify current sp_el0 with iee token info
+                asm volatile("mrs %x0, sp_el0":"=r"(tsk));
+                token = (struct task_token *)((unsigned long)tsk + (unsigned long)iee_offset);
+                
+                /* 
+                 * token->pgd != NULL means it is a user task, then we need to check whether current ttbr0 is correct.
+                 */ 
+                if (token->pgd){
+                    old_val = read_sysreg(ttbr0_el1);
+                    // When TTBR0 is reserved_pg_dir then no checking is available.
+                    if (old_val != iee_base_reserved_pg_dir){
+						old_phys = (old_val & PAGE_MASK) & ~TTBR_ASID_MASK;
+                        token_phys = __pa(token->pgd);
+                        if (old_phys != token_phys)
+                            panic("IEE SI warning: Pgd set error. old ttbr0:%lx, token ttbr0:%lx, token pgd:%lx", 
+                                (unsigned long)old_phys, (unsigned long)token_phys, (unsigned long)(token->pgd));
+                    }
+                }
+            }
+            // all checks are done.
+            write_sysreg(new_val, ttbr0_el1);
+			
+			// SET ASID in TTBR1 when context switch
+			if (flag == IEE_CONTEXT_SWITCH){
+				new_val = (read_sysreg(ttbr1_el1) & ~TTBR_ASID_MASK) | FIELD_PREP(TTBR_ASID_MASK, new_asid-1);
+				write_sysreg(new_val, ttbr1_el1);
+			}
+            break;
+        }
+        case IEE_WRITE_VBAR: {
+            u64 el1_vector;
+            new_val = va_arg(pArgs, u64);
+            el1_vector = iee_base__bp_harden_el1_vectors;
+            if(new_val == el1_vector || new_val == el1_vector+SZ_2K || 
+                    new_val == el1_vector+SZ_2K*2 || new_val == el1_vector+SZ_2K*3)
+                write_sysreg(new_val, vbar_el1);
+            break;
+        }
+        case IEE_WRITE_TCR: {
+            old_val = read_sysreg(tcr_el1);
+            new_val = va_arg(pArgs, u64);
+            new_val = iee_si_mask(IEE_TCR_MASK, new_val, old_val);
+            write_sysreg(new_val, tcr_el1);
+            break;
+        }
+    }
+    va_end(pArgs);
+	return 0;
+}
+/* 
+ * TODO: scan a page to check whether it contains sensitive instructions 
+ * return 1 when finding sensitive inst, 0 on safe page.
+ */
+int iee_si_scan_page(unsigned long addr);
+
+#endif
\ No newline at end of file
diff --git a/arch/arm64/kernel/iee/pgtable_slab.c b/arch/arm64/kernel/iee/pgtable_slab.c
new file mode 100644
index 000000000000..10d8a6727a44
--- /dev/null
+++ b/arch/arm64/kernel/iee/pgtable_slab.c
@@ -0,0 +1,116 @@
+#include <linux/slab.h>
+#include <linux/slub_def.h>
+#include <linux/mm.h>
+#define PGTABLE_ORDER 9
+#define PGTABLE_MAX_ORDER (20-PGTABLE_ORDER)
+
+struct kmem_cache *pgtable_jar;
+struct kmem_cache *pgtable_page_jar;
+struct kmem_cache *iee_stack_jar;
+extern void iee_set_freeptr(void **pptr, void *ptr);
+
+#ifdef CONFIG_PTP
+extern void early_pgtable_jar_alloc(struct kmem_cache *pgtable_jar);
+void __init iee_pmd_pgtable_init(pud_t *pud) {
+    struct page *page;
+    struct pgtable_page *tmp;
+    pmd_t *orig_pmd = pud_pgtable(*pud);
+    pmd_t *pmd;
+    int i;
+
+    for (i = 0; i < PTRS_PER_PMD; i++) {
+        pmd = orig_pmd + i;
+        if (pmd_none(*pmd) || pmd_bad(*pmd))
+            continue;
+        page = pmd_page(*pmd);
+        tmp = kmem_cache_alloc(pgtable_page_jar, GFP_KERNEL | __GFP_ZERO);
+        spin_lock_init(&tmp->ptl);
+        page->slab_cache = (struct kmem_cache *)tmp;
+        ((struct pgtable_page *)(page->slab_cache))->page = page;
+    }
+}
+
+void __init iee_pud_pgtable_init(p4d_t *p4d) {
+    struct page *page;
+    struct pgtable_page *tmp;
+    pud_t *orig_pud = p4d_pgtable(*p4d);
+    pud_t *pud;
+    int i;
+    
+    for (i = 0; i < PTRS_PER_PUD; i++) {
+        pud = orig_pud + i;
+        if (pud_none(*pud) || pud_bad(*pud))
+            continue;
+        iee_pmd_pgtable_init(pud);
+        page = pud_page(*pud);
+        tmp = kmem_cache_alloc(pgtable_page_jar, GFP_KERNEL | __GFP_ZERO);
+        spin_lock_init(&tmp->ptl);
+        page->slab_cache = (struct kmem_cache *)tmp;
+        ((struct pgtable_page *)(page->slab_cache))->page = page;
+    }
+}
+
+void __init iee_pgtable_init(void)
+{
+    int i;
+    pgd_t *pgd;
+    struct page* page;
+    struct pgtable_page *tmp;
+    pgtable_page_jar = kmem_cache_create("pgtable_page_jar", sizeof(struct pgtable_page), 0, SLAB_PANIC|SLAB_RED_ZONE, NULL);
+	pgtable_jar = kmem_cache_create("pgtable_jar", PAGE_SIZE, PAGE_SIZE,
+			SLAB_PANIC, NULL);
+    for(i = 0; i < (1 << (PGTABLE_MAX_ORDER))/nr_cpu_ids; i++)
+    {
+        early_pgtable_jar_alloc(pgtable_jar);
+    }
+    #ifdef CONFIG_KOI
+    for (i = 0; i < PTRS_PER_PGD; i++) {
+        pgd = swapper_pg_dir + i;
+        if (p4d_none_or_clear_bad((p4d_t *)pgd))
+            continue;
+        iee_pud_pgtable_init((p4d_t *)pgd);
+        page = pgd_page(*pgd);
+        tmp = kmem_cache_alloc(pgtable_page_jar, GFP_KERNEL | __GFP_ZERO);
+        spin_lock_init(&tmp->ptl);
+        page->slab_cache = (struct kmem_cache *)tmp;
+        ((struct pgtable_page *)((page)->slab_cache))->page = page;
+    }
+    #endif
+}
+#else
+void __init iee_pgtable_init(void)
+{
+    ;
+}
+#endif
+
+void __init iee_stack_init(void)
+{
+    iee_stack_jar = kmem_cache_create("iee_stack_jar", (PAGE_SIZE << 3), (PAGE_SIZE << 3), SLAB_PANIC, NULL);
+}
+
+extern void iee_memset(void *ptr, int data, size_t n);
+void *get_iee_pgtable_page(gfp_t gfpflags)
+{
+    struct page *page;
+    void *res = kmem_cache_alloc(pgtable_jar, gfpflags | __GFP_ZERO);
+    iee_set_freeptr((void **)((unsigned long)res + pgtable_jar->offset), NULL);
+    page = virt_to_page(res);
+    page_ref_inc(page);
+    return res;
+}
+
+void free_iee_pgtable_page(void *obj)
+{
+    kmem_cache_free(pgtable_jar, obj);
+}
+
+void *get_iee_stack(void)
+{
+    return kmem_cache_alloc(iee_stack_jar, GFP_KERNEL);
+}
+
+void free_iee_stack(void *obj)
+{
+    kmem_cache_free(iee_stack_jar, obj);
+}
\ No newline at end of file
diff --git a/arch/arm64/kernel/irq.c b/arch/arm64/kernel/irq.c
index 60456a62da11..6323369f1f4f 100644
--- a/arch/arm64/kernel/irq.c
+++ b/arch/arm64/kernel/irq.c
@@ -26,7 +26,9 @@
 DEFINE_PER_CPU(struct nmi_ctx, nmi_contexts);
 
 DEFINE_PER_CPU(unsigned long *, irq_stack_ptr);
-
+#ifdef CONFIG_KOI
+EXPORT_SYMBOL(irq_stack_ptr);
+#endif
 #ifdef CONFIG_VMAP_STACK
 static void init_irq_stacks(void)
 {
diff --git a/arch/arm64/kernel/koi/Makefile b/arch/arm64/kernel/koi/Makefile
new file mode 100644
index 000000000000..9be8710b714a
--- /dev/null
+++ b/arch/arm64/kernel/koi/Makefile
@@ -0,0 +1 @@
+obj-y += koi.o
\ No newline at end of file
diff --git a/arch/arm64/kernel/koi/koi.c b/arch/arm64/kernel/koi/koi.c
new file mode 100644
index 000000000000..0c162f4c2795
--- /dev/null
+++ b/arch/arm64/kernel/koi/koi.c
@@ -0,0 +1,1653 @@
+#include "asm/koi.h"
+#include "linux/compiler_attributes.h"
+#include "linux/compiler_types.h"
+#include "asm/barrier.h"
+#include "asm-generic/bug.h"
+#include "asm-generic/errno-base.h"
+#include "asm-generic/memory_model.h"
+#include "asm-generic/pgtable-nop4d.h"
+#include "asm-generic/rwonce.h"
+#include "asm/pgalloc.h"
+#include "asm/memory.h"
+#include "linux/bitfield.h"
+#include "linux/compiler.h"
+#include "linux/types.h"
+#include "linux/spinlock.h"
+#include "linux/spinlock_types.h"
+#include "linux/kernel.h"
+#include "linux/rculist.h"
+#include "linux/rcupdate.h"
+#include "linux/list.h"
+#include "asm/current.h"
+#include "linux/compiler_types.h"
+#include "asm-generic/barrier.h"
+#include "asm-generic/rwonce.h"
+#include "asm-generic/pgalloc.h"
+#include "asm/cpufeature.h"
+#include "asm/kvm_hyp.h"
+#include "asm/mmu.h"
+#include "asm/mmu_context.h"
+#include "asm/page-def.h"
+#include "asm/pgalloc.h"
+#include "asm/pgtable-hwdef.h"
+#include "asm/pgtable-types.h"
+#include "asm/pgtable.h"
+#include "asm/string.h"
+#include "asm/sysreg.h"
+#include "linux/bitfield.h"
+#include "linux/compiler.h"
+#include "linux/export.h"
+#include "linux/gfp.h"
+#include "linux/huge_mm.h"
+#include "linux/kallsyms.h"
+#include "linux/kconfig.h"
+#include "linux/kern_levels.h"
+#include "linux/kernel.h"
+#include "linux/list.h"
+#include "linux/lockdep.h"
+#include "linux/mm.h"
+#include "linux/mm_types.h"
+#include "linux/pgtable.h"
+#include "linux/printk.h"
+#include "linux/rculist.h"
+#include "linux/rcupdate.h"
+#include "linux/rmap.h"
+#include "linux/sched.h"
+#include "linux/stddef.h"
+#include "linux/string.h"
+#include "linux/swap.h"
+#include "linux/swapops.h"
+#include "linux/types.h"
+#include "linux/slab.h"
+#include "linux/string.h"
+#include "linux/hashtable.h"
+
+// #define DEBUG
+
+#ifdef DEBUG
+#define debug_printk(...) printk(KERN_ERR __VA_ARGS__)
+#else
+#define debug_printk(...)
+#endif
+
+#define __koi_code __section(".koi.text")
+#define __koi_data __section(".data..koi")
+
+#define KOI_FLAG_MASK 0xffff000000000fff
+
+extern unsigned long __koi_code_start[];
+extern unsigned long __koi_code_end[];
+extern unsigned long __koi_data_start[];
+extern unsigned long __koi_data_end[];
+#ifdef CONFIG_IEE
+extern unsigned long __iee_si_data_start[];
+extern unsigned long __iee_si_text_end[];
+#endif
+
+__koi_data unsigned long koi_swapper_ttbr1 = 0;
+EXPORT_SYMBOL(koi_swapper_ttbr1);
+#define KOI_SWAPPER_MASK 0x0000fffffffffff0
+
+__attribute__((aligned(PAGE_SIZE)))
+DEFINE_PER_CPU(unsigned long[PAGE_SIZE / sizeof(unsigned long)],
+	       koi_irq_current_ttbr1);
+EXPORT_SYMBOL(koi_irq_current_ttbr1);
+
+extern void koi_switch_to_ko_stack(unsigned long stack_top);
+extern void init_ko_mm(struct mm_struct *ko_mm, pgd_t *pgdp);
+extern void koi_check_and_switch_context(struct mm_struct *mm);
+extern void koi_add_page_mapping(unsigned long dst, unsigned long src);
+extern unsigned long _iee_read_token_ttbr1(unsigned long iee_offset, struct task_struct *tsk);
+/**
+*struct koi_mem_list - maintain a linked list of free memory in the kernel
+*@addr: stating address of this memory
+*@size: the size of the memory
+*@list: the head of the koi_mem_list
+*@rcu: for rcu 
+*/
+struct koi_mem_list {
+	unsigned long addr;
+	unsigned long size;
+	struct list_head list;
+	struct rcu_head rcu;
+};
+//mapping parameter pointer to copy
+struct koi_addr_map {
+	unsigned long buffer_addr;
+	unsigned long orig_addr;
+	int offset;
+	struct hlist_node node;
+	struct rcu_head rcu;
+};
+
+DEFINE_HASHTABLE(koi_mem_htbl, HASH_TABLE_BIT);
+EXPORT_SYMBOL(koi_mem_htbl);
+DEFINE_SPINLOCK(koi_mem_htbl_spin_lock);
+EXPORT_SYMBOL(koi_mem_htbl_spin_lock);
+
+EXPORT_SYMBOL(koi_do_switch_to_kernel_stack);
+EXPORT_SYMBOL(koi_do_switch_to_ko_stack);
+
+/**
+* koi_ttbr_ctor - return ttbr1 for the given driver module
+*/
+unsigned long koi_ttbr_ctor(struct module *mod)
+{
+	struct koi_mem_hash_node *ko;
+	struct mm_struct *ko_mm;
+	unsigned long ttbr1;
+	unsigned long asid;
+	int bkt;
+	rcu_read_lock();
+	hash_for_each_rcu (koi_mem_htbl, bkt, ko, node) {
+		if (ko->mod == mod) {
+			ko_mm = ko->ko_mm;
+			break;
+		}
+	}
+	rcu_read_unlock();
+	if (!ko_mm) {
+		printk(KERN_ERR "cannot found module %s in koi_mem_htbl",
+		       mod->name);
+		return 0;
+	}
+#ifndef CONFIG_IEE
+    asm volatile("mrs %0, ttbr0_el1\n":"=r"(asid):);
+    asid &= TTBR_ASID_MASK;
+    ttbr1 = ko->ko_ttbr1 | asid;
+#else
+	koi_check_and_switch_context(ko_mm);
+	asid = ASID(ko_mm) | USER_ASID_FLAG;
+	ttbr1 = ko->ko_ttbr1 | FIELD_PREP(TTBR_ASID_MASK, asid);
+#endif
+	return ttbr1;
+}
+EXPORT_SYMBOL(koi_ttbr_ctor);
+//release the hash node
+static __maybe_unused void koi_mem_hash_node_free(struct rcu_head *rcu)
+{
+	struct koi_mem_hash_node *node =
+		container_of(rcu, struct koi_mem_hash_node, rcu);
+	kfree(node);
+}
+//release free memory linked list nodes
+static void koi_mem_node_free(struct rcu_head *rcu)
+{
+	struct koi_mem_list *mem_node =
+		container_of(rcu, struct koi_mem_list, rcu);
+	kfree(mem_node);
+}
+//release the node in koi_addr_map
+static void koi_addr_map_node_free(struct rcu_head *rcu)
+{
+	struct koi_addr_map *addr_map_node =
+		container_of(rcu, struct koi_addr_map, rcu);
+	kfree(addr_map_node);
+}
+
+#ifndef CONFIG_IEE
+/*
+ * This function is used to switch to ko's pgtable.
+ */
+__koi_code noinline unsigned long koi_do_switch_to_ko_pgtbl(void)
+{
+	struct koi_mem_hash_node *ko;
+	// struct mm_struct *ko_mm;
+	unsigned long addr;
+	unsigned long ttbr1, asid;
+	unsigned long *ptr;
+	struct task_token *token_addr =
+		(struct task_token *)((unsigned long)current +
+				      (unsigned long)koi_offset);
+	int bkt;
+    unsigned long flags;
+	asm volatile(" mrs %0, elr_el1\n" : "=r"(addr));
+	ptr = SHIFT_PERCPU_PTR(koi_irq_current_ttbr1, __kern_my_cpu_offset());
+	rcu_read_lock();
+	hash_for_each_rcu (koi_mem_htbl, bkt, ko, node) {
+        spin_lock_irqsave(&ko->mod_lock, flags);
+        if (!ko->is_valid) {
+            spin_unlock_irqrestore(&ko->mod_lock, flags);
+            goto out;
+        }
+		if (ko->mod != NULL && ko->mod->init_layout.base != NULL) {
+			if (addr >= (unsigned long)ko->mod->init_layout.base &&
+			    addr < (unsigned long)(ko->mod->init_layout.base +
+						   ko->mod->init_layout.size)) {
+                spin_unlock_irqrestore(&ko->mod_lock, flags);
+				if (token_addr->current_ttbr1 == ko->ko_ttbr1 ||
+				    *ptr == ko->ko_ttbr1) {
+					// ko_mm = ko->ko_mm;
+					// koi_check_and_switch_context(ko_mm);
+                    // asid = ASID(ko_mm);
+				    // ttbr1 = ko->ko_ttbr1;
+				    // ttbr1 |= FIELD_PREP(TTBR_ASID_MASK, asid);
+                    asm volatile("mrs %0, ttbr0_el1\n":"=r"(asid):);
+                    asid &= TTBR_ASID_MASK;
+					ttbr1 = ko->ko_ttbr1 | asid;
+                    rcu_read_unlock();
+					return ttbr1;
+				}
+                goto out;
+			}
+		}
+		if (addr >= (unsigned long)ko->mod->core_layout.base &&
+		    addr < (unsigned long)ko->mod->core_layout.base +
+				    ko->mod->core_layout.size) {
+            spin_unlock_irqrestore(&ko->mod_lock, flags);
+			if (token_addr->current_ttbr1 == ko->ko_ttbr1 ||
+			    *ptr == ko->ko_ttbr1) {
+				// ko_mm = ko->ko_mm;
+				// koi_check_and_switch_context(ko_mm);
+				// asid = ASID(ko_mm);
+				// ttbr1 = ko->ko_ttbr1;
+				// ttbr1 |= FIELD_PREP(TTBR_ASID_MASK, asid);
+                asm volatile("mrs %0, ttbr0_el1\n":"=r"(asid):);
+                asid &= TTBR_ASID_MASK;
+                ttbr1 = ko->ko_ttbr1 | asid;
+                rcu_read_unlock();
+				return ttbr1;
+			}
+            goto out;
+		}
+        spin_unlock_irqrestore(&ko->mod_lock, flags);
+	}
+out:
+	rcu_read_unlock();
+	return 0;
+}
+/**
+* koi_do_switch_to_kernel_pgtbl - switch to kernel pagetable
+*/
+__koi_code noinline int koi_do_switch_to_kernel_pgtbl(void)
+{
+	unsigned long curr_ttbr1, asid;
+	// if (!cpu_online(smp_processor_id()))
+	//     return 0;
+	asm volatile("	mrs %0, ttbr1_el1\n" : "=r"(curr_ttbr1));
+	if ((curr_ttbr1 & KOI_SWAPPER_MASK) ==
+	    (koi_swapper_ttbr1 & KOI_SWAPPER_MASK)) {
+		return 0;
+	}
+	// if (((curr_ttbr1 & TTBR_ASID_MASK) >> 48) <= 1) {
+	// 	return 0;
+	// }
+    asm volatile("mrs %0, ttbr0_el1\n":"=r"(asid):);
+    asid &= ~USER_ASID_FLAG;
+    asid &= TTBR_ASID_MASK;
+	write_sysreg(koi_swapper_ttbr1 | asid, ttbr1_el1);
+	isb();
+	asm volatile(ALTERNATIVE("nop; nop; nop", "ic iallu; dsb nsh; isb",
+				 ARM64_WORKAROUND_CAVIUM_27456));
+	return 1;
+}
+#else
+__koi_code noinline unsigned long koi_do_switch_to_ko_pgtbl(void)
+{
+	struct koi_mem_hash_node *ko;
+	unsigned long addr, pan_flag, current_ttbr1, asid, ttbr1;
+    unsigned long *ptr;
+    struct mm_struct *ko_mm;
+	int bkt;
+	asm volatile("mrs %0, pan\n"
+		     "msr pan, 0x0\n"
+		     : "=r"(pan_flag)
+		     :);
+	current_ttbr1 = _iee_read_token_ttbr1(iee_offset, current);
+	asm volatile("msr pan, %0\n" : : "r"(pan_flag));
+    ptr = SHIFT_PERCPU_PTR(koi_irq_current_ttbr1, __kern_my_cpu_offset());
+	if (current_ttbr1 == 0 && *ptr == 0)
+		return 0;
+	asm volatile(" mrs %0, elr_el1\n" : "=r"(addr));
+	rcu_read_lock();
+	hash_for_each_rcu (koi_mem_htbl, bkt, ko, node) {
+		if (ko->mod != NULL && ko->mod->init_layout.base != NULL) {
+			if (addr >= (unsigned long)ko->mod->init_layout.base &&
+			    addr < (unsigned long)(ko->mod->init_layout.base +
+						   ko->mod->init_layout.size)) {
+				rcu_read_unlock();
+				if (current_ttbr1 == ko->ko_ttbr1 || *ptr == ko->ko_ttbr1) {
+					ko_mm = ko->ko_mm;
+					koi_check_and_switch_context(ko_mm);
+					asid = ASID(ko_mm) | USER_ASID_FLAG;
+					ttbr1 = ko->ko_ttbr1;
+					ttbr1 |= FIELD_PREP(TTBR_ASID_MASK, asid);
+					return ttbr1;
+				}
+				return 0;
+			}
+		}
+		if (addr >= (unsigned long)ko->mod->core_layout.base &&
+		    addr < (unsigned long)ko->mod->core_layout.base +
+				    ko->mod->core_layout.size) {
+			rcu_read_unlock();
+			if (current_ttbr1 == ko->ko_ttbr1 || *ptr == ko->ko_ttbr1) {
+				ko_mm = ko->ko_mm;
+				koi_check_and_switch_context(ko_mm);
+				asid = ASID(ko_mm) | USER_ASID_FLAG;
+				ttbr1 = ko->ko_ttbr1;
+				ttbr1 |= FIELD_PREP(TTBR_ASID_MASK, asid);
+				return ttbr1;
+			}
+			return 0;
+		}
+	}
+	rcu_read_unlock();
+	return 0;
+}
+
+__koi_code noinline int koi_do_switch_to_kernel_pgtbl(void)
+{
+	unsigned long curr_ttbr1, asid, error_addr;
+	// if (!cpu_online(smp_processor_id()))
+	//     return 0;
+	asm volatile("	mrs %0, ttbr1_el1\n" : "=r"(curr_ttbr1));
+	if ((curr_ttbr1 & KOI_SWAPPER_MASK) ==
+	    (koi_swapper_ttbr1 & KOI_SWAPPER_MASK)) {
+		return 0;
+	}
+	// if (((curr_ttbr1 & TTBR_ASID_MASK) >> 48) <= 1) {
+	// 	return 0;
+	// }
+	error_addr = read_sysreg(elr_el1);
+	if ((error_addr >= (unsigned long)__iee_si_data_start) && (error_addr <= (unsigned long)__iee_si_text_end))
+	{	
+		unsigned long esr = read_sysreg(esr_el1);
+		asm volatile("mrs %0, ttbr1_el1\n":"=r"(asid):);
+    	asid &= ~USER_ASID_FLAG;
+    	asid &= TTBR_ASID_MASK;
+		write_sysreg(koi_swapper_ttbr1 | asid, ttbr1_el1);
+		isb();
+		printk(KERN_ERR "IEE SI: Error on switch to kernel. ELR_EL1:0x%llx, ESR_EL1:0x%llx, TTBR1:0x%llx", error_addr, esr, curr_ttbr1);
+	}
+	else{
+		iee_rwx_gate_entry(IEE_SWITCH_TO_KERNEL);
+	}
+	return 1;
+}
+#endif
+/**
+* koi_save_ttbr - save ttbr of each driver module
+* @mod: driver module
+* @pgdp:pointer to driver module top page table,pgd
+*/
+static void koi_save_ttbr(struct module *mod, pgd_t *pgdp,
+			  struct koi_mem_hash_node *node)
+{
+	phys_addr_t ttbr1 = phys_to_ttbr(virt_to_phys(pgdp));
+	if (system_supports_cnp())
+		ttbr1 |= TTBR_CNP_BIT;
+	node->ko_ttbr1 = ttbr1;
+}
+/**
+*kio_normal_page - to obtain the pointer of the corresponding struct page structure
+*from a given page table entry(pte) 
+*/
+struct page *koi_normal_page(pte_t pte)
+{
+	unsigned long pfn = pte_pfn(pte);
+
+	if (IS_ENABLED(CONFIG_ARCH_HAS_PTE_SPECIAL)) {
+		if (likely(!pte_special(pte)))
+			goto check_pfn;
+		if (is_zero_pfn(pfn)) {
+			// printk(KERN_ERR "zero pfn found! pte=0x%16llx\n", pte);
+			return NULL;
+		}
+		// if (pte_devmap(pte)) {
+		// 	// printk(KERN_ERR "pte for dev found! pte=0x%16llx\n",
+		// 	//        pte);
+		// 	return NULL;
+		// }
+		// return NULL;
+	}
+
+check_pfn:
+	return pfn_to_page(pfn);
+}
+
+/**
+ * Copy one pte. Returns 0 if succeeded, or -EAGAIN if one preallocated page 
+ * is required to copy this pte.
+*/
+static inline int koi_copy_present_pte(struct mm_struct *ko_mm, pte_t *dst_pte, pte_t *src_pte,
+				       unsigned long addr)
+{
+	pte_t pte = *src_pte;
+	struct page *page;
+
+	page = koi_normal_page(pte);
+	if (!page) {
+		printk(KERN_ERR "pte_page unavailable. Impossible.....\n");
+		return -1;
+	}
+    // printk(KERN_ERR "addr=0x%16llx, dst_pte=0x%16llx\n", addr, dst_pte);
+    #ifdef CONFIG_IEE
+    if ((pte_val(pte) & PTE_USER) && (pte_val(pte) & PTE_DBM) && !(pte_val(pte) & PTE_PXN)) {
+        set_pte(dst_pte, __pte(pte_val(pte) & (~PTE_DBM) | PTE_RDONLY));
+    } else {
+    #endif
+        set_pte(dst_pte, pte);
+    #ifdef CONFIG_IEE 
+    }
+	#endif
+	return 0;
+}
+/**
+* copy huge pmd from kernel space to driver space. 
+*/
+static int koi_copy_huge_pmd(struct mm_struct *ko_mm, pmd_t *dst_pmd,
+			     pmd_t *src_pmd, unsigned long addr)
+{
+	spinlock_t *src_ptl, *dst_ptl;
+	pmd_t pmd;
+	int ret = -ENOMEM;
+    debug_printk("hugepmd: src_pmd=0x%16llx, dst_pmd=0x%16llx, src_pmd_val=0x%16llx, dst_pmd_val=0x%16llx, addr=0x%16llx\n", 
+        src_pmd, dst_pmd, pmd_val(*src_pmd), pmd_val(*dst_pmd), addr);
+    dst_ptl = pmd_lockptr(ko_mm, dst_pmd);
+	src_ptl = pmd_lockptr(&init_mm, src_pmd);
+    spin_lock_bh(dst_ptl);
+	spin_lock_bh(src_ptl);
+
+	pmd = *src_pmd;
+
+	set_pte((pte_t *)dst_pmd, pmd_pte(pmd));
+	ret = 0;
+	spin_unlock_bh(src_ptl);
+    spin_unlock_bh(dst_ptl);
+    return ret;
+}
+
+int __koi_pte_alloc(struct mm_struct *mm, pmd_t *pmd)
+{
+	spinlock_t *ptl;
+	// pgtable_t new = alloc_page(GFP_PGTABLE_KERNEL);
+    pte_t *new = pte_alloc_one_kernel(mm);
+    printk(KERN_ERR "alloc new=0x%16llx\n", new);
+	if (!new)
+		return -ENOMEM;
+
+	/*
+	 * Ensure all pte setup (eg. pte page lock and page clearing) are
+	 * visible before the pte is made visible to other CPUs by being
+	 * put into page tables.
+	 *
+	 * The other side of the story is the pointer chasing in the page
+	 * table walking code (when walking the page table without locking;
+	 * ie. most of the time). Fortunately, these data accesses consist
+	 * of a chain of data-dependent loads, meaning most CPUs (alpha
+	 * being the notable   exception) will already guarantee loads are
+	 * seen in-order. See the alpha page table accessors for the
+	 * smp_rmb() barriers in page table walking code.
+	 */
+	smp_wmb(); /* Could be smp_wmb__xxx(before|after)_spin_lock */
+
+	ptl = pmd_lockptr(mm, pmd);
+    spin_lock_bh(ptl);
+	if (likely(pmd_none(*pmd))) {	/* Has another populated it ? */
+        mm_inc_nr_ptes(mm);
+		pmd_populate_kernel(mm, pmd, new);
+		new = NULL;
+	}
+	spin_unlock_bh(ptl);
+	if (new) {
+    	pte_free_kernel(mm, new);
+    }
+	return 0;
+}
+
+#define koi_pte_alloc(mm, pmd) (unlikely(pmd_none(*(pmd))) && __koi_pte_alloc(mm, pmd))
+
+#define koi_pte_offset_map_lock(mm, pmd, address, ptlp)	\
+({							\
+	spinlock_t *__ptl = pte_lockptr(mm, pmd);	\
+	pte_t *__pte = pte_offset_map(pmd, address);	\
+	*(ptlp) = __ptl;				\
+	spin_lock_bh(__ptl);				\
+	__pte;						\
+})
+
+#define koi_pte_alloc_map_lock(mm, pmd, address, ptlp)	\
+	(koi_pte_alloc(mm, pmd) ?			\
+		 NULL : koi_pte_offset_map_lock(mm, pmd, address, ptlp))
+
+/**
+*koi_copy_pte_range - copy pte from kernel space to driver space
+*/
+static int koi_copy_pte_range(struct mm_struct *ko_mm, pmd_t *dst_pmd,
+			      pmd_t *src_pmd, unsigned long addr,
+			      unsigned long end)
+{
+	pte_t *src_pte, *dst_pte;
+	spinlock_t *src_ptl, *dst_ptl;
+    struct page* page;
+	int ret = 0;
+again:
+	dst_pte = koi_pte_alloc_map_lock(ko_mm, dst_pmd, addr, &dst_ptl);
+	if (!dst_pte) {
+		ret = -ENOMEM;
+		goto unlock;
+	}
+	src_pte = pte_offset_map(src_pmd, addr);
+	src_ptl = pte_lockptr(&init_mm, src_pmd);
+    spin_lock_bh(src_ptl);
+	do {
+		if (pte_none(*src_pte))
+			continue;
+		if (unlikely(!pte_present(*src_pte))) {
+            printk(KERN_ERR "present pte found: addr=0x%16llx, end=0x%16llx\n", addr, end);
+    		continue;
+        }
+        if (pte_valid(*dst_pte)) {
+            continue;
+        }
+		/* koi_copy_present_pte() will clear `*prealloc` if consumed */
+		ret = koi_copy_present_pte(ko_mm, dst_pte, src_pte, addr);
+		debug_printk("dst_pte=0x%16llx, dst_pte_val=0x%16llx, src_pte=0x%16llx, src_pte_val=0x%16llx, addr=0x%16llx\n",dst_pte, pte_val(*dst_pte), src_pte, pte_val(*src_pte), addr);
+        if (unlikely(ret == -EAGAIN))
+			break;
+	} while (dst_pte++, src_pte++, addr += PAGE_SIZE, addr != end);
+    spin_unlock_bh(src_ptl);
+    spin_unlock_bh(dst_ptl);
+
+	if (ret) {
+		WARN_ON_ONCE(ret != -EAGAIN);
+		ret = 0;
+	}
+	if (addr != end)
+		goto again;
+
+    return ret;
+unlock:
+    spin_unlock_bh(dst_ptl);
+	return ret;
+}
+
+int __koi_pmd_alloc(struct mm_struct *mm, pud_t *pud, unsigned long address)
+{
+	spinlock_t *ptl;
+	// struct page* page = alloc_page(GFP_PGTABLE_KERNEL);
+    // pmd_t *new = (pmd_t *)page_address(page);
+    pmd_t *new = pmd_alloc_one(mm, address);
+	if (!new)
+		return -ENOMEM;
+
+	smp_wmb(); /* See comment in __pte_alloc */
+
+	ptl = pud_lockptr(mm, pud);
+    spin_lock_bh(ptl);
+	if (!pud_present(*pud)) {
+		mm_inc_nr_pmds(mm);
+		pud_populate(mm, pud, new);
+	} else { /* Another has populated it */
+		pmd_free(mm, new);
+        // free_page((unsigned long)new);
+    }
+	spin_unlock_bh(ptl);
+	return 0;
+}
+
+static inline pmd_t *koi_pmd_alloc(struct mm_struct *mm, pud_t *pud, unsigned long address)
+{
+	return (unlikely(pud_none(*pud)) && __koi_pmd_alloc(mm, pud, address))?
+		NULL: pmd_offset(pud, address);
+}
+
+/**
+*kio_copy_pmd_range - copy pmd from kernel to driver space
+*/
+static inline int koi_copy_pmd_range(struct mm_struct *ko_mm, pud_t *dst_pud,
+				     pud_t *src_pud, unsigned long addr,
+				     unsigned long end)
+{
+	pmd_t *src_pmd, *dst_pmd;
+	unsigned long next, flag;
+	int err;
+    debug_printk("copy_pud_range src_pud=0x%16llx, dst_pud=0x%16llx, addr=0x%16llx, end=0x%16llx\n", src_pud, dst_pud, addr, end);
+	dst_pmd = koi_pmd_alloc(ko_mm, dst_pud, addr);
+	if (!dst_pmd) {
+		return -ENOMEM;  
+	}
+	src_pmd = pmd_offset(src_pud, addr);
+	do {
+		next = pmd_addr_end(addr, end);
+        flag = pmd_val(*src_pmd) & KOI_FLAG_MASK;
+        // debug_printk("src_pmd=0x%16llx, dst_pmd=0x%16llx, addr=0x%16llx\n", src_pmd, dst_pmd, next);
+		// CONFIG_TRANSPARENT_HUGEPAGE is enabled, so we must add copy_huge_pmd
+		if (pmd_none(*src_pmd))
+            continue;
+        if (!(pmd_val(*src_pmd) & PMD_TABLE_BIT)) {
+            // if src_pmd is huge page
+            debug_printk("src_pmd=0x%16llx, dst_pmd=0x%16llx, addr=0x%16llx\n", src_pmd, dst_pmd, addr);
+			err = koi_copy_huge_pmd(ko_mm, dst_pmd, src_pmd, addr);
+			if (err == -ENOMEM)
+				return -ENOMEM;
+			continue;
+		}
+		if (koi_copy_pte_range(ko_mm, dst_pmd, src_pmd, addr, next))
+			return -ENOMEM;
+        set_pmd(dst_pmd, __pmd(pmd_val(*dst_pmd) | flag));
+        debug_printk("src_pmd_val=0x%16llx, dst_pmd_val=0x%16llx, addr=0x%16llx\n", pmd_val(*src_pmd), pmd_val(*dst_pmd), addr);
+	} while (dst_pmd++, src_pmd++, addr = next, addr != end);
+	return 0;
+}
+
+int __koi_pud_alloc(struct mm_struct *mm, p4d_t *p4d, unsigned long address)
+{
+	// pud_t *new = pud_alloc_one(mm, address);
+
+    // struct page *page = alloc_page(GFP_PGTABLE_KERNEL);
+    // pud_t *new = (pud_t *)page_address(page);
+    pud_t *new = pud_alloc_one(mm, address);
+	printk(KERN_ERR "pud alloc pud=0x%16llx\n", new);
+    if (!new)
+		return -ENOMEM;
+
+	smp_wmb(); /* See comment in __pte_alloc */
+
+	spin_lock_bh(&mm->page_table_lock);
+	if (!p4d_present(*p4d)) {
+		mm_inc_nr_puds(mm);
+		p4d_populate(mm, p4d, new);
+	} else	{/* Another has populated it */
+        printk(KERN_ERR "free pud=0x%16llx\n", new);
+    	pud_free(mm, new);
+        // free_page((unsigned long)new);
+    }
+	spin_unlock_bh(&mm->page_table_lock);
+	return 0;
+}
+
+static inline pud_t *koi_pud_alloc(struct mm_struct *mm, p4d_t *p4d,
+		unsigned long address)
+{
+	return (unlikely(p4d_none(*p4d)) && __koi_pud_alloc(mm, p4d, address)) ?
+		NULL : pud_offset(p4d, address);
+}
+
+static int koi_copy_huge_pud(struct mm_struct *ko_mm, pud_t *dst_pud, pud_t *src_pud, unsigned long addr) {
+    spinlock_t *src_ptl, *dst_ptl;
+    // pmd_t pmd;
+    int ret = -ENOMEM;
+    debug_printk("src_pud=0x%16llx, dst_pud=0x%16llx, addr=0x%16llx\n", src_pud, dst_pud, addr);
+    dst_ptl = pud_lockptr(ko_mm, dst_pud);    
+    src_ptl = pud_lockptr(&init_mm, src_pud);
+    spin_lock_bh(dst_ptl);
+    spin_lock_bh(src_ptl);
+    set_pte((pte_t *)dst_pud, __pte(pud_val(*src_pud)));
+    spin_unlock_bh(src_ptl);
+    spin_unlock_bh(dst_ptl);
+    ret = 0;
+    return ret;
+}
+
+/**
+*koi_copy_pud_range - copy pud from kernel to driver
+*/
+static inline int koi_copy_pud_range(struct mm_struct *ko_mm, p4d_t *dst_p4d,
+				     p4d_t *src_p4d, unsigned long addr,
+				     unsigned long end)
+{
+	pud_t *src_pud, *dst_pud;
+	unsigned long next, flag;
+	dst_pud = koi_pud_alloc(ko_mm, dst_p4d, addr);
+	if (!dst_pud)
+		return -ENOMEM;
+	src_pud = pud_offset(src_p4d, addr);
+	do {
+        next = pud_addr_end(addr, end);
+        flag = pud_val(*src_pud) & KOI_FLAG_MASK;
+		debug_printk("src_pud=0x%16llx, dst_pud=0x%16llx, addr=0x%16llx\n", src_pud, dst_pud, next);
+        if (pud_none(*src_pud)) {
+            continue;
+        }
+        if (!(pud_val(*src_pud) & PMD_TABLE_BIT)) {
+            // indicates that the src_pud maps to a huge page
+            koi_copy_huge_pud(ko_mm, dst_pud, src_pud, addr);
+            continue;
+        }
+        // if (pud_trans_huge(*src_pud) || pud_devmap(*src_pud)) {
+        //     debug_printk("pud_trans_huge=%d, pud_devmap=%d, src_pud=0x%16llx\n", pud_trans_huge(*src_pud) , pud_devmap(*src_pud), src_pud);
+		// 	continue;
+		// 	/* fall through */
+		// }
+		if (koi_copy_pmd_range(ko_mm, dst_pud, src_pud, addr, next))
+			return -ENOMEM;
+        set_pud(dst_pud, __pud(pud_val(*dst_pud) | flag));
+	} while (dst_pud++, src_pud++, addr = next, addr != end);
+	return 0;
+}
+
+/**
+* koi_copy_p4d_range - map the kernel pagetable to the driver space level by level
+* @ko_mm: the mm_struct of driver module
+* @dst_pgd: destination pgd 
+* @src_pgd: source pgd
+* @addr: the start of address
+* @end:  the end of  address
+*/
+static inline int koi_copy_p4d_range(struct mm_struct *ko_mm, pgd_t *dst_pgd,
+				     pgd_t *src_pgd, unsigned long addr,
+				     unsigned long end)
+{
+	p4d_t *src_p4d, *dst_p4d;
+	unsigned long next;
+	dst_p4d = p4d_alloc(ko_mm, dst_pgd, addr);
+	if (!dst_p4d)
+		return -ENOMEM;
+	src_p4d = p4d_offset(src_pgd, addr);
+	do {
+		next = p4d_addr_end(addr, end);
+		if (p4d_none(*src_p4d) || p4d_bad(*src_p4d))
+			continue;
+        debug_printk(KERN_ERR "dst_p4d=0x%16llx, dst_p4d_val=0x%16llx\n", dst_p4d, p4d_val(*dst_p4d));
+		if (koi_copy_pud_range(ko_mm, dst_p4d, src_p4d, addr, next)) {
+			return -ENOMEM;
+		}
+	} while (dst_p4d++, src_p4d++, addr = next, addr != end);
+	return 0;
+}
+
+/**
+*int koi_copy_pagetable - map the address range from "addr" to "end" to the driver pagetable
+*@ko_mm: the mm_struct of the driver module
+*@koi_pg_dir: koi_pg_dir, related to the driver module, the entry for driver pagetable
+*@addr: the starting address of mapping zone
+*@end:  the end address of mapping zone
+*/
+int koi_copy_pagetable(struct mm_struct *ko_mm, pgd_t *koi_pg_dir,
+		       unsigned long addr, unsigned long end)
+{
+	int ret = 0;
+	unsigned long next;
+
+	pgd_t *src_pgd, *dst_pgd;
+    unsigned long flag;
+	src_pgd = pgd_offset_pgd(swapper_pg_dir, addr);
+	dst_pgd = pgd_offset_pgd(koi_pg_dir, addr);
+	do {
+        flag = pgd_val(*src_pgd) & KOI_FLAG_MASK;
+		next = pgd_addr_end(addr, end);
+		if (pgd_none(*src_pgd) || pgd_bad(*src_pgd))
+			continue;
+		if (unlikely(koi_copy_p4d_range(ko_mm, dst_pgd, src_pgd, addr,
+						next))) {
+			ret = -ENOMEM;
+			break;
+		}
+        set_pgd(dst_pgd, __pgd(pgd_val(*dst_pgd) | flag));
+	} while (dst_pgd++, src_pgd++, addr = next, addr != end);
+
+	return ret;
+}
+
+void koi_set_rdonly(unsigned long addr, pgd_t *pgdir)
+{
+	p4d_t *p4dp;
+	pud_t *pudp;
+	pmd_t *pmdp;
+	pte_t *ptep;
+	pgd_t *pgdp = pgd_offset_pgd(pgdir, addr);
+	if (pgd_none(*pgdp) || pgd_bad(*pgdp)) {
+		return;
+	}
+
+	p4dp = p4d_offset(pgdp, addr);
+	if (p4d_none(*p4dp) || p4d_bad(*p4dp)) {
+		return;
+	}
+
+	pudp = pud_offset(p4dp, addr);
+	if (pud_none(*pudp) || pud_bad(*pudp)) {
+		return;
+	}
+	pmdp = pmd_offset(pudp, addr);
+	if (pmd_none(*pmdp) || pmd_bad(*pmdp)) {
+		return;
+	}
+
+	ptep = pte_offset_kernel(pmdp, addr);
+	if (pte_none(*ptep)) {
+		// printk(KERN_ERR "ptep 0x%16llx not available\n", ptep);
+		return;
+	}
+	set_pte(ptep, __pte(pte_val(*ptep) | PTE_RDONLY));
+	// printk(KERN_ERR "set_readonly successfully\n");
+	return;
+}
+
+void koi_unmap_pte_table(struct mm_struct *ko_mm, pmd_t *pmd, unsigned long addr, unsigned long end) {
+    pte_t *pte;
+    if (!pmd)
+        return;
+    debug_printk("pmd=0x%16llx, addr=0x%16llx, end=0x%16llx\n", pmd, addr, end);
+    
+    // struct page *page = pte_page(*pte);
+    // printk(KERN_ERR "pte=0x%16llx, pte_val=0x%16llx\n", pte, pte_val(*pte));
+    // debug_printk("free pte table 0x%16llx, pmd=0x%16llx, page=0x%16llx, pmd points to page=0x%16llx\n", pte, pmd, page, pte_page(pmd_pte(*pmd)));
+    // printk(KERN_ERR "pmd_pfn=0x%16llx, pte_pfn=0x%16llx\n", pmd_pfn(*pmd), pte_pfn(*pte));
+    // pte_free(ko_mm, pte_page(pmd_pte(*pmd)));
+    do {
+        pte = pte_offset_kernel(pmd, addr);
+        debug_printk("pte=0x%16llx, pte_val=0x%16llx\n", pte, pte_val(*pte));
+        set_pte(pte, __pte(0));
+    } while (addr += PAGE_SIZE, addr != end);
+}
+
+void koi_unmap_pmd_range(struct mm_struct *ko_mm, pud_t *pud, unsigned long addr, unsigned long end) {
+    pmd_t *pmd, *orig_pmd;
+    unsigned long next;
+    if (!pud)
+        return;
+    orig_pmd = pmd_offset(pud, addr);
+    pmd = orig_pmd;
+    debug_printk("pud=0x%16llx, addr=0x%16llx, end=0x%16llx\n", pud, addr, end);
+    // printk(KERN_ERR "pud_pfn=0x%16llx, pmd_pfn=0x%16llx\n", pud_pfn(*pud), pmd_pfn(*pmd));
+    do {
+        // printk(KERN_ERR "pmd=0x%16llx, pmd_val=0x%16llx\n", pmd, pmd_val(*pmd));
+        next = pmd_addr_end(addr, end);
+        if (pmd_none_or_clear_bad(pmd))
+            continue;
+        koi_unmap_pte_table(ko_mm, pmd, addr, next);
+    } while(pmd++, addr = next, addr != end);
+}
+
+void koi_unmap_pud_range(struct mm_struct *ko_mm, p4d_t *p4d, unsigned long addr, unsigned long end) {
+    pud_t *pud, *orig_pud;
+    unsigned long next;
+    if (!p4d)
+        return;
+    orig_pud = pud_offset(p4d, addr);
+    pud = orig_pud;
+    debug_printk("p4d=0x%16llx, addr=0x%16llx, end=0x%16llx\n", p4d, addr, end);
+    do {
+        // printk(KERN_ERR "pud=0x%16llx, pud_val=0x%16llx\n", pud, pud_val(*pud));
+        next = pud_addr_end(addr, end);
+        if (pud_none_or_clear_bad(pud)) {
+            // if pud points to a huge page, just clear and skip it.
+            continue;
+        }
+        koi_unmap_pmd_range(ko_mm, pud, addr, next);
+    } while (pud++, addr = next, addr != end);
+    debug_printk("free pud 0x%16llx, p4d=0x%16llx, orig_pud=0x%16llx\n", pud, p4d, orig_pud);
+    // pud_free(ko_mm, (unsigned long)orig_pud & PAGE_MASK);
+}
+
+void koi_unmap_p4d_range(struct mm_struct *ko_mm, pgd_t *pgd, unsigned long addr, unsigned long end) {
+    p4d_t *p4d, *orig_p4d;
+    unsigned long next;
+    if (!pgd)
+        return;
+    debug_printk("pgd=0x%16llx, addr=0x%16llx, end=0x%16llx\n", pgd, addr, end);
+    orig_p4d = p4d_offset(pgd, addr);
+    p4d = orig_p4d;
+    do {
+        next = p4d_addr_end(addr, end);
+        // printk(KERN_ERR "p4d=0x%16llx, p4d_val=0x%16llx, p4d_none=%d\n", p4d, p4d_val(*p4d), p4d_none(*p4d));
+        if (p4d_none_or_clear_bad(p4d)) {
+            // printk(KERN_ERR "p4d none=%d, p4d_bad=%d\n", p4d_none(*p4d), p4d_bad(*p4d));
+            continue;
+        }
+        koi_unmap_pud_range(ko_mm, p4d, addr, next);
+    } while (p4d++, addr = next, addr != end);
+}
+
+void koi_unmap_pagetable(struct mm_struct *ko_mm, pgd_t *ko_pg_dir, unsigned long addr, unsigned long end) {
+    unsigned long next;
+    pgd_t *pgd = pgd_offset_pgd(ko_pg_dir, addr);
+    debug_printk("freepagetable addr=0x%16llx, end=0x%16llx\n", addr, end);
+    do {
+        next = pgd_addr_end(addr, end);
+        // printk(KERN_ERR "pgd=0x%16llx, pgd_val=0x%16llx\n", pgd, pgd_val(*pgd));
+        if (pgd_none_or_clear_bad(pgd)) {
+            // printk(KERN_ERR "pgd none\n");
+            continue;
+        }
+        koi_unmap_p4d_range(ko_mm, pgd, addr, next);
+    } while (pgd++, addr = next, addr != end);
+}
+
+void koi_remove_pte_range(struct mm_struct *ko_mm, pgd_t *ko_pg_dir, pmd_t *pmd) {
+    pte_t *pte = (pte_t *)pmd_page_vaddr(*pmd);
+    debug_printk("pte=0x%16llx, page=0x%16llx, pmd=0x%16llx, pmd_val=0x%16llx\n", pte, pte_page(pmd_pte(*pmd)), pmd, pmd_val(*pmd));
+    // printk(KERN_ERR "pte=0x%16llx, pte_val=0x%16llx, pte_page=0x%16llx\n", pte, pte_val(*pte), pte_page(*pte));
+    printk(KERN_ERR "free orig_pte=0x%16llx\n", pte);
+    pte_free_kernel(ko_mm, pte);
+    // __free_page((unsigned long)pte_page(pmd_pte(*pmd)));
+    // free_page((unsigned long)pte);
+}
+
+void koi_remove_pmd_range(struct mm_struct *ko_mm, pgd_t *ko_pg_dir, pud_t *pud) {
+    pmd_t *orig_pmd = pud_pgtable(*pud);
+    pmd_t *pmd;
+    int i;
+    for (i = 0; i < PTRS_PER_PMD; i++) {
+        pmd = orig_pmd + i;
+        if (pmd_none(*pmd) || pmd_bad(*pmd))
+            continue;
+        debug_printk("pmd=0x%16llx, pmd_val=0x%16llx\n", pmd, pmd_val(*pmd));
+        koi_remove_pte_range(ko_mm, ko_pg_dir, pmd);
+    }
+    debug_printk("free pmd=0x%16llx, page=0x%16llx\n", orig_pmd, pte_page(pud_pte(*pud)));
+    printk(KERN_ERR "free orig_pmd=0x%16llx\n", orig_pmd);
+    pmd_free(ko_mm, orig_pmd);
+    // free_page((unsigned long)orig_pmd);
+}
+
+void koi_remove_pud_range(struct mm_struct *ko_mm, pgd_t *ko_pg_dir, p4d_t *p4d) {
+    pud_t *orig_pud = p4d_pgtable(*p4d);
+    pud_t *pud;
+    int i;
+    for (i = 0; i < PTRS_PER_PUD; i++) {
+        pud = orig_pud + i;
+        if (pud_none(*pud) || pud_bad(*pud))
+            continue;
+        debug_printk("pud=0x%16llx, pud_val=0x%16llx\n", pud, pud_val(*pud));
+        koi_remove_pmd_range(ko_mm, ko_pg_dir, pud);
+    }
+    debug_printk("free pud=0x%16llx, page=0x%16llx\n", orig_pud, pte_page(p4d_pte(*p4d)));
+    printk(KERN_ERR "free orig_pud=0x%16llx\n", orig_pud);
+    pud_free(ko_mm, orig_pud);
+    // free_page((unsigned long)orig_pud);
+}
+
+void koi_remove_pagetable(struct mm_struct *ko_mm, pgd_t *ko_pg_dir) {
+    pgd_t *pgd;
+    int i;
+    for (i = 0; i < PTRS_PER_PGD; i++) {
+        pgd = ko_pg_dir + i;
+        if (p4d_none(*(p4d_t *)pgd) || p4d_bad(*(p4d_t *)pgd)) 
+            continue;
+        debug_printk("pgd=0x%16llx, pgd_val=0x%16llx\n", pgd, pgd_val(*pgd));    
+        koi_remove_pud_range(ko_mm, ko_pg_dir, (p4d_t *)pgd);
+    }
+    debug_printk("free pgd=0x%16llx\n", ko_pg_dir);
+    pgd_free(ko_mm, ko_pg_dir);
+    flush_tlb_all();
+}
+
+void koi_destroy_pagetable(struct module *mod)
+{
+    // int cpu;
+    // unsigned long *ptr;
+	struct koi_mem_hash_node *target = NULL;
+	struct koi_mem_list *mem_node;
+	struct koi_addr_map *addr_map_node;
+    unsigned long bkt;
+    unsigned long vbar;
+    unsigned long flags;
+    asm volatile("mrs %0, VBAR_EL1\n" : "=r"(vbar) :);
+	rcu_read_lock();
+	hash_for_each_possible_rcu (koi_mem_htbl, target, node,
+				    (unsigned long)mod) {
+		if (target->mod == mod) {
+			break;
+		}
+	}
+	rcu_read_unlock();
+	if (target == NULL) {
+		// printk(KERN_ERR "mem node for module: %s not found, maybe destroyed before?\n",
+		// 	mod->name);
+		return;
+	}
+    spin_lock_irqsave(&target->mod_lock, flags);
+    target->is_valid = false;
+    spin_unlock_irqrestore(&target->mod_lock, flags);
+
+    spin_lock_irqsave(&koi_mem_htbl_spin_lock, flags);
+	hash_del_rcu(&target->node);
+	call_rcu(&target->rcu, koi_mem_hash_node_free);
+	spin_unlock_irqrestore(&koi_mem_htbl_spin_lock, flags);
+
+	// free addr_htbl
+	spin_lock(&target->addr_htbl_spin_lock);
+	hash_for_each_rcu (target->addr_htbl, bkt, addr_map_node, node) {
+		hash_del_rcu(&addr_map_node->node);
+		call_rcu(&addr_map_node->rcu, koi_addr_map_node_free);
+	}
+	spin_unlock(&target->addr_htbl_spin_lock);
+    // free free mem list
+	spin_lock(&target->spin_lock);
+	list_for_each_entry_rcu (mem_node, &target->mem_list_head, list) {
+		list_del_rcu(&mem_node->list);
+		call_rcu(&mem_node->rcu, koi_mem_node_free);
+	}
+	spin_unlock(&target->spin_lock);
+
+    koi_remove_pagetable(target->ko_mm, target->ko_mm->pgd);
+    kfree(target->ko_mm);
+}
+
+/**
+* koi_create_pagetable - create pagetable for driver
+* @mod: driver module
+* 1.create a new koi_mem_hash_node  new_node
+* 2.create page table return the pgd address, init the new_node->pgdp
+* 3.create and init the new_node->ko_mm
+* 4.map swapper_ttbr1 to the newly created pagetable
+* 5.map the interrupt vector table to the newly created pagetable
+* 6.map the init_layout of the module
+* 7.map the core_layout of the module
+* 8.map switch_to_kernel_pgtable into driver view
+* 9.map share memory
+*/
+void koi_create_pagetable(struct module *mod)
+{
+	int ret = 0, cpu;
+	unsigned long vbar, addr, ttbr1;
+	pgd_t *pgdp;
+	unsigned long *ptr;
+	struct koi_mem_list *new_mem_node;
+	struct koi_mem_hash_node *new_node =
+		kzalloc(sizeof(struct koi_mem_hash_node), GFP_KERNEL);
+	if (!new_node) {
+		// printk(KERN_ERR "NULL new_node\n");
+		return;
+	};
+	if (koi_swapper_ttbr1 == 0) {
+		pgdp = lm_alias(swapper_pg_dir);
+		ttbr1 = phys_to_ttbr(virt_to_phys(pgdp));
+		if (system_supports_cnp() &&
+		    !WARN_ON(pgdp != lm_alias(swapper_pg_dir)))
+			ttbr1 |= TTBR_CNP_BIT;
+
+		koi_swapper_ttbr1 = ttbr1;
+		// __WRITE_ONCE(koi_swapper_ttbr1, ttbr1);
+		// koi_set_rdonly(&koi_swapper_ttbr1, swapper_pg_dir);
+	}
+	new_node->pgdp = koi_pgd_alloc();
+	new_node->ko_mm =
+		kzalloc(sizeof(struct mm_struct) +
+				sizeof(unsigned long) * BITS_TO_LONGS(NR_CPUS),
+			GFP_KERNEL);
+	init_ko_mm(new_node->ko_mm, new_node->pgdp);
+	new_node->mod = mod;
+	koi_save_ttbr(mod, new_node->pgdp, new_node);
+	debug_printk("copying koi_data, start=0x%16llx, end=0x%16llx\n",
+	       (unsigned long)__koi_data_start, (unsigned long)__koi_data_end);
+	// copy koi_swapper_ttbr1, which records page dir base for kernel view
+	koi_copy_pagetable(new_node->ko_mm, new_node->pgdp,
+			   (unsigned long)__koi_data_start,
+			   (unsigned long)__koi_data_end);
+	asm volatile("mrs %0, VBAR_EL1\n" : "=r"(vbar) :);
+
+	// copy interrupt vectors
+    debug_printk("copying interrupt vectors, start=0x%16llx, end=0x%16llx\n",
+	       vbar & PAGE_MASK, (vbar + PAGE_SIZE - 1) & PAGE_MASK);
+	koi_copy_pagetable(new_node->ko_mm, new_node->pgdp, vbar & PAGE_MASK,
+			   (vbar + PAGE_SIZE - 1) & PAGE_MASK);
+
+	// copy module init_layout, which contains init data and text in driver
+    debug_printk("copying init_layout, start=0x%16llx, end=0x%16llx\n",
+	       (unsigned long)mod->init_layout.base,  (unsigned long)mod->init_layout.base + mod->init_layout.size);
+	ret = koi_copy_pagetable(new_node->ko_mm, new_node->pgdp,
+				 (unsigned long)mod->init_layout.base,
+				 (unsigned long)mod->init_layout.base +
+					 mod->init_layout.size);
+	if (ret != 0)
+		printk(KERN_ERR
+		       "\033[33mError occur when copying init_layout, Eno:%d\033[0m\n",
+		       ret);
+
+	// copy module core_layout, which contains non-init data and text in driver
+    debug_printk(KERN_ERR "copying core_layout, start=0x%16llx, end=0x%16llx\n",
+	       (unsigned long)mod->core_layout.base,  (unsigned long)mod->core_layout.base + mod->core_layout.size);
+	ret = koi_copy_pagetable(new_node->ko_mm, new_node->pgdp,
+				 (unsigned long)mod->core_layout.base,
+				 (unsigned long)mod->core_layout.base +
+					 mod->core_layout.size);
+	if (ret != 0)
+		printk(KERN_ERR
+		       "\033[33mError occur when copying core_layout, Eno: %d\033[0m\n",
+		       ret);
+
+    
+	// mapping switch_to_kernel_pgtable into driver view, which is used to switch to kernel view when entering INT
+    debug_printk("copying core_layout, start=0x%16llx, end=0x%16llx\n",
+	       (unsigned long)__koi_code_start,  (unsigned long)__koi_code_end);
+	koi_copy_pagetable(new_node->ko_mm, new_node->pgdp,
+			   (unsigned long)__koi_code_start,
+			   (unsigned long)__koi_code_end);
+
+	for_each_possible_cpu (cpu) {
+		ptr = per_cpu(irq_stack_ptr, cpu);
+		debug_printk(
+		       "\033[33mirq_stack_ptr on cpu %d addr=0x%16llx, end=0x%16llx\033[0m\n",
+		       cpu, (unsigned long)ptr,
+		       (unsigned long)ptr + IRQ_STACK_SIZE);
+		koi_copy_pagetable(new_node->ko_mm, new_node->pgdp,
+				   (unsigned long)ptr,
+				   (unsigned long)ptr + IRQ_STACK_SIZE);
+	}
+
+	for_each_possible_cpu (cpu) {
+		ptr = per_cpu(koi_irq_current_ttbr1, cpu);
+		debug_printk(
+		       "\033[33mirq_current_ptr on cpu %d addr=0x%16llx, end=0x%16llx\033[0m\n",
+		       cpu, (unsigned long)ptr, (unsigned long)ptr + PAGE_SIZE);
+		koi_copy_pagetable(new_node->ko_mm, new_node->pgdp,
+				   (unsigned long)ptr,
+				   (unsigned long)ptr + PAGE_SIZE);
+	}
+
+#ifdef CONFIG_IEE
+    debug_printk(
+		       "\033[33miee_si addr=0x%16llx, end=0x%16llx\033[0m\n",
+		       (unsigned long)__iee_si_data_start, (unsigned long)__iee_si_text_end);
+	// mapping iee_rwx_gate_entry and iee_si_base to ko's pagetable
+	koi_copy_pagetable(new_node->ko_mm, new_node->pgdp,
+			   (unsigned long)__iee_si_data_start,
+			   (unsigned long)__iee_si_text_end);
+    debug_printk(
+		       "\033[33miee_si mapping finished\n");
+#endif
+
+	// alloc 16KB memory for new ko, and add it into hashtable
+	addr = (unsigned long)kmalloc(THREAD_SIZE, GFP_KERNEL);
+	if ((void *)addr == NULL) {
+		printk(KERN_ERR "alloc buffer error\n");
+	}
+    debug_printk(
+		       "\033[33mcopying buffer, start=0x%16llx, end=0x%16llx\033[0m\n",
+		       addr, addr + THREAD_SIZE);
+	koi_copy_pagetable(new_node->ko_mm, new_node->pgdp, addr,
+			   addr + THREAD_SIZE);
+#ifdef CONFIG_IEE
+    iee_rw_gate(IEE_SET_KOI_PGD, new_node->ko_mm->pgd);
+#endif
+	new_mem_node = kmalloc(sizeof(struct koi_mem_list), GFP_KERNEL);
+	if (new_mem_node == NULL) {
+		printk(KERN_ERR "alloc new_mem_node error\n");
+	}
+	new_mem_node->addr = addr;
+	new_mem_node->size = THREAD_SIZE;
+
+	new_node->mem_list_head =
+		(struct list_head)LIST_HEAD_INIT(new_node->mem_list_head);
+	hash_init(new_node->addr_htbl);
+	spin_lock_init(&new_node->addr_htbl_spin_lock);
+	spin_lock_init(&new_node->spin_lock);
+    spin_lock_init(&new_node->mod_lock);
+    new_node->is_valid = true;
+
+	spin_lock(&new_node->spin_lock);
+	list_add_rcu(&new_mem_node->list, &new_node->mem_list_head);
+	spin_unlock(&new_node->spin_lock);
+
+	spin_lock(&koi_mem_htbl_spin_lock);
+	hash_add_rcu(koi_mem_htbl, &new_node->node,
+		     (unsigned long)new_node->mod);
+	spin_unlock(&koi_mem_htbl_spin_lock);
+    
+    // printk(KERN_DEBUG "mod=0x%16llx, end=0x16llx\n", mod, (unsigned long)mod + sizeof(struct module));
+    // printk(KERN_ERR "koi create pagetable pgd=0x%16llx\n", new_node->pgdp);
+	// printk(KERN_ERR "koi mm=0x%16llx\n", (unsigned long)(new_node->ko_mm));
+}
+/**
+* koi_mem_alloc 
+*@mod: driver module
+*@orig_addr: the starting address of the parameter in kernel
+*@size: the size of the parameter
+*/
+unsigned long koi_mem_alloc(struct module *mod, unsigned long orig_addr,
+			    unsigned long size)
+{
+	struct koi_mem_hash_node *target = NULL;
+	struct koi_mem_list *mem_node;
+	struct koi_addr_map *new_addr_node;
+	unsigned long addr = 0, flags;
+	struct koi_mem_list *new_mem_node;
+	rcu_read_lock();
+	hash_for_each_possible_rcu (koi_mem_htbl, target, node,
+				    (unsigned long)mod) {
+		if (target->mod == mod) {
+			break;
+		}
+	}
+	rcu_read_unlock();
+	if (target == NULL) {
+		printk(KERN_ERR "mem node for module: %s not found\n",
+		       mod->name);
+		return 0;
+	}
+	spin_lock_irqsave(&target->spin_lock, flags);
+	list_for_each_entry_rcu (mem_node, &target->mem_list_head, list) {
+		if (mem_node->size >= size) {
+			addr = mem_node->addr;
+			mem_node->size -= size;
+			if (mem_node->size == 0) {
+				list_del_rcu(&mem_node->list);
+			} else {
+				new_mem_node =
+					kmalloc(sizeof(struct koi_mem_list),
+						GFP_ATOMIC);
+				new_mem_node->addr = addr + size;
+				new_mem_node->size = mem_node->size;
+				list_replace_rcu(&mem_node->list,
+						 &new_mem_node->list);
+			}
+			call_rcu(&mem_node->rcu, koi_mem_node_free);
+		}
+	}
+	spin_unlock_irqrestore(&target->spin_lock, flags);
+	if (!addr) {
+		addr = (unsigned long)kmalloc(THREAD_SIZE, GFP_KERNEL);
+		if ((void *)addr == NULL) {
+			return 0;
+		}
+		koi_copy_pagetable(target->ko_mm, target->pgdp, addr,
+				   addr + THREAD_SIZE);
+		mem_node = kmalloc(sizeof(struct koi_mem_list), GFP_KERNEL);
+		if (!mem_node) {
+			printk(KERN_ERR "NULL mem_node\n");
+		}
+		if (size > THREAD_SIZE) {
+			return 0;
+		}
+		mem_node->addr = addr + size;
+		mem_node->size = THREAD_SIZE - size;
+		spin_lock_irqsave(&target->spin_lock, flags);
+		list_add_tail_rcu(&mem_node->list, &target->mem_list_head);
+		spin_unlock_irqrestore(&target->spin_lock, flags);
+	}
+
+	new_addr_node = kzalloc(sizeof(struct koi_addr_map), GFP_KERNEL);
+	new_addr_node->buffer_addr = addr;
+	new_addr_node->orig_addr = orig_addr;
+	spin_lock_irqsave(&target->addr_htbl_spin_lock, flags);
+	hash_add_rcu(target->addr_htbl, &new_addr_node->node,
+		     new_addr_node->buffer_addr);
+	spin_unlock_irqrestore(&target->addr_htbl_spin_lock, flags);
+	return addr;
+}
+EXPORT_SYMBOL(koi_mem_alloc);
+// find the parameter pointer corresponding to the copy
+noinline void *koi_mem_lookup(struct module *mod, unsigned long addr)
+{
+	struct koi_mem_hash_node *target = NULL;
+	struct koi_addr_map *addr_map_node;
+	unsigned long orig_addr = addr;
+	rcu_read_lock();
+	hash_for_each_possible_rcu (koi_mem_htbl, target, node,
+				    (unsigned long)mod) {
+		if (target->mod == mod) {
+			break;
+		}
+	}
+	rcu_read_unlock();
+	if (target == NULL) {
+		printk(KERN_ERR "mem node for module: %s not found\n",
+		       mod->name);
+		return NULL;
+	}
+
+	rcu_read_lock();
+	hash_for_each_possible_rcu (target->addr_htbl, addr_map_node, node,
+				    orig_addr) {
+		if (addr_map_node->buffer_addr == addr) {
+			break;
+		}
+	}
+	rcu_read_unlock();
+	if (addr_map_node) {
+		return (void *)(addr_map_node->orig_addr);
+	} else {
+		return NULL;
+	}
+}
+EXPORT_SYMBOL(koi_mem_lookup);
+/**
+* kio_mem_free - recycle a copy of the copied parameters and synchronize the parameters
+* @mod: driver module
+* @addr: the starting addr of parameter
+* @size: the size of the parameter
+* @is_const: const pointers or not
+* @count: contry the number of parameters
+*/
+noinline void koi_mem_free(struct module *mod, unsigned long addr,
+			   unsigned long size, bool is_const, int count, ...)
+{
+	struct koi_mem_hash_node *target = NULL;
+	struct koi_mem_list *mem_node;
+	struct list_head *pos = NULL;
+	struct koi_addr_map *addr_map_node;
+	unsigned long orig_size = size;
+	unsigned long orig_addr = addr;
+	va_list valist;
+	int i;
+	unsigned int offset;
+	unsigned long flags;
+	rcu_read_lock();
+	hash_for_each_possible_rcu (koi_mem_htbl, target, node,
+				    (unsigned long)mod) {
+		if (target->mod == mod) {
+			break;
+		}
+	}
+	rcu_read_unlock();
+	if (target == NULL) {
+		printk(KERN_ERR "mem node for module: %s not found\n",
+		       mod->name);
+		return;
+	}
+
+	rcu_read_lock();
+	hash_for_each_possible_rcu (target->addr_htbl, addr_map_node, node,
+				    orig_addr) {
+		if (addr_map_node->buffer_addr == orig_addr) {
+			break;
+		}
+	}
+	rcu_read_unlock();
+	va_start(valist, count);
+	for (i = 0; i < count; i++) {
+		offset = va_arg(valist, int);
+		*(unsigned long *)(addr_map_node->buffer_addr + offset) =
+			*(unsigned long *)(addr_map_node->orig_addr + offset);
+	}
+	va_end(valist);
+	memcpy((void *)addr_map_node->orig_addr,
+	       (void *)addr_map_node->buffer_addr, orig_size);
+
+	spin_lock_irqsave(&target->addr_htbl_spin_lock, flags);
+	hlist_del_init_rcu(&addr_map_node->node);
+	call_rcu(&addr_map_node->rcu, koi_addr_map_node_free);
+	spin_unlock_irqrestore(&target->addr_htbl_spin_lock, flags);
+
+	spin_lock_irqsave(&target->spin_lock, flags);
+	list_for_each_entry_rcu (mem_node, &target->mem_list_head, list) {
+		if (mem_node->addr + mem_node->size == addr) {
+			pos = mem_node->list.prev;
+			addr = mem_node->addr;
+			size += mem_node->size;
+			list_del_rcu(&mem_node->list);
+			call_rcu(&mem_node->rcu, koi_mem_node_free);
+		} else if (addr + size == mem_node->addr) {
+			if (!pos)
+				pos = mem_node->list.prev;
+			size += mem_node->size;
+			list_del_rcu(&mem_node->list);
+			call_rcu(&mem_node->rcu, koi_mem_node_free);
+		} else if (addr + size < mem_node->addr) {
+			if (!pos)
+				pos = mem_node->list.prev;
+			break;
+		}
+	}
+	mem_node = kzalloc(sizeof(struct koi_mem_list), GFP_ATOMIC);
+	mem_node->addr = addr;
+	mem_node->size = size;
+	if (pos)
+		list_add_rcu(&mem_node->list, pos);
+	else
+		list_add_tail_rcu(&mem_node->list, &target->mem_list_head);
+	spin_unlock_irqrestore(&target->spin_lock, flags);
+}
+EXPORT_SYMBOL(koi_mem_free);
+/**
+* koi_mem_free_callback - used to recycle the copy of parameter.
+*@addr: the address of the parameter
+*@(*func)(void*): callback func, used to release the copy of the parameter pointer
+*/
+noinline void koi_mem_free_callback(struct module *mod, unsigned long addr,
+				    unsigned long size, void (*func)(void *))
+{
+	struct koi_mem_hash_node *target = NULL;
+	struct koi_mem_list *mem_node;
+	struct list_head *pos = NULL;
+	struct koi_addr_map *addr_map_node;
+	unsigned long flags;
+	unsigned long orig_size = size;
+	unsigned long orig_addr = addr;
+	rcu_read_lock();
+	hash_for_each_possible_rcu (koi_mem_htbl, target, node,
+				    (unsigned long)mod) {
+		if (target->mod == mod) {
+			break;
+		}
+	}
+	rcu_read_unlock();
+	if (target == NULL) {
+		// printk("mem node for module: %s not found\n", mod->name);
+		return;
+	}
+
+	rcu_read_lock();
+	hash_for_each_possible_rcu (target->addr_htbl, addr_map_node, node,
+				    orig_addr) {
+		if (addr_map_node->buffer_addr == orig_addr) {
+			break;
+		}
+	}
+	rcu_read_unlock();
+	if (addr_map_node != NULL) {
+		memcpy((void *)addr_map_node->orig_addr,
+		       (void *)addr_map_node->buffer_addr, orig_size);
+		func((void *)addr_map_node->orig_addr);
+	} else {
+		printk("Cannot find addr_map_node in addr_htbl, maybe addr is in kernel space!!\n");
+		func((void *)orig_addr);
+	}
+
+	spin_lock_irqsave(&target->addr_htbl_spin_lock, flags);
+	if (addr_map_node != NULL) {
+		hlist_del_init_rcu(&addr_map_node->node);
+		call_rcu(&addr_map_node->rcu, koi_addr_map_node_free);
+	}
+	spin_unlock_irqrestore(&target->addr_htbl_spin_lock, flags);
+	spin_lock_irqsave(&target->spin_lock, flags);
+	list_for_each_entry_rcu (mem_node, &target->mem_list_head, list) {
+		if (mem_node->addr + mem_node->size == addr) {
+			pos = mem_node->list.prev;
+			addr = mem_node->addr;
+			size += mem_node->size;
+			list_del_rcu(&mem_node->list);
+			call_rcu(&mem_node->rcu, koi_mem_node_free);
+		} else if (addr + size == mem_node->addr) {
+			if (!pos)
+				pos = mem_node->list.prev;
+			size += mem_node->size;
+			list_del_rcu(&mem_node->list);
+			call_rcu(&mem_node->rcu, koi_mem_node_free);
+		} else if (addr + size < mem_node->addr) {
+			if (!pos)
+				pos = mem_node->list.prev;
+			break;
+		}
+	}
+	mem_node = kzalloc(sizeof(struct koi_mem_list), GFP_ATOMIC);
+	mem_node->addr = addr;
+	mem_node->size = size;
+	if (pos)
+		list_add_rcu(&mem_node->list, pos);
+	else
+		list_add_tail_rcu(&mem_node->list, &target->mem_list_head);
+	spin_unlock_irqrestore(&target->spin_lock, flags);
+}
+EXPORT_SYMBOL(koi_mem_free_callback);
+
+void koi_map_mem(struct module *mod, unsigned long addr, unsigned long size)
+{
+	struct koi_mem_hash_node *target = NULL;
+	rcu_read_lock();
+	hash_for_each_possible_rcu (koi_mem_htbl, target, node,
+				    (unsigned long)mod) {
+		if (target->mod == mod)
+			break;
+	}
+	rcu_read_unlock();
+
+	if (target == NULL) {
+		printk(KERN_ERR "mem node for module: %s not found\n",
+		       mod->name);
+		return;
+	}
+	koi_copy_pagetable(target->ko_mm, target->pgdp, addr & PAGE_MASK,
+			   (addr + size + PAGE_SIZE - 1) & PAGE_MASK);
+    flush_tlb_kernel_range(addr & PAGE_MASK, (addr + size + PAGE_SIZE - 1) & PAGE_MASK);
+}
+EXPORT_SYMBOL(koi_map_mem);
+
+void koi_unmap_mem(struct module *mod, unsigned long addr, unsigned long size) {
+    struct koi_mem_hash_node *target = NULL;
+	rcu_read_lock();
+	hash_for_each_possible_rcu (koi_mem_htbl, target, node,
+				    (unsigned long)mod) {
+		if (target->mod == mod)
+			break;
+	}
+	rcu_read_unlock();
+
+	if (target == NULL) {
+		printk(KERN_ERR "mem node for module: %s not found\n",
+		       mod->name);
+		return;
+	}
+	koi_unmap_pagetable(target->ko_mm, target->pgdp, addr & PAGE_MASK,
+			   (addr + size + PAGE_SIZE - 1) & PAGE_MASK);
+    flush_tlb_kernel_range(addr & PAGE_MASK, (addr + size + PAGE_SIZE - 1) & PAGE_MASK);
+}
+EXPORT_SYMBOL(koi_unmap_mem);
+/**
+* koi_mem_free_to_user - function 'copy_to_user' in driver space
+*/
+void koi_mem_free_to_user(struct module *mod, unsigned long addr,
+			  unsigned long size)
+{
+	struct koi_mem_hash_node *target = NULL;
+	struct koi_mem_list *mem_node;
+	struct list_head *pos = NULL;
+	struct koi_addr_map *addr_map_node;
+	unsigned long flags;
+	unsigned long orig_size = size;
+	unsigned long orig_addr = addr;
+	rcu_read_lock();
+	hash_for_each_possible_rcu (koi_mem_htbl, target, node,
+				    (unsigned long)mod) {
+		if (target->mod == mod) {
+			break;
+		}
+	}
+	rcu_read_unlock();
+	if (target == NULL) {
+		printk(KERN_ERR "mem node for module: %s not found\n",
+		       mod->name);
+		return;
+	}
+
+	rcu_read_lock();
+	hash_for_each_possible_rcu (target->addr_htbl, addr_map_node, node,
+				    orig_addr) {
+		if (addr_map_node->buffer_addr == orig_addr) {
+			break;
+		}
+	}
+	rcu_read_unlock();
+	if (copy_to_user((void *)addr_map_node->orig_addr,
+			 (void *)addr_map_node->buffer_addr, orig_size)) {
+		return;
+	}
+
+	spin_lock_irqsave(&target->addr_htbl_spin_lock, flags);
+	hlist_del_init_rcu(&addr_map_node->node);
+	call_rcu(&addr_map_node->rcu, koi_addr_map_node_free);
+	spin_unlock_irqrestore(&target->addr_htbl_spin_lock, flags);
+	spin_lock_irqsave(&target->spin_lock, flags);
+	list_for_each_entry_rcu (mem_node, &target->mem_list_head, list) {
+		if (mem_node->addr + mem_node->size == addr) {
+			pos = mem_node->list.prev;
+			addr = mem_node->addr;
+			size += mem_node->size;
+			list_del_rcu(&mem_node->list);
+			call_rcu(&mem_node->rcu, koi_mem_node_free);
+		} else if (addr + size == mem_node->addr) {
+			if (!pos)
+				pos = mem_node->list.prev;
+			size += mem_node->size;
+			list_del_rcu(&mem_node->list);
+			call_rcu(&mem_node->rcu, koi_mem_node_free);
+		} else if (addr + size < mem_node->addr) {
+			if (!pos)
+				pos = mem_node->list.prev;
+			break;
+		}
+	}
+	mem_node = kzalloc(sizeof(struct koi_mem_list), GFP_ATOMIC);
+	mem_node->addr = addr;
+	mem_node->size = size;
+	if (pos)
+		list_add_rcu(&mem_node->list, pos);
+	else
+		list_add_tail_rcu(&mem_node->list, &target->mem_list_head);
+	spin_unlock_irqrestore(&target->spin_lock, flags);
+}
+EXPORT_SYMBOL(koi_mem_free_to_user);
+// map the driver stack to kernel
+void koi_map_kostack(struct module *mod)
+{
+	struct koi_mem_hash_node *target = NULL;
+	void *koi_stack;
+	unsigned long cur_sp;
+#ifndef CONFIG_IEE
+    struct task_token *token_addr;
+#endif
+	asm volatile("mov %0, sp\n" : "=r"(cur_sp) :);
+	if (on_irq_stack(cur_sp, NULL)) {
+		return;
+	}
+#ifndef CONFIG_IEE
+	token_addr = (struct task_token *)((unsigned long)current + (unsigned long)koi_offset);
+	if (token_addr->koi_stack_base != NULL)
+		return;
+#else
+	koi_stack = (void *)iee_rw_gate(IEE_READ_KOI_STACK, current);
+	if (koi_stack != NULL)
+		return;
+#endif
+	koi_stack = (void *)__get_free_pages(GFP_KERNEL, 3);
+	free_pages((unsigned long)koi_stack + 4 * PAGE_SIZE, 2);
+	printk(KERN_ERR "alloc dstack start=0x%16lx, end=0x%16lx\n",
+	        (unsigned long)koi_stack, (unsigned long)koi_stack + 4 * PAGE_SIZE);
+#ifndef CONFIG_IEE
+	token_addr->koi_stack =
+		(struct pt_regs *)(THREAD_SIZE + (unsigned long)koi_stack) - 1;
+	token_addr->koi_stack_base = koi_stack;
+#else
+	iee_rw_gate(
+		IEE_WRITE_KOI_STACK, current,
+		(unsigned long)((struct pt_regs *)(THREAD_SIZE + (unsigned long)koi_stack) - 1));
+	iee_rw_gate(IEE_WRITE_KOI_STACK_BASE, current, (unsigned long)koi_stack);
+#endif
+	rcu_read_lock();
+	hash_for_each_possible_rcu (koi_mem_htbl, target, node,
+				    (unsigned long)mod) {
+		if (target->mod == mod) {
+			break;
+		}
+	}
+	rcu_read_unlock();
+	if (target == NULL) {
+		// printk(KERN_ERR "mem node for module: %s not found\n",
+		//        mod->name);
+		return;
+	}
+	koi_copy_pagetable(target->ko_mm, target->pgdp,
+			   (unsigned long)koi_stack,
+			   (unsigned long)koi_stack + THREAD_SIZE);
+    flush_tlb_kernel_range((unsigned long)koi_stack, (unsigned long)koi_stack + THREAD_SIZE);
+	// printk(KERN_ERR "create ko stack: 0x%16llx\n",
+	//        (unsigned long)koi_stack);
+}
+EXPORT_SYMBOL(koi_map_kostack);
+
+#ifndef CONFIG_IEE
+void koi_init_token(struct task_struct *tsk) {
+    struct task_token *token_addr = (struct task_token *)(__phys_to_virt(__pa(tsk)) + KOI_OFFSET);
+
+    token_addr->koi_kernel_stack = NULL;
+    token_addr->koi_stack = NULL;
+    token_addr->koi_stack_base = NULL;
+    token_addr->current_ttbr1 = 0;
+}
+
+#endif
\ No newline at end of file
diff --git a/arch/arm64/kernel/mte.c b/arch/arm64/kernel/mte.c
index 4a069f85bd91..4631dc788dd3 100644
--- a/arch/arm64/kernel/mte.c
+++ b/arch/arm64/kernel/mte.c
@@ -78,7 +78,11 @@ int memcmp_pages(struct page *page1, struct page *page2)
 static void update_sctlr_el1_tcf0(u64 tcf0)
 {
 	/* ISB required for the kernel uaccess routines */
+#ifdef CONFIG_IEE
+    sysreg_clear_set_iee_si(sctlr_el1, SCTLR_EL1_TCF0_MASK, tcf0);
+#else
 	sysreg_clear_set(sctlr_el1, SCTLR_EL1_TCF0_MASK, tcf0);
+#endif
 	isb();
 }
 
diff --git a/arch/arm64/kernel/process.c b/arch/arm64/kernel/process.c
index 14300c9e06d5..daba80a40544 100644
--- a/arch/arm64/kernel/process.c
+++ b/arch/arm64/kernel/process.c
@@ -85,7 +85,11 @@ static void noinstr __cpu_do_idle_irqprio(void)
 	unsigned long daif_bits;
 
 	daif_bits = read_sysreg(daif);
+// #ifdef CONFIG_IEE
+//     iee_si_write_daif(daif_bits | PSR_I_BIT);
+// #else
 	write_sysreg(daif_bits | PSR_I_BIT, daif);
+// #endif
 
 	/*
 	 * Unmask PMR before going idle to make sure interrupts can
@@ -97,7 +101,11 @@ static void noinstr __cpu_do_idle_irqprio(void)
 	__cpu_do_idle();
 
 	gic_write_pmr(pmr);
+// #ifdef CONFIG_IEE
+//     iee_si_write_daif(daif_bits);
+// #else
 	write_sysreg(daif_bits, daif);
+// #endif
 }
 
 /*
@@ -477,7 +485,7 @@ int copy_thread(unsigned long clone_flags, unsigned long stack_start,
 	}
 	p->thread.cpu_context.pc = (unsigned long)ret_from_fork;
 	p->thread.cpu_context.sp = (unsigned long)childregs;
-
+    
 	ptrace_hw_copy_thread(p);
 
 	return 0;
@@ -538,7 +546,14 @@ DEFINE_PER_CPU(struct task_struct *, __entry_task);
 
 static void entry_task_switch(struct task_struct *next)
 {
+	#if defined(CONFIG_IEE) || defined(CONFIG_KOI)
+	if(next == &init_task)
+		__this_cpu_write(__entry_task, (struct task_struct *)__va(__pa_symbol(next)));
+	else
+		__this_cpu_write(__entry_task, next);
+	#else
 	__this_cpu_write(__entry_task, next);
+	#endif
 }
 
 /*
diff --git a/arch/arm64/kernel/proton-pack.c b/arch/arm64/kernel/proton-pack.c
index c569889b0322..f89d68459a0a 100644
--- a/arch/arm64/kernel/proton-pack.c
+++ b/arch/arm64/kernel/proton-pack.c
@@ -576,7 +576,11 @@ static enum mitigation_state spectre_v4_enable_hw_mitigation(void)
 		return state;
 
 	if (spectre_v4_mitigations_off()) {
+#ifdef CONFIG_IEE
+        sysreg_clear_set_iee_si(sctlr_el1, 0, SCTLR_ELx_DSSBS);
+#else
 		sysreg_clear_set(sctlr_el1, 0, SCTLR_ELx_DSSBS);
+#endif
 		set_pstate_ssbs(1);
 		return SPECTRE_VULNERABLE;
 	}
@@ -992,7 +996,11 @@ static void this_cpu_set_vectors(enum arm64_bp_harden_el1_vectors slot)
 	if (arm64_kernel_unmapped_at_el0())
 		return;
 
+#ifdef CONFIG_IEE
+    iee_rwx_gate_entry(IEE_WRITE_vbar_el1, v);
+#else
 	write_sysreg(v, vbar_el1);
+#endif
 	isb();
 }
 
diff --git a/arch/arm64/kernel/setup.c b/arch/arm64/kernel/setup.c
index 18e457bbb7a3..79992984aec1 100644
--- a/arch/arm64/kernel/setup.c
+++ b/arch/arm64/kernel/setup.c
@@ -33,6 +33,11 @@
 #include <linux/mm.h>
 #include <linux/pin_mem.h>
 
+#ifdef CONFIG_IEE
+#include <linux/iee-func.h>
+#include <asm/iee-si.h>
+#endif
+
 #include <asm/acpi.h>
 #include <asm/fixmap.h>
 #include <asm/cpu.h>
@@ -360,12 +365,34 @@ u64 cpu_logical_map(int cpu)
 }
 EXPORT_SYMBOL(cpu_logical_map);
 
+#ifdef CONFIG_IEE
+/* used for secure modification of vbar*/
+extern char __bp_harden_el1_vectors[];
+/* prepare iee rwx gate for senario of ttbr1=init_pg_dir */
+static void __init iee_si_init_early(void)
+{
+    /* prepare data used for iee rwx gate. */
+    iee_base_swapper_pg_dir = phys_to_ttbr(__pa_symbol(swapper_pg_dir));
+    iee_base_idmap_pg_dir = phys_to_ttbr(__pa_symbol(idmap_pg_dir));
+    iee_base_reserved_pg_dir = phys_to_ttbr(__pa_symbol(reserved_pg_dir)) 
+		| FIELD_PREP(TTBR_ASID_MASK, 1);
+	iee_base__bp_harden_el1_vectors = (unsigned long)__bp_harden_el1_vectors;
+	iee_si_tcr_outside = read_sysreg(tcr_el1) & ~(IEE_TCR_MASK);
+    iee_si_tcr = 0;
+    iee_si_tcr_inside = iee_si_tcr_outside & ~(SYS_TCR_IEE_SI);
+}
+#endif
+
 void __init __no_sanitize_address setup_arch(char **cmdline_p)
 {
 	init_mm.start_code = (unsigned long) _text;
 	init_mm.end_code   = (unsigned long) _etext;
 	init_mm.end_data   = (unsigned long) _edata;
 	init_mm.brk	   = (unsigned long) _end;
+	#ifdef CONFIG_IEE
+	init_new_context(&init_task, &init_mm);
+	atomic64_set(&init_mm.context.id, (1UL << get_cpu_asid_bits()) | INIT_ASID);
+	#endif
 
 	*cmdline_p = boot_command_line;
 
@@ -398,6 +425,14 @@ void __init __no_sanitize_address setup_arch(char **cmdline_p)
 	 */
 	local_daif_restore(DAIF_PROCCTX_NOIRQ);
 
+#ifdef CONFIG_IEE
+    /* 
+     * Map iee si codes to init_pg_dir to run the following
+     * cpu_uninstall_idmap() which writes ttbr0.
+     */
+    iee_si_init_early();
+#endif
+
 	/*
 	 * TTBR0 is only used for the identity mapping at this stage. Make it
 	 * point to zero page to avoid speculatively fetching new entries.
diff --git a/arch/arm64/kernel/syscall.c b/arch/arm64/kernel/syscall.c
index 9bd304568d90..2156532b45f5 100644
--- a/arch/arm64/kernel/syscall.c
+++ b/arch/arm64/kernel/syscall.c
@@ -93,13 +93,21 @@ static void cortex_a76_erratum_1463225_svc_handler(void)
 	__this_cpu_write(__in_cortex_a76_erratum_1463225_wa, 1);
 	reg = read_sysreg(mdscr_el1);
 	val = reg | DBG_MDSCR_SS | DBG_MDSCR_KDE;
+// #ifdef CONFIG_IEE
+//     iee_rwx_gate_entry(IEE_WRITE_mdscr_el1, val);
+// #else
 	write_sysreg(val, mdscr_el1);
+// #endif
 	asm volatile("msr daifclr, #8");
 	isb();
 
 	/* We will have taken a single-step exception by this point */
 
+// #ifdef CONFIG_IEE
+//     iee_rwx_gate_entry(IEE_WRITE_mdscr_el1, reg);
+// #else
 	write_sysreg(reg, mdscr_el1);
+// #endif
 	__this_cpu_write(__in_cortex_a76_erratum_1463225_wa, 0);
 }
 #else
diff --git a/arch/arm64/kernel/traps.c b/arch/arm64/kernel/traps.c
index 15c9c90639f1..55cd44151327 100644
--- a/arch/arm64/kernel/traps.c
+++ b/arch/arm64/kernel/traps.c
@@ -51,7 +51,11 @@ static const char *handler[]= {
 	"Synchronous Abort",
 	"IRQ",
 	"FIQ",
-	"Error"
+	"Error",
+#ifdef CONFIG_IEE
+	"IEE",
+	"IEE_SI"
+#endif
 };
 
 int show_unhandled_signals = 0;
diff --git a/arch/arm64/kernel/vmlinux.lds.S b/arch/arm64/kernel/vmlinux.lds.S
index 71f4b5f24d15..1ced88b8f6ae 100644
--- a/arch/arm64/kernel/vmlinux.lds.S
+++ b/arch/arm64/kernel/vmlinux.lds.S
@@ -85,6 +85,53 @@ jiffies = jiffies_64;
 #define TRAMP_TEXT
 #endif
 
+#ifdef CONFIG_IEE
+#define IEE_TEXT \
+	. = ALIGN(PAGE_SIZE);				\
+	__iee_code_start = .;       \
+	*(.iee.text.header)         \
+	*(.iee.text)				        \
+	. = ALIGN(PAGE_SIZE);				\
+	__iee_code_end = .;
+#else
+#define IEE_TEXT
+#endif
+
+#ifdef CONFIG_IEE
+#define IEE_SI_TEXT \
+    . = ALIGN(PAGE_SIZE);       \
+    __iee_si_data_start = .;	\
+	*(.iee.si_data)             \
+	. = ALIGN(PAGE_SIZE);       \
+	__iee_exec_entry_start = .;   	\
+    __iee_si_no_irq = . + (16);		\
+	*(.iee.exec_entry)        		\
+	. = ALIGN(PAGE_SIZE);       	\
+	__iee_si_start = .; 			\
+	*(.iee.si_text)				    \
+	. = ALIGN(PAGE_SIZE);           \
+    . += PAGE_SIZE - (24);	    \
+	__iee_si_end = . + (24);  	\
+	__iee_exec_exit = .;        \
+	*(.iee.exec_exit)           \
+	. = ALIGN(PAGE_SIZE);       \
+    __iee_si_text_end = .;
+	
+#else 
+#define IEE_SI_TEXT
+#endif
+
+#ifdef CONFIG_KOI
+#define KOI_TEXT \
+	. = ALIGN(PAGE_SIZE);				\
+	__koi_code_start = .;       \
+	*(.koi.text)				        \
+	. = ALIGN(PAGE_SIZE);				\
+	__koi_code_end = .;
+#else 
+#define KOI_TEXT
+#endif
+
 /*
  * The size of the PE/COFF section that covers the kernel image, which
  * runs from _stext to _edata, must be a round multiple of the PE/COFF
@@ -127,6 +174,7 @@ SECTIONS
 			SOFTIRQENTRY_TEXT
 			ENTRY_TEXT
 			TEXT_TEXT
+			IEE_TEXT
 			SCHED_TEXT
 			CPUIDLE_TEXT
 			LOCK_TEXT
@@ -135,6 +183,8 @@ SECTIONS
 			IDMAP_TEXT
 			HIBERNATE_TEXT
 			TRAMP_TEXT
+			IEE_SI_TEXT
+            KOI_TEXT
 			*(.fixup)
 			*(.gnu.warning)
 		. = ALIGN(16);
@@ -261,6 +311,18 @@ SECTIONS
 	. += INIT_DIR_SIZE;
 	init_pg_end = .;
 
+	#ifdef CONFIG_IEE
+	. = ALIGN(PAGE_SIZE*8);
+	init_iee_stack_begin = .;
+	. += PAGE_SIZE*4;
+	init_iee_stack_end = .;
+
+    . = ALIGN(PAGE_SIZE);
+	init_iee_si_stack_begin = .;
+	. += PAGE_SIZE*4;
+	init_iee_si_stack_end = .;
+	#endif
+
 	. = ALIGN(SEGMENT_ALIGN);
 	__pecoff_data_size = ABSOLUTE(. - __initdata_begin);
 	_end = .;
diff --git a/arch/arm64/mm/context.c b/arch/arm64/mm/context.c
index 001737a8f309..22f401d2066a 100644
--- a/arch/arm64/mm/context.c
+++ b/arch/arm64/mm/context.c
@@ -17,6 +17,10 @@
 #include <asm/smp.h>
 #include <asm/tlbflush.h>
 
+#ifdef CONFIG_IEE
+#include <asm/iee-si.h>
+#endif
+
 static u32 asid_bits;
 static DEFINE_RAW_SPINLOCK(cpu_asid_lock);
 
@@ -39,7 +43,11 @@ static unsigned long *pinned_asid_map;
 #define idx2asid(idx)		asid2idx(idx)
 
 /* Get the ASIDBits supported by the current CPU */
+#ifdef CONFIG_IEE
+u32 get_cpu_asid_bits(void)
+#else
 static u32 get_cpu_asid_bits(void)
+#endif
 {
 	u32 asid;
 	int fld = cpuid_feature_extract_unsigned_field(read_cpuid(ID_AA64MMFR0_EL1),
@@ -96,6 +104,18 @@ static void set_reserved_asid_bits(void)
 		set_kpti_asid_bits(asid_map);
 	else
 		bitmap_clear(asid_map, 0, NUM_USER_ASIDS);
+
+    #ifdef CONFIG_IEE
+        unsigned int len = BITS_TO_LONGS(NUM_USER_ASIDS) * sizeof(unsigned long);
+	    memset(asid_map, 0xaa, len);
+	    __set_bit(INIT_ASID, asid_map);
+    #else 
+        #ifdef CONFIG_KOI
+            unsigned int len = BITS_TO_LONGS(NUM_USER_ASIDS) * sizeof(unsigned long);
+	        memset(asid_map, 0xaa, len);
+        #endif
+    #endif
+
 }
 
 #define asid_gen_match(asid) \
@@ -212,6 +232,38 @@ static u64 new_context(struct mm_struct *mm)
 	return idx2asid(asid) | generation;
 }
 
+#ifdef CONFIG_KOI
+/*
+ * This function is used to check and allocate ASID for ko's pgd
+ * The mm MUST point to the isolated kos' mm_struct, other behaviours are undefined.
+ */
+void koi_check_and_switch_context(struct mm_struct *mm) {
+	u64 asid = atomic64_read(&mm->context.id);
+	u64 old_active_asid;
+	unsigned long flags;
+	unsigned int cpu;
+
+	old_active_asid = atomic64_read(this_cpu_ptr(&active_asids));
+	if (old_active_asid && asid_gen_match(asid) && atomic64_cmpxchg_relaxed(this_cpu_ptr(&active_asids), old_active_asid, asid)) {
+		return;
+	}
+	
+	raw_spin_lock_irqsave(&cpu_asid_lock, flags);
+	asid = atomic64_read(&mm->context.id);
+	if (!asid_gen_match(asid)) {
+		asid = new_context(mm);
+		atomic64_set(&mm->context.id, asid);
+	}
+
+	cpu = smp_processor_id();
+	if (cpumask_test_and_clear_cpu(cpu, &tlb_flush_pending))
+		local_flush_tlb_all();
+
+	atomic64_set(this_cpu_ptr(&active_asids), asid);
+	raw_spin_unlock_irqrestore(&cpu_asid_lock, flags);
+}
+#endif
+
 void check_and_switch_context(struct mm_struct *mm)
 {
 	unsigned long flags;
@@ -348,7 +400,9 @@ asmlinkage void post_ttbr_update_workaround(void)
 
 void cpu_do_switch_mm(phys_addr_t pgd_phys, struct mm_struct *mm)
 {
+	#ifndef CONFIG_IEE
 	unsigned long ttbr1 = read_sysreg(ttbr1_el1);
+	#endif
 	unsigned long asid = ASID(mm);
 	unsigned long ttbr0 = phys_to_ttbr(pgd_phys);
 
@@ -360,14 +414,27 @@ void cpu_do_switch_mm(phys_addr_t pgd_phys, struct mm_struct *mm)
 	if (IS_ENABLED(CONFIG_ARM64_SW_TTBR0_PAN))
 		ttbr0 |= FIELD_PREP(TTBR_ASID_MASK, asid);
 
-	/* Set ASID in TTBR1 since TCR.A1 is set */
+	#ifdef CONFIG_IEE
+	ttbr0 |= FIELD_PREP(TTBR_ASID_MASK, asid+1);
+    iee_rwx_gate_entry(IEE_CONTEXT_SWITCH, ttbr0);
+
+	#else
+	/* Set ASID in TTBR0 since TCR.A1 is set 0*/
+
+	#ifdef CONFIG_KOI
+	ttbr0 |= FIELD_PREP(TTBR_ASID_MASK, asid+1);
+    ttbr1 &= ~TTBR_ASID_MASK;
+	ttbr1 |= FIELD_PREP(TTBR_ASID_MASK, asid);
+	#else
 	ttbr1 &= ~TTBR_ASID_MASK;
 	ttbr1 |= FIELD_PREP(TTBR_ASID_MASK, asid);
-
+	#endif
 	write_sysreg(ttbr1, ttbr1_el1);
 	isb();
 	write_sysreg(ttbr0, ttbr0_el1);
 	isb();
+    #endif
+
 	post_ttbr_update_workaround();
 }
 
@@ -375,11 +442,28 @@ static int asids_update_limit(void)
 {
 	unsigned long num_available_asids = NUM_USER_ASIDS;
 
-	if (arm64_kernel_unmapped_at_el0()) {
-		num_available_asids /= 2;
-		if (pinned_asid_map)
-			set_kpti_asid_bits(pinned_asid_map);
+    if (arm64_kernel_unmapped_at_el0()) {
+	    num_available_asids /= 2;
+	    if (pinned_asid_map)
+		    set_kpti_asid_bits(pinned_asid_map);
 	}
+    #ifdef CONFIG_IEE
+        num_available_asids /= 2;
+		if (pinned_asid_map) {
+            unsigned int len = BITS_TO_LONGS(NUM_USER_ASIDS) * sizeof(unsigned long);
+    	    memset(pinned_asid_map, 0xaa, len);
+			__set_bit(INIT_ASID, pinned_asid_map);
+        }
+    #else
+    #ifdef CONFIG_KOI
+        num_available_asids /= 2;
+		if (pinned_asid_map) {
+            unsigned int len = BITS_TO_LONGS(NUM_USER_ASIDS) * sizeof(unsigned long);
+    	    memset(pinned_asid_map, 0xaa, len);
+        }
+    #endif
+    #endif
+
 	/*
 	 * Expect allocation after rollover to fail if we don't have at least
 	 * one more ASID than CPUs. ASID #0 is reserved for init_mm.
@@ -400,6 +484,10 @@ arch_initcall(asids_update_limit);
 
 static int asids_init(void)
 {
+	#if defined(CONFIG_IEE) || defined(CONFIG_KOI)
+	unsigned int len;
+	#endif
+
 	asid_bits = get_cpu_asid_bits();
 	atomic64_set(&asid_generation, ASID_FIRST_VERSION);
 	asid_map = kcalloc(BITS_TO_LONGS(NUM_USER_ASIDS), sizeof(*asid_map),
@@ -412,13 +500,25 @@ static int asids_init(void)
 				  sizeof(*pinned_asid_map), GFP_KERNEL);
 	nr_pinned_asids = 0;
 
-	/*
-	 * We cannot call set_reserved_asid_bits() here because CPU
-	 * caps are not finalized yet, so it is safer to assume KPTI
-	 * and reserve kernel ASID's from beginning.
-	 */
-	if (IS_ENABLED(CONFIG_UNMAP_KERNEL_AT_EL0))
-		set_kpti_asid_bits(asid_map);
+    #ifdef CONFIG_IEE
+        len = BITS_TO_LONGS(NUM_USER_ASIDS) * sizeof(unsigned long);
+    	memset(asid_map, 0xaa, len);
+		__set_bit(INIT_ASID, asid_map);
+    #else 
+        #ifdef CONFIG_KOI
+            len = BITS_TO_LONGS(NUM_USER_ASIDS) * sizeof(unsigned long);
+    	    memset(asid_map, 0xaa, len);
+        #else 
+            /*
+	         * We cannot call set_reserved_asid_bits() here because CPU
+	         * caps are not finalized yet, so it is safer to assume KPTI
+	         * and reserve kernel ASID's from beginning.
+	         */
+	        if (IS_ENABLED(CONFIG_UNMAP_KERNEL_AT_EL0))
+		        set_kpti_asid_bits(asid_map);
+        #endif
+    #endif
+
 	return 0;
 }
 early_initcall(asids_init);
diff --git a/arch/arm64/mm/fault.c b/arch/arm64/mm/fault.c
index a2c61725c176..e719a0358dd0 100644
--- a/arch/arm64/mm/fault.c
+++ b/arch/arm64/mm/fault.c
@@ -24,6 +24,9 @@
 #include <linux/perf_event.h>
 #include <linux/preempt.h>
 #include <linux/hugetlb.h>
+#ifdef CONFIG_HIVE
+#include <linux/sfi_bpf.h>
+#endif
 
 #include <asm/acpi.h>
 #include <asm/bug.h>
@@ -218,7 +221,16 @@ int ptep_set_access_flags(struct vm_area_struct *vma,
 		pteval ^= PTE_RDONLY;
 		pteval |= pte_val(entry);
 		pteval ^= PTE_RDONLY;
+        #ifdef CONFIG_KOI
+        if (pteval & PTE_VALID) {
+		    pteval |= PTE_NG;
+        }
+        #endif
+		#ifdef CONFIG_PTP
+		pteval = iee_set_cmpxchg_relaxed(ptep, old_pteval, pteval);
+		#else
 		pteval = cmpxchg_relaxed(&pte_val(*ptep), old_pteval, pteval);
+		#endif
 	} while (pteval != old_pteval);
 
 	/* Invalidate a stale read-only entry */
@@ -288,6 +300,14 @@ static void die_kernel_fault(const char *msg, unsigned long addr,
 {
 	bust_spinlocks(1);
 
+	#ifdef CONFIG_HIVE
+	if (bpf_sfi_hook_kernel_fault(addr)) {
+		pr_err("detected bpf sfi guard page %lx access\n", addr);
+		regs->pc += 4;
+		return;
+	}
+	#endif
+
 	pr_alert("Unable to handle kernel %s at virtual address %016lx\n", msg,
 		 addr);
 
diff --git a/arch/arm64/mm/init.c b/arch/arm64/mm/init.c
index afcede934bc3..576f782bd772 100644
--- a/arch/arm64/mm/init.c
+++ b/arch/arm64/mm/init.c
@@ -58,8 +58,20 @@
  * that cannot be mistaken for a real physical address.
  */
 s64 memstart_addr __ro_after_init = -1;
+#if defined(CONFIG_IEE) || defined(CONFIG_KOI)
+s64 memstart_addr_init __ro_after_init = -1;
+#endif
+#ifdef CONFIG_KOI
+s64 koi_offset __ro_after_init = -1;
+EXPORT_SYMBOL(koi_offset);
+#endif
+#ifdef CONFIG_IEE
+s64 iee_offset __ro_after_init = -1;
+extern s64 iee_si_offset;
+#endif
 EXPORT_SYMBOL(memstart_addr);
 
+
 /*
  * If the corresponding config options are enabled, we create both ZONE_DMA
  * and ZONE_DMA32. By default ZONE_DMA covers the 32-bit addressable memory
@@ -414,19 +426,34 @@ early_param("memmap", parse_memmap_opt);
 
 void __init arm64_memblock_init(void)
 {
+	#if defined(CONFIG_IEE) || defined(CONFIG_KOI)
+	const s64 linear_region_size = BIT(vabits_actual - 2);
+	#else
 	const s64 linear_region_size = BIT(vabits_actual - 1);
+	#endif
 
 	/* Handle linux,usable-memory-range property */
 	fdt_enforce_memory_region();
 
 	/* Remove memory above our supported physical address size */
+	#ifdef CONFIG_IEE
+	// If config iee, phys size can not be above 0x400000000000
+	if(__pa_symbol(_end) > BIT_ULL(vabits_actual - 2))
+		panic("Image on too high phys mem.\n");
+	else
+		memblock_remove(BIT_ULL(vabits_actual - 2), ULLONG_MAX);
+	#else
 	memblock_remove(1ULL << PHYS_MASK_SHIFT, ULLONG_MAX);
+	#endif
 
 	/*
 	 * Select a suitable value for the base of physical memory.
 	 */
 	memstart_addr = round_down(memblock_start_of_DRAM(),
 				   ARM64_MEMSTART_ALIGN);
+	#if defined(CONFIG_IEE) || defined(CONFIG_KOI)
+	memstart_addr_init = memstart_addr;
+	#endif
 
 	/*
 	 * Remove the memory that we will not be able to cover with the
@@ -507,7 +534,15 @@ void __init arm64_memblock_init(void)
 					 ((range * memstart_offset_seed) >> 16);
 		}
 	}
-
+	
+    #ifdef CONFIG_KOI
+	koi_offset = memstart_addr - memstart_addr_init + ((unsigned long)BIT(vabits_actual - 2));
+    #endif
+	#ifdef CONFIG_IEE
+	iee_offset = memstart_addr - memstart_addr_init + ((unsigned long)BIT(vabits_actual - 2));
+    iee_si_offset = iee_offset;
+	#endif
+    
 	/*
 	 * Register the kernel text, kernel data, initrd, and initial
 	 * pagetables with memblock.
diff --git a/arch/arm64/mm/mmu.c b/arch/arm64/mm/mmu.c
index adaca1fd5a27..2e15f1b2c18c 100644
--- a/arch/arm64/mm/mmu.c
+++ b/arch/arm64/mm/mmu.c
@@ -6,6 +6,7 @@
  * Copyright (C) 2012 ARM Ltd.
  */
 
+#include "asm/pgtable.h"
 #include <linux/cache.h>
 #include <linux/export.h>
 #include <linux/kernel.h>
@@ -39,6 +40,13 @@
 #include <asm/tlbflush.h>
 #include <asm/pgalloc.h>
 #include <asm/set_memory.h>
+#ifdef CONFIG_IEE
+#include <linux/iee-func.h>
+#include <asm/iee.h>
+#include <asm/iee-si.h>
+#include <asm/pgtable_slab.h>
+#include <asm/daifflags.h>
+#endif
 
 #define NO_BLOCK_MAPPINGS	BIT(0)
 #define NO_CONT_MAPPINGS	BIT(1)
@@ -66,8 +74,247 @@ static pud_t bm_pud[PTRS_PER_PUD] __page_aligned_bss __maybe_unused;
 static DEFINE_SPINLOCK(swapper_pgdir_lock);
 static DEFINE_MUTEX(fixmap_lock);
 
+#ifdef CONFIG_IEE
+extern struct cred init_cred;
+void *bm_pte_addr = (void *)bm_pte;
+void *init_token_page_vaddr;
+
+// extern unsigned long __iee_si_base_start[];
+// extern unsigned long __iee_exec_entry_start[];
+extern unsigned long __iee_si_data_start[];
+extern unsigned long __iee_exec_entry_start[];
+extern unsigned long __iee_si_start[];
+extern unsigned long __iee_si_end[];
+
+#ifdef CONFIG_PTP
+/* Funcs to set pgtable before iee initialized. */
+static void iee_set_swapper_pgd_pre_init(pgd_t *pgdp, pgd_t pgd)
+{
+	pgd_t *fixmap_pgdp;
+
+	spin_lock(&swapper_pgdir_lock);
+	fixmap_pgdp = pgd_set_fixmap_init(__pa_symbol(pgdp));
+	WRITE_ONCE(*fixmap_pgdp, pgd);
+	/*
+	 * We need dsb(ishst) here to ensure the page-table-walker sees
+	 * our new entry before set_p?d() returns. The fixmap's
+	 * flush_tlb_kernel_range() via clear_fixmap() does this for us.
+	 */
+	pgd_clear_fixmap_init();
+	spin_unlock(&swapper_pgdir_lock);
+}
+
+static inline void iee_set_p4d_pre_init(p4d_t *p4dp, p4d_t p4d)
+{
+	if (in_swapper_pgdir(p4dp)) {
+		iee_set_swapper_pgd_pre_init((pgd_t *)p4dp, __pgd(p4d_val(p4d)));
+		return;
+	}
+
+	WRITE_ONCE(*p4dp, p4d);
+	dsb(ishst);
+	isb();
+}
+
+static inline void iee_set_pud_pre_init(pud_t *pudp, pud_t pud)
+{
+#ifdef __PAGETABLE_PUD_FOLDED
+	if (in_swapper_pgdir(pudp)) {
+		iee_set_swapper_pgd_pre_init((pgd_t *)pudp, __pgd(pud_val(pud)));
+		return;
+	}
+#endif /* __PAGETABLE_PUD_FOLDED */
+#ifdef CONFIG_KOI
+    pudval_t val = pud_val(pud);
+    if (pud_valid(pud) && !(val & PUD_TABLE_BIT)) {
+        // There is no PUD_SEC_NG, so we use PMD_SECT_NG instead.
+        pud = __pud(val | PMD_SECT_NG);
+    }
+#endif
+	WRITE_ONCE(*pudp, pud);
+
+	if (pud_valid(pud)) {
+		dsb(ishst);
+		isb();
+	}
+}
+
+static inline void iee_set_pmd_pre_init(pmd_t *pmdp, pmd_t pmd)
+{
+#ifdef __PAGETABLE_PMD_FOLDED
+	if (in_swapper_pgdir(pmdp)) {
+		iee_set_swapper_pgd_pre_init((pgd_t *)pmdp, __pgd(pmd_val(pmd)));
+		return;
+	}
+#endif /* __PAGETABLE_PMD_FOLDED */
+#ifdef CONFIG_KOI
+    pmdval_t val = pmd_val(pmd);
+    if (pmd_valid(pmd) && !(val & PMD_TABLE_BIT)) {
+        pmd = __pmd(val | PMD_SECT_NG);
+    }
+#endif
+	WRITE_ONCE(*pmdp, pmd);
+
+	if (pmd_valid(pmd)) {
+		dsb(ishst);
+		isb();
+	}
+}
+
+static inline void __iee_p4d_populate_pre_init(p4d_t *p4dp, phys_addr_t pudp, p4dval_t prot)
+{
+	iee_set_p4d_pre_init(p4dp, __p4d(__phys_to_p4d_val(pudp) | prot));
+}
+
+static inline void __iee_pud_populate_pre_init(pud_t *pudp, phys_addr_t pmdp, pudval_t prot)
+{
+	iee_set_pud_pre_init(pudp, __pud(__phys_to_pud_val(pmdp) | prot));
+}
+
+static inline void __iee_pmd_populate_pre_init(pmd_t *pmdp, phys_addr_t ptep,
+				  pmdval_t prot)
+{
+	iee_set_pmd_pre_init(pmdp, __pmd(__phys_to_pmd_val(ptep) | prot));
+}
+
+#define set_pgd_init(pgdptr, pgdval) iee_set_p4d_pre_init((p4d_t *)(pgdptr), (p4d_t) { pgdval })
+
+/* Funcs to set fixmap before iee initialized. */
+static bool pgattr_change_is_safe(u64 old, u64 new);
+static int iee_pud_set_huge_fixmap(pud_t *pudp, phys_addr_t phys, pgprot_t prot)
+{
+	pud_t new_pud = pfn_pud(__phys_to_pfn(phys), mk_pud_sect_prot(prot));
+
+	/* Only allow permission changes for now */
+	if (!pgattr_change_is_safe(READ_ONCE(pud_val(*pudp)),
+				   pud_val(new_pud)))
+		return 0;
+
+	VM_BUG_ON(phys & ~PUD_MASK);
+	iee_set_fixmap_pud_pre_init(pudp, new_pud);
+	return 1;
+}
+
+static int iee_pmd_set_huge_fixmap(pmd_t *pmdp, phys_addr_t phys, pgprot_t prot)
+{
+	pmd_t new_pmd = pfn_pmd(__phys_to_pfn(phys), mk_pmd_sect_prot(prot));
+
+	/* Only allow permission changes for now */
+	if (!pgattr_change_is_safe(READ_ONCE(pmd_val(*pmdp)),
+				   pmd_val(new_pmd)))
+		return 0;
+
+	VM_BUG_ON(phys & ~PMD_MASK);
+	iee_set_fixmap_pmd_pre_init(pmdp, new_pmd);
+	return 1;
+}
+
+static inline void __iee_pmd_populate_fixmap(pmd_t *pmdp, phys_addr_t ptep,
+				  pmdval_t prot)
+{
+	iee_set_fixmap_pmd_pre_init(pmdp, __pmd(__phys_to_pmd_val(ptep) | prot));
+}
+
+static inline void __iee_pud_populate_fixmap(pud_t *pudp, phys_addr_t pmdp, pudval_t prot)
+{
+	iee_set_fixmap_pud_pre_init(pudp, __pud(__phys_to_pud_val(pmdp) | prot));
+}
+#endif
+
+void iee_set_pte_pre_init(pte_t *ptep, pte_t pte)
+{
+#ifdef CONFIG_KOI
+    if (pte_valid(pte)) {
+		pte = __pte(pte_val(pte) | PTE_NG);
+    }
+#endif    
+	WRITE_ONCE(*ptep, pte);
+
+	/*
+	 * Only if the new pte is valid and kernel, otherwise TLB maintenance
+	 * or update_mmu_cache() have the necessary barriers.
+	 */
+	if (pte_valid_not_user(pte)) {
+		dsb(ishst);
+		isb();
+	}
+}
+
+static void __init iee_set_token_page_valid_pre_init(void *token, void *new)
+{
+	pgd_t *pgdir = swapper_pg_dir;
+	pgd_t *pgdp = pgd_offset_pgd(pgdir, (unsigned long)token);
+
+	p4d_t *p4dp = p4d_offset(pgdp, (unsigned long)token);
+
+	pud_t *pudp = pud_offset(p4dp, (unsigned long)token);
+
+	pmd_t *pmdp = pmd_offset(pudp, (unsigned long)token);
+
+	pte_t *ptep = pte_offset_kernel(pmdp, (unsigned long)token);
+	pte_t pte = READ_ONCE(*ptep);
+	pte = __pte(((pte_val(pte) | 0x1) & ~PTE_ADDR_MASK) | __phys_to_pte_val(__pa(new)));
+	#ifdef CONFIG_PTP
+	iee_set_pte_pre_init(ptep, pte);
+	#else
+	set_pte(ptep, pte);
+	#endif
+	flush_tlb_kernel_range((unsigned long)token, (unsigned long)(token+PAGE_SIZE));
+	isb();
+}
+#endif
+
+#if defined(CONFIG_KOI) && !defined(CONFIG_IEE)
+
+void koi_add_page_mapping(void *token, void *new)
+{
+	pgd_t *pgdir = swapper_pg_dir;
+	pgd_t *pgdp = pgd_offset_pgd(pgdir, token);
+
+	p4d_t *p4dp = p4d_offset(pgdp, token);
+
+	pud_t *pudp = pud_offset(p4dp, token);
+
+	pmd_t *pmdp = pmd_offset(pudp, token);
+
+	pte_t *ptep = pte_offset_kernel(pmdp, token);
+	pte_t pte = READ_ONCE(*ptep);
+	pte = __pte(((pte_val(pte) | 0x1) & ~PTE_ADDR_MASK) | __phys_to_pte_val(__pa(new)));
+	set_pte(ptep, pte);
+    dsb(ishst);
+	isb();
+    
+    flush_tlb_kernel_range(new, new+PAGE_SIZE);
+	flush_tlb_kernel_range(token, token+PAGE_SIZE);
+	isb();
+}
+
+void koi_remove_page_mapping(unsigned long token) {
+    pgd_t *pgdir = swapper_pg_dir;
+	pgd_t *pgdp = pgd_offset_pgd(pgdir, token);
+
+	p4d_t *p4dp = p4d_offset(pgdp, token);
+
+	pud_t *pudp = pud_offset(p4dp, token);
+
+	pmd_t *pmdp = pmd_offset(pudp, token);
+
+	pte_t *ptep = pte_offset_kernel(pmdp, token);
+	pte_t pte = READ_ONCE(*ptep);
+	pte = __pte(((pte_val(pte) & ~((unsigned long)0x1)) & ~PTE_ADDR_MASK) | __phys_to_pte_val(__pa(token - KOI_OFFSET)));
+	set_pte(ptep, pte);
+	flush_tlb_kernel_range(token, token+PAGE_SIZE);
+	isb();
+}
+#endif
+
 void set_swapper_pgd(pgd_t *pgdp, pgd_t pgd)
 {
+	#ifdef CONFIG_PTP
+	spin_lock(&swapper_pgdir_lock);
+	iee_rw_gate(IEE_OP_SET_SWAPPER_PGD, pgdp, pgd);
+	spin_unlock(&swapper_pgdir_lock);
+	#else
 	pgd_t *fixmap_pgdp;
 
 	spin_lock(&swapper_pgdir_lock);
@@ -80,6 +327,7 @@ void set_swapper_pgd(pgd_t *pgdp, pgd_t pgd)
 	 */
 	pgd_clear_fixmap();
 	spin_unlock(&swapper_pgdir_lock);
+	#endif
 }
 
 pgprot_t phys_mem_access_prot(struct file *file, unsigned long pfn,
@@ -93,6 +341,34 @@ pgprot_t phys_mem_access_prot(struct file *file, unsigned long pfn,
 }
 EXPORT_SYMBOL(phys_mem_access_prot);
 
+#ifdef CONFIG_PTP
+phys_addr_t __init early_pgtable_alloc(int shift)
+{
+	phys_addr_t phys;
+	void *ptr;
+
+	phys = memblock_phys_alloc(PAGE_SIZE, PAGE_SIZE);
+	if (!phys)
+		panic("Failed to allocate page table page\n");
+
+	/*
+	 * The FIX_{PGD,PUD,PMD} slots may be in active use, but the FIX_PTE
+	 * slot will be free, so we can (ab)use the FIX_PTE slot to initialise
+	 * any level of table.
+	 */
+	ptr = pte_set_fixmap_init(phys);
+
+	memset(ptr, 0, PAGE_SIZE);
+
+	/*
+	 * Implicit barriers also ensure the zeroed page is visible to the page
+	 * table walker
+	 */
+	pte_clear_fixmap_init();
+
+	return phys;
+}
+#else
 static phys_addr_t __init early_pgtable_alloc(int shift)
 {
 	phys_addr_t phys;
@@ -119,6 +395,7 @@ static phys_addr_t __init early_pgtable_alloc(int shift)
 
 	return phys;
 }
+#endif
 
 static bool pgattr_change_is_safe(u64 old, u64 new)
 {
@@ -167,7 +444,11 @@ static void init_pte(pmd_t *pmdp, unsigned long addr, unsigned long end,
 	do {
 		pte_t old_pte = READ_ONCE(*ptep);
 
+		#ifdef CONFIG_PTP
+		iee_set_fixmap_pte_pre_init(ptep, pfn_pte(__phys_to_pfn(phys), prot));
+		#else
 		set_pte(ptep, pfn_pte(__phys_to_pfn(phys), prot));
+		#endif
 
 		/*
 		 * After the PTE entry has been populated once, we
@@ -196,7 +477,11 @@ static void alloc_init_cont_pte(pmd_t *pmdp, unsigned long addr,
 		phys_addr_t pte_phys;
 		BUG_ON(!pgtable_alloc);
 		pte_phys = pgtable_alloc(PAGE_SHIFT);
+		#ifdef CONFIG_PTP
+		__iee_pmd_populate_fixmap(pmdp, pte_phys, PMD_TYPE_TABLE);
+		#else
 		__pmd_populate(pmdp, pte_phys, PMD_TYPE_TABLE);
+		#endif
 		pmd = READ_ONCE(*pmdp);
 	}
 	BUG_ON(pmd_bad(pmd));
@@ -231,9 +516,17 @@ static void init_pmd(pud_t *pudp, unsigned long addr, unsigned long end,
 		next = pmd_addr_end(addr, end);
 
 		/* try section mapping first */
+		#ifdef CONFIG_IEE
+		if (!((pmd_val(old_pmd) & PTE_VALID) && (pmd_val(old_pmd) & PTE_TABLE_BIT)) && (((addr | next | phys) & ~SECTION_MASK) == 0 && (flags & NO_BLOCK_MAPPINGS) == 0)) {
+		#else
 		if (((addr | next | phys) & ~SECTION_MASK) == 0 &&
 		    (flags & NO_BLOCK_MAPPINGS) == 0) {
+		#endif
+			#ifdef CONFIG_PTP
+			iee_pmd_set_huge_fixmap(pmdp, phys, prot);
+			#else
 			pmd_set_huge(pmdp, phys, prot);
+			#endif
 
 			/*
 			 * After the PMD entry has been populated once, we
@@ -270,7 +563,11 @@ static void alloc_init_cont_pmd(pud_t *pudp, unsigned long addr,
 		phys_addr_t pmd_phys;
 		BUG_ON(!pgtable_alloc);
 		pmd_phys = pgtable_alloc(PMD_SHIFT);
+		#ifdef CONFIG_PTP
+		__iee_pud_populate_fixmap(pudp, pmd_phys, PUD_TYPE_TABLE);
+		#else
 		__pud_populate(pudp, pmd_phys, PUD_TYPE_TABLE);
+		#endif
 		pud = READ_ONCE(*pudp);
 	}
 	BUG_ON(pud_bad(pud));
@@ -294,6 +591,10 @@ static void alloc_init_cont_pmd(pud_t *pudp, unsigned long addr,
 static inline bool use_1G_block(unsigned long addr, unsigned long next,
 			unsigned long phys)
 {
+	#ifdef CONFIG_IEE
+	return false;
+	#endif
+
 	if (PAGE_SHIFT != 12)
 		return false;
 
@@ -339,7 +640,11 @@ static void alloc_init_pud(pgd_t *pgdp, unsigned long addr, unsigned long end,
 		 */
 		if (use_1G_block(addr, next, phys) &&
 		    (flags & NO_BLOCK_MAPPINGS) == 0) {
+			#ifdef CONFIG_PTP
+			iee_pud_set_huge_fixmap(pudp, phys, prot);
+			#else
 			pud_set_huge(pudp, phys, prot);
+			#endif
 
 			/*
 			 * After the PUD entry has been populated once, we
@@ -370,6 +675,10 @@ static void __create_pgd_mapping(pgd_t *pgdir, phys_addr_t phys,
 {
 	unsigned long addr, end, next;
 	pgd_t *pgdp = pgd_offset_pgd(pgdir, virt);
+	#ifdef CONFIG_IEE
+	p4d_t *p4dp;
+	p4d_t p4d;
+	#endif
 
 	/*
 	 * If the virtual and physical address don't have the same offset
@@ -388,96 +697,363 @@ static void __create_pgd_mapping(pgd_t *pgdir, phys_addr_t phys,
 		next = pgd_addr_end(addr, end);
 		alloc_init_pud(pgdp, addr, next, phys, prot, pgtable_alloc,
 			       flags);
+		#ifdef CONFIG_IEE
+		p4dp = p4d_offset(pgdp, addr);
+		p4d = READ_ONCE(*p4dp);
+		__p4d_populate(p4dp, __p4d_to_phys(p4d), (PGD_APT | PUD_TYPE_TABLE));
+		#endif
 		phys += next - addr;
 	} while (pgdp++, addr = next, addr != end);
 }
 
-static phys_addr_t __pgd_pgtable_alloc(int shift)
+#ifdef CONFIG_PTP
+static int __init iee_pud_set_huge_pre_init(pud_t *pudp, phys_addr_t phys, pgprot_t prot)
 {
-	void *ptr = (void *)__get_free_page(GFP_PGTABLE_KERNEL);
-	BUG_ON(!ptr);
+	pud_t new_pud = pfn_pud(__phys_to_pfn(phys), mk_pud_sect_prot(prot));
 
-	/* Ensure the zeroed page is visible to the page table walker */
-	dsb(ishst);
-	return __pa(ptr);
+	/* Only allow permission changes for now */
+	if (!pgattr_change_is_safe(READ_ONCE(pud_val(*pudp)),
+				   pud_val(new_pud)))
+		return 0;
+
+	VM_BUG_ON(phys & ~PUD_MASK);
+	iee_set_pud_pre_init(pudp, new_pud);
+	return 1;
 }
 
-static phys_addr_t pgd_pgtable_alloc(int shift)
+static int __init iee_pmd_set_huge_pre_init(pmd_t *pmdp, phys_addr_t phys, pgprot_t prot)
 {
-	phys_addr_t pa = __pgd_pgtable_alloc(shift);
+	pmd_t new_pmd = pfn_pmd(__phys_to_pfn(phys), mk_pmd_sect_prot(prot));
 
-	/*
-	 * Call proper page table ctor in case later we need to
-	 * call core mm functions like apply_to_page_range() on
-	 * this pre-allocated page table.
-	 *
-	 * We don't select ARCH_ENABLE_SPLIT_PMD_PTLOCK if pmd is
-	 * folded, and if so pgtable_pmd_page_ctor() becomes nop.
-	 */
-	if (shift == PAGE_SHIFT)
-		BUG_ON(!pgtable_pte_page_ctor(phys_to_page(pa)));
-	else if (shift == PMD_SHIFT)
-		BUG_ON(!pgtable_pmd_page_ctor(phys_to_page(pa)));
+	/* Only allow permission changes for now */
+	if (!pgattr_change_is_safe(READ_ONCE(pmd_val(*pmdp)),
+				   pmd_val(new_pmd)))
+		return 0;
 
-	return pa;
+	VM_BUG_ON(phys & ~PMD_MASK);
+	iee_set_pmd_pre_init(pmdp, new_pmd);
+	return 1;
 }
 
-/*
- * This function can only be used to modify existing table entries,
- * without allocating new levels of table. Note that this permits the
- * creation of new section or page entries.
- */
-static void __init create_mapping_noalloc(phys_addr_t phys, unsigned long virt,
-				  phys_addr_t size, pgprot_t prot)
+static __init void iee_init_pte_pre_init(pmd_t *pmdp, unsigned long addr, unsigned long end,
+		     phys_addr_t phys, pgprot_t prot)
 {
-	if (virt < PAGE_OFFSET) {
-		pr_warn("BUG: not creating mapping for %pa at 0x%016lx - outside kernel range\n",
-			&phys, virt);
-		return;
-	}
-	__create_pgd_mapping(init_mm.pgd, phys, virt, size, prot, NULL,
-			     NO_CONT_MAPPINGS);
-}
+	pte_t *ptep;
 
-void __init create_pgd_mapping(struct mm_struct *mm, phys_addr_t phys,
-			       unsigned long virt, phys_addr_t size,
-			       pgprot_t prot, bool page_mappings_only)
-{
-	int flags = 0;
+	ptep = pte_set_fixmap_offset_init(pmdp, addr);
+	do {
+		pte_t old_pte = READ_ONCE(*ptep);
 
-	BUG_ON(mm == &init_mm);
+		iee_set_pte_pre_init(ptep, pfn_pte(__phys_to_pfn(phys), prot));
 
-	if (page_mappings_only)
-		flags = NO_BLOCK_MAPPINGS | NO_CONT_MAPPINGS;
+		/*
+		 * After the PTE entry has been populated once, we
+		 * only allow updates to the permission attributes.
+		 */
+		BUG_ON(!pgattr_change_is_safe(pte_val(old_pte),
+					      READ_ONCE(pte_val(*ptep))));
 
-	__create_pgd_mapping(mm->pgd, phys, virt, size, prot,
-			     pgd_pgtable_alloc, flags);
+		phys += PAGE_SIZE;
+	} while (ptep++, addr += PAGE_SIZE, addr != end);
+
+	pte_clear_fixmap_init();
 }
 
-static void update_mapping_prot(phys_addr_t phys, unsigned long virt,
-				phys_addr_t size, pgprot_t prot)
+static __init void iee_alloc_init_cont_pte_pre_init(pmd_t *pmdp, unsigned long addr,
+				unsigned long end, phys_addr_t phys,
+				pgprot_t prot,
+				phys_addr_t (*pgtable_alloc)(int),
+				int flags)
 {
-	if (virt < PAGE_OFFSET) {
-		pr_warn("BUG: not updating mapping for %pa at 0x%016lx - outside kernel range\n",
-			&phys, virt);
-		return;
+	unsigned long next;
+	pmd_t pmd = READ_ONCE(*pmdp);
+
+	BUG_ON(pmd_sect(pmd));
+	if (pmd_none(pmd)) {
+		phys_addr_t pte_phys;
+		BUG_ON(!pgtable_alloc);
+		pte_phys = pgtable_alloc(PAGE_SHIFT);
+		__iee_pmd_populate_pre_init(pmdp, pte_phys, PMD_TYPE_TABLE);
+		pmd = READ_ONCE(*pmdp);
 	}
+	BUG_ON(pmd_bad(pmd));
 
-	__create_pgd_mapping(init_mm.pgd, phys, virt, size, prot, NULL,
-			     NO_CONT_MAPPINGS);
+	do {
+		pgprot_t __prot = prot;
 
-	/* flush the TLBs after updating live kernel mappings */
-	flush_tlb_kernel_range(virt, virt + size);
-}
+		next = pte_cont_addr_end(addr, end);
 
-static void __init __map_memblock(pgd_t *pgdp, phys_addr_t start,
-				  phys_addr_t end, pgprot_t prot, int flags)
-{
-	__create_pgd_mapping(pgdp, start, __phys_to_virt(start), end - start,
-			     prot, early_pgtable_alloc, flags);
+		/* use a contiguous mapping if the range is suitably aligned */
+		if ((((addr | next | phys) & ~CONT_PTE_MASK) == 0) &&
+		    (flags & NO_CONT_MAPPINGS) == 0)
+			__prot = __pgprot(pgprot_val(prot) | PTE_CONT);
+
+		iee_init_pte_pre_init(pmdp, addr, next, phys, __prot);
+
+		phys += next - addr;
+	} while (addr = next, addr != end);
 }
 
-void __init mark_linear_text_alias_ro(void)
+static __init void iee_init_pmd_pre_init(pud_t *pudp, unsigned long addr, unsigned long end,
+		     phys_addr_t phys, pgprot_t prot,
+		     phys_addr_t (*pgtable_alloc)(int), int flags)
+{
+	unsigned long next;
+	pmd_t *pmdp;
+
+	pmdp = pmd_set_fixmap_offset_init(pudp, addr);
+	do {
+		pmd_t old_pmd = READ_ONCE(*pmdp);
+
+		next = pmd_addr_end(addr, end);
+
+		/* try section mapping first */
+		if (((addr | next | phys) & ~SECTION_MASK) == 0 &&
+		    (flags & NO_BLOCK_MAPPINGS) == 0) {
+			iee_pmd_set_huge_pre_init(pmdp, phys, prot);
+
+			/*
+			 * After the PMD entry has been populated once, we
+			 * only allow updates to the permission attributes.
+			 */
+			BUG_ON(!pgattr_change_is_safe(pmd_val(old_pmd),
+						      READ_ONCE(pmd_val(*pmdp))));
+		} else {
+			iee_alloc_init_cont_pte_pre_init(pmdp, addr, next, phys, prot,
+					    pgtable_alloc, flags);
+
+			BUG_ON(pmd_val(old_pmd) != 0 &&
+			       pmd_val(old_pmd) != READ_ONCE(pmd_val(*pmdp)));
+		}
+		phys += next - addr;
+	} while (pmdp++, addr = next, addr != end);
+
+	pmd_clear_fixmap_init();
+}
+
+static __init void iee_alloc_init_cont_pmd_pre_init(pud_t *pudp, unsigned long addr,
+				unsigned long end, phys_addr_t phys,
+				pgprot_t prot,
+				phys_addr_t (*pgtable_alloc)(int), int flags)
+{
+	unsigned long next;
+	pud_t pud = READ_ONCE(*pudp);
+
+	/*
+	 * Check for initial section mappings in the pgd/pud.
+	 */
+	BUG_ON(pud_sect(pud));
+	if (pud_none(pud)) {
+		phys_addr_t pmd_phys;
+		BUG_ON(!pgtable_alloc);
+		pmd_phys = pgtable_alloc(PMD_SHIFT);
+		__iee_pud_populate_pre_init(pudp, pmd_phys, PUD_TYPE_TABLE);
+		pud = READ_ONCE(*pudp);
+	}
+	BUG_ON(pud_bad(pud));
+
+	do {
+		pgprot_t __prot = prot;
+
+		next = pmd_cont_addr_end(addr, end);
+
+		/* use a contiguous mapping if the range is suitably aligned */
+		if ((((addr | next | phys) & ~CONT_PMD_MASK) == 0) &&
+		    (flags & NO_CONT_MAPPINGS) == 0)
+			__prot = __pgprot(pgprot_val(prot) | PTE_CONT);
+
+		iee_init_pmd_pre_init(pudp, addr, next, phys, __prot, pgtable_alloc, flags);
+
+		phys += next - addr;
+	} while (addr = next, addr != end);
+}
+
+static __init void iee_alloc_init_pud_pre_init(pgd_t *pgdp, unsigned long addr, unsigned long end,
+			   phys_addr_t phys, pgprot_t prot,
+			   phys_addr_t (*pgtable_alloc)(int),
+			   int flags)
+{
+	unsigned long next;
+	pud_t *pudp;
+	p4d_t *p4dp = p4d_offset(pgdp, addr);
+	p4d_t p4d = READ_ONCE(*p4dp);
+
+	if (p4d_none(p4d)) {
+		phys_addr_t pud_phys;
+		BUG_ON(!pgtable_alloc);
+		pud_phys = pgtable_alloc(PUD_SHIFT);
+		__iee_p4d_populate_pre_init(p4dp, pud_phys, PUD_TYPE_TABLE);
+		p4d = READ_ONCE(*p4dp);
+	}
+	BUG_ON(p4d_bad(p4d));
+
+	pudp = pud_set_fixmap_offset_init(p4dp, addr);
+	do {
+		pud_t old_pud = READ_ONCE(*pudp);
+
+		next = pud_addr_end(addr, end);
+
+		/*
+		 * For 4K granule only, attempt to put down a 1GB block
+		 */
+		if (use_1G_block(addr, next, phys) &&
+		    (flags & NO_BLOCK_MAPPINGS) == 0) {
+			iee_pud_set_huge_pre_init(pudp, phys, prot);
+
+			/*
+			 * After the PUD entry has been populated once, we
+			 * only allow updates to the permission attributes.
+			 */
+			BUG_ON(!pgattr_change_is_safe(pud_val(old_pud),
+						      READ_ONCE(pud_val(*pudp))));
+		} else {
+			iee_alloc_init_cont_pmd_pre_init(pudp, addr, next, phys, prot,
+					    pgtable_alloc, flags);
+
+			BUG_ON(pud_val(old_pud) != 0 &&
+			       pud_val(old_pud) != READ_ONCE(pud_val(*pudp)));
+		}
+		phys += next - addr;
+	} while (pudp++, addr = next, addr != end);
+
+	pud_clear_fixmap_init();
+}
+
+static __init void __iee_create_pgd_mapping_pre_init(pgd_t *pgdir, phys_addr_t phys,
+				 unsigned long virt, phys_addr_t size,
+				 pgprot_t prot,
+				 phys_addr_t (*pgtable_alloc)(int),
+				 int flags)
+{
+	unsigned long addr, end, next;
+	pgd_t *pgdp = pgd_offset_pgd(pgdir, virt);
+	p4d_t *p4dp;
+	p4d_t p4d;
+
+	/*
+	 * If the virtual and physical address don't have the same offset
+	 * within a page, we cannot map the region as the caller expects.
+	 */
+	if (WARN_ON((phys ^ virt) & ~PAGE_MASK))
+		return;
+
+	phys &= PAGE_MASK;
+	addr = virt & PAGE_MASK;
+	end = PAGE_ALIGN(virt + size);
+
+	do {
+		next = pgd_addr_end(addr, end);
+		iee_alloc_init_pud_pre_init(pgdp, addr, next, phys, prot, pgtable_alloc,
+			       flags);
+		p4dp = p4d_offset(pgdp, addr);
+		p4d = READ_ONCE(*p4dp);
+		__iee_p4d_populate_pre_init(p4dp, __p4d_to_phys(p4d), (PGD_APT | PUD_TYPE_TABLE));
+		phys += next - addr;
+	} while (pgdp++, addr = next, addr != end);
+}
+#endif
+
+static phys_addr_t __pgd_pgtable_alloc(int shift)
+{
+	#ifdef CONFIG_PTP
+	void *ptr = get_iee_pgtable_page(GFP_PGTABLE_KERNEL);
+	#else
+	void *ptr = (void *)__get_free_page(GFP_PGTABLE_KERNEL);
+	#endif
+	BUG_ON(!ptr);
+
+	/* Ensure the zeroed page is visible to the page table walker */
+	dsb(ishst);
+	return __pa(ptr);
+}
+
+static phys_addr_t pgd_pgtable_alloc(int shift)
+{
+	phys_addr_t pa = __pgd_pgtable_alloc(shift);
+
+	/*
+	 * Call proper page table ctor in case later we need to
+	 * call core mm functions like apply_to_page_range() on
+	 * this pre-allocated page table.
+	 *
+	 * We don't select ARCH_ENABLE_SPLIT_PMD_PTLOCK if pmd is
+	 * folded, and if so pgtable_pmd_page_ctor() becomes nop.
+	 */
+	if (shift == PAGE_SHIFT)
+		BUG_ON(!pgtable_pte_page_ctor(phys_to_page(pa)));
+	else if (shift == PMD_SHIFT)
+		BUG_ON(!pgtable_pmd_page_ctor(phys_to_page(pa)));
+
+	return pa;
+}
+
+/*
+ * This function can only be used to modify existing table entries,
+ * without allocating new levels of table. Note that this permits the
+ * creation of new section or page entries.
+ */
+static void __init create_mapping_noalloc(phys_addr_t phys, unsigned long virt,
+				  phys_addr_t size, pgprot_t prot)
+{
+	if (virt < PAGE_OFFSET) {
+		pr_warn("BUG: not creating mapping for %pa at 0x%016lx - outside kernel range\n",
+			&phys, virt);
+		return;
+	}
+
+	#ifdef CONFIG_PTP
+	__iee_create_pgd_mapping_pre_init(init_mm.pgd, phys, virt, size, prot, NULL,
+			     NO_CONT_MAPPINGS);
+	#else
+	__create_pgd_mapping(init_mm.pgd, phys, virt, size, prot, NULL,
+			     NO_CONT_MAPPINGS);
+	#endif
+}
+
+void __init create_pgd_mapping(struct mm_struct *mm, phys_addr_t phys,
+			       unsigned long virt, phys_addr_t size,
+			       pgprot_t prot, bool page_mappings_only)
+{
+	int flags = 0;
+
+	BUG_ON(mm == &init_mm);
+
+	if (page_mappings_only)
+		flags = NO_BLOCK_MAPPINGS | NO_CONT_MAPPINGS;
+
+	__create_pgd_mapping(mm->pgd, phys, virt, size, prot,
+			     pgd_pgtable_alloc, flags);
+}
+
+static void update_mapping_prot(phys_addr_t phys, unsigned long virt,
+				phys_addr_t size, pgprot_t prot)
+{
+	if (virt < PAGE_OFFSET) {
+		pr_warn("BUG: not updating mapping for %pa at 0x%016lx - outside kernel range\n",
+			&phys, virt);
+		return;
+	}
+
+	__create_pgd_mapping(init_mm.pgd, phys, virt, size, prot, NULL,
+			     NO_CONT_MAPPINGS);
+
+	/* flush the TLBs after updating live kernel mappings */
+	flush_tlb_kernel_range(virt, virt + size);
+}
+
+static void __init __map_memblock(pgd_t *pgdp, phys_addr_t start,
+				  phys_addr_t end, pgprot_t prot, int flags)
+{
+	#ifdef CONFIG_PTP
+	__iee_create_pgd_mapping_pre_init(pgdp, start, __phys_to_virt(start), end - start,
+			     prot, early_pgtable_alloc, flags);
+	#else
+	__create_pgd_mapping(pgdp, start, __phys_to_virt(start), end - start,
+			     prot, early_pgtable_alloc, flags);
+	#endif
+}
+
+void __init mark_linear_text_alias_ro(void)
 {
 	/*
 	 * Remove the write permissions from the linear alias of .text/.rodata
@@ -625,8 +1201,13 @@ static void __init map_kernel_segment(pgd_t *pgdp, void *va_start, void *va_end,
 	BUG_ON(!PAGE_ALIGNED(pa_start));
 	BUG_ON(!PAGE_ALIGNED(size));
 
+	#ifdef CONFIG_PTP
+	__iee_create_pgd_mapping_pre_init(pgdp, pa_start, (unsigned long)va_start, size, prot,
+			     early_pgtable_alloc, flags);
+	#else
 	__create_pgd_mapping(pgdp, pa_start, (unsigned long)va_start, size, prot,
 			     early_pgtable_alloc, flags);
+	#endif
 
 	if (!(vm_flags & VM_NO_GUARD))
 		size += PAGE_SIZE;
@@ -640,133 +1221,810 @@ static void __init map_kernel_segment(pgd_t *pgdp, void *va_start, void *va_end,
 	vm_area_add_early(vma);
 }
 
-#ifdef CONFIG_UNMAP_KERNEL_AT_EL0
-static int __init map_entry_trampoline(void)
+#ifdef CONFIG_UNMAP_KERNEL_AT_EL0
+static int __init map_entry_trampoline(void)
+{
+	int i;
+
+	pgprot_t prot = rodata_enabled ? PAGE_KERNEL_ROX : PAGE_KERNEL_EXEC;
+	phys_addr_t pa_start = __pa_symbol(__entry_tramp_text_start);
+
+	/* The trampoline is always mapped and can therefore be global */
+	pgprot_val(prot) &= ~PTE_NG;
+
+	/* Map only the text into the trampoline page table */
+	memset(tramp_pg_dir, 0, PGD_SIZE);
+	#ifdef CONFIG_PTP
+	iee_set_logical_mem_ro((unsigned long)tramp_pg_dir);
+	#endif
+	__create_pgd_mapping(tramp_pg_dir, pa_start, TRAMP_VALIAS,
+			     entry_tramp_text_size(), prot,
+			     __pgd_pgtable_alloc, NO_BLOCK_MAPPINGS);
+
+	/* Map both the text and data into the kernel page table */
+	for (i = 0; i < DIV_ROUND_UP(entry_tramp_text_size(), PAGE_SIZE); i++)
+		__set_fixmap(FIX_ENTRY_TRAMP_TEXT1 - i,
+			     pa_start + i * PAGE_SIZE, prot);
+
+	if (IS_ENABLED(CONFIG_RANDOMIZE_BASE)) {
+		extern char __entry_tramp_data_start[];
+
+		__set_fixmap(FIX_ENTRY_TRAMP_DATA,
+			     __pa_symbol(__entry_tramp_data_start),
+			     PAGE_KERNEL_RO);
+	}
+
+	return 0;
+}
+core_initcall(map_entry_trampoline);
+#endif
+
+/*
+ * Open coded check for BTI, only for use to determine configuration
+ * for early mappings for before the cpufeature code has run.
+ */
+static bool arm64_early_this_cpu_has_bti(void)
+{
+	u64 pfr1;
+
+	if (!IS_ENABLED(CONFIG_ARM64_BTI_KERNEL))
+		return false;
+
+	pfr1 = read_sysreg_s(SYS_ID_AA64PFR1_EL1);
+	return cpuid_feature_extract_unsigned_field(pfr1,
+						    ID_AA64PFR1_BT_SHIFT);
+}
+
+#ifdef CONFIG_IEE
+/* Set PMD APTable of iee si codes as (1,1) to revert it to ROX P pages when HPD1=0. */
+static void __init iee_si_set_pmd_APtable(unsigned long addr, pgd_t *pgdir)
+{
+	pgd_t *pgdp = pgd_offset_pgd(pgdir, addr);
+
+	p4d_t *p4dp = p4d_offset(pgdp, addr);
+
+    #ifdef CONFIG_PTP
+	pud_t *pudp = pud_set_fixmap_offset_init(p4dp, addr);
+
+	pmd_t *pmdp = pmd_set_fixmap_offset_init(pudp, addr);
+
+    pmd_t pmd = READ_ONCE(*pmdp);
+
+    __iee_pmd_populate_pre_init(pmdp, __pmd_to_phys(pmd), PGD_APT_RO | PGD_APT | PMD_TYPE_TABLE);
+
+	pud_clear_fixmap_init();
+	pmd_clear_fixmap_init();
+    #else
+    pud_t *pudp = pud_set_fixmap_offset(p4dp, addr);
+
+	pmd_t *pmdp = pmd_set_fixmap_offset(pudp, addr);
+
+    pmd_t pmd = READ_ONCE(*pmdp);
+
+    __pmd_populate(pmdp, __pmd_to_phys(pmd), PGD_APT_RO | PGD_APT | PMD_TYPE_TABLE);
+
+	pud_clear_fixmap();
+	pmd_clear_fixmap();
+    #endif
+}
+/* Set PMD APTable of iee si codes as (1,1) to revert it to ROX P pages when HPD1=0. */
+static void __init mark_iee_si_pmd_APtable(pgd_t *pgdir)
+{
+    unsigned long addr = (unsigned long)__iee_si_start;
+    iee_si_set_pmd_APtable(addr, pgdir);
+    // iee rwx gate exit may be mapped by another pmd.
+    iee_si_set_pmd_APtable(addr + PAGE_SIZE, pgdir);
+}
+#endif
+
+/*
+ * Create fine-grained mappings for the kernel.
+ */
+static void __init map_kernel(pgd_t *pgdp)
+{
+	static struct vm_struct vmlinux_text, vmlinux_rodata, vmlinux_inittext,
+				vmlinux_initdata, vmlinux_data;
+	
+	#ifdef CONFIG_IEE
+    static struct vm_struct vmlinux_text_idmap, vmlinux_iee_data, vmlinux_iee_gate, 
+				vmlinux_iee_code, vmlinux_text_end;
+	#endif
+
+	/*
+	 * External debuggers may need to write directly to the text
+	 * mapping to install SW breakpoints. Allow this (only) when
+	 * explicitly requested with rodata=off.
+	 */
+	pgprot_t text_prot = rodata_enabled ? PAGE_KERNEL_ROX : PAGE_KERNEL_EXEC;
+
+	/*
+	 * If we have a CPU that supports BTI and a kernel built for
+	 * BTI then mark the kernel executable text as guarded pages
+	 * now so we don't have to rewrite the page tables later.
+	 */
+	if (arm64_early_this_cpu_has_bti())
+		text_prot = __pgprot_modify(text_prot, PTE_GP, PTE_GP);
+
+	/*
+	 * Only rodata will be remapped with different permissions later on,
+	 * all other segments are allowed to use contiguous mappings.
+	 */
+	#ifdef CONFIG_IEE
+	map_kernel_segment(pgdp, _text, __idmap_text_start, text_prot, &vmlinux_text,
+			   0, VM_NO_GUARD);
+	/*
+	 * Cancel contiguous mappings of idmap and iee si sections to 
+	 * simplify modifications later.
+	 */
+	map_kernel_segment(pgdp, __idmap_text_start, __iee_si_data_start, text_prot, &vmlinux_text_idmap,
+			   0, VM_NO_GUARD);
+	/* Set iee si data RW. */
+	map_kernel_segment(pgdp, __iee_si_data_start, __iee_exec_entry_start, SET_NG(PAGE_KERNEL), 
+			   &vmlinux_iee_data, NO_CONT_MAPPINGS | NO_BLOCK_MAPPINGS, VM_NO_GUARD);
+	/* Set iee entry codes NG. */		   
+	map_kernel_segment(pgdp, __iee_exec_entry_start, __iee_si_start, SET_NG(text_prot), &vmlinux_iee_gate,
+			   NO_CONT_MAPPINGS | NO_BLOCK_MAPPINGS, VM_NO_GUARD);
+	/* Map __iee_si_start - __iee_si_end as U RWX pages and set PMD APTABLE = (1,1). */
+	map_kernel_segment(pgdp, __iee_si_start, __iee_si_end, SET_NG((PAGE_KERNEL_EXEC)),
+			   &vmlinux_iee_code, NO_CONT_MAPPINGS | NO_BLOCK_MAPPINGS, VM_NO_GUARD);
+    mark_iee_si_pmd_APtable(pgdp);
+    
+	map_kernel_segment(pgdp, __iee_si_end, _etext, text_prot, &vmlinux_text_end, 0,
+			   VM_NO_GUARD);
+	
+	map_kernel_segment(pgdp, __start_rodata, __inittext_begin, PAGE_KERNEL,
+			   &vmlinux_rodata, NO_CONT_MAPPINGS | NO_BLOCK_MAPPINGS, VM_NO_GUARD);
+	map_kernel_segment(pgdp, __inittext_begin, __inittext_end, text_prot,
+			   &vmlinux_inittext, 0, VM_NO_GUARD);
+	map_kernel_segment(pgdp, __initdata_begin, __initdata_end, PAGE_KERNEL,
+			   &vmlinux_initdata, 0, VM_NO_GUARD);
+	map_kernel_segment(pgdp, _data, _end, PAGE_KERNEL, &vmlinux_data, NO_CONT_MAPPINGS | NO_BLOCK_MAPPINGS, 0);
+	#else
+	map_kernel_segment(pgdp, _text, _etext, text_prot, &vmlinux_text, 0,
+			   VM_NO_GUARD);
+	map_kernel_segment(pgdp, __start_rodata, __inittext_begin, PAGE_KERNEL,
+			   &vmlinux_rodata, NO_CONT_MAPPINGS, VM_NO_GUARD);
+	map_kernel_segment(pgdp, __inittext_begin, __inittext_end, text_prot,
+			   &vmlinux_inittext, 0, VM_NO_GUARD);
+	map_kernel_segment(pgdp, __initdata_begin, __initdata_end, PAGE_KERNEL,
+			   &vmlinux_initdata, 0, VM_NO_GUARD);
+	map_kernel_segment(pgdp, _data, _end, PAGE_KERNEL, &vmlinux_data, 0, 0);
+	#endif
+
+
+	if (!READ_ONCE(pgd_val(*pgd_offset_pgd(pgdp, FIXADDR_START)))) {
+		/*
+		 * The fixmap falls in a separate pgd to the kernel, and doesn't
+		 * live in the carveout for the swapper_pg_dir. We can simply
+		 * re-use the existing dir for the fixmap.
+		 */
+		#ifdef CONFIG_PTP
+		set_pgd_init(pgd_offset_pgd(pgdp, FIXADDR_START),
+			READ_ONCE(*pgd_offset_k(FIXADDR_START)));
+		#else
+		set_pgd(pgd_offset_pgd(pgdp, FIXADDR_START),
+			READ_ONCE(*pgd_offset_k(FIXADDR_START)));
+		#endif
+	} else if (CONFIG_PGTABLE_LEVELS > 3) {
+		pgd_t *bm_pgdp;
+		p4d_t *bm_p4dp;
+		pud_t *bm_pudp;
+		/*
+		 * The fixmap shares its top level pgd entry with the kernel
+		 * mapping. This can really only occur when we are running
+		 * with 16k/4 levels, so we can simply reuse the pud level
+		 * entry instead.
+		 */
+		BUG_ON(!IS_ENABLED(CONFIG_ARM64_16K_PAGES));
+		bm_pgdp = pgd_offset_pgd(pgdp, FIXADDR_START);
+		bm_p4dp = p4d_offset(bm_pgdp, FIXADDR_START);
+		#ifdef CONFIG_PTP
+		bm_pudp = pud_set_fixmap_offset_init(bm_p4dp, FIXADDR_START);
+		__iee_pud_populate_pre_init(bm_pudp, __pa(lm_alias(bm_pmd)), PMD_TYPE_TABLE);
+		pud_clear_fixmap_init();
+		#else
+		bm_pudp = pud_set_fixmap_offset(bm_p4dp, FIXADDR_START);
+		pud_populate(&init_mm, bm_pudp, lm_alias(bm_pmd));
+		pud_clear_fixmap();
+		#endif
+	} else {
+		BUG();
+	}
+
+	kasan_copy_shadow(pgdp);
+}
+
+#ifdef CONFIG_IEE
+static void __create_pgd_mapping_for_iee(pgd_t *pgdir, phys_addr_t phys,
+				 unsigned long virt, phys_addr_t size,
+				 pgprot_t prot,
+				 phys_addr_t (*pgtable_alloc)(int),
+				 int flags)
+{
+	unsigned long addr, end, next;
+	pgd_t *pgdp = pgd_offset_pgd(pgdir, virt);
+	p4d_t *p4dp;
+	p4d_t p4d;
+
+	/*
+	 * If the virtual and physical address don't have the same offset
+	 * within a page, we cannot map the region as the caller expects.
+	 */
+	if (WARN_ON((phys ^ virt) & ~PAGE_MASK))
+		return;
+
+	phys &= PAGE_MASK;
+	addr = virt & PAGE_MASK;
+	end = PAGE_ALIGN(virt + size);
+
+	do {
+		next = pgd_addr_end(addr, end);
+		#ifdef CONFIG_PTP
+		iee_alloc_init_pud_pre_init(pgdp, addr, next, phys, prot, pgtable_alloc,
+			       flags);
+		#else
+		alloc_init_pud(pgdp, addr, next, phys, prot, pgtable_alloc,
+			       flags);
+		#endif
+		p4dp = p4d_offset(pgdp, addr);
+		p4d = READ_ONCE(*p4dp);
+		#ifdef CONFIG_PTP
+		__iee_p4d_populate_pre_init(p4dp, __p4d_to_phys(p4d), (PGD_APT | PGD_PXN | PGD_UXN | PUD_TYPE_TABLE));
+		#else
+		__p4d_populate(p4dp, __p4d_to_phys(p4d), (PGD_APT | PGD_PXN | PGD_UXN | PUD_TYPE_TABLE));
+		#endif
+		phys += next - addr;
+	} while (pgdp++, addr = next, addr != end);
+}
+
+static void __init __map_memblock_for_iee(pgd_t *pgdp, phys_addr_t start,
+				  phys_addr_t end, pgprot_t prot, int flags)
+{
+	#ifdef CONFIG_PTP
+	__create_pgd_mapping_for_iee(pgdp, start, __phys_to_iee(start), end - start,
+			     prot, early_pgtable_alloc, flags);
+	#else
+	__create_pgd_mapping_for_iee(pgdp, start, __phys_to_iee(start), end - start,
+			     prot, early_pgtable_alloc, flags);
+	#endif
+}
+
+static void __init map_iee(pgd_t *pgdp)
+{
+	phys_addr_t kernel_start = __pa_symbol(_text);
+	phys_addr_t kernel_end = __pa_symbol(__init_begin);
+	phys_addr_t start, end;
+	int flags = 0;
+	u64 i;
+
+	flags = NO_BLOCK_MAPPINGS | NO_CONT_MAPPINGS;
+
+	/*
+	 * Take care not to create a writable alias for the
+	 * read-only text and rodata sections of the kernel image.
+	 * So temporarily mark them as NOMAP to skip mappings in
+	 * the following for-loop
+	 */
+	memblock_mark_nomap(kernel_start, kernel_end - kernel_start);
+#ifdef CONFIG_KEXEC_CORE
+	if (crashk_res.end)
+		memblock_mark_nomap(crashk_res.start,
+				    resource_size(&crashk_res));
+#endif
+
+	/* map all the memory banks */
+	for_each_mem_range(i, &start, &end) {
+		if (start >= end)
+			break;
+		/*
+		 * The linear map must allow allocation tags reading/writing
+		 * if MTE is present. Otherwise, it has the same attributes as
+		 * PAGE_KERNEL.
+		 */
+		__map_memblock_for_iee(pgdp, start, end, SET_NG(SET_INVALID(SET_UPAGE(PAGE_KERNEL))), flags);
+	}
+
+	/*
+	 * Map the linear alias of the [_text, __init_begin) interval
+	 * as non-executable now, and remove the write permission in
+	 * mark_linear_text_alias_ro() below (which will be called after
+	 * alternative patching has completed). This makes the contents
+	 * of the region accessible to subsystems such as hibernate,
+	 * but protects it from inadvertent modification or execution.
+	 * Note that contiguous mappings cannot be remapped in this way,
+	 * so we should avoid them here.
+	 */
+	__map_memblock_for_iee(pgdp, kernel_start, kernel_end,
+		       SET_NG(SET_INVALID(SET_UPAGE(PAGE_KERNEL))), flags);
+	memblock_clear_nomap(kernel_start, kernel_end - kernel_start);
+
+#ifdef CONFIG_KEXEC_CORE
+	/*
+	 * Use page-level mappings here so that we can shrink the region
+	 * in page granularity and put back unused memory to buddy system
+	 * through /sys/kernel/kexec_crash_size interface.
+	 */
+	if (crashk_res.end) {
+		__map_memblock_for_iee(pgdp, crashk_res.start, crashk_res.end + 1,
+			       SET_NG(SET_INVALID(SET_UPAGE(PAGE_KERNEL))),
+			       NO_BLOCK_MAPPINGS | NO_CONT_MAPPINGS);
+		memblock_clear_nomap(crashk_res.start,
+				     resource_size(&crashk_res));
+	}
+#endif
+}
+
+/*
+ * Change page access permission, whereas not handling huge pages.
+ * Only used on IEE init functions.
+ */ 
+static int __init iee_si_set_page_attr(unsigned long addr, pteval_t attr)
+{
+	unsigned long flag;
+    pgd_t *pgdir = swapper_pg_dir;
+	pgd_t *pgdp = pgd_offset_pgd(pgdir, addr);
+
+	p4d_t *p4dp = p4d_offset(pgdp, addr);
+
+	pud_t *pudp = pud_offset(p4dp, addr);
+
+	pmd_t *pmdp = pmd_offset(pudp, addr);
+
+    pte_t *ptep = pte_offset_kernel(pmdp, addr);
+    pte_t pte = READ_ONCE(*ptep);
+    pr_info("IEE: page access permission changed on address 0x%lx, curr pte val: 0x%lx",
+            addr, (unsigned long)pte_val(pte));
+    if(attr & PTE_RDONLY)
+        pte = __pte((pte_val(pte) | PTE_RDONLY) & ~PTE_DBM);
+    pte = __pte(pte_val(pte) | attr);
+    #ifdef CONFIG_PTP
+	// Write pgtable in IEE directly.
+	flag = local_daif_save();
+	asm volatile ("msr pan, #0");
+    WRITE_ONCE(*((pte_t *)(__phys_to_iee(__pa(ptep)))), pte);
+	asm volatile ("msr pan, #1");
+	local_daif_restore(flag);
+    #else
+    WRITE_ONCE(*ptep, pte);
+    #endif
+    pr_info("IEE: modified pte val: 0x%lx", (unsigned long)pte_val(pte));
+    return 1;
+}
+
+int __init iee_si_test_page_attr(unsigned long addr)
+{
+    pgd_t *pgdir = swapper_pg_dir;
+	pgd_t *pgdp = pgd_offset_pgd(pgdir, addr);
+
+	p4d_t *p4dp = p4d_offset(pgdp, addr);
+
+	pud_t *pudp = pud_offset(p4dp, addr);
+
+	pmd_t *pmdp = pmd_offset(pudp, addr);
+
+	pte_t *ptep = pte_offset_kernel(pmdp, addr);
+
+    pmd_t pmd = READ_ONCE(*pmdp);
+	pte_t pte = READ_ONCE(*ptep);
+
+    pr_info("IEE: Testing address 0x%lx. pmdp address:0x%lx", addr, (unsigned long)pmdp);
+    if ((pmd_val(pmd) & PMD_TABLE_BIT))
+        pr_info("IEE: address 0x%lx is not a huge page. pmd val:0x%lx\n", addr, (unsigned long)pmd_val(pmd));
+    else{
+        pr_info("IEE: address 0x%lx is a 2M huge page. pmd val:0x%lx\n", addr, (unsigned long)pmd_val(pmd));
+        return 0;
+    }
+    pr_info("IEE: pte val on address 0x%lx : 0x%lx", addr, (unsigned long)pte_val(pte));
+    return 1;
+}
+
+// void iee_si_test_page_attr_all(unsigned long addr)
+// {
+//     pgd_t *pgdir = swapper_pg_dir;
+// 	pgd_t *pgdp = pgd_offset_pgd(pgdir, addr);
+
+	
+
+// 	p4d_t *p4dp = p4d_offset(pgdp, addr);
+
+// 	pud_t *pudp = pud_offset(p4dp, addr);
+
+// 	pmd_t *pmdp = pmd_offset(pudp, addr);
+
+// 	pte_t *ptep = pte_offset_kernel(pmdp, addr);
+
+// 	pgd_t pgd = READ_ONCE(*pgdp);
+// 	pud_t pud = READ_ONCE(*pudp);
+//     pmd_t pmd = READ_ONCE(*pmdp);
+// 	pte_t pte = READ_ONCE(*ptep);
+
+// 	unsigned long pgd_val = pgd_val(pgd);
+// 	unsigned long pud_val = pud_val(pud);
+// 	unsigned long pmd_val = pmd_val(pmd);
+// 	unsigned long pte_val = pte_val(pte);
+//     pr_info("IEE: Testing address 0x%lx. pgd:0x%lx, pud:0x%lx, pmd:0x%lx", addr, pgd_val, pud_val, pmd_val);
+//     // if ((pmd_val(pmd) & PMD_TABLE_BIT))
+//     //     pr_info("IEE: address 0x%lx is not a huge page. pmd val:0x%lx\n", addr, pmd_val(pmd));
+//     // else{
+//     //     pr_info("IEE: address 0x%lx is a 2M huge page. pmd val:0x%lx\n", addr, pmd_val(pmd));
+//     //     return 0;
+//     // }
+//     pr_info("IEE: pte val on address 0x%lx : 0x%lx", addr, pte_val);
+// }
+
+/* map idmap function inside vmalloc region to be ROU pages too. */
+void __init mark_idmap_vmallc_map_ROU(void)
+{
+    unsigned long va = (unsigned long)__idmap_text_start;
+    // protect vmalloc mapping of idmap function page.
+    if(iee_si_set_page_attr(va, PTE_PXN | PTE_UXN | PTE_RDONLY))
+        pr_info("IEE: idmap functions protected.\n");
+    else
+        pr_info("IEE warning: idmap protection failed.\n");
+}
+
+/* Prepare data used for iee rwx gates. These data are setted only once. */
+void __init iee_si_prepare_data(void)
+{
+	unsigned long va;
+	// Record current TCR val after system init.
+	iee_si_tcr = read_sysreg(tcr_el1) & ~(SYS_TCR_IEE_SI);
+    // CNP maybe enable.
+    if (system_supports_cnp()) {
+		iee_base_swapper_pg_dir |= TTBR_CNP_BIT;
+	}
+	// Mark iee data as RO and move it to iee after setting up.
+	va = (unsigned long)__iee_si_data_start;
+	iee_si_set_page_attr(va, PTE_RDONLY);
+	va = (unsigned long)__iee_si_start;
+	iee_si_set_page_attr(va, PTE_USER);
+	va = (unsigned long)__iee_si_start + PAGE_SIZE;
+	iee_si_set_page_attr(va, PTE_USER);
+	flush_tlb_all();
+}
+#endif
+
+#ifdef CONFIG_PTP
+// Attention : Using set_xxx without adding offset.
+static void __init set_iee_valid_pre_init(unsigned long addr)
+{
+	pgd_t *pgdir = swapper_pg_dir;
+	pgd_t *pgdp = pgd_offset_pgd(pgdir, addr);
+
+	p4d_t *p4dp = p4d_offset(pgdp, addr);
+
+	pud_t *pudp = pud_offset(p4dp, addr);
+
+	pmd_t *pmdp = pmd_offset(pudp, addr);
+
+	pte_t *ptep = pte_offset_kernel(pmdp, addr);
+	pte_t pte = READ_ONCE(*ptep);
+
+	if((addr < (PAGE_OFFSET + IEE_OFFSET)) | (addr > (PAGE_OFFSET + BIT(vabits_actual - 1))))
+		return;
+
+	pte = __pte(pte_val(pte) | 0x1);
+	iee_set_pte_pre_init(ptep, pte);
+	flush_tlb_kernel_range(addr, addr+PAGE_SIZE);
+	isb();
+}
+
+static void __init move_pte_table_into_iee(pmd_t *pmdp, unsigned long addr, unsigned long end)
+{
+	pmd_t pmd = READ_ONCE(*pmdp);
+	unsigned long iee_addr = __phys_to_iee(__pmd_to_phys(pmd));
+	set_iee_valid_pre_init(iee_addr);
+}
+
+static void __init move_pmd_table_into_iee(pud_t *pudp, unsigned long addr, unsigned long end)
+{
+	unsigned long next;
+	pud_t pud = READ_ONCE(*pudp);
+	pmd_t *pmdp;
+	pmd_t pmd;
+	unsigned long iee_addr = __phys_to_iee(__pud_to_phys(pud));
+	set_iee_valid_pre_init(iee_addr);
+
+	pmdp = pmd_offset(pudp, addr);
+	do {
+		next = pmd_addr_end(addr, end);
+		pmd = READ_ONCE(*pmdp);
+		if((pmd_val(pmd) & PMD_TABLE_BIT) == 0)
+		{
+			continue;
+		}
+		else
+		{
+			move_pte_table_into_iee(pmdp, addr, next);
+		}
+	} while (pmdp++, addr = next, addr != end);
+}
+
+static void __init move_pud_table_into_iee(pgd_t *pgdp, unsigned long addr, unsigned long end)
+{
+	unsigned long next;
+	p4d_t *p4dp = p4d_offset(pgdp, addr);
+	p4d_t p4d = READ_ONCE(*p4dp);
+	pud_t *pudp;
+	pud_t pud;
+	unsigned long iee_addr = __phys_to_iee(__p4d_to_phys(p4d));
+	set_iee_valid_pre_init(iee_addr);
+
+	pudp = pud_offset(p4dp, addr);
+	do {
+		next = pud_addr_end(addr, end);
+		pud = READ_ONCE(*pudp);
+		if ((pud_val(pud) & PUD_TABLE_BIT) == 0)
+		{
+			continue;
+		}
+		else
+		{
+			move_pmd_table_into_iee(pudp, addr, next);
+		}
+	} while (pudp++, addr = next, addr != end);
+}
+
+static void __init init_iee_for_one_region(pgd_t *pgdir, unsigned long va_start, unsigned long va_end)
+{
+	unsigned long addr, end, next;
+	pgd_t *pgdp = pgd_offset_pgd(pgdir, va_start);
+
+	addr = va_start & PAGE_MASK;
+	end = PAGE_ALIGN(va_end);
+
+	do {
+		next = pgd_addr_end(addr, end);
+		move_pud_table_into_iee(pgdp, addr, next);
+	} while (pgdp++, addr = next, addr != end);
+}
+
+static void __init init_iee(void)
 {
-	int i;
+	unsigned long iee_addr;
+	phys_addr_t start, end;
+	u64 i;
+	pgd_t *pgdp;
 
-	pgprot_t prot = rodata_enabled ? PAGE_KERNEL_ROX : PAGE_KERNEL_EXEC;
-	phys_addr_t pa_start = __pa_symbol(__entry_tramp_text_start);
+	#ifdef CONFIG_UNMAP_KERNEL_AT_EL0
+	// handling 1-level tramp page table tramp_pg_dir
+	iee_addr = (unsigned long)__phys_to_iee(__pa_symbol(tramp_pg_dir));
+	set_iee_valid_pre_init(iee_addr);
+	#endif
+	// handling 1-level page table swapper_pg_dir
+	pgdp = swapper_pg_dir;
+	iee_addr = (unsigned long)__phys_to_iee(__pa_symbol(swapper_pg_dir));
+	set_iee_valid_pre_init(iee_addr);
+	// handling 2/3/4-level page table for kernel
+	init_iee_for_one_region(pgdp, (unsigned long)_text, (unsigned long)_etext);
+	init_iee_for_one_region(pgdp, (unsigned long)__start_rodata, (unsigned long)__inittext_begin);
+	init_iee_for_one_region(pgdp, (unsigned long)__inittext_begin, (unsigned long)__inittext_end);
+	init_iee_for_one_region(pgdp, (unsigned long)__initdata_begin, (unsigned long)__initdata_end);
+	init_iee_for_one_region(pgdp, (unsigned long)_data, (unsigned long)_end);
+	// handling 2/3/4-level page table for fixmap i.e. remap bm_xxx
+	iee_addr = (unsigned long)__phys_to_iee(__pa_symbol(bm_pte));
+	set_iee_valid_pre_init(iee_addr);
+	iee_addr = (unsigned long)__phys_to_iee(__pa_symbol(bm_pmd));
+	set_iee_valid_pre_init(iee_addr);
+	iee_addr = (unsigned long)__phys_to_iee(__pa_symbol(bm_pud));
+	set_iee_valid_pre_init(iee_addr);
+	// handling 2/3/4-level page table for logical mem and iee
+	for_each_mem_range(i, &start, &end) {
+		if (start >= end)
+			break;
+		/*
+		 * The linear map must allow allocation tags reading/writing
+		 * if MTE is present. Otherwise, it has the same attributes as
+		 * PAGE_KERNEL.
+		 */
+		init_iee_for_one_region(pgdp, (unsigned long)__va(start), (unsigned long)__va(end));
+		init_iee_for_one_region(pgdp, (unsigned long)__phys_to_iee(start), (unsigned long)__phys_to_iee(end));
+	}
+}
 
-	/* The trampoline is always mapped and can therefore be global */
-	pgprot_val(prot) &= ~PTE_NG;
+static void iee_set_kernel_upage_pre_init(unsigned long addr)
+{
+	pgd_t *pgdir = swapper_pg_dir;
+	pgd_t *pgdp = pgd_offset_pgd(pgdir, addr);
 
-	/* Map only the text into the trampoline page table */
-	memset(tramp_pg_dir, 0, PGD_SIZE);
-	__create_pgd_mapping(tramp_pg_dir, pa_start, TRAMP_VALIAS,
-			     entry_tramp_text_size(), prot,
-			     __pgd_pgtable_alloc, NO_BLOCK_MAPPINGS);
+	p4d_t *p4dp = p4d_offset(pgdp, addr);
 
-	/* Map both the text and data into the kernel page table */
-	for (i = 0; i < DIV_ROUND_UP(entry_tramp_text_size(), PAGE_SIZE); i++)
-		__set_fixmap(FIX_ENTRY_TRAMP_TEXT1 - i,
-			     pa_start + i * PAGE_SIZE, prot);
+	pud_t *pudp = pud_offset(p4dp, addr);
 
-	if (IS_ENABLED(CONFIG_RANDOMIZE_BASE)) {
-		extern char __entry_tramp_data_start[];
+	pmd_t *pmdp = pmd_offset(pudp, addr);
 
-		__set_fixmap(FIX_ENTRY_TRAMP_DATA,
-			     __pa_symbol(__entry_tramp_data_start),
-			     PAGE_KERNEL_RO);
+	pte_t *ptep = pte_offset_kernel(pmdp, addr);
+
+	int i;
+	for(i = 0; i < 4; i++)
+	{
+		pte_t pte = READ_ONCE(*ptep);
+		pte = __pte(pte_val(pte) | PTE_USER | PTE_NG);
+		iee_set_pte_pre_init(ptep, pte);
+		ptep++;
 	}
+	flush_tlb_kernel_range(addr, addr+4*PAGE_SIZE);
+	isb();
+}
 
-	return 0;
+static void __init iee_set_pte_table_ro(pmd_t *pmdp, unsigned long addr, unsigned long end)
+{
+	pmd_t pmd = READ_ONCE(*pmdp);
+	unsigned long logical_addr = (unsigned long)__va(__pmd_to_phys(pmd));
+	iee_set_logical_mem_ro(logical_addr);
 }
-core_initcall(map_entry_trampoline);
-#endif
 
-/*
- * Open coded check for BTI, only for use to determine configuration
- * for early mappings for before the cpufeature code has run.
- */
-static bool arm64_early_this_cpu_has_bti(void)
+static void __init iee_set_pmd_table_ro(pud_t *pudp, unsigned long addr, unsigned long end)
 {
-	u64 pfr1;
+	unsigned long next;
+	pud_t pud = READ_ONCE(*pudp);
+	pmd_t *pmdp;
+	pmd_t pmd;
+	unsigned long logical_addr = (unsigned long)__va(__pud_to_phys(pud));
+	iee_set_logical_mem_ro(logical_addr);
 
-	if (!IS_ENABLED(CONFIG_ARM64_BTI_KERNEL))
-		return false;
+	pmdp = pmd_offset(pudp, addr);
+	do {
+		next = pmd_addr_end(addr, end);
+		pmd = READ_ONCE(*pmdp);
+		if((pmd_val(pmd) & PMD_TABLE_BIT) == 0)
+		{
+			continue;
+		}
+		else
+		{
+			iee_set_pte_table_ro(pmdp, addr, next);
+		}
+	} while (pmdp++, addr = next, addr != end);
+}
 
-	pfr1 = read_sysreg_s(SYS_ID_AA64PFR1_EL1);
-	return cpuid_feature_extract_unsigned_field(pfr1,
-						    ID_AA64PFR1_BT_SHIFT);
+static void __init iee_set_pud_table_ro(pgd_t *pgdp, unsigned long addr, unsigned long end)
+{
+	unsigned long next;
+	p4d_t *p4dp = p4d_offset(pgdp, addr);
+	p4d_t p4d = READ_ONCE(*p4dp);
+	pud_t *pudp;
+	pud_t pud;
+	unsigned long logical_addr = (unsigned long)__va(__p4d_to_phys(p4d));
+	iee_set_logical_mem_ro(logical_addr);
+
+	pudp = pud_offset(p4dp, addr);
+	do {
+		next = pud_addr_end(addr, end);
+		pud = READ_ONCE(*pudp);
+		if ((pud_val(pud) & PUD_TABLE_BIT) == 0)
+		{
+			continue;
+		}
+		else
+		{
+			iee_set_pmd_table_ro(pudp, addr, next);
+		}
+	} while (pudp++, addr = next, addr != end);
 }
 
-/*
- * Create fine-grained mappings for the kernel.
- */
-static void __init map_kernel(pgd_t *pgdp)
+static void __init iee_mark_pgtable_for_one_region_ro(pgd_t *pgdir, unsigned long va_start, unsigned long va_end)
 {
-	static struct vm_struct vmlinux_text, vmlinux_rodata, vmlinux_inittext,
-				vmlinux_initdata, vmlinux_data;
+	unsigned long addr, end, next;
+	pgd_t *pgdp = pgd_offset_pgd(pgdir, va_start);
 
-	/*
-	 * External debuggers may need to write directly to the text
-	 * mapping to install SW breakpoints. Allow this (only) when
-	 * explicitly requested with rodata=off.
-	 */
-	pgprot_t text_prot = rodata_enabled ? PAGE_KERNEL_ROX : PAGE_KERNEL_EXEC;
+	addr = va_start & PAGE_MASK;
+	end = PAGE_ALIGN(va_end);
 
-	/*
-	 * If we have a CPU that supports BTI and a kernel built for
-	 * BTI then mark the kernel executable text as guarded pages
-	 * now so we don't have to rewrite the page tables later.
-	 */
-	if (arm64_early_this_cpu_has_bti())
-		text_prot = __pgprot_modify(text_prot, PTE_GP, PTE_GP);
+	do {
+		next = pgd_addr_end(addr, end);
+		iee_set_pud_table_ro(pgdp, addr, next);
+	} while (pgdp++, addr = next, addr != end);
+}
 
-	/*
-	 * Only rodata will be remapped with different permissions later on,
-	 * all other segments are allowed to use contiguous mappings.
-	 */
-	map_kernel_segment(pgdp, _text, _etext, text_prot, &vmlinux_text, 0,
-			   VM_NO_GUARD);
-	map_kernel_segment(pgdp, __start_rodata, __inittext_begin, PAGE_KERNEL,
-			   &vmlinux_rodata, NO_CONT_MAPPINGS, VM_NO_GUARD);
-	map_kernel_segment(pgdp, __inittext_begin, __inittext_end, text_prot,
-			   &vmlinux_inittext, 0, VM_NO_GUARD);
-	map_kernel_segment(pgdp, __initdata_begin, __initdata_end, PAGE_KERNEL,
-			   &vmlinux_initdata, 0, VM_NO_GUARD);
-	map_kernel_segment(pgdp, _data, _end, PAGE_KERNEL, &vmlinux_data, 0, 0);
+// Mark pgtable outside as RO.
+void __init iee_mark_all_lm_pgtable_ro(void)
+{
+	unsigned long logical_addr;
+	phys_addr_t start, end;
+	u64 i;
+	pgd_t *pgdp;
 
-	if (!READ_ONCE(pgd_val(*pgd_offset_pgd(pgdp, FIXADDR_START)))) {
-		/*
-		 * The fixmap falls in a separate pgd to the kernel, and doesn't
-		 * live in the carveout for the swapper_pg_dir. We can simply
-		 * re-use the existing dir for the fixmap.
-		 */
-		set_pgd(pgd_offset_pgd(pgdp, FIXADDR_START),
-			READ_ONCE(*pgd_offset_k(FIXADDR_START)));
-	} else if (CONFIG_PGTABLE_LEVELS > 3) {
-		pgd_t *bm_pgdp;
-		p4d_t *bm_p4dp;
-		pud_t *bm_pudp;
+	// handling static allocated page table
+	#ifdef CONFIG_UNMAP_KERNEL_AT_EL0
+	// handling 1-level tramp page table tramp_pg_dir
+	logical_addr = (unsigned long)__va(__pa_symbol(tramp_pg_dir));
+	iee_set_logical_mem_ro(logical_addr);
+	#endif
+	// handling 1-level page table swapper_pg_dir
+	pgdp = swapper_pg_dir;
+	iee_set_logical_mem_ro((unsigned long)swapper_pg_dir);
+	logical_addr = (unsigned long)__va(__pa_symbol(swapper_pg_dir));
+	iee_set_logical_mem_ro(logical_addr);
+
+	// handling 2/3/4-level page table for kernel
+	iee_mark_pgtable_for_one_region_ro(pgdp, (unsigned long)_text, (unsigned long)_etext);
+	iee_mark_pgtable_for_one_region_ro(pgdp, (unsigned long)__start_rodata, (unsigned long)__inittext_begin);
+	iee_mark_pgtable_for_one_region_ro(pgdp, (unsigned long)__inittext_begin, (unsigned long)__inittext_end);
+	iee_mark_pgtable_for_one_region_ro(pgdp, (unsigned long)__initdata_begin, (unsigned long)__initdata_end);
+	iee_mark_pgtable_for_one_region_ro(pgdp, (unsigned long)_data, (unsigned long)_end);
+
+	// handling 2/3/4-level page table for fixmap i.e. remap bm_xxx
+	logical_addr = (unsigned long)__va(__pa_symbol(bm_pte));
+	iee_set_logical_mem_ro(logical_addr);
+
+	iee_set_logical_mem_ro((unsigned long)bm_pmd);
+	logical_addr = (unsigned long)__va(__pa_symbol(bm_pmd));
+	iee_set_logical_mem_ro(logical_addr);
+
+	iee_set_logical_mem_ro((unsigned long)bm_pud);
+	logical_addr = (unsigned long)__va(__pa_symbol(bm_pud));
+	iee_set_logical_mem_ro(logical_addr);
+
+	// handling 2/3/4-level page table for logical mem and iee
+	for_each_mem_range(i, &start, &end) {
+		if (start >= end)
+			break;
 		/*
-		 * The fixmap shares its top level pgd entry with the kernel
-		 * mapping. This can really only occur when we are running
-		 * with 16k/4 levels, so we can simply reuse the pud level
-		 * entry instead.
+		 * The linear map must allow allocation tags reading/writing
+		 * if MTE is present. Otherwise, it has the same attributes as
+		 * PAGE_KERNEL.
 		 */
-		BUG_ON(!IS_ENABLED(CONFIG_ARM64_16K_PAGES));
-		bm_pgdp = pgd_offset_pgd(pgdp, FIXADDR_START);
-		bm_p4dp = p4d_offset(bm_pgdp, FIXADDR_START);
-		bm_pudp = pud_set_fixmap_offset(bm_p4dp, FIXADDR_START);
-		pud_populate(&init_mm, bm_pudp, lm_alias(bm_pmd));
-		pud_clear_fixmap();
-	} else {
-		BUG();
+		iee_mark_pgtable_for_one_region_ro(pgdp, (unsigned long)__va(start), (unsigned long)__va(end));
+		iee_mark_pgtable_for_one_region_ro(pgdp, (unsigned long)__phys_to_iee(start), (unsigned long)__phys_to_iee(end));
 	}
-
-	kasan_copy_shadow(pgdp);
 }
+#endif
+
+#if !defined(CONFIG_IEE) && defined (CONFIG_KOI)
+static void map_koi(pgd_t *pgdp);
+extern s64 koi_offset;
+__attribute__((aligned(PAGE_SIZE))) DECLARE_PER_CPU(struct task_struct *[PAGE_SIZE/sizeof(struct task_struct *)], __entry_task);
+#endif
 
 void __init paging_init(void)
 {
-	pgd_t *pgdp = pgd_set_fixmap(__pa_symbol(swapper_pg_dir));
+	pgd_t *pgdp;
+	#ifdef CONFIG_IEE
+	unsigned long SP_EL0;
+	void *new;
+	void *init_token;
+	struct task_token *token;
+	unsigned long tcr;
+	#endif
+
+	// Check if cpu has PAN and HPDS.
+	#ifdef CONFIG_IEE
+	if(!cpuid_feature_extract_unsigned_field(read_cpuid(ID_AA64MMFR1_EL1),
+						ID_AA64MMFR1_PAN_SHIFT))
+		panic("Architecture doesn't support PAN, please disable CONFIG_IEE.\n");
+	
+	if(!cpuid_feature_extract_unsigned_field(read_cpuid(ID_AA64MMFR1_EL1),
+						ID_AA64MMFR1_HPD_SHIFT))
+		panic("Architecture doesn't support HPDS, please disable CONFIG_IEE.\n");
+	#endif
+
+	// Avoid using iee code to modify pgtable before iee initialized.
+	#ifdef CONFIG_PTP
+	pgdp = pgd_set_fixmap_init(__pa_symbol(swapper_pg_dir));
+	#else
+	pgdp = pgd_set_fixmap(__pa_symbol(swapper_pg_dir));
+	#endif
 
 	map_kernel(pgdp);
 	map_mem(pgdp);
 
+	// Map the whole physical mem into IEE, but set invalid.
+	#ifdef CONFIG_IEE
+	map_iee(pgdp);
+    // map_iee_si(pgdp);
+    #else 
+    #ifdef CONFIG_KOI
+    map_koi(pgdp);
+    #endif
+	#endif
+
+	// Avoid using iee code to modify pgtable before iee initialized.
+	#ifdef CONFIG_PTP
+	pgd_clear_fixmap_init();
+	#else
 	pgd_clear_fixmap();
+	#endif
 
 	cpu_replace_ttbr1(lm_alias(swapper_pg_dir));
 	init_mm.pgd = swapper_pg_dir;
@@ -775,6 +2033,84 @@ void __init paging_init(void)
 		      __pa_symbol(init_pg_end) - __pa_symbol(init_pg_dir));
 
 	memblock_allow_resize();
+
+	#ifdef CONFIG_IEE
+	// Initialize init iee stack.
+	#ifdef CONFIG_PTP
+	iee_set_kernel_upage_pre_init((unsigned long)init_iee_stack_begin);
+	#else
+	iee_set_kernel_upage_early((unsigned long)init_iee_stack_begin, 2);
+	#endif
+	#endif
+
+	// Init token for init_task.
+	#ifdef CONFIG_IEE
+	// Change SP_EL0 from Image VA to Logical VA.
+	SP_EL0 = (unsigned long)__va(__pa_symbol(&init_task));
+	write_sysreg(SP_EL0, sp_el0);
+	init_task.cpus_ptr = &(((struct task_struct *)(__va(__pa_symbol(&init_task))))->cpus_mask);
+	init_task.children.prev = (__va(__pa_symbol(init_task.children.prev)));
+	init_task.children.next = (__va(__pa_symbol(init_task.children.next)));
+	// Alloc a page for init_token.
+	new = __va(early_pgtable_alloc(0));
+	init_token_page_vaddr = new;
+	init_token = (void *)__phys_to_iee(__pa_symbol(&init_task));
+	// Use lm to write token before IEE initialized.
+	token = (struct task_token *)((unsigned long)new + (((unsigned long)&init_task) & ~PAGE_MASK));
+	token->pgd = NULL;
+	token->iee_stack = (void *)init_iee_stack_end;
+	token->valid = true;
+	iee_set_token_page_valid_pre_init(init_token, new);
+	#endif
+
+	#ifdef CONFIG_PTP
+	// Map the existing pgtable into IEE, set valid.
+	init_iee();
+	#endif
+
+	#ifdef CONFIG_IEE
+	sysreg_clear_set(sctlr_el1, 0, SCTLR_EL1_SPAN);
+	#endif
+
+	// IEE ready.
+	// Pgtable writing before uses logical memory and after uses IEE memory.
+
+	#ifdef CONFIG_IEE
+	// Set HPD1 as 1.
+	tcr = read_sysreg(tcr_el1);
+	tcr |= ((unsigned long)0x1 << 42);
+	write_sysreg(tcr, tcr_el1);
+	isb();
+
+	// Flush tlb to enable IEE.
+	flush_tlb_all();
+
+	// mark that iee is prepared.
+	iee_init_done = true;
+	iee_si_test_page_attr((unsigned long)__iee_si_start);
+	// iee_si_test_page_attr_all(__iee_si_start);
+	#endif
+    #if defined(CONFIG_KOI) && !defined(CONFIG_IEE)
+        unsigned long SP_EL0 = __va(__pa_symbol(&init_task));
+	    write_sysreg(SP_EL0, sp_el0);
+	    init_task.cpus_ptr = &(((struct task_struct *)(__va(__pa_symbol(&init_task))))->cpus_mask);
+	    init_task.children.prev = (__va(__pa_symbol(init_task.children.prev)));
+	    init_task.children.next = (__va(__pa_symbol(init_task.children.next)));
+	    // Set init_task into __entry_task before per_cpu init.
+	    *(struct task_struct **)__entry_task = __va(__pa_symbol(&init_task));
+        // create a new page for token
+        void *alloc_token = __va(early_pgtable_alloc(0));
+        // get the address of token 
+        void *token_addr = __phys_to_virt(__pa_symbol(&init_task)) + KOI_OFFSET;
+        // add memory mapping for token
+        koi_add_page_mapping(token_addr, (void *)alloc_token);
+        // printk(KERN_ERR "token_addr=0x%16llx, alloc_token=0x%16llx, init_task=0x%16llx, virt=0x%16llx\n", token_addr, alloc_token, &init_task, __phys_to_virt(__pa_symbol(&init_task)));
+	    struct task_token *token = (struct task_token *)((unsigned long)alloc_token + (((unsigned long)&init_task) & ~PAGE_MASK));
+        token->koi_kernel_stack = NULL;
+        token->koi_stack = NULL;
+        token->koi_stack_base = NULL;
+        token->current_ttbr1 = 0;
+    #endif    
 }
 
 /*
@@ -1295,13 +2631,25 @@ void __init early_fixmap_init(void)
 		pudp = pud_offset_kimg(p4dp, addr);
 	} else {
 		if (p4d_none(p4d))
+			#ifdef CONFIG_PTP
+			__iee_p4d_populate_pre_init(p4dp, __pa_symbol(bm_pud), PUD_TYPE_TABLE);
+			#else
 			__p4d_populate(p4dp, __pa_symbol(bm_pud), PUD_TYPE_TABLE);
+			#endif
 		pudp = fixmap_pud(addr);
 	}
 	if (pud_none(READ_ONCE(*pudp)))
+		#ifdef CONFIG_PTP
+		__iee_pud_populate_pre_init(pudp, __pa_symbol(bm_pmd), PMD_TYPE_TABLE);
+		#else
 		__pud_populate(pudp, __pa_symbol(bm_pmd), PMD_TYPE_TABLE);
+		#endif
 	pmdp = fixmap_pmd(addr);
+	#ifdef CONFIG_PTP
+	__iee_pmd_populate_pre_init(pmdp, __pa_symbol(bm_pte), PMD_TYPE_TABLE);
+	#else
 	__pmd_populate(pmdp, __pa_symbol(bm_pte), PMD_TYPE_TABLE);
+	#endif
 
 	/*
 	 * The boot-ioremap range spans multiple pmds, for which
@@ -1326,6 +2674,26 @@ void __init early_fixmap_init(void)
 	}
 }
 
+#ifdef CONFIG_PTP
+void __iee_set_fixmap_pre_init(enum fixed_addresses idx,
+			       phys_addr_t phys, pgprot_t flags)
+{
+	unsigned long addr = __fix_to_virt(idx);
+	pte_t *ptep;
+
+	BUG_ON(idx <= FIX_HOLE || idx >= __end_of_fixed_addresses);
+
+	ptep = fixmap_pte(addr);
+
+	if (pgprot_val(flags)) {
+		iee_set_pte_pre_init(ptep, pfn_pte(phys >> PAGE_SHIFT, flags));
+	} else {
+		iee_set_pte_pre_init(ptep, __pte(0));
+		flush_tlb_kernel_range(addr, addr+PAGE_SIZE);
+	}
+}
+#endif
+
 /*
  * Unusually, this is also called in IRQ context (ghes_iounmap_irq) so if we
  * ever need to use IPIs for TLB broadcasting, then we're in trouble here.
@@ -1342,9 +2710,17 @@ void __set_fixmap(enum fixed_addresses idx,
 
 	if (pgprot_val(flags)) {
 		flags = pgprot_pbha_bit0(flags);
+		#ifdef CONFIG_PTP
+		iee_set_bm_pte(ptep, pfn_pte(phys >> PAGE_SHIFT, flags));
+		#else
 		set_pte(ptep, pfn_pte(phys >> PAGE_SHIFT, flags));
+		#endif
 	} else {
+		#ifdef CONFIG_PTP
+		iee_set_bm_pte(ptep, __pte(0));
+		#else
 		pte_clear(&init_mm, addr, ptep);
+		#endif
 		flush_tlb_kernel_range(addr, addr+PAGE_SIZE);
 	}
 }
@@ -1461,6 +2837,9 @@ int pmd_free_pte_page(pmd_t *pmdp, unsigned long addr)
 	table = pte_offset_kernel(pmdp, addr);
 	pmd_clear(pmdp);
 	__flush_tlb_kernel_pgtable(addr);
+	#ifdef CONFIG_PTP
+	iee_memset(table, 0, PAGE_SIZE);
+	#endif
 	pte_free_kernel(NULL, table);
 	return 1;
 }
@@ -1613,3 +2992,93 @@ static int __init prevent_bootmem_remove_init(void)
 }
 device_initcall(prevent_bootmem_remove_init);
 #endif
+
+#if !defined(CONFIG_IEE) && defined (CONFIG_KOI)
+static void __create_pgd_mapping_for_koi(pgd_t *pgdir, phys_addr_t phys,
+				 unsigned long virt, phys_addr_t size,
+				 pgprot_t prot,
+				 phys_addr_t (*pgtable_alloc)(int),
+				 int flags)
+{
+	unsigned long addr, end, next;
+	pgd_t *pgdp = pgd_offset_pgd(pgdir, virt);
+
+	/*
+	 * If the virtual and physical address don't have the same offset
+	 * within a page, we cannot map the region as the caller expects.
+	 */
+	if (WARN_ON((phys ^ virt) & ~PAGE_MASK))
+		return;
+
+	phys &= PAGE_MASK;
+	addr = virt & PAGE_MASK;
+	end = PAGE_ALIGN(virt + size);
+
+	do {
+		next = pgd_addr_end(addr, end);
+		alloc_init_pud(pgdp, addr, next, phys, prot, pgtable_alloc,
+			       flags);
+		p4d_t *p4dp = p4d_offset(pgdp, addr);
+		p4d_t p4d = READ_ONCE(*p4dp);
+		__p4d_populate(p4dp, __p4d_to_phys(p4d),  PUD_TYPE_TABLE);
+		phys += next - addr;
+	} while (pgdp++, addr = next, addr != end);
+}
+
+static void __init __map_memblock_for_koi(pgd_t *pgdp, phys_addr_t start,
+				  phys_addr_t end, pgprot_t prot, int flags)
+{
+	__create_pgd_mapping_for_koi(pgdp, start, __phys_to_virt(start) + KOI_OFFSET, end - start,
+			     prot, early_pgtable_alloc, flags);
+}
+
+static void __init map_koi(pgd_t *pgdp)
+{
+	phys_addr_t kernel_start = __pa_symbol(_text);
+	phys_addr_t kernel_end = __pa_symbol(__init_begin);
+	phys_addr_t start, end;
+	int flags = 0;
+	u64 i;
+
+	flags = NO_BLOCK_MAPPINGS | NO_CONT_MAPPINGS;
+
+	/*
+	 * Take care not to create a writable alias for the
+	 * read-only text and rodata sections of the kernel image.
+	 * So temporarily mark them as NOMAP to skip mappings in
+	 * the following for-loop
+	 */
+	memblock_mark_nomap(kernel_start, kernel_end - kernel_start);
+#ifdef CONFIG_KEXEC_CORE
+	if (crashk_res.end)
+		memblock_mark_nomap(crashk_res.start,
+				    resource_size(&crashk_res));
+#endif
+
+	/* map all the memory banks */
+	for_each_mem_range(i, &start, &end) {
+		if (start >= end)
+			break;
+		/*
+		 * The linear map must allow allocation tags reading/writing
+		 * if MTE is present. Otherwise, it has the same attributes as
+		 * PAGE_KERNEL.
+		 */
+		__map_memblock_for_koi(pgdp, start, end, SET_NG(SET_INVALID(PAGE_KERNEL)), flags);
+	}
+#ifdef CONFIG_KEXEC_CORE
+	/*
+	 * Use page-level mappings here so that we can shrink the region
+	 * in page granularity and put back unused memory to buddy system
+	 * through /sys/kernel/kexec_crash_size interface.
+	 */
+	if (crashk_res.end) {
+		__map_memblock_for_koi(pgdp, crashk_res.start, crashk_res.end + 1,
+			       SET_NG(SET_INVALID(PAGE_KERNEL)),
+			       NO_BLOCK_MAPPINGS | NO_CONT_MAPPINGS);
+		memblock_clear_nomap(crashk_res.start,
+				     resource_size(&crashk_res));
+	}
+#endif
+}
+#endif
\ No newline at end of file
diff --git a/arch/arm64/mm/numa.c b/arch/arm64/mm/numa.c
index dd72f25452c1..5bc7d92c9fca 100644
--- a/arch/arm64/mm/numa.c
+++ b/arch/arm64/mm/numa.c
@@ -19,7 +19,11 @@
 struct pglist_data *node_data[MAX_NUMNODES] __read_mostly;
 EXPORT_SYMBOL(node_data);
 nodemask_t numa_nodes_parsed __initdata;
+#ifdef CONFIG_PTP
+int cpu_to_node_map[NR_CPUS] = { [0 ... NR_CPUS-1] = NUMA_NO_NODE };
+#else
 static int cpu_to_node_map[NR_CPUS] = { [0 ... NR_CPUS-1] = NUMA_NO_NODE };
+#endif
 
 static int numa_distance_cnt;
 static u8 *numa_distance;
diff --git a/arch/arm64/mm/pgd.c b/arch/arm64/mm/pgd.c
index 4a64089e5771..b99b35a5190f 100644
--- a/arch/arm64/mm/pgd.c
+++ b/arch/arm64/mm/pgd.c
@@ -15,14 +15,38 @@
 #include <asm/page.h>
 #include <asm/tlbflush.h>
 
+#ifdef CONFIG_PTP
+#include <linux/iee-func.h>
+#endif
+
 static struct kmem_cache *pgd_cache __ro_after_init;
 
+#ifdef CONFIG_KOI
+pgd_t *koi_pgd_alloc(void)
+{
+    pgd_t *pgd;
+#ifdef CONFIG_PTP
+    pgd = (pgd_t *)get_iee_pgtable_page(GFP_PGTABLE_KERNEL);
+#else
+	pgd = (pgd_t *)__get_free_page(GFP_PGTABLE_KERNEL);
+#endif
+	return pgd;
+}
+#endif
+
 pgd_t *pgd_alloc(struct mm_struct *mm)
 {
 	gfp_t gfp = GFP_PGTABLE_USER;
 
 	if (PGD_SIZE == PAGE_SIZE)
+#ifdef CONFIG_PTP
+    {
+        pgd_t* new = (pgd_t *)get_iee_pgtable_page(gfp);
+        return new;
+    }
+#else
 		return (pgd_t *)__get_free_page(gfp);
+#endif        
 	else
 		return kmem_cache_alloc(pgd_cache, gfp);
 }
@@ -30,7 +54,13 @@ pgd_t *pgd_alloc(struct mm_struct *mm)
 void pgd_free(struct mm_struct *mm, pgd_t *pgd)
 {
 	if (PGD_SIZE == PAGE_SIZE)
+#ifdef CONFIG_PTP
+    {
+        free_iee_pgtable_page((void *)pgd);
+    }
+#else
 		free_page((unsigned long)pgd);
+#endif
 	else
 		kmem_cache_free(pgd_cache, pgd);
 }
diff --git a/arch/arm64/mm/proc.S b/arch/arm64/mm/proc.S
index a3fdc71c01eb..67efa1edf1e2 100644
--- a/arch/arm64/mm/proc.S
+++ b/arch/arm64/mm/proc.S
@@ -20,6 +20,8 @@
 #include <asm/smp.h>
 #include <asm/sysreg.h>
 
+
+
 #ifdef CONFIG_ARM64_64K_PAGES
 #define TCR_TG_FLAGS	TCR_TG0_64K | TCR_TG1_64K
 #elif defined(CONFIG_ARM64_16K_PAGES)
@@ -103,6 +105,7 @@ SYM_FUNC_END(cpu_do_suspend)
  * x0: Address of context pointer
  */
 	.pushsection ".idmap.text", "awx"
+
 SYM_FUNC_START(cpu_do_resume)
 	ldp	x2, x3, [x0]
 	ldp	x4, x5, [x0, #16]
@@ -190,6 +193,7 @@ SYM_FUNC_START(idmap_cpu_replace_ttbr1)
 	__idmap_cpu_set_reserved_ttbr1 x1, x3
 
 	offset_ttbr1 x0, x3
+
 	msr	ttbr1_el1, x0
 	isb
 
@@ -497,6 +501,11 @@ SYM_FUNC_START(__cpu_setup)
 	orr	x10, x10, #TCR_HA		// hardware Access flag update
 1:
 #endif	/* CONFIG_ARM64_HW_AFDBM */
+
+#ifdef CONFIG_IEE
+	orr	x10, x10, #TCR_HPD1		// Hierarchical permission disables
+#endif
+
 	msr	tcr_el1, x10
 	/*
 	 * Prepare SCTLR
diff --git a/arch/arm64/net/bpf_jit_comp.c b/arch/arm64/net/bpf_jit_comp.c
index 5560d20f68f4..71910ab6e9f4 100644
--- a/arch/arm64/net/bpf_jit_comp.c
+++ b/arch/arm64/net/bpf_jit_comp.c
@@ -21,6 +21,10 @@
 
 #include "bpf_jit.h"
 
+#ifdef CONFIG_HIVE
+#include <linux/sfi_bpf.h>
+#endif
+
 #define TMP_REG_1 (MAX_BPF_JIT_REG + 0)
 #define TMP_REG_2 (MAX_BPF_JIT_REG + 1)
 #define TCALL_CNT (MAX_BPF_JIT_REG + 2)
@@ -53,6 +57,10 @@ static const int bpf2a64[] = {
 	/* temporary register for blinding constants */
 	[BPF_REG_AX] = A64_R(9),
 	[FP_BOTTOM] = A64_R(27),
+	#ifdef CONFIG_HIVE
+	/* fbpf base addr */
+	[BPF_REG_BASE] = A64_R(28),
+	#endif
 };
 
 struct jit_ctx {
@@ -270,7 +278,15 @@ static bool is_lsi_offset(int offset, int scale)
 #define STACK_ALIGN(sz) (((sz) + 15) & ~15)
 
 /* Tail call offset to jump into */
+#ifdef CONFIG_HIVE
+#if IS_ENABLED(CONFIG_ARM64_BTI_KERNEL)
+#define PROLOGUE_OFFSET 8 + 6
+#else
+#define PROLOGUE_OFFSET 7 + 6
+#endif
+#else
 #define PROLOGUE_OFFSET (BTI_INSNS + 2 + 8)
+#endif
 
 static int build_prologue(struct jit_ctx *ctx, bool ebpf_from_cbpf)
 {
@@ -282,6 +298,11 @@ static int build_prologue(struct jit_ctx *ctx, bool ebpf_from_cbpf)
 	const u8 fp = bpf2a64[BPF_REG_FP];
 	const u8 tcc = bpf2a64[TCALL_CNT];
 	const u8 fpb = bpf2a64[FP_BOTTOM];
+	#ifdef CONFIG_HIVE
+	const u8 base = bpf2a64[BPF_REG_BASE];
+	u64 sfi_base, sfi_stack;
+	int idx_before;
+	#endif
 	const int idx0 = ctx->idx;
 	int cur_offset;
 
@@ -328,9 +349,30 @@ static int build_prologue(struct jit_ctx *ctx, bool ebpf_from_cbpf)
 	emit(A64_PUSH(r8, r9, A64_SP), ctx);
 	emit(A64_PUSH(fp, tcc, A64_SP), ctx);
 	emit(A64_PUSH(fpb, A64_R(28), A64_SP), ctx);
+	#ifdef CONFIG_HIVE
+	emit(A64_PUSH(A64_R(27), base, A64_SP), ctx);
+	#endif
 
 	/* Set up BPF prog stack base register */
-	emit(A64_MOV(1, fp, A64_SP), ctx);
+	#ifdef CONFIG_HIVE
+		sfi_base = (u64)prog->shadow_region_addr;
+		sfi_stack = (u64)(prog->shadow_stack_addr);
+
+		fbpf_log("fp=%016llx, base=%016llx\n", sfi_stack, sfi_base);
+		
+		idx_before = ctx->idx;
+		emit_a64_mov_i64(fp, sfi_stack, ctx); // 3 insns
+		while (ctx->idx - idx_before < 3) {
+			emit(A64_NOP, ctx);
+		}
+		idx_before = ctx->idx;
+		emit_a64_mov_i64(base, sfi_base, ctx); // 3 insns
+		while (ctx->idx - idx_before < 3) {
+			emit(A64_NOP, ctx);
+		}	
+	#else
+		emit(A64_MOV(1, fp, A64_SP), ctx);
+	#endif
 
 	if (!ebpf_from_cbpf) {
 		/* Initialize tail_call_cnt */
@@ -338,8 +380,13 @@ static int build_prologue(struct jit_ctx *ctx, bool ebpf_from_cbpf)
 
 		cur_offset = ctx->idx - idx0;
 		if (cur_offset != PROLOGUE_OFFSET) {
+			#ifdef CONFIG_HIVE
+			pr_err("PROLOGUE_OFFSET = %d, expected %d!\n",
+				    cur_offset, PROLOGUE_OFFSET);
+			#else
 			pr_err_once("PROLOGUE_OFFSET = %d, expected %d!\n",
 				    cur_offset, PROLOGUE_OFFSET);
+			#endif
 			return -1;
 		}
 
@@ -482,10 +529,18 @@ static void build_epilogue(struct jit_ctx *ctx)
 	const u8 r9 = bpf2a64[BPF_REG_9];
 	const u8 fp = bpf2a64[BPF_REG_FP];
 	const u8 fpb = bpf2a64[FP_BOTTOM];
+	#ifdef CONFIG_HIVE
+	const u8 base = bpf2a64[BPF_REG_BASE];
+	#endif
 
 	/* We're done with BPF stack */
 	emit(A64_ADD_I(1, A64_SP, A64_SP, ctx->stack_size), ctx);
 
+	#ifdef CONFIG_HIVE
+	/* Restore x27 and base (x28) */
+	emit(A64_POP(A64_R(27), base, A64_SP), ctx);
+	#endif
+
 	/* Restore x27 and x28 */
 	emit(A64_POP(fpb, A64_R(28), A64_SP), ctx);
 	/* Restore fs (x25) and x26 */
@@ -583,6 +638,9 @@ static int build_insn(const struct bpf_insn *insn, struct jit_ctx *ctx,
 	const u8 fp = bpf2a64[BPF_REG_FP];
 	const u8 fpb = bpf2a64[FP_BOTTOM];
 	const s16 off = insn->off;
+	#ifdef CONFIG_HIVE
+	u8 off_reg;
+	#endif
 	const s32 imm = insn->imm;
 	const int i = insn - ctx->prog->insnsi;
 	const bool is64 = BPF_CLASS(code) == BPF_ALU64 ||
@@ -1007,6 +1065,33 @@ static int build_insn(const struct bpf_insn *insn, struct jit_ctx *ctx,
 			return ret;
 		break;
 
+	#ifdef CONFIG_HIVE
+	case BPF_LDX | BPF_REG | BPF_W:
+	case BPF_LDX | BPF_REG | BPF_H:
+	case BPF_LDX | BPF_REG | BPF_B:
+	case BPF_LDX | BPF_REG | BPF_DW:
+		off_reg = bpf2a64[off];
+		switch (BPF_SIZE(code)) {
+		case BPF_W:
+			emit(A64_LDR32(dst, src, off_reg), ctx);
+			break;
+		case BPF_H:
+			emit(A64_LDRH(dst, src, off_reg), ctx);
+			break;
+		case BPF_B:
+			emit(A64_LDRB(dst, src, off_reg), ctx);
+			break;
+		case BPF_DW:
+			emit(A64_LDR64(dst, src, off_reg), ctx);
+			break;
+		}
+
+		ret = add_exception_handler(insn, ctx, dst);
+		if (ret)
+			return ret;
+		break;
+	#endif
+
 	/* speculation barrier */
 	case BPF_ST | BPF_NOSPEC:
 		/*
@@ -1070,6 +1155,31 @@ static int build_insn(const struct bpf_insn *insn, struct jit_ctx *ctx,
 		}
 		break;
 
+	#ifdef CONFIG_HIVE
+	case BPF_ST | BPF_REG | BPF_W:
+	case BPF_ST | BPF_REG | BPF_H:
+	case BPF_ST | BPF_REG | BPF_B:
+	case BPF_ST | BPF_REG | BPF_DW:
+		off_reg = bpf2a64[off];
+		/* Load imm to a register then store it */
+		emit_a64_mov_i(1, tmp, imm, ctx);
+		switch (BPF_SIZE(code)) {
+		case BPF_W:
+			emit(A64_STR32(tmp, dst, off_reg), ctx);
+			break;
+		case BPF_H:
+			emit(A64_STRH(tmp, dst, off_reg), ctx);
+			break;
+		case BPF_B:
+			emit(A64_STRB(tmp, dst, off_reg), ctx);
+			break;
+		case BPF_DW:
+			emit(A64_STR64(tmp, dst, off_reg), ctx);
+			break;
+		}
+		break;
+	#endif
+
 	/* STX: *(size *)(dst + off) = src */
 	case BPF_STX | BPF_MEM | BPF_W:
 	case BPF_STX | BPF_MEM | BPF_H:
@@ -1118,6 +1228,29 @@ static int build_insn(const struct bpf_insn *insn, struct jit_ctx *ctx,
 		}
 		break;
 
+	#ifdef CONFIG_HIVE
+	case BPF_STX | BPF_REG | BPF_W:
+	case BPF_STX | BPF_REG | BPF_H:
+	case BPF_STX | BPF_REG | BPF_B:
+	case BPF_STX | BPF_REG | BPF_DW:
+		off_reg = bpf2a64[off];
+		switch (BPF_SIZE(code)) {
+		case BPF_W:
+			emit(A64_STR32(src, dst, off_reg), ctx);
+			break;
+		case BPF_H:
+			emit(A64_STRH(src, dst, off_reg), ctx);
+			break;
+		case BPF_B:
+			emit(A64_STRB(src, dst, off_reg), ctx);
+			break;
+		case BPF_DW:
+			emit(A64_STR64(src, dst, off_reg), ctx);
+			break;
+		}
+		break;
+	#endif
+
 	/* STX XADD: lock *(u32 *)(dst + off) += src */
 	case BPF_STX | BPF_XADD | BPF_W:
 	/* STX XADD: lock *(u64 *)(dst + off) += src */
@@ -1410,6 +1543,9 @@ struct bpf_prog *bpf_int_jit_compile(struct bpf_prog *prog)
 	}
 
 	/* And we're done. */
+	#ifdef CONFIG_HIVE
+	pr_info("[%s] jit insn len = %d, type = %d\n", prog->aux->name, prog->len, prog->type);
+	#endif
 	if (bpf_jit_enable > 1)
 		bpf_jit_dump(prog->len, prog_size, 2, ctx.image);
 
diff --git a/drivers/firmware/efi/arm-runtime.c b/drivers/firmware/efi/arm-runtime.c
index 9054c2852580..790753f27747 100644
--- a/drivers/firmware/efi/arm-runtime.c
+++ b/drivers/firmware/efi/arm-runtime.c
@@ -94,7 +94,11 @@ static int __init arm_enable_runtime_services(void)
 		return 0;
 	}
 
+	#ifdef CONFIG_PTP
+	efi_memmap_unmap_after_init();
+	#else
 	efi_memmap_unmap();
+	#endif
 
 	mapsize = efi.memmap.desc_size * efi.memmap.nr_map;
 
diff --git a/drivers/firmware/efi/memmap.c b/drivers/firmware/efi/memmap.c
index 0155bf066ba5..74fba95fbdf2 100644
--- a/drivers/firmware/efi/memmap.c
+++ b/drivers/firmware/efi/memmap.c
@@ -174,6 +174,26 @@ void __init efi_memmap_unmap(void)
 	clear_bit(EFI_MEMMAP, &efi.flags);
 }
 
+#ifdef CONFIG_PTP
+void __init efi_memmap_unmap_after_init(void)
+{
+	if (!efi_enabled(EFI_MEMMAP))
+		return;
+
+	if (!(efi.memmap.flags & EFI_MEMMAP_LATE)) {
+		unsigned long size;
+
+		size = efi.memmap.desc_size * efi.memmap.nr_map;
+		early_iounmap_after_init((__force void __iomem *)efi.memmap.map, size);
+	} else {
+		memunmap(efi.memmap.map);
+	}
+
+	efi.memmap.map = NULL;
+	clear_bit(EFI_MEMMAP, &efi.flags);
+}
+#endif
+
 /**
  * efi_memmap_init_late - Map efi.memmap with memremap()
  * @phys_addr: Physical address of the new EFI memory map
diff --git a/drivers/tty/serial/earlycon.c b/drivers/tty/serial/earlycon.c
index b70877932d47..fe8f3d8351ff 100644
--- a/drivers/tty/serial/earlycon.c
+++ b/drivers/tty/serial/earlycon.c
@@ -40,7 +40,11 @@ static void __iomem * __init earlycon_map(resource_size_t paddr, size_t size)
 {
 	void __iomem *base;
 #ifdef CONFIG_FIX_EARLYCON_MEM
+	#ifdef CONFIG_PTP
+	__iee_set_fixmap_pre_init(FIX_EARLYCON_MEM_BASE, paddr & PAGE_MASK, FIXMAP_PAGE_IO);
+	#else
 	set_fixmap_io(FIX_EARLYCON_MEM_BASE, paddr & PAGE_MASK);
+	#endif
 	base = (void __iomem *)__fix_to_virt(FIX_EARLYCON_MEM_BASE);
 	base += paddr & ~PAGE_MASK;
 #else
diff --git a/drivers/usb/early/ehci-dbgp.c b/drivers/usb/early/ehci-dbgp.c
index 45b42d8f6453..b71072d6957e 100644
--- a/drivers/usb/early/ehci-dbgp.c
+++ b/drivers/usb/early/ehci-dbgp.c
@@ -879,7 +879,11 @@ int __init early_dbgp_init(char *s)
 	 * FIXME I don't have the bar size so just guess PAGE_SIZE is more
 	 * than enough.  1K is the biggest I have seen.
 	 */
+	#ifdef CONFIG_PTP
+	__iee_set_fixmap_pre_init(FIX_DBGP_BASE, bar_val & PAGE_MASK, FIXMAP_PAGE_NOCACHE);
+	#else
 	set_fixmap_nocache(FIX_DBGP_BASE, bar_val & PAGE_MASK);
+	#endif
 	ehci_bar = (void __iomem *)__fix_to_virt(FIX_DBGP_BASE);
 	ehci_bar += bar_val & ~PAGE_MASK;
 	dbgp_printk("ehci_bar: %p\n", ehci_bar);
diff --git a/fs/cifs/cifs_spnego.c b/fs/cifs/cifs_spnego.c
index 4f9d08ac9dde..99e51e48bf4a 100644
--- a/fs/cifs/cifs_spnego.c
+++ b/fs/cifs/cifs_spnego.c
@@ -30,6 +30,10 @@
 #include "cifs_spnego.h"
 #include "cifs_debug.h"
 #include "cifsproto.h"
+#ifdef CONFIG_CREDP
+#include <asm/iee-cred.h>
+#endif
+
 static const struct cred *spnego_cred;
 
 /* create a new cifs key */
@@ -224,8 +228,13 @@ init_cifs_spnego(void)
 	 * the results it looks up
 	 */
 	set_bit(KEY_FLAG_ROOT_CAN_CLEAR, &keyring->flags);
+	#ifdef CONFIG_CREDP
+	iee_set_cred_thread_keyring(cred,keyring);
+	iee_set_cred_jit_keyring(cred,KEY_REQKEY_DEFL_THREAD_KEYRING);
+	#else
 	cred->thread_keyring = keyring;
 	cred->jit_keyring = KEY_REQKEY_DEFL_THREAD_KEYRING;
+	#endif
 	spnego_cred = cred;
 
 	cifs_dbg(FYI, "cifs spnego keyring: %d\n", key_serial(keyring));
diff --git a/fs/cifs/cifsacl.c b/fs/cifs/cifsacl.c
index ef4784e72b1d..d140e6c175e3 100644
--- a/fs/cifs/cifsacl.c
+++ b/fs/cifs/cifsacl.c
@@ -33,6 +33,10 @@
 #include "cifsproto.h"
 #include "cifs_debug.h"
 
+#ifdef CONFIG_CREDP
+#include <asm/iee-cred.h>
+#endif
+
 /* security id for everyone/world system group */
 static const struct cifs_sid sid_everyone = {
 	1, 1, {0, 0, 0, 0, 0, 1}, {0} };
@@ -496,8 +500,13 @@ init_cifs_idmap(void)
 	/* instruct request_key() to use this special keyring as a cache for
 	 * the results it looks up */
 	set_bit(KEY_FLAG_ROOT_CAN_CLEAR, &keyring->flags);
+	#ifdef CONFIG_CREDP
+	iee_set_cred_thread_keyring(cred,keyring);
+	iee_set_cred_jit_keyring(cred,KEY_REQKEY_DEFL_THREAD_KEYRING);
+	#else
 	cred->thread_keyring = keyring;
 	cred->jit_keyring = KEY_REQKEY_DEFL_THREAD_KEYRING;
+	#endif
 	root_cred = cred;
 
 	cifs_dbg(FYI, "cifs idmap keyring: %d\n", key_serial(keyring));
diff --git a/fs/coredump.c b/fs/coredump.c
index 535c3fdc1598..a092ddf00eff 100644
--- a/fs/coredump.c
+++ b/fs/coredump.c
@@ -53,6 +53,10 @@
 
 #include <trace/events/sched.h>
 
+#ifdef CONFIG_CREDP
+#include <asm/iee-cred.h>
+#endif
+
 static bool dump_vma_snapshot(struct coredump_params *cprm);
 static void free_vma_snapshot(struct coredump_params *cprm);
 
@@ -627,7 +631,11 @@ void do_coredump(const kernel_siginfo_t *siginfo)
 	 */
 	if (__get_dumpable(cprm.mm_flags) == SUID_DUMP_ROOT) {
 		/* Setuid core dump mode */
+		#ifdef CONFIG_CREDP
+		iee_set_cred_fsuid(cred,GLOBAL_ROOT_UID);
+		#else
 		cred->fsuid = GLOBAL_ROOT_UID;	/* Dump root private */
+		#endif
 		need_suid_safe = true;
 	}
 
diff --git a/fs/exec.c b/fs/exec.c
index 43378e25abcb..4db00fbe1836 100644
--- a/fs/exec.c
+++ b/fs/exec.c
@@ -78,6 +78,14 @@
 
 #include <trace/events/sched.h>
 
+#ifdef CONFIG_CREDP
+#include <asm/iee-cred.h>
+#endif
+
+#ifdef CONFIG_IEE
+#include <asm/iee-token.h>
+#endif
+
 static int bprm_creds_from_file(struct linux_binprm *bprm);
 
 int suid_dumpable = 0;
@@ -734,7 +742,11 @@ static int shift_arg_pages(struct vm_area_struct *vma, unsigned long shift)
 		free_pgd_range(&tlb, old_start, old_end, new_end,
 			vma->vm_next ? vma->vm_next->vm_start : USER_PGTABLES_CEILING);
 	}
+	#ifdef CONFIG_PTP
+	iee_tlb_finish_mmu(&tlb, old_start, old_end);
+	#else
 	tlb_finish_mmu(&tlb, old_start, old_end);
+	#endif
 
 	/*
 	 * Shrink the vma to just the new range.  Always succeeds.
@@ -1017,6 +1029,9 @@ static int exec_mmap(struct mm_struct *mm)
 	if (!IS_ENABLED(CONFIG_ARCH_WANT_IRQS_OFF_ACTIVATE_MM))
 		local_irq_enable();
 	activate_mm(active_mm, mm);
+	#ifdef CONFIG_IEE
+	iee_set_token_pgd(tsk, mm->pgd);
+	#endif
 	if (IS_ENABLED(CONFIG_ARCH_WANT_IRQS_OFF_ACTIVATE_MM))
 		local_irq_enable();
 	tsk->mm->vmacache_seqnum = 0;
@@ -1609,12 +1624,20 @@ static void bprm_fill_uid(struct linux_binprm *bprm, struct file *file)
 
 	if (mode & S_ISUID) {
 		bprm->per_clear |= PER_CLEAR_ON_SETID;
+		#ifdef CONFIG_CREDP
+		iee_set_cred_euid(bprm->cred,uid);
+		#else
 		bprm->cred->euid = uid;
+		#endif
 	}
 
 	if ((mode & (S_ISGID | S_IXGRP)) == (S_ISGID | S_IXGRP)) {
 		bprm->per_clear |= PER_CLEAR_ON_SETID;
+		#ifdef CONFIG_CREDP
+		iee_set_cred_egid(bprm->cred,gid);
+		#else
 		bprm->cred->egid = gid;
+		#endif
 	}
 }
 
diff --git a/fs/file_table.c b/fs/file_table.c
index 32d33a7b3852..497cb39f84a6 100644
--- a/fs/file_table.c
+++ b/fs/file_table.c
@@ -240,6 +240,7 @@ static struct file *alloc_file(const struct path *path, int flags,
 	file->f_op = fop;
 	if ((file->f_mode & (FMODE_READ | FMODE_WRITE)) == FMODE_READ)
 		i_readcount_inc(path->dentry->d_inode);
+
 	return file;
 }
 
diff --git a/fs/nfs/flexfilelayout/flexfilelayout.c b/fs/nfs/flexfilelayout/flexfilelayout.c
index e4f2820ba5a5..3d55f6c83b3b 100644
--- a/fs/nfs/flexfilelayout/flexfilelayout.c
+++ b/fs/nfs/flexfilelayout/flexfilelayout.c
@@ -15,6 +15,10 @@
 
 #include <linux/sunrpc/metrics.h>
 
+#ifdef CONFIG_CREDP
+#include <asm/iee-cred.h>
+#endif
+
 #include "flexfilelayout.h"
 #include "../nfs4session.h"
 #include "../nfs4idmap.h"
@@ -496,8 +500,13 @@ ff_layout_alloc_lseg(struct pnfs_layout_hdr *lh,
 		rc = -ENOMEM;
 		if (!kcred)
 			goto out_err_free;
+		#ifdef CONFIG_CREDP
+		iee_set_cred_fsuid(kcred,uid);
+		iee_set_cred_fsgid(kcred,gid);
+		#else
 		kcred->fsuid = uid;
 		kcred->fsgid = gid;
+		#endif
 		cred = RCU_INITIALIZER(kcred);
 
 		if (lgr->range.iomode == IOMODE_READ)
diff --git a/fs/nfs/nfs4idmap.c b/fs/nfs/nfs4idmap.c
index ec6afd3c4bca..dc259bdb4bc8 100644
--- a/fs/nfs/nfs4idmap.c
+++ b/fs/nfs/nfs4idmap.c
@@ -48,6 +48,10 @@
 #include <linux/module.h>
 #include <linux/user_namespace.h>
 
+#ifdef CONFIG_CREDP
+#include <asm/iee-cred.h>
+#endif
+
 #include "internal.h"
 #include "netns.h"
 #include "nfs4idmap.h"
@@ -226,8 +230,13 @@ int nfs_idmap_init(void)
 		goto failed_reg_legacy;
 
 	set_bit(KEY_FLAG_ROOT_CAN_CLEAR, &keyring->flags);
+	#ifdef CONFIG_CREDP
+	iee_set_cred_thread_keyring(cred,keyring);
+	iee_set_cred_jit_keyring(cred,KEY_REQKEY_DEFL_THREAD_KEYRING);
+	#else
 	cred->thread_keyring = keyring;
 	cred->jit_keyring = KEY_REQKEY_DEFL_THREAD_KEYRING;
+	#endif
 	id_resolver_cache = cred;
 	return 0;
 
diff --git a/fs/nfsd/auth.c b/fs/nfsd/auth.c
index fdf2aad73470..5a23bc9632c9 100644
--- a/fs/nfsd/auth.c
+++ b/fs/nfsd/auth.c
@@ -2,6 +2,9 @@
 /* Copyright (C) 1995, 1996 Olaf Kirch <okir@monad.swb.de> */
 
 #include <linux/sched.h>
+#ifdef CONFIG_CREDP
+#include <asm/iee-cred.h>
+#endif
 #include "nfsd.h"
 #include "auth.h"
 
@@ -34,22 +37,40 @@ int nfsd_setuser(struct svc_rqst *rqstp, struct svc_export *exp)
 	if (!new)
 		return -ENOMEM;
 
+	#ifdef CONFIG_CREDP
+	iee_set_cred_fsuid(new,rqstp->rq_cred.cr_uid);
+	iee_set_cred_fsgid(new,rqstp->rq_cred.cr_gid);
+	#else
 	new->fsuid = rqstp->rq_cred.cr_uid;
 	new->fsgid = rqstp->rq_cred.cr_gid;
+	#endif
 
 	rqgi = rqstp->rq_cred.cr_group_info;
 
 	if (flags & NFSEXP_ALLSQUASH) {
+		#ifdef CONFIG_CREDP
+		iee_set_cred_fsuid(new,exp->ex_anon_uid);
+		iee_set_cred_fsgid(new,exp->ex_anon_gid);
+		#else
 		new->fsuid = exp->ex_anon_uid;
 		new->fsgid = exp->ex_anon_gid;
+		#endif
 		gi = groups_alloc(0);
 		if (!gi)
 			goto oom;
 	} else if (flags & NFSEXP_ROOTSQUASH) {
 		if (uid_eq(new->fsuid, GLOBAL_ROOT_UID))
+			#ifdef CONFIG_CREDP
+			iee_set_cred_fsuid(new,exp->ex_anon_uid);
+			#else
 			new->fsuid = exp->ex_anon_uid;
+			#endif
 		if (gid_eq(new->fsgid, GLOBAL_ROOT_GID))
+			#ifdef CONFIG_CREDP
+			iee_set_cred_fsgid(new,exp->ex_anon_gid);
+			#else
 			new->fsgid = exp->ex_anon_gid;
+			#endif
 
 		gi = groups_alloc(rqgi->ngroups);
 		if (!gi)
@@ -69,18 +90,35 @@ int nfsd_setuser(struct svc_rqst *rqstp, struct svc_export *exp)
 	}
 
 	if (uid_eq(new->fsuid, INVALID_UID))
+		#ifdef CONFIG_CREDP
+		iee_set_cred_fsuid(new,exp->ex_anon_uid);
+		#else
 		new->fsuid = exp->ex_anon_uid;
+		#endif
 	if (gid_eq(new->fsgid, INVALID_GID))
+		#ifdef CONFIG_CREDP
+		iee_set_cred_fsgid(new,exp->ex_anon_gid);
+		#else
 		new->fsgid = exp->ex_anon_gid;
+		#endif
 
 	set_groups(new, gi);
 	put_group_info(gi);
 
 	if (!uid_eq(new->fsuid, GLOBAL_ROOT_UID))
+		#ifdef CONFIG_CREDP
+		iee_set_cred_cap_effective(new,cap_drop_nfsd_set(new->cap_effective));
+		#else
 		new->cap_effective = cap_drop_nfsd_set(new->cap_effective);
+		#endif
 	else
+		#ifdef CONFIG_CREDP
+		iee_set_cred_cap_effective(new,cap_raise_nfsd_set(new->cap_effective,
+							new->cap_permitted));
+		#else
 		new->cap_effective = cap_raise_nfsd_set(new->cap_effective,
 							new->cap_permitted);
+		#endif
 	validate_process_creds();
 	put_cred(override_creds(new));
 	put_cred(new);
diff --git a/fs/nfsd/nfs4callback.c b/fs/nfsd/nfs4callback.c
index f5b7ad0847f2..dd9bdc0b9016 100644
--- a/fs/nfsd/nfs4callback.c
+++ b/fs/nfsd/nfs4callback.c
@@ -41,6 +41,9 @@
 #include "trace.h"
 #include "xdr4cb.h"
 #include "xdr4.h"
+#ifdef CONFIG_CREDP
+#include <asm/iee-cred.h>
+#endif
 
 #define NFSDDBG_FACILITY                NFSDDBG_PROC
 
@@ -875,8 +878,13 @@ static const struct cred *get_backchannel_cred(struct nfs4_client *clp, struct r
 		if (!kcred)
 			return NULL;
 
+		#ifdef CONFIG_CREDP
+		iee_set_cred_uid(kcred,ses->se_cb_sec.uid);
+		iee_set_cred_gid(kcred,ses->se_cb_sec.gid);
+		#else
 		kcred->fsuid = ses->se_cb_sec.uid;
 		kcred->fsgid = ses->se_cb_sec.gid;
+		#endif
 		return kcred;
 	}
 }
diff --git a/fs/nfsd/nfs4recover.c b/fs/nfsd/nfs4recover.c
index 83c4e6883953..3d437e0b3f68 100644
--- a/fs/nfsd/nfs4recover.c
+++ b/fs/nfsd/nfs4recover.c
@@ -44,6 +44,10 @@
 #include <linux/sunrpc/clnt.h>
 #include <linux/nfsd/cld.h>
 
+#ifdef CONFIG_CREDP
+#include <asm/iee-cred.h>
+#endif
+
 #include "nfsd.h"
 #include "state.h"
 #include "vfs.h"
@@ -78,8 +82,13 @@ nfs4_save_creds(const struct cred **original_creds)
 	if (!new)
 		return -ENOMEM;
 
+	#ifdef CONFIG_CREDP
+	iee_set_cred_fsuid(new,GLOBAL_ROOT_UID);
+	iee_set_cred_fsgid(new,GLOBAL_ROOT_GID);
+	#else
 	new->fsuid = GLOBAL_ROOT_UID;
 	new->fsgid = GLOBAL_ROOT_GID;
+	#endif
 	*original_creds = override_creds(new);
 	put_cred(new);
 	return 0;
diff --git a/fs/nfsd/nfsfh.c b/fs/nfsd/nfsfh.c
index c81dbbad8792..aa39fe110b0c 100644
--- a/fs/nfsd/nfsfh.c
+++ b/fs/nfsd/nfsfh.c
@@ -16,6 +16,10 @@
 #include "auth.h"
 #include "trace.h"
 
+#ifdef CONFIG_CREDP
+#include <asm/iee-cred.h>
+#endif
+
 #define NFSDDBG_FACILITY		NFSDDBG_FH
 
 
@@ -234,9 +238,14 @@ static __be32 nfsd_set_fh_dentry(struct svc_rqst *rqstp, struct svc_fh *fhp)
 			error =  nfserrno(-ENOMEM);
 			goto out;
 		}
+		#ifdef CONFIG_CREDP
+		iee_set_cred_cap_effective(new,cap_raise_nfsd_set(new->cap_effective,
+					   new->cap_permitted));
+		#else
 		new->cap_effective =
 			cap_raise_nfsd_set(new->cap_effective,
 					   new->cap_permitted);
+		#endif
 		put_cred(override_creds(new));
 		put_cred(new);
 	} else {
diff --git a/fs/open.c b/fs/open.c
index 8092178ceab0..869327cf2b95 100644
--- a/fs/open.c
+++ b/fs/open.c
@@ -33,6 +33,10 @@
 #include <linux/dnotify.h>
 #include <linux/compat.h>
 
+#ifdef CONFIG_CREDP
+#include <asm/iee-cred.h>
+#endif
+
 #include "internal.h"
 
 int do_truncate(struct dentry *dentry, loff_t length, unsigned int time_attrs,
@@ -354,17 +358,32 @@ static const struct cred *access_override_creds(void)
 	if (!override_cred)
 		return NULL;
 
+	#ifdef CONFIG_CREDP
+	iee_set_cred_fsuid(override_cred,override_cred->uid);
+	iee_set_cred_fsgid(override_cred,override_cred->gid);
+	#else
 	override_cred->fsuid = override_cred->uid;
 	override_cred->fsgid = override_cred->gid;
+	#endif
 
 	if (!issecure(SECURE_NO_SETUID_FIXUP)) {
 		/* Clear the capabilities if we switch to a non-root user */
 		kuid_t root_uid = make_kuid(override_cred->user_ns, 0);
 		if (!uid_eq(override_cred->uid, root_uid))
+			#ifdef CONFIG_CREDP
+			do {
+				iee_set_cred_cap_effective(override_cred, __cap_empty_set);
+			} while (0);
+			#else
 			cap_clear(override_cred->cap_effective);
+			#endif
 		else
+			#ifdef CONFIG_CREDP
+			iee_set_cred_cap_effective(override_cred,override_cred->cap_permitted);
+			#else
 			override_cred->cap_effective =
 				override_cred->cap_permitted;
+			#endif
 	}
 
 	/*
@@ -384,7 +403,11 @@ static const struct cred *access_override_creds(void)
 	 * expecting RCU freeing. But normal thread-synchronous
 	 * cred accesses will keep things non-RCY.
 	 */
+	#ifdef CONFIG_CREDP
+	iee_set_cred_non_rcu(override_cred,1);
+	#else
 	override_cred->non_rcu = 1;
+	#endif
 
 	old_cred = override_creds(override_cred);
 
diff --git a/fs/overlayfs/dir.c b/fs/overlayfs/dir.c
index b2eb48b495f7..1c8df580ae22 100644
--- a/fs/overlayfs/dir.c
+++ b/fs/overlayfs/dir.c
@@ -16,6 +16,10 @@
 #include <linux/ratelimit.h>
 #include "overlayfs.h"
 
+#ifdef CONFIG_CREDP
+#include <asm/iee-cred.h>
+#endif
+
 static unsigned short ovl_redirect_max = 256;
 module_param_named(redirect_max, ovl_redirect_max, ushort, 0644);
 MODULE_PARM_DESC(redirect_max,
@@ -603,8 +607,13 @@ static int ovl_create_or_link(struct dentry *dentry, struct inode *inode,
 		 * create a new inode, so just use the ovl mounter's
 		 * fs{u,g}id.
 		 */
+		#ifdef CONFIG_CREDP
+		iee_set_cred_fsuid(override_cred,inode->i_uid);
+		iee_set_cred_fsgid(override_cred,inode->i_gid);
+		#else
 		override_cred->fsuid = inode->i_uid;
 		override_cred->fsgid = inode->i_gid;
+		#endif
 		err = security_dentry_create_files_as(dentry,
 				attr->mode, &dentry->d_name, old_cred,
 				override_cred);
diff --git a/fs/overlayfs/super.c b/fs/overlayfs/super.c
index 5d7df839902d..93bbe723c422 100644
--- a/fs/overlayfs/super.c
+++ b/fs/overlayfs/super.c
@@ -17,6 +17,10 @@
 #include <linux/exportfs.h>
 #include "overlayfs.h"
 
+#ifdef CONFIG_CREDP
+#include <asm/iee-cred.h>
+#endif
+
 MODULE_AUTHOR("Miklos Szeredi <miklos@szeredi.hu>");
 MODULE_DESCRIPTION("Overlay filesystem");
 MODULE_LICENSE("GPL");
@@ -2022,7 +2026,15 @@ static int ovl_fill_super(struct super_block *sb, void *data, int silent)
 		sb->s_export_op = &ovl_export_operations;
 
 	/* Never override disk quota limits or use reserved space */
+	#ifdef CONFIG_CREDP
+	{
+		kernel_cap_t tmp = cred->cap_effective;
+		cap_lower(tmp, CAP_SYS_RESOURCE);
+		iee_set_cred_cap_effective(cred, tmp);
+	}
+	#else
 	cap_lower(cred->cap_effective, CAP_SYS_RESOURCE);
+	#endif
 
 	sb->s_magic = OVERLAYFS_SUPER_MAGIC;
 	sb->s_xattr = ovl_xattr_handlers;
diff --git a/include/asm-generic/early_ioremap.h b/include/asm-generic/early_ioremap.h
index 9def22e6e2b3..13b287b7cdc3 100644
--- a/include/asm-generic/early_ioremap.h
+++ b/include/asm-generic/early_ioremap.h
@@ -17,6 +17,9 @@ extern void *early_memremap_ro(resource_size_t phys_addr,
 extern void *early_memremap_prot(resource_size_t phys_addr,
 				 unsigned long size, unsigned long prot_val);
 extern void early_iounmap(void __iomem *addr, unsigned long size);
+#ifdef CONFIG_PTP
+extern void early_iounmap_after_init(void __iomem *addr, unsigned long size);
+#endif
 extern void early_memunmap(void *addr, unsigned long size);
 
 /*
diff --git a/include/asm-generic/fixmap.h b/include/asm-generic/fixmap.h
index 8cc7b09c1bc7..83158589a545 100644
--- a/include/asm-generic/fixmap.h
+++ b/include/asm-generic/fixmap.h
@@ -70,6 +70,24 @@ static inline unsigned long virt_to_fix(const unsigned long vaddr)
 	__set_fixmap(idx, 0, FIXMAP_PAGE_CLEAR)
 #endif
 
+#ifdef CONFIG_PTP
+#ifndef clear_fixmap_init
+#define clear_fixmap_init(idx)			\
+	__iee_set_fixmap_pre_init(idx, 0, FIXMAP_PAGE_CLEAR)
+#endif
+
+#define __iee_set_fixmap_offset_pre_init(idx, phys, flags)				\
+({									\
+	unsigned long ________addr;					\
+	__iee_set_fixmap_pre_init(idx, phys, flags);					\
+	________addr = fix_to_virt(idx) + ((phys) & (PAGE_SIZE - 1));	\
+	________addr;							\
+})
+
+#define iee_set_fixmap_offset_pre_init(idx, phys) \
+	__iee_set_fixmap_offset_pre_init(idx, phys, FIXMAP_PAGE_NORMAL)
+#endif
+
 /* Return a pointer with offset calculated */
 #define __set_fixmap_offset(idx, phys, flags)				\
 ({									\
diff --git a/include/asm-generic/pgalloc.h b/include/asm-generic/pgalloc.h
index 02932efad3ab..c039cf1228b4 100644
--- a/include/asm-generic/pgalloc.h
+++ b/include/asm-generic/pgalloc.h
@@ -4,6 +4,10 @@
 
 #ifdef CONFIG_MMU
 
+#ifdef CONFIG_PTP
+#include <asm/pgtable_slab.h>
+#endif
+
 #define GFP_PGTABLE_KERNEL	(GFP_KERNEL | __GFP_ZERO)
 #define GFP_PGTABLE_USER	(GFP_PGTABLE_KERNEL | __GFP_ACCOUNT)
 
@@ -18,7 +22,11 @@
  */
 static inline pte_t *__pte_alloc_one_kernel(struct mm_struct *mm)
 {
+	#ifdef CONFIG_PTP
+	return (pte_t *)get_iee_pgtable_page(GFP_PGTABLE_KERNEL);
+	#else
 	return (pte_t *)__get_free_page(GFP_PGTABLE_KERNEL);
+	#endif
 }
 
 #ifndef __HAVE_ARCH_PTE_ALLOC_ONE_KERNEL
@@ -41,7 +49,11 @@ static inline pte_t *pte_alloc_one_kernel(struct mm_struct *mm)
  */
 static inline void pte_free_kernel(struct mm_struct *mm, pte_t *pte)
 {
+	#ifdef CONFIG_PTP
+	free_iee_pgtable_page((void *)pte);
+	#else
 	free_page((unsigned long)pte);
+	#endif
 }
 
 /**
@@ -60,11 +72,19 @@ static inline pgtable_t __pte_alloc_one(struct mm_struct *mm, gfp_t gfp)
 {
 	struct page *pte;
 
+	#ifdef CONFIG_PTP
+	pte = virt_to_page(get_iee_pgtable_page(gfp));
+	#else
 	pte = alloc_page(gfp);
+	#endif
 	if (!pte)
 		return NULL;
 	if (!pgtable_pte_page_ctor(pte)) {
+		#ifdef CONFIG_PTP
+		free_iee_pgtable_page((void *)page_to_virt(pte));
+		#else
 		__free_page(pte);
+		#endif
 		return NULL;
 	}
 
@@ -99,7 +119,11 @@ static inline pgtable_t pte_alloc_one(struct mm_struct *mm)
 static inline void pte_free(struct mm_struct *mm, struct page *pte_page)
 {
 	pgtable_pte_page_dtor(pte_page);
+	#ifdef CONFIG_PTP
+	free_iee_pgtable_page((void *)page_to_virt(pte_page));
+	#else
 	__free_page(pte_page);
+	#endif
 }
 
 
@@ -123,11 +147,19 @@ static inline pmd_t *pmd_alloc_one(struct mm_struct *mm, unsigned long addr)
 
 	if (mm == &init_mm)
 		gfp = GFP_PGTABLE_KERNEL;
+	#ifdef CONFIG_PTP
+	page = virt_to_page(get_iee_pgtable_page(gfp));
+	#else
 	page = alloc_pages(gfp, 0);
+	#endif
 	if (!page)
 		return NULL;
 	if (!pgtable_pmd_page_ctor(page)) {
+		#ifdef CONFIG_PTP
+		free_iee_pgtable_page((void *)page_to_virt(page));
+		#else
 		__free_pages(page, 0);
+		#endif
 		return NULL;
 	}
 	return (pmd_t *)page_address(page);
@@ -139,7 +171,11 @@ static inline void pmd_free(struct mm_struct *mm, pmd_t *pmd)
 {
 	BUG_ON((unsigned long)pmd & (PAGE_SIZE-1));
 	pgtable_pmd_page_dtor(virt_to_page(pmd));
+	#ifdef CONFIG_PTP
+	free_iee_pgtable_page((void *)pmd);
+	#else
 	free_page((unsigned long)pmd);
+	#endif
 }
 #endif
 
@@ -163,14 +199,22 @@ static inline pud_t *pud_alloc_one(struct mm_struct *mm, unsigned long addr)
 
 	if (mm == &init_mm)
 		gfp = GFP_PGTABLE_KERNEL;
+	#ifdef CONFIG_PTP
+	return (pud_t *)get_iee_pgtable_page(gfp);
+	#else
 	return (pud_t *)get_zeroed_page(gfp);
+	#endif
 }
 #endif
 
 static inline void pud_free(struct mm_struct *mm, pud_t *pud)
 {
 	BUG_ON((unsigned long)pud & (PAGE_SIZE-1));
+	#ifdef CONFIG_PTP
+	free_iee_pgtable_page((void *)pud);
+	#else
 	free_page((unsigned long)pud);
+	#endif
 }
 
 #endif /* CONFIG_PGTABLE_LEVELS > 3 */
diff --git a/include/asm-generic/tlb.h b/include/asm-generic/tlb.h
index f40c9534f20b..b31a74eb2c46 100644
--- a/include/asm-generic/tlb.h
+++ b/include/asm-generic/tlb.h
@@ -185,6 +185,9 @@ struct mmu_table_batch {
 	((PAGE_SIZE - sizeof(struct mmu_table_batch)) / sizeof(void *))
 
 extern void tlb_remove_table(struct mmu_gather *tlb, void *table);
+#ifdef CONFIG_PTP
+extern void iee_tlb_remove_table(struct mmu_gather *tlb, void *table);
+#endif
 
 #else /* !CONFIG_MMU_GATHER_HAVE_TABLE_FREE */
 
diff --git a/include/asm-generic/vmlinux.lds.h b/include/asm-generic/vmlinux.lds.h
index 8716609fb333..771245a02602 100644
--- a/include/asm-generic/vmlinux.lds.h
+++ b/include/asm-generic/vmlinux.lds.h
@@ -324,6 +324,17 @@
 	KEEP(*(.dtb.init.rodata))					\
 	__dtb_end = .;
 
+#ifdef CONFIG_KOI
+#define KOI_DATA() \
+	. = ALIGN(PAGE_SIZE);	\
+	__koi_data_start = .;	\
+	*(.data..koi)	\
+	. = ALIGN(PAGE_SIZE);	\
+	__koi_data_end = .;
+#else
+#define KOI_DATA()		
+#endif
+
 /*
  * .data section
  */
@@ -350,8 +361,8 @@
 	BRANCH_PROFILE()						\
 	TRACE_PRINTKS()							\
 	BPF_RAW_TP()							\
-	TRACEPOINT_STR()
-
+	TRACEPOINT_STR()                        \
+    KOI_DATA()	
 /*
  * Data section helpers
  */
@@ -1133,6 +1144,14 @@
  * They will fit only a subset of the architectures
  */
 
+#ifdef CONFIG_CREDP
+	#define CRED_DATA		\
+		. = ALIGN(PAGE_SIZE);		\
+		*(.iee.cred)		\
+		. = ALIGN(PAGE_SIZE);
+#else
+	#define CRED_DATA
+#endif
 
 /*
  * Writeable data.
@@ -1150,6 +1169,7 @@
 	. = ALIGN(PAGE_SIZE);						\
 	.data : AT(ADDR(.data) - LOAD_OFFSET) {				\
 		INIT_TASK_DATA(inittask)				\
+		CRED_DATA						\
 		NOSAVE_DATA						\
 		PAGE_ALIGNED_DATA(pagealigned)				\
 		CACHELINE_ALIGNED_DATA(cacheline)			\
diff --git a/include/linux/bpf.h b/include/linux/bpf.h
index fc6754747781..d52238cf6c99 100644
--- a/include/linux/bpf.h
+++ b/include/linux/bpf.h
@@ -171,6 +171,17 @@ struct bpf_map {
 	bool frozen; /* write-once; write-protected by freeze_mutex */
 	KABI_EXTEND(bool free_after_mult_rcu_gp)
 	/* 17 bytes hole */
+	#ifdef CONFIG_HIVE
+	/* fbpf add for aggregation */
+	bool is_aggregated;
+	int used_page_cnt;
+	union {
+		struct bpf_used_page *used_pages;
+		void *value;
+	};
+	void *shadow_data;
+	struct mutex used_page_mutex;
+	#endif
 
 	/* The 3rd and 4th cacheline with misc members to avoid false sharing
 	 * particularly with refcounting.
diff --git a/include/linux/bpf_verifier.h b/include/linux/bpf_verifier.h
index d760079a6be6..0aaa1cdac12f 100644
--- a/include/linux/bpf_verifier.h
+++ b/include/linux/bpf_verifier.h
@@ -7,6 +7,9 @@
 #include <linux/bpf.h> /* for enum bpf_reg_type */
 #include <linux/filter.h> /* for MAX_BPF_STACK */
 #include <linux/tnum.h>
+#ifdef CONFIG_HIVE
+#include <linux/sfi_bpf.h>
+#endif
 
 /* Maximum variable offset umax_value permitted when resolving memory accesses.
  * In practice this is far bigger than any realistic pointer offset; this limit
@@ -150,6 +153,11 @@ struct bpf_reg_state {
 	enum bpf_reg_liveness live;
 	/* if (!precise && SCALAR_VALUE) min/max/tnum don't affect safety */
 	bool precise;
+	#ifdef CONFIG_HIVE
+	/* used to record whether the reg is checked */
+	// bool sfi_checked;
+	enum bpf_sfi_check_state sfi_check_state;
+	#endif
 };
 
 enum bpf_stack_slot_type {
@@ -353,6 +361,12 @@ struct bpf_insn_aux_data {
 	bool sanitize_stack_spill; /* subject to Spectre v4 sanitation */
 	bool zext_dst; /* this insn zero extends dst reg */
 	u8 alu_state; /* used in combination with alu_limit */
+	#ifdef CONFIG_HIVE
+	/* fbpf record for patch isnns */
+	enum bpf_reg_type arg_reg_type[5];
+	u64 extra_map_ptr;
+	// struct bpf_sfi_check_unit *sfi_check_list;
+	#endif
 
 	/* below fields are initialized once */
 	unsigned int orig_idx; /* original instruction index */
@@ -436,6 +450,10 @@ struct bpf_verifier_env {
 	bool bypass_spec_v4;
 	bool seen_direct_write;
 	struct bpf_insn_aux_data *insn_aux_data; /* array of per-insn state */
+	#ifdef CONFIG_HIVE
+	struct bpf_sfi_check_unit **insn_check_lists; /* array of per-insn check_list */
+	struct mutex insn_check_list_mutex;
+	#endif
 	const struct bpf_line_info *prev_linfo;
 	struct bpf_verifier_log log;
 	struct bpf_subprog_info subprog_info[BPF_MAX_SUBPROGS + 1];
diff --git a/include/linux/cred.h b/include/linux/cred.h
index cd1b5fc47d52..8843cb5c9d9e 100644
--- a/include/linux/cred.h
+++ b/include/linux/cred.h
@@ -18,6 +18,11 @@
 #include <linux/sched/user.h>
 #include <linux/kabi.h>
 
+#ifdef CONFIG_IEE
+#include <linux/iee-flag.h>
+#include <asm/iee-def.h>
+#endif
+
 struct cred;
 struct inode;
 
@@ -164,6 +169,22 @@ struct cred {
 	KABI_RESERVE(10)
 } __randomize_layout;
 
+#ifdef CONFIG_CREDP
+extern unsigned long long iee_rw_gate(int flag, ...);
+static void iee_set_cred_non_rcu(struct cred *cred, int non_rcu)
+{
+    iee_rw_gate(IEE_OP_SET_CRED_NON_RCU,cred,non_rcu);
+	*(int *)(&(((struct rcu_head *)(cred->rcu.func))->next)) = non_rcu;
+}
+
+static bool iee_set_cred_atomic_op_usage(struct cred *cred, int flag)
+{
+    bool ret;
+    ret = iee_rw_gate(IEE_OP_SET_CRED_ATOP_USAGE,cred,flag);
+    return ret;
+}
+#endif
+
 extern void __put_cred(struct cred *);
 extern void exit_creds(struct task_struct *);
 extern int copy_creds(struct task_struct *, unsigned long);
@@ -239,7 +260,11 @@ static inline bool cap_ambient_invariant_ok(const struct cred *cred)
  */
 static inline struct cred *get_new_cred(struct cred *cred)
 {
+	#ifdef CONFIG_CREDP
+	iee_set_cred_atomic_op_usage(cred,AT_INC);
+	#else
 	atomic_inc(&cred->usage);
+	#endif
 	return cred;
 }
 
@@ -262,7 +287,11 @@ static inline const struct cred *get_cred(const struct cred *cred)
 	if (!cred)
 		return cred;
 	validate_creds(cred);
+	#ifdef CONFIG_CREDP
+	iee_set_cred_non_rcu(nonconst_cred,0);
+	#else
 	nonconst_cred->non_rcu = 0;
+	#endif
 	return get_new_cred(nonconst_cred);
 }
 
@@ -271,10 +300,19 @@ static inline const struct cred *get_cred_rcu(const struct cred *cred)
 	struct cred *nonconst_cred = (struct cred *) cred;
 	if (!cred)
 		return NULL;
+	#ifdef CONFIG_CREDP
+	if (!iee_set_cred_atomic_op_usage(nonconst_cred,AT_INC_NOT_ZERO))
+		return NULL;
+	#else
 	if (!atomic_inc_not_zero(&nonconst_cred->usage))
 		return NULL;
+	#endif
 	validate_creds(cred);
+	#ifdef CONFIG_CREDP
+	iee_set_cred_non_rcu(nonconst_cred,0);
+	#else
 	nonconst_cred->non_rcu = 0;
+	#endif
 	return cred;
 }
 
@@ -295,8 +333,13 @@ static inline void put_cred(const struct cred *_cred)
 
 	if (cred) {
 		validate_creds(cred);
+		#ifdef CONFIG_CREDP
+		if (iee_set_cred_atomic_op_usage(cred,AT_DEC_AND_TEST))
+			__put_cred(cred);
+		#else
 		if (atomic_dec_and_test(&(cred)->usage))
 			__put_cred(cred);
+		#endif
 	}
 }
 
diff --git a/include/linux/efi.h b/include/linux/efi.h
index 9816e03cf05b..ebdd48da4741 100644
--- a/include/linux/efi.h
+++ b/include/linux/efi.h
@@ -644,6 +644,9 @@ extern void __efi_memmap_free(u64 phys, unsigned long size,
 extern int __init efi_memmap_init_early(struct efi_memory_map_data *data);
 extern int __init efi_memmap_init_late(phys_addr_t addr, unsigned long size);
 extern void __init efi_memmap_unmap(void);
+#ifdef CONFIG_PTP
+extern void __init efi_memmap_unmap_after_init(void);
+#endif
 extern int __init efi_memmap_install(struct efi_memory_map_data *data);
 extern int __init efi_memmap_split_count(efi_memory_desc_t *md,
 					 struct range *range);
diff --git a/include/linux/filter.h b/include/linux/filter.h
index 2a0c2dd47599..902209e47bf2 100644
--- a/include/linux/filter.h
+++ b/include/linux/filter.h
@@ -50,6 +50,9 @@ struct ctl_table_header;
 #define BPF_REG_ARG5	BPF_REG_5
 #define BPF_REG_CTX	BPF_REG_6
 #define BPF_REG_FP	BPF_REG_10
+#ifdef CONFIG_HIVE
+#define BPF_REG_BASE	BPF_REG_11
+#endif
 
 /* Additional register mappings for converted user programs. */
 #define BPF_REG_A	BPF_REG_0
@@ -557,6 +560,14 @@ struct bpf_prog {
 	u8			tag[BPF_TAG_SIZE];
 	struct bpf_prog_aux	*aux;		/* Auxiliary fields */
 	struct sock_fprog_kern	*orig_prog;	/* Original BPF program */
+	#ifdef CONFIG_HIVE
+	/* fbpf record info while aggregating */
+	void *shadow_stack_addr, *shadow_region_addr, *shadow_top_addr, 
+		*shadow_skb_addr, *low_guard_region_addr, *high_guard_region_addr,
+		*map_data_addr;
+	int shadow_stack_page_cnt, total_page_cnt, shadow_skb_page_cnt, 
+		guard_region_page_cnt, map_page_cnt;
+	#endif
 	unsigned int		(*bpf_func)(const void *ctx,
 					    const struct bpf_insn *insn);
 	/* Instructions for interpreter */
diff --git a/include/linux/iee-flag.h b/include/linux/iee-flag.h
new file mode 100644
index 000000000000..e3cf1c33e7b3
--- /dev/null
+++ b/include/linux/iee-flag.h
@@ -0,0 +1,74 @@
+#ifndef _LINUX_IEE_FLAG_H
+#define _LINUX_IEE_FLAG_H
+
+enum {
+    IEE_WRITE_IN_BYTE=0,                // Parameters: void *ptr, __u64 data, int length
+    IEE_OP_SET_PTE,                     // Parameters: pte_t *ptep, pte_t pte
+    IEE_OP_SET_PMD,                     // Parameters: pmd_t *pmdp, pmd_t pmd
+    IEE_OP_SET_PUD,                     // Parameters: pud_t *pudp, pud_t pud
+    IEE_OP_SET_P4D,                     // Parameters: p4d_t *p4dp, p4d_t p4d
+    IEE_OP_SET_BM_PTE,                  // Parameters: pte_t *ptep, pte_t pte
+    IEE_OP_SET_SWAPPER_PGD,             // Parameters: pgd_t *pgdp, pgd_t pgd
+    IEE_OP_SET_TRAMP_PGD,               // Parameters: pgd_t *pgdp, pgd_t pgd
+	IEE_OP_COPY_CRED,                   // Parameters: struct cred *old, struct cred *new
+	IEE_OP_SET_CRED_UID,                // Parameters: struct cred *cred, kuid_t uid
+	IEE_OP_SET_CRED_GID,                // Parameters: struct cred *cred, kgid_t gid
+	IEE_OP_SET_CRED_SUID,               // Parameters: struct cred *cred, kuid_t suid
+	IEE_OP_SET_CRED_SGID,               // Parameters: struct cred *cred, kgid_t sgid
+	IEE_OP_SET_CRED_EUID,               // Parameters: struct cred *cred, kuid_t euid
+	IEE_OP_SET_CRED_EGID,               // Parameters: struct cred *cred, kgid_t egid
+	IEE_OP_SET_CRED_FSUID,              // Parameters: struct cred *cred, kuid_t fsuid
+	IEE_OP_SET_CRED_FSGID,              // Parameters: struct cred *cred, kgid_t fsgid
+	IEE_OP_SET_CRED_USER,               // Parameters: struct cred *cred, struct user_struct *user
+	IEE_OP_SET_CRED_USER_NS,            // Parameters: struct cred *cred, struct user_namespace *user_ns
+	IEE_OP_SET_CRED_GROUP_INFO,         // Parameters: struct cred *cred, struct group_info *group_info
+	IEE_OP_SET_CRED_SECUREBITS,         // Parameters: struct cred *cred, unsigned securebits
+	IEE_OP_SET_CRED_CAP_INHER,          // Parameters: struct cred *cred, kernel_cap_t cap_inheritable
+	IEE_OP_SET_CRED_CAP_PERM,           // Parameters: struct cred *cred, kernel_cap_t cap_permitted
+	IEE_OP_SET_CRED_CAP_EFFECT,         // Parameters: struct cred *cred, kernel_cap_t cap_effective
+	IEE_OP_SET_CRED_CAP_BSET,           // Parameters: struct cred *cred, kernel_cap_t cap_bset
+	IEE_OP_SET_CRED_CAP_AMBIENT,        // Parameters: struct cred *cred, kernel_cap_t cap_ambient
+	IEE_OP_SET_CRED_JIT_KEYRING,        // Parameters: struct cred *cred, unsigned char jit_keyring
+	IEE_OP_SET_CRED_SESS_KEYRING,       // Parameters: struct cred *cred, struct key *session_keyring
+	IEE_OP_SET_CRED_PROC_KEYRING,       // Parameters: struct cred *cred, struct key *process_keyring
+	IEE_OP_SET_CRED_THREAD_KEYRING,     // Parameters: struct cred *cred, struct key *thread_keyring
+	IEE_OP_SET_CRED_REQ_KEYRING,        // Parameters: struct cred *cred, struct key *request_key_auth
+	IEE_OP_SET_CRED_NON_RCU,            // Parameters: struct cred *cred, int non_rcu
+	IEE_OP_SET_CRED_ATSET_USAGE,        // Parameters: struct cred *cred, int i
+	IEE_OP_SET_CRED_ATOP_USAGE,         // Parameters: struct cred *cred, int flag
+	IEE_OP_SET_CRED_SECURITY,           // Parameters: struct cred *cred, void *security
+	IEE_OP_SET_CRED_RCU,                // Parameters: struct cred *cred, struct rcu_head *rcu
+    IEE_MEMSET,                         // Parameters: void *ptr, int data, size_t n
+	IEE_OP_SET_TRACK,                   // Parameters: struct track *ptr, struct track *data
+	IEE_OP_SET_FREEPTR,                 // Parameters: void **pptr, void *ptr
+	IEE_OP_SET_PTE_U,                   // Parameters: pte_t *ptep
+	IEE_OP_SET_PTE_P,                   // Parameters: pte_t *ptep
+    IEE_SET_TOKEN_PGD,                  // Parameters: struct task_token *token, pgd_t *pgd
+    IEE_INIT_TOKEN,                     // Parameters: struct task_struct *tsk, void *kernel_stack, void *iee_stack
+    IEE_INVALIDATE_TOKEN,                     // Parameters: struct task_struct *tsk
+    IEE_SET_SENSITIVE_PTE,              // Parameters: pte_t *lm_ptep, pte_t *iee_ptep
+    IEE_UNSET_SENSITIVE_PTE,            // Parameters: pte_t *lm_ptep, pte_t *iee_ptep
+    IEE_SET_TOKEN,                      // Parameters: pte_t *ptep, void *new, unsigned long order
+    IEE_UNSET_TOKEN,                    // Parameters: pte_t *ptep, void *token_addr, void *token_page, unsigned long order
+    IEE_COPY_PTE_RANGE,                 // Parameters: pte_t *new_dst, pte_t *old_dst, pte_t *src_pte, struct vm_area_struct *src_vma, unsigned long dst_vm_flags, pte_t *end_pte
+	IEE_SPLIT_HUGE_PMD,
+	IEE_VALIDATE_TOKEN,
+#ifdef CONFIG_KOI
+    _IEE_READ_KOI_STACK,                 // Parameters: struct task_struct *tsk
+    _IEE_WRITE_KOI_STACK,                // Parameters: struct task_struct *tsk, unsigned long koi_stack
+    _IEE_READ_TOKEN_TTBR1,               // Parameters: struct task_struct *tsk
+    _IEE_WRITE_TOKEN_TTBR1,              // Parameters: struct task_struct *tsk, unsigned long current_ttbr1
+    _IEE_READ_KOI_KERNEL_STACK,          // Parameters: struct task_struct *tsk
+    _IEE_WRITE_KOI_KERNEL_STACK,         // Parameters: struct task_struct *tsk, unsigned long kernel_stack
+    _IEE_READ_KOI_STACK_BASE,            // Parameters: struct task_struct *tsk
+    _IEE_WRITE_KOI_STACK_BASE,           // Parameters: struct task_struct *tsk, unsigned long koi_stack_base
+	_IEE_SET_KOI_PGD,					// Parameters: unsigned long koi_pgd_addr
+#endif
+#ifdef CONFIG_CREDP
+	IEE_OP_COMMIT_CRED,             	// Parameters: struct cred *cred
+	IEE_OP_COPY_CRED_KERNEL,        	// Parameters: struct cred *old, struct cred *new
+#endif
+    IEE_FLAG_END
+};
+
+#endif
\ No newline at end of file
diff --git a/include/linux/iee-func.h b/include/linux/iee-func.h
new file mode 100644
index 000000000000..333434dc7141
--- /dev/null
+++ b/include/linux/iee-func.h
@@ -0,0 +1,39 @@
+#ifndef _LINUX_IEE_FUNC_H
+#define _LINUX_IEE_FUNC_H
+
+#ifdef CONFIG_IEE
+#define TASK_ORDER 4
+
+#ifdef CONFIG_PTP
+extern int cpu_to_node_map[NR_CPUS];
+#endif
+extern unsigned long init_iee_stack_begin[];
+extern unsigned long init_iee_stack_end[];
+extern void *init_token_page_vaddr;
+
+extern unsigned long long iee_rw_gate(int flag, ...);
+extern u32 get_cpu_asid_bits(void);
+extern unsigned long arm64_mm_context_get(struct mm_struct *mm);
+extern void set_iee_page(unsigned long addr, int order);
+extern void unset_iee_page(unsigned long addr, int order);
+extern void set_iee_page_valid(unsigned long addr);
+extern void iee_set_logical_mem_ro(unsigned long addr);
+extern void __init iee_mark_all_lm_pgtable_ro(void);
+extern void iee_set_token_pgd(struct task_struct *tsk, pgd_t *pgd);
+extern void iee_init_token(struct task_struct *tsk, void *iee_stack, void *tmp_page);
+extern void iee_invalidate_token(struct task_struct *tsk);
+extern void iee_validate_token(struct task_struct *tsk);
+extern unsigned long iee_read_token_stack(struct task_struct *tsk);
+extern void iee_set_token_page_valid(void *token, void *new, unsigned int order);
+extern void iee_set_token_page_invalid(void *token_addr, void *token_page, unsigned long order);
+extern void iee_set_kernel_ppage(unsigned long addr, int order);
+extern void iee_set_kernel_upage(unsigned long addr, int order);
+extern void __init iee_set_kernel_upage_early(unsigned long addr, int order);
+extern void iee_write_in_byte(void *ptr, u64 data, int length);
+extern void *iee_read_tmp_page(struct task_struct *tsk);
+extern void *iee_read_freeptr(void *ptr);
+extern void iee_set_stack_freeptr(unsigned long addr, void *free_ptr);
+extern void iee_memset(void *ptr, int data, size_t n);
+#endif
+
+#endif
\ No newline at end of file
diff --git a/include/linux/mm.h b/include/linux/mm.h
index e0d269b83c8f..a14783e086f8 100644
--- a/include/linux/mm.h
+++ b/include/linux/mm.h
@@ -2217,7 +2217,11 @@ extern void ptlock_free(struct page *page);
 
 static inline spinlock_t *ptlock_ptr(struct page *page)
 {
+	#ifdef CONFIG_PTP
+	return ((struct pgtable_page *)(page->slab_cache))->ptl;
+	#else
 	return page->ptl;
+	#endif
 }
 #else /* ALLOC_SPLIT_PTLOCKS */
 static inline void ptlock_cache_init(void)
@@ -2235,7 +2239,11 @@ static inline void ptlock_free(struct page *page)
 
 static inline spinlock_t *ptlock_ptr(struct page *page)
 {
+	#ifdef CONFIG_PTP
+	return &(((struct pgtable_page *)(page->slab_cache))->ptl);
+	#else
 	return &page->ptl;
+	#endif
 }
 #endif /* ALLOC_SPLIT_PTLOCKS */
 
@@ -2253,7 +2261,11 @@ static inline bool ptlock_init(struct page *page)
 	 * It can happen if arch try to use slab for page table allocation:
 	 * slab code uses page->slab_cache, which share storage with page->ptl.
 	 */
+	#ifdef CONFIG_PTP
+	VM_BUG_ON_PAGE(*(unsigned long *)(&(((struct pgtable_page *)(page->slab_cache))->ptl)), page);
+	#else
 	VM_BUG_ON_PAGE(*(unsigned long *)&page->ptl, page);
+	#endif
 	if (!ptlock_alloc(page))
 		return false;
 	spin_lock_init(ptlock_ptr(page));
@@ -2338,7 +2350,11 @@ static inline spinlock_t *pmd_lockptr(struct mm_struct *mm, pmd_t *pmd)
 static inline bool pmd_ptlock_init(struct page *page)
 {
 #ifdef CONFIG_TRANSPARENT_HUGEPAGE
+	#ifdef CONFIG_PTP
+	((struct pgtable_page *)(page->slab_cache))->pmd_huge_pte = NULL;
+	#else
 	page->pmd_huge_pte = NULL;
+	#endif
 #endif
 	return ptlock_init(page);
 }
@@ -2346,12 +2362,20 @@ static inline bool pmd_ptlock_init(struct page *page)
 static inline void pmd_ptlock_free(struct page *page)
 {
 #ifdef CONFIG_TRANSPARENT_HUGEPAGE
+	#ifdef CONFIG_PTP
+	VM_BUG_ON_PAGE(((struct pgtable_page *)(page->slab_cache))->pmd_huge_pte, page);
+	#else
 	VM_BUG_ON_PAGE(page->pmd_huge_pte, page);
+	#endif
 #endif
 	ptlock_free(page);
 }
 
+#ifdef CONFIG_PTP
+#define pmd_huge_pte(mm, pmd) (((struct pgtable_page *)(pmd_to_page(pmd)->slab_cache))->pmd_huge_pte)
+#else
 #define pmd_huge_pte(mm, pmd) (pmd_to_page(pmd)->pmd_huge_pte)
+#endif
 
 #else
 
diff --git a/include/linux/mm_types.h b/include/linux/mm_types.h
index d1c5946ad402..66dc282a8102 100644
--- a/include/linux/mm_types.h
+++ b/include/linux/mm_types.h
@@ -83,6 +83,30 @@ struct kvm;
 #define _struct_page_alignment
 #endif
 
+#ifdef CONFIG_PTP
+struct pgtable_page {	/* Page table pages */
+	union
+	{
+		struct list_head lru;
+		struct {
+			unsigned long _pt_pad_1;	/* compound_head */
+			pgtable_t pmd_huge_pte; /* protected by page->ptl */
+		};
+	};
+	unsigned long _pt_pad_2;	/* mapping */
+	union {
+		struct mm_struct *pt_mm; /* x86 pgds only */
+		atomic_t pt_frag_refcount; /* powerpc */
+	};
+	struct page *page;
+#if ALLOC_SPLIT_PTLOCKS
+	spinlock_t *ptl;
+#else
+	spinlock_t ptl;
+#endif
+};
+#endif
+
 struct page {
 	unsigned long flags;		/* Atomic flags, some possibly
 					 * updated asynchronously */
@@ -699,6 +723,10 @@ extern void tlb_gather_mmu(struct mmu_gather *tlb, struct mm_struct *mm,
 				unsigned long start, unsigned long end);
 extern void tlb_finish_mmu(struct mmu_gather *tlb,
 				unsigned long start, unsigned long end);
+#ifdef CONFIG_PTP
+extern void iee_tlb_finish_mmu(struct mmu_gather *tlb,
+				unsigned long start, unsigned long end);
+#endif
 
 static inline void init_tlb_flush_pending(struct mm_struct *mm)
 {
diff --git a/include/linux/module.h b/include/linux/module.h
index b2b2c742a397..9d23bc618e9d 100644
--- a/include/linux/module.h
+++ b/include/linux/module.h
@@ -568,6 +568,7 @@ struct module {
 	KABI_RESERVE(2)
 	KABI_RESERVE(3)
 	KABI_RESERVE(4)
+
 } ____cacheline_aligned __randomize_layout;
 #ifndef MODULE_ARCH_INIT
 #define MODULE_ARCH_INIT {}
diff --git a/include/linux/sched.h b/include/linux/sched.h
index fa83018137ce..dc7c8fc0d794 100644
--- a/include/linux/sched.h
+++ b/include/linux/sched.h
@@ -695,6 +695,28 @@ struct task_struct_resvd {
 #endif
 };
 
+#if defined(CONFIG_IEE) || defined(CONFIG_KOI)
+struct task_token {
+#ifdef CONFIG_IEE
+	pgd_t *pgd; /* Logical VA */
+	void *iee_stack; /* VA */
+	void *tmp_page;
+	bool valid;
+    void *kernel_stack; /* VA */
+#endif
+#ifdef CONFIG_KOI
+    void *koi_kernel_stack; /* VA */
+    void *koi_stack;    /* VA */
+    void *koi_stack_base; /* VA */
+    unsigned long   current_ttbr1;
+#endif
+#ifdef CONFIG_CREDP
+	struct cred* curr_cred;
+	struct cred* new_cred;
+#endif
+};
+#endif
+
 struct task_struct {
 #ifdef CONFIG_THREAD_INFO_IN_TASK
 	/*
@@ -713,6 +735,7 @@ struct task_struct {
 	randomized_struct_fields_start
 
 	void				*stack;
+
 	refcount_t			usage;
 	/* Per task flags (PF_*), defined further below: */
 	unsigned int			flags;
diff --git a/include/linux/sfi_bpf.h b/include/linux/sfi_bpf.h
new file mode 100644
index 000000000000..dd76c8ee2566
--- /dev/null
+++ b/include/linux/sfi_bpf.h
@@ -0,0 +1,89 @@
+#ifndef SFI_BPF_H
+#define SFI_BPF_H
+
+#include <linux/types.h>
+#include <linux/bpf.h>
+
+/* fbpf log */
+#define FBPF_LOG_ENABLE
+#define fbpf_log(fmt, ...) do_fbpf_log(__FUNCTION__, fmt, ##__VA_ARGS__)
+void do_fbpf_log(const char *func_name, const char *fmt, ...);
+
+/* fbpf used for output */
+extern const char *bpf_map_type_strings[];
+
+/* fbpf map vaddr to struct page* */
+struct page *kv_virt_to_page(const void *vaddr);
+
+/* fbpf dump insns of a BPF Program */
+void dump_insns(struct bpf_prog *prog, int start, int len, const char *prompt);
+
+/* fbpf maintain origin isnn's aux while patching insns */
+int find_origin_insn(struct bpf_insn *insnsi, int len, struct bpf_insn *tar_insn);
+
+struct bpf_prog *bpf_patch_insn_data(struct bpf_verifier_env *env, u32 off,
+					    const struct bpf_insn *patch, u32 len);
+
+/* fbpf aggregate */
+int bpf_sfi_aggregate_memory(struct bpf_verifier_env *env);
+
+/* fbpf patch to check ld/st insns */
+int bpf_sfi_check_ldst(struct bpf_verifier_env *env);
+
+/* fbpf patch to check helper's args */
+int bpf_sfi_check_helper_args(struct bpf_verifier_env *env);
+
+/* fbpf record percpu map used pages */
+struct bpf_used_page {
+	struct page *physic_page;
+	struct list_head list_head;
+	u64 shadow_page;
+};
+
+/* fbpf: relevant api for bpf_used_pages */
+int bpf_record_used_pages(u64 start_addr, u64 end_addr,
+	struct mutex *write_mutex, struct list_head *head);
+
+/* fbpf: htab's value addr is built-in element, use api to substitue */
+void substitute_hash_value_ptr(struct bpf_map *map);
+
+/* fbpf: check type for a reg in insn */
+enum bpf_sfi_check_type {
+	BPF_SFI_CHECK_LDST_AS_UNSAFE_PTR,
+	BPF_SFI_CHECK_LDST_AS_SAFE_PTR,
+	BPF_SFI_CHECK_LDST_AS_OFFSET,
+	BPF_SFI_CHECK_HELPER_AS_UNSAFE_PTR,
+	BPF_SFI_CHECK_HELPER_AS_SAFE_PTR,
+	BPF_SFI_CHECK_HELPER_AS_OFFSET,
+};
+
+/* fbpf: check state for a reg */
+enum bpf_sfi_check_state {
+	BPF_SFI_UNSAFE_PTR,
+	BPF_SFI_SAFE_PTR,
+	BPF_SFI_OFFSET,
+};
+
+// TODO: allocate and free this link list for each insn_aux_data
+/* fbpf: check unit (link list) for a insn */
+struct bpf_sfi_check_unit {
+	struct list_head list_head;
+	int reg_no;
+	enum bpf_sfi_check_type check_type;
+	bool reg_as_offset;
+	enum bpf_sfi_check_state proposed_state;
+};
+
+struct bpf_sfi_check_unit *bpf_sfi_get_check_list(
+	struct bpf_verifier_env *env, struct bpf_insn *insn, 
+	struct bpf_reg_state *regs);
+
+int bpf_sfi_tmp_check(struct bpf_verifier_env *env);
+
+int bpf_sfi_hook_kernel_fault(u64 addr);
+
+inline void *alloc_aligned_memory(u64 size);
+
+inline int map_physic_pages(struct page **pages, void *virt_addr, int page_cnt);
+
+#endif
\ No newline at end of file
diff --git a/include/linux/skbuff.h b/include/linux/skbuff.h
index 95f0a69225fc..407ccb5ba7bd 100644
--- a/include/linux/skbuff.h
+++ b/include/linux/skbuff.h
@@ -932,6 +932,10 @@ struct sk_buff {
 	KABI_RESERVE(3)
 	KABI_RESERVE(4)
 
+	#ifdef CONFIG_HIVE
+	bool sfi_bpf_mapped;
+	#endif
+
 	/* These elements must be at the end, see alloc_skb() for details.  */
 	sk_buff_data_t		tail;
 	sk_buff_data_t		end;
@@ -939,6 +943,9 @@ struct sk_buff {
 				*data;
 	unsigned int		truesize;
 	refcount_t		users;
+	#ifdef CONFIG_HIVE
+	unsigned char		*sfi_data, *sfi_data_meta, *sfi_data_end;
+	#endif
 
 #ifdef CONFIG_SKB_EXTENSIONS
 	/* only useable after checking ->active_extensions != 0 */
diff --git a/include/linux/stacktrace.h b/include/linux/stacktrace.h
index 52e59df0faf4..241276592268 100644
--- a/include/linux/stacktrace.h
+++ b/include/linux/stacktrace.h
@@ -21,6 +21,10 @@ unsigned int stack_trace_save_tsk(struct task_struct *task,
 unsigned int stack_trace_save_regs(struct pt_regs *regs, unsigned long *store,
 				   unsigned int size, unsigned int skipnr);
 unsigned int stack_trace_save_user(unsigned long *store, unsigned int size);
+#ifdef CONFIG_IEE
+unsigned int stack_trace_save_iee(unsigned long *store, unsigned int size,
+                             unsigned int skipnr);
+#endif
 unsigned int filter_irq_stacks(unsigned long *entries, unsigned int nr_entries);
 
 /* Internal interfaces. Do not use in generic code */
diff --git a/include/uapi/linux/bpf.h b/include/uapi/linux/bpf.h
index f4ebb476cf03..e51756876833 100644
--- a/include/uapi/linux/bpf.h
+++ b/include/uapi/linux/bpf.h
@@ -56,6 +56,7 @@ enum {
 	BPF_REG_8,
 	BPF_REG_9,
 	BPF_REG_10,
+	BPF_REG_11,
 	__MAX_BPF_REG,
 };
 
diff --git a/include/uapi/linux/bpf_common.h b/include/uapi/linux/bpf_common.h
index ee97668bdadb..bfe086a27905 100644
--- a/include/uapi/linux/bpf_common.h
+++ b/include/uapi/linux/bpf_common.h
@@ -26,6 +26,7 @@
 #define		BPF_MEM		0x60
 #define		BPF_LEN		0x80
 #define		BPF_MSH		0xa0
+#define     BPF_REG     0xe0
 
 /* alu/jmp fields */
 #define BPF_OP(code)    ((code) & 0xf0)
diff --git a/init/Kconfig b/init/Kconfig
index e552194efbea..245cbdd5643d 100644
--- a/init/Kconfig
+++ b/init/Kconfig
@@ -1899,6 +1899,18 @@ config BPF_SYSCALL
 	  Enable the bpf() system call that allows to manipulate eBPF
 	  programs and maps via file descriptors.
 
+config HIVE
+	bool "Reserved for eBPF security enhancement"
+	default n
+	depends on BPF_SYSCALL
+	depends on DEBUG_INFO_DWARF4
+	depends on DEBUG_INFO_BTF
+	select BPF_JIT_ALWAYS_ON
+	select NET_ACT_BPF
+	select BPFILTER
+	select NET_CLS_BPF
+	select NET_SCH_INGRESS
+
 config ARCH_WANT_DEFAULT_BPF_JIT
 	bool
 
diff --git a/init/main.c b/init/main.c
index 2b466bd04110..a400bccf3dad 100644
--- a/init/main.c
+++ b/init/main.c
@@ -100,6 +100,13 @@
 #include <linux/init_syscalls.h>
 #include <linux/randomize_kstack.h>
 
+#ifdef CONFIG_IEE
+#include <linux/iee-func.h>
+#include <asm/iee-si.h>
+#include <asm/pgtable_slab.h>
+#include <linux/stop_machine.h>
+#endif
+
 #include <asm/io.h>
 #include <asm/setup.h>
 #include <asm/sections.h>
@@ -110,6 +117,10 @@
 
 #include <kunit/test.h>
 
+#ifdef CONFIG_PTP
+extern void *bm_pte_addr;
+#endif
+
 static int kernel_init(void *);
 
 extern void init_IRQ(void);
@@ -931,6 +942,12 @@ asmlinkage __visible void __init __no_sanitize_address start_kernel(void)
 	sort_main_extable();
 	trap_init();
 	mm_init();
+	
+	#ifdef CONFIG_IEE
+	iee_stack_init();
+	iee_pgtable_init();
+	#endif
+	
 	poking_init();
 	ftrace_init();
 
@@ -1072,6 +1089,16 @@ asmlinkage __visible void __init __no_sanitize_address start_kernel(void)
 	sfi_init_late();
 	kcsan_init();
 
+	// Later IEE settings.
+	#ifdef CONFIG_IEE
+	iee_set_kernel_upage((unsigned long)__va(__pa_symbol(init_iee_stack_begin)), 0);
+	set_iee_page((unsigned long)init_token_page_vaddr, 2);
+	// Set the logical va of existing pgtable readonly.
+    #ifdef CONFIG_PTP
+	iee_mark_all_lm_pgtable_ro();
+    #endif
+	#endif
+
 	/* Do the rest non-__init'ed, we're now alive */
 	arch_call_rest_init();
 
@@ -1437,18 +1464,22 @@ void __weak free_initmem(void)
 	free_initmem_default(POISON_FREE_INITMEM);
 }
 
+
 static int __ref kernel_init(void *unused)
 {
 	int ret;
 
 	kernel_init_freeable();
+	#ifdef CONFIG_PTP
+	iee_set_logical_mem_ro((unsigned long)bm_pte_addr);
+	#endif
 	/* need to finish all async __init code before freeing the memory */
 	async_synchronize_full();
 	kprobe_free_init_mem();
 	ftrace_free_init_mem();
 	kgdb_free_init_mem();
 	free_initmem();
-	mark_readonly();
+	mark_readonly(); 
 
 	/*
 	 * Kernel mappings are now finalized - update the userspace page-table
@@ -1456,6 +1487,7 @@ static int __ref kernel_init(void *unused)
 	 */
 	pti_finalize();
 
+    
 	system_state = SYSTEM_RUNNING;
 	numa_default_policy();
 
diff --git a/kernel/bpf/Makefile b/kernel/bpf/Makefile
index c1b9f71ee6aa..aed91d8562f0 100644
--- a/kernel/bpf/Makefile
+++ b/kernel/bpf/Makefile
@@ -36,3 +36,4 @@ obj-$(CONFIG_BPF_SYSCALL) += bpf_struct_ops.o
 obj-${CONFIG_BPF_LSM} += bpf_lsm.o
 endif
 obj-$(CONFIG_BPF_PRELOAD) += preload/
+obj-$(CONFIG_HIVE) += sfi_bpf.o
diff --git a/kernel/bpf/arraymap.c b/kernel/bpf/arraymap.c
index b5b8b57dc212..183148d5d4b4 100644
--- a/kernel/bpf/arraymap.c
+++ b/kernel/bpf/arraymap.c
@@ -11,6 +11,9 @@
 #include <linux/perf_event.h>
 #include <uapi/linux/btf.h>
 #include <linux/rcupdate_trace.h>
+#ifdef CONFIG_HIVE
+#include <linux/sfi_bpf.h>
+#endif
 
 #include "map_in_map.h"
 
@@ -20,19 +23,90 @@
 
 static void bpf_array_free_percpu(struct bpf_array *array)
 {
-	int i;
+	#ifdef CONFIG_HIVE
+	if (unlikely(!array->map.is_aggregated)) {
+		int i;
+		for (i = 0; i < array->map.max_entries; i++) {
+			free_percpu(array->pptrs[i]);
+			cond_resched();
+		}
+	} else {
+		struct bpf_used_page *used_page_entry, *used_page_next;
+		struct list_head *used_pages_list_head = &array->map.used_pages->list_head;
 
+		free_percpu(array->pptrs[0]);
+ 		cond_resched();
+
+		list_for_each_entry_safe(used_page_entry, used_page_next, 
+			used_pages_list_head, list_head){
+			list_del(&used_page_entry->list_head);
+			kfree(used_page_entry);
+		}
+	}
+	#else
+	int i;
 	for (i = 0; i < array->map.max_entries; i++) {
 		free_percpu(array->pptrs[i]);
 		cond_resched();
 	}
+	#endif
 }
 
 static int bpf_array_alloc_percpu(struct bpf_array *array)
 {
 	void __percpu *ptr;
 	int i;
+	#ifdef CONFIG_HIVE
+	int page_cnt;
+	struct bpf_used_page *used_pages;
+	u64 start_address, end_address;
+	#endif
+
+	#ifdef CONFIG_HIVE
+	if (unlikely(!array->map.is_aggregated)) {
+		for (i = 0; i < array->map.max_entries; i++) {
+			ptr = __alloc_percpu_gfp(array->elem_size, 8,
+						GFP_USER | __GFP_NOWARN);
+			if (!ptr) {
+				bpf_array_free_percpu(array);
+				return -ENOMEM;
+			}
+			array->pptrs[i] = ptr;
+			cond_resched();
+		}
+	} else {
+		/* init used_pages of map */
+		used_pages = kzalloc(sizeof(*used_pages), GFP_KERNEL);
+		if (!used_pages)
+			return -ENOMEM;
+		INIT_LIST_HEAD(&used_pages->list_head);
+		mutex_init(&array->map.used_page_mutex);
+		array->map.used_pages = used_pages;
+		/* WARNING, align to PAGE_SIZE tends to alloc failed */
+		ptr = __alloc_percpu_gfp(array->elem_size * array->map.max_entries, 
+				PAGE_SIZE, GFP_USER | __GFP_NOWARN);
+ 		if (!ptr) {
+ 			bpf_array_free_percpu(array);
+			pr_err("alloc percpu failed");
+ 			return -ENOMEM;
+ 		}
+		for (i = 0; i < array->map.max_entries; i++) {
+			array->pptrs[i] = (void *)((u64) ptr + i * array->elem_size);
+			cond_resched();
+		}
 
+		/* record physic pages */
+		start_address = round_down((u64)ptr, PAGE_SIZE);
+		end_address = round_up((u64)ptr + array->map.max_entries * 
+			array->elem_size, PAGE_SIZE);
+		page_cnt = bpf_record_used_pages(start_address, end_address,
+			&array->map.used_page_mutex, &array->map.used_pages->list_head);
+		if (page_cnt >= 0)
+			array->map.used_page_cnt = page_cnt;
+		else
+			return page_cnt;
+	}
+	#else
 	for (i = 0; i < array->map.max_entries; i++) {
 		ptr = __alloc_percpu_gfp(array->elem_size, 8,
 					 GFP_USER | __GFP_NOWARN);
@@ -43,7 +117,8 @@ static int bpf_array_alloc_percpu(struct bpf_array *array)
 		array->pptrs[i] = ptr;
 		cond_resched();
 	}
-
+	#endif
+	
 	return 0;
 }
 
@@ -87,6 +162,18 @@ static struct bpf_map *array_map_alloc(union bpf_attr *attr)
 	u64 cost, array_size, mask64;
 	struct bpf_map_memory mem;
 	struct bpf_array *array;
+	#ifdef CONFIG_HIVE
+	bool is_aggregated;
+	#endif
+
+	#ifdef CONFIG_HIVE
+	/* bpf_sfi_on && map_need_aggregate => is_aggregated */
+	if (attr->map_type == BPF_MAP_TYPE_ARRAY ||
+		attr->map_type == BPF_MAP_TYPE_PERCPU_ARRAY)
+		is_aggregated = true;
+	else
+	 	is_aggregated = false;
+	#endif
 
 	elem_size = round_up(attr->value_size, 8);
 
@@ -113,17 +200,30 @@ static struct bpf_map *array_map_alloc(union bpf_attr *attr)
 
 	array_size = sizeof(*array);
 	if (percpu) {
+		#ifdef CONFIG_HIVE
+		array_size += PAGE_ALIGN((u64) max_entries * sizeof(void *));
+		#else
 		array_size += (u64) max_entries * sizeof(void *);
+		#endif
 	} else {
 		/* rely on vmalloc() to return page-aligned memory and
 		 * ensure array->value is exactly page-aligned
 		 */
+		#ifdef CONFIG_HIVE
+		if ((attr->map_flags & BPF_F_MMAPABLE) || is_aggregated) {
+			array_size = PAGE_ALIGN(array_size);
+			array_size += PAGE_ALIGN((u64) max_entries * elem_size);
+		} else {
+			array_size += (u64) max_entries * elem_size;
+		}
+		#else
 		if (attr->map_flags & BPF_F_MMAPABLE) {
 			array_size = PAGE_ALIGN(array_size);
 			array_size += PAGE_ALIGN((u64) max_entries * elem_size);
 		} else {
 			array_size += (u64) max_entries * elem_size;
 		}
+		#endif
 	}
 
 	/* make sure there is no u32 overflow later in round_up() */
@@ -136,6 +236,23 @@ static struct bpf_map *array_map_alloc(union bpf_attr *attr)
 		return ERR_PTR(ret);
 
 	/* allocate all map elements and zero-initialize them */
+	#ifdef CONFIG_HIVE
+	if ((attr->map_flags & BPF_F_MMAPABLE) || 
+		(is_aggregated && !percpu)) {
+		void *data;
+
+		/* kmalloc'ed memory can't be mmap'ed, use explicit vmalloc */
+		data = bpf_map_area_mmapable_alloc(array_size, numa_node);
+		if (!data) {
+			bpf_map_charge_finish(&mem);
+			return ERR_PTR(-ENOMEM);
+		}
+		array = data + PAGE_ALIGN(sizeof(struct bpf_array))
+			- offsetof(struct bpf_array, value);
+	} else {
+		array = bpf_map_area_alloc(array_size, numa_node);
+	}
+	#else
 	if (attr->map_flags & BPF_F_MMAPABLE) {
 		void *data;
 
@@ -150,12 +267,22 @@ static struct bpf_map *array_map_alloc(union bpf_attr *attr)
 	} else {
 		array = bpf_map_area_alloc(array_size, numa_node);
 	}
+	#endif
 	if (!array) {
 		bpf_map_charge_finish(&mem);
 		return ERR_PTR(-ENOMEM);
 	}
 	array->index_mask = index_mask;
 	array->map.bypass_spec_v1 = bypass_spec_v1;
+	#ifdef CONFIG_HIVE
+	array->map.is_aggregated = is_aggregated;
+	array->map.value = array->value;
+	
+	/* record map_page_cnt for aggregation */
+	if (!percpu && is_aggregated)
+		array->map.used_page_cnt = PAGE_ALIGN((u64) max_entries * elem_size) 
+			>> PAGE_SHIFT;
+	#endif
 
 	/* copy mandatory map attributes */
 	bpf_map_init_from_attr(&array->map, attr);
@@ -180,7 +307,18 @@ static void *array_map_lookup_elem(struct bpf_map *map, void *key)
 	if (unlikely(index >= array->map.max_entries))
 		return NULL;
 
+	
+	#ifdef CONFIG_HIVE
+	/* here array->shadow_data equals map->shadow_data */
+	if (map->is_aggregated && map->shadow_data)
+		return map->shadow_data + array->elem_size * 
+			(index & array->index_mask);
+	else {
+		return array->value + array->elem_size * (index & array->index_mask);
+	}
+	#else
 	return array->value + array->elem_size * (index & array->index_mask);
+	#endif
 }
 
 static int array_map_direct_value_addr(const struct bpf_map *map, u64 *imm,
@@ -193,7 +331,15 @@ static int array_map_direct_value_addr(const struct bpf_map *map, u64 *imm,
 	if (off >= map->value_size)
 		return -EINVAL;
 
+
+	#ifdef CONFIG_HIVE
+	if (map->is_aggregated && map->shadow_data)
+		*imm = (unsigned long)map->shadow_data;
+	else
+		*imm = (unsigned long)array->value;
+	#else
 	*imm = (unsigned long)array->value;
+	#endif
 	return 0;
 }
 
@@ -226,7 +372,22 @@ static int array_map_gen_lookup(struct bpf_map *map, struct bpf_insn *insn_buf)
 	if (map->map_flags & BPF_F_INNER_MAP)
 		return -EOPNOTSUPP;
 
+
+	#ifdef CONFIG_HIVE
+	if (map->is_aggregated && map->shadow_data) {
+		/* substitute array->value with map->shadow_data */
+		/* assume map is the first attribute of struct array,
+			so that array == array->map 
+			array=ffff8000844efe80, &array->map=ffff8000844efe80 */
+		// fbpf_log("array=%016llx, array->map=%016llx\n", array, &array->map);
+		*insn++ = BPF_LDX_MEM(BPF_DW, map_ptr, map_ptr, offsetof(struct bpf_map, shadow_data));
+	}
+	else
+		*insn++ = BPF_ALU64_IMM(BPF_ADD, map_ptr, 
+			offsetof(struct bpf_array, value));
+	#else
 	*insn++ = BPF_ALU64_IMM(BPF_ADD, map_ptr, offsetof(struct bpf_array, value));
+	#endif
 	*insn++ = BPF_LDX_MEM(BPF_W, ret, index, 0);
 	if (!map->bypass_spec_v1) {
 		*insn++ = BPF_JMP_IMM(BPF_JGE, ret, map->max_entries, 4);
@@ -246,6 +407,32 @@ static int array_map_gen_lookup(struct bpf_map *map, struct bpf_insn *insn_buf)
 	return insn - insn_buf;
 }
 
+
+#ifdef CONFIG_HIVE
+static void *__percpu_array_map_lookup_elem(struct bpf_array *array, u64 value_ptr)
+{
+	struct page *phy_page;
+	struct list_head *used_pages_head;
+	struct bpf_used_page *entry;
+	struct bpf_used_page *next;
+	u64 in_page_offset;
+	
+	in_page_offset = value_ptr - round_down(value_ptr, PAGE_SIZE);
+	phy_page = kv_virt_to_page((void *)value_ptr);
+	
+	used_pages_head = &array->map.used_pages->list_head;
+	list_for_each_entry_safe(entry, next, used_pages_head, list_head) {
+		if (entry->physic_page == phy_page) {
+			return (void *)entry->shadow_page + in_page_offset;
+		}
+	}
+
+	pr_err("fail to find shadow_data of percpu array %016llx\n", 
+			(u64)(&array->map));
+	return NULL;
+}
+#endif
+
 /* Called from eBPF program */
 static void *percpu_array_map_lookup_elem(struct bpf_map *map, void *key)
 {
@@ -255,7 +442,18 @@ static void *percpu_array_map_lookup_elem(struct bpf_map *map, void *key)
 	if (unlikely(index >= array->map.max_entries))
 		return NULL;
 
+	
+	#ifdef CONFIG_HIVE
+	if (!map->is_aggregated)
+		return this_cpu_ptr(array->pptrs[index & array->index_mask]);
+	else {
+		u64 value_ptr = (u64)this_cpu_ptr(
+							array->pptrs[index & array->index_mask]);
+		return __percpu_array_map_lookup_elem(array, value_ptr);
+	}
+	#else
 	return this_cpu_ptr(array->pptrs[index & array->index_mask]);
+	#endif
 }
 
 int bpf_percpu_array_copy(struct bpf_map *map, void *key, void *value)
@@ -398,8 +596,14 @@ static void array_map_free(struct bpf_map *map)
 	if (array->map.map_type == BPF_MAP_TYPE_PERCPU_ARRAY)
 		bpf_array_free_percpu(array);
 
+	
+	#ifdef CONFIG_HIVE
+	if ((array->map.map_flags & BPF_F_MMAPABLE) || array->map.is_aggregated)
+		bpf_map_area_free(array_map_vmalloc_addr(array));
+	#else
 	if (array->map.map_flags & BPF_F_MMAPABLE)
 		bpf_map_area_free(array_map_vmalloc_addr(array));
+	#endif
 	else
 		bpf_map_area_free(array);
 }
diff --git a/kernel/bpf/hashtab.c b/kernel/bpf/hashtab.c
index 72bc5f575254..1756d5032793 100644
--- a/kernel/bpf/hashtab.c
+++ b/kernel/bpf/hashtab.c
@@ -13,6 +13,9 @@
 #include "percpu_freelist.h"
 #include "bpf_lru_list.h"
 #include "map_in_map.h"
+#ifdef CONFIG_HIVE
+#include <linux/sfi_bpf.h>
+#endif
 
 #define HTAB_CREATE_FLAG_MASK						\
 	(BPF_F_NO_PREALLOC | BPF_F_NO_COMMON_LRU | BPF_F_NUMA_NODE |	\
@@ -192,6 +195,19 @@ static inline void __percpu *htab_elem_get_ptr(struct htab_elem *l, u32 key_size
 	return *(void __percpu **)(l->key + key_size);
 }
 
+#ifdef CONFIG_HIVE
+static inline void htab_normal_elem_set_ptr(struct htab_elem *l, u32 key_size,
+				     void *pptr)
+{
+	*(void **)(l->key + key_size) = pptr;
+}
+
+static inline void *htab_normal_elem_get_ptr(struct htab_elem *l, u32 key_size)
+{
+	return *(void **)(l->key + key_size);
+}
+#endif
+
 static void *fd_htab_map_get_ptr(const struct bpf_map *map, struct htab_elem *l)
 {
 	return *(void **)(l->key + roundup(map->key_size, 8));
@@ -209,6 +225,33 @@ static void htab_free_elems(struct bpf_htab *htab)
 	if (!htab_is_percpu(htab))
 		goto free_elems;
 
+	
+	#ifdef CONFIG_HIVE
+	if (unlikely(!htab->map.is_aggregated)) {
+		for (i = 0; i < htab->map.max_entries; i++) {
+			void __percpu *pptr;
+			pptr = htab_elem_get_ptr(get_htab_elem(htab, i),
+						htab->map.key_size);
+			free_percpu(pptr);
+			cond_resched();
+		}
+	} else {
+		void __percpu *pptr;
+		struct bpf_used_page *used_page_entry, *used_page_next;
+		struct list_head *used_pages_list_head = &htab->map.used_pages->list_head;
+
+		pptr = htab_elem_get_ptr(get_htab_elem(htab, 0), htab->map.key_size);
+ 		free_percpu(pptr);
+ 		cond_resched();
+
+		/* free used_pages list */
+		list_for_each_entry_safe(used_page_entry, used_page_next,
+			used_pages_list_head, list_head) {
+			list_del(&used_page_entry->list_head);
+			kfree(used_page_entry);
+		}
+	}
+	#else
 	for (i = 0; i < htab->map.max_entries; i++) {
 		void __percpu *pptr;
 
@@ -217,8 +260,14 @@ static void htab_free_elems(struct bpf_htab *htab)
 		free_percpu(pptr);
 		cond_resched();
 	}
+	#endif
 free_elems:
 	bpf_map_area_free(htab->elems);
+	#ifdef CONFIG_HIVE
+	if (htab->map.is_aggregated) {
+		bpf_map_area_free(htab->map.value);
+	}
+	#endif
 }
 
 /* The LRU list has a lock (lru_lock). Each htab bucket has a lock
@@ -251,6 +300,10 @@ static int prealloc_init(struct bpf_htab *htab)
 {
 	u32 num_entries = htab->map.max_entries;
 	int err = -ENOMEM, i;
+	#ifdef CONFIG_HIVE
+	void *data;
+	u64 value_size, alloc_size;	
+	#endif
 
 	if (!htab_is_percpu(htab) && !htab_is_lru(htab))
 		num_entries += num_possible_cpus();
@@ -263,6 +316,54 @@ static int prealloc_init(struct bpf_htab *htab)
 	if (!htab_is_percpu(htab))
 		goto skip_percpu_elems;
 
+
+	#ifdef CONFIG_HIVE
+	if (unlikely(!htab->map.is_aggregated)) {
+		for (i = 0; i < num_entries; i++) {
+			u32 size = round_up(htab->map.value_size, 8);
+			void __percpu *pptr;
+
+			pptr = __alloc_percpu_gfp(size, 8, GFP_USER | __GFP_NOWARN);
+			if (!pptr)
+				goto free_elems;
+			htab_elem_set_ptr(get_htab_elem(htab, i), htab->map.key_size,
+					pptr);
+			cond_resched();
+		}
+	} else {
+		u32 size = round_up(htab->map.value_size, 8);
+ 		void __percpu *pptr;
+		struct bpf_used_page *used_pages;
+		u64 start_address, end_address;
+		u64 page_cnt;
+
+		pptr = __alloc_percpu_gfp(size * num_entries, PAGE_SIZE,
+			GFP_USER | __GFP_NOWARN);
+		if (!pptr)
+ 			goto free_elems;
+		for (i = 0; i < num_entries; i++)
+			htab_elem_set_ptr(get_htab_elem(htab, i), htab->map.key_size, 
+				pptr + size * i);
+		cond_resched();
+
+		/* fBPF init user_pages */
+		used_pages = kzalloc(sizeof(*used_pages), GFP_KERNEL);
+		htab->map.used_pages = used_pages;
+		if (!used_pages)
+			return -ENOMEM;
+		INIT_LIST_HEAD(&used_pages->list_head);
+		mutex_init(&htab->map.used_page_mutex);
+
+		/* fBPF record percpu physic pages */
+		start_address = round_down((u64)pptr, PAGE_SIZE);
+		end_address = round_up((u64)pptr + htab->map.max_entries * size, PAGE_SIZE);
+		page_cnt = bpf_record_used_pages(start_address, end_address, 
+			&htab->map.used_page_mutex, &htab->map.used_pages->list_head);
+		if (page_cnt < 0)
+			goto free_elems;
+		htab->map.used_page_cnt = page_cnt;
+ 	}
+	#else
 	for (i = 0; i < num_entries; i++) {
 		u32 size = round_up(htab->map.value_size, 8);
 		void __percpu *pptr;
@@ -274,8 +375,27 @@ static int prealloc_init(struct bpf_htab *htab)
 				  pptr);
 		cond_resched();
 	}
+	#endif
 
 skip_percpu_elems:
+	#ifdef CONFIG_HIVE
+	if (htab_is_percpu(htab))
+		goto skip_elems;
+
+	value_size = round_up(htab->map.value_size, 8);
+	alloc_size = PAGE_ALIGN(value_size * num_entries);
+	data = bpf_map_area_alloc(alloc_size, htab->map.numa_node);
+	if (!data)
+		goto free_elems;
+	htab->map.value = data;
+	htab->map.used_page_cnt = alloc_size >> PAGE_SHIFT;
+	for (i = 0; i < num_entries; i++)
+		htab_normal_elem_set_ptr(get_htab_elem(htab, i), round_up(htab->map.key_size, 8),
+			data + value_size * i);
+
+skip_elems:
+	#endif
+
 	if (htab_is_lru(htab))
 		err = bpf_lru_init(&htab->lru,
 				   htab->map.map_flags & BPF_F_NO_COMMON_LRU,
@@ -305,6 +425,29 @@ static int prealloc_init(struct bpf_htab *htab)
 	return err;
 }
 
+#ifdef CONFIG_HIVE
+void substitute_hash_value_ptr(struct bpf_map *map)
+{
+	struct bpf_htab *htab = container_of(map, struct bpf_htab, map);
+	int i;
+	u32 value_size = round_up(map->value_size, 8);
+	int num_entries = map->max_entries;
+
+	if (!htab_is_percpu(htab) && !htab_is_lru(htab))
+		num_entries += num_possible_cpus();
+
+	for (i = 0; i < num_entries; i++) {
+		htab_normal_elem_set_ptr(get_htab_elem(htab, i),
+			round_up(htab->map.key_size, 8),
+			map->shadow_data + value_size * i);
+	}
+
+	pr_info("substitute htab %d data from %016llx to %016llx-%016llx\n",
+		map->id, (u64)htab->map.value, (u64)map->shadow_data,
+		(u64)map->shadow_data + value_size * num_entries);
+}
+#endif
+
 static void prealloc_destroy(struct bpf_htab *htab)
 {
 	htab_free_elems(htab);
@@ -430,6 +573,17 @@ static struct bpf_map *htab_map_alloc(union bpf_attr *attr)
 		return ERR_PTR(-ENOMEM);
 
 	bpf_map_init_from_attr(&htab->map, attr);
+	#ifdef CONFIG_HIVE
+	if (htab->map.map_type == BPF_MAP_TYPE_HASH ||
+		htab->map.map_type == BPF_MAP_TYPE_PERCPU_HASH ||
+		htab->map.map_type == BPF_MAP_TYPE_LRU_HASH ||
+		htab->map.map_type == BPF_MAP_TYPE_LRU_PERCPU_HASH) {
+		htab->map.is_aggregated = true;
+		htab->map.map_flags &= ~BPF_F_NO_PREALLOC;
+		pr_warn("BPF_F_NO_PREALLOC flag is deprecated\n");
+		prealloc = true;
+	}
+	#endif
 
 	if (percpu_lru) {
 		/* ensure each CPU's lru list has >=1 elements.
@@ -452,12 +606,22 @@ static struct bpf_map *htab_map_alloc(union bpf_attr *attr)
 
 	htab->n_buckets = roundup_pow_of_two(htab->map.max_entries);
 
+	#ifdef CONFIG_HIVE
+	/* elem size = htab_elem + key + value */
+	htab->elem_size = sizeof(struct htab_elem) +
+ 			  round_up(htab->map.key_size, 8);
+	if (percpu || htab->map.is_aggregated)
+		htab->elem_size += sizeof(void *);
+ 	else
+ 		htab->elem_size += round_up(htab->map.value_size, 8);
+	#else
 	htab->elem_size = sizeof(struct htab_elem) +
 			  round_up(htab->map.key_size, 8);
 	if (percpu)
 		htab->elem_size += sizeof(void *);
 	else
 		htab->elem_size += round_up(htab->map.value_size, 8);
+	#endif
 
 	/* check for u32 overflow */
 	if (htab->n_buckets > U32_MAX / sizeof(struct bucket))
@@ -599,8 +763,17 @@ static void *htab_map_lookup_elem(struct bpf_map *map, void *key)
 {
 	struct htab_elem *l = __htab_map_lookup_elem(map, key);
 
+	#ifdef CONFIG_HIVE
+	if (l) {
+		if (map->is_aggregated)
+			return htab_normal_elem_get_ptr(l, round_up(map->key_size, 8));
+		else
+			return l->key + round_up(map->key_size, 8);
+	}
+	#else
 	if (l)
 		return l->key + round_up(map->key_size, 8);
+	#endif
 
 	return NULL;
 }
@@ -625,9 +798,21 @@ static int htab_map_gen_lookup(struct bpf_map *map, struct bpf_insn *insn_buf)
 		     (void *(*)(struct bpf_map *map, void *key))NULL));
 	*insn++ = BPF_EMIT_CALL(BPF_CAST_CALL(__htab_map_lookup_elem));
 	*insn++ = BPF_JMP_IMM(BPF_JEQ, ret, 0, 1);
+	#ifdef CONFIG_HIVE
+	if (map->is_aggregated)
+		*insn++ = BPF_LDX_MEM(BPF_DW, ret, ret,
+ 				offsetof(struct htab_elem, key) +
+ 				round_up(map->key_size, 8));
+	else {
+		*insn++ = BPF_ALU64_IMM(BPF_ADD, ret, 
+				offsetof(struct htab_elem, key) +
+				roundup(map->key_size, 8));
+	}
+	#else
 	*insn++ = BPF_ALU64_IMM(BPF_ADD, ret,
 				offsetof(struct htab_elem, key) +
 				round_up(map->key_size, 8));
+	#endif
 	return insn - insn_buf;
 }
 
@@ -639,7 +824,14 @@ static __always_inline void *__htab_lru_map_lookup_elem(struct bpf_map *map,
 	if (l) {
 		if (mark)
 			bpf_lru_node_set_ref(&l->lru_node);
+		#ifdef CONFIG_HIVE
+		if (map->is_aggregated)
+			return htab_normal_elem_get_ptr(l, round_up(map->key_size, 8));
+		else
+			return l->key + round_up(map->key_size, 8);
+		#else
 		return l->key + round_up(map->key_size, 8);
+		#endif
 	}
 
 	return NULL;
@@ -674,9 +866,20 @@ static int htab_lru_map_gen_lookup(struct bpf_map *map,
 			     offsetof(struct htab_elem, lru_node) +
 			     offsetof(struct bpf_lru_node, ref),
 			     1);
+	#ifdef CONFIG_HIVE
+	if (map->is_aggregated)
+		*insn++ = BPF_LDX_MEM(BPF_DW, ret, ret,
+				offsetof(struct htab_elem, key) +
+				round_up(map->key_size, 8));
+	else
+		*insn++ = BPF_ALU64_IMM(BPF_ADD, ret,
+ 				offsetof(struct htab_elem, key) +
+ 				round_up(map->key_size, 8));
+	#else
 	*insn++ = BPF_ALU64_IMM(BPF_ADD, ret,
 				offsetof(struct htab_elem, key) +
 				round_up(map->key_size, 8));
+	#endif
 	return insn - insn_buf;
 }
 
@@ -862,7 +1065,11 @@ static struct htab_elem *alloc_htab_elem(struct bpf_htab *htab, void *key,
 					 bool percpu, bool onallcpus,
 					 struct htab_elem *old_elem)
 {
+	#ifdef CONFIG_HIVE
+	u32 size = round_up(htab->map.value_size, 8);
+	#else
 	u32 size = htab->map.value_size;
+	#endif
 	bool prealloc = htab_is_prealloc(htab);
 	struct htab_elem *l_new, **pl_new;
 	void __percpu *pptr;
@@ -927,11 +1134,30 @@ static struct htab_elem *alloc_htab_elem(struct bpf_htab *htab, void *key,
 			htab_elem_set_ptr(l_new, key_size, pptr);
 	} else if (fd_htab_map_needs_adjust(htab)) {
 		size = round_up(size, 8);
+		#ifdef CONFIG_HIVE
+		if (htab->map.is_aggregated) {
+			memcpy(htab_normal_elem_get_ptr(l_new, round_up(key_size, 8)),
+				value, size);
+		} else
+			memcpy(l_new->key + round_up(key_size, 8), value, size);
+		#else
 		memcpy(l_new->key + round_up(key_size, 8), value, size);
+		#endif
 	} else {
+		#ifdef CONFIG_HIVE
+		if (htab->map.is_aggregated)
+			copy_map_value(&htab->map,
+			       htab_normal_elem_get_ptr(l_new, round_up(key_size, 8)),
+			       value);
+		else
+			copy_map_value(&htab->map,
+ 			       l_new->key + round_up(key_size, 8),
+ 			       value);
+		#else
 		copy_map_value(&htab->map,
 			       l_new->key + round_up(key_size, 8),
 			       value);
+		#endif
 	}
 
 	l_new->hash = hash;
@@ -991,9 +1217,20 @@ static int htab_map_update_elem(struct bpf_map *map, void *key, void *value,
 			return ret;
 		if (l_old) {
 			/* grab the element lock and update value in place */
+			#ifdef CONFIG_HIVE
+			if (map->is_aggregated)
+				copy_map_value_locked(map,
+					htab_normal_elem_get_ptr(l_old, round_up(key_size, 8)),
+					value, false);
+			else
+				copy_map_value_locked(map,
+					l_old->key + round_up(key_size, 8),
+					value, false);
+			#else
 			copy_map_value_locked(map,
 					      l_old->key + round_up(key_size, 8),
 					      value, false);
+			#endif
 			return 0;
 		}
 		/* fall through, grab the bucket lock and lookup again.
@@ -1017,9 +1254,20 @@ static int htab_map_update_elem(struct bpf_map *map, void *key, void *value,
 		 * grab the element lock in addition to the bucket lock
 		 * and update element in place
 		 */
+		#ifdef CONFIG_HIVE
+		if (map->is_aggregated)
+			copy_map_value_locked(map,
+				htab_normal_elem_get_ptr(l_old, round_up(key_size, 8)),
+				value, false);
+		else
+			copy_map_value_locked(map,
+				l_old->key + round_up(key_size, 8),
+				value, false);
+		#else
 		copy_map_value_locked(map,
 				      l_old->key + round_up(key_size, 8),
 				      value, false);
+		#endif
 		ret = 0;
 		goto err;
 	}
@@ -1079,7 +1327,14 @@ static int htab_lru_map_update_elem(struct bpf_map *map, void *key, void *value,
 	l_new = prealloc_lru_pop(htab, key, hash);
 	if (!l_new)
 		return -ENOMEM;
+	#ifdef CONFIG_HIVE
+	if (map->is_aggregated)
+		memcpy(htab_normal_elem_get_ptr(l_new, round_up(map->key_size, 8)), value, map->value_size);
+	else
+		memcpy(l_new->key + round_up(map->key_size, 8), value, map->value_size);
+	#else
 	memcpy(l_new->key + round_up(map->key_size, 8), value, map->value_size);
+	#endif
 
 	flags = htab_lock_bucket(htab, b);
 
@@ -1870,13 +2125,47 @@ const struct bpf_map_ops htab_lru_map_ops = {
 	.iter_seq_info = &iter_seq_info,
 };
 
+#ifdef CONFIG_HIVE
+static void *percpu_htab_aggregated_addr(struct bpf_htab *htab, const void *value_ptr1)
+{
+	struct page *phy_ptr;
+	struct list_head *used_pages_head;
+	struct bpf_used_page *entry;
+	struct bpf_used_page *next;
+	u64 in_page_offset;
+
+	phy_ptr = kv_virt_to_page(value_ptr1);
+	used_pages_head = &htab->map.used_pages->list_head;
+	in_page_offset = (u64)value_ptr1 - round_down((u64)value_ptr1, PAGE_SIZE);
+
+	list_for_each_entry_safe(entry, next, used_pages_head, list_head) {
+		if ((u64)entry->physic_page == (u64)phy_ptr) {
+			return (void *)entry->shadow_page + in_page_offset;
+		}
+	}
+
+	return 0;
+}
+#endif
+
 /* Called from eBPF program */
 static void *htab_percpu_map_lookup_elem(struct bpf_map *map, void *key)
 {
 	struct htab_elem *l = __htab_map_lookup_elem(map, key);
 
+	#ifdef CONFIG_HIVE
+	if (l) {
+		if (map->is_aggregated && map->shadow_data) {
+			struct bpf_htab *htab = container_of(map, struct bpf_htab, map);
+			void *value_ptr = this_cpu_ptr(htab_elem_get_ptr(l, map->key_size));
+			return percpu_htab_aggregated_addr(htab, value_ptr);
+		} else
+			return this_cpu_ptr(htab_elem_get_ptr(l, map->key_size));
+	}
+	#else
 	if (l)
 		return this_cpu_ptr(htab_elem_get_ptr(l, map->key_size));
+	#endif
 	else
 		return NULL;
 }
@@ -1887,7 +2176,16 @@ static void *htab_lru_percpu_map_lookup_elem(struct bpf_map *map, void *key)
 
 	if (l) {
 		bpf_lru_node_set_ref(&l->lru_node);
+		#ifdef CONFIG_HIVE
+		if (map->is_aggregated && map->shadow_data) {
+			struct bpf_htab *htab = container_of(map, struct bpf_htab, map);
+			void *value_ptr = this_cpu_ptr(htab_elem_get_ptr(l, map->key_size));
+			return percpu_htab_aggregated_addr(htab, value_ptr);
+		} else
+			return this_cpu_ptr(htab_elem_get_ptr(l, map->key_size));
+		#else
 		return this_cpu_ptr(htab_elem_get_ptr(l, map->key_size));
+		#endif
 	}
 
 	return NULL;
diff --git a/kernel/bpf/sfi_bpf.c b/kernel/bpf/sfi_bpf.c
new file mode 100644
index 000000000000..db48c42d3936
--- /dev/null
+++ b/kernel/bpf/sfi_bpf.c
@@ -0,0 +1,1430 @@
+#include <linux/bpf.h>
+#include <linux/bpf_verifier.h>
+#include "disasm.h"
+#ifdef CONFIG_HIVE
+#include <linux/sfi_bpf.h>
+#endif
+
+const enum bpf_map_type can_lookup_map_types[] = {
+	BPF_MAP_TYPE_ARRAY,
+	BPF_MAP_TYPE_PERCPU_ARRAY,
+	BPF_MAP_TYPE_HASH,
+	BPF_MAP_TYPE_LRU_HASH,
+	BPF_MAP_TYPE_PERCPU_HASH,
+	BPF_MAP_TYPE_LRU_PERCPU_HASH,
+	BPF_MAP_TYPE_CPUMAP,
+	BPF_MAP_TYPE_CGROUP_STORAGE,
+	BPF_MAP_TYPE_PERCPU_CGROUP_STORAGE,
+	BPF_MAP_TYPE_QUEUE,
+	BPF_MAP_TYPE_STACK,
+	BPF_MAP_TYPE_SK_STORAGE,
+	BPF_MAP_TYPE_INODE_STORAGE,
+	BPF_MAP_TYPE_REUSEPORT_SOCKARRAY,
+	BPF_MAP_TYPE_LPM_TRIE,
+	BPF_MAP_TYPE_SOCKMAP,
+	BPF_MAP_TYPE_SOCKHASH,
+};
+
+DEFINE_MUTEX(bpf_sfi_lock);
+
+void do_fbpf_log(const char *func_name, const char *fmt, ...)
+{
+	#ifdef FBPF_LOG_ENABLE
+    va_list args;
+    char buffer[256];
+
+    va_start(args, fmt);
+    vsnprintf(buffer, sizeof(buffer), fmt, args);
+    va_end(args);
+
+    pr_info("<%s> %s", func_name, buffer);
+	#endif
+}
+
+const char *bpf_map_type_strings[] = {
+	"BPF_MAP_TYPE_UNSPEC",
+	"BPF_MAP_TYPE_HASH",
+	"BPF_MAP_TYPE_ARRAY",
+	"BPF_MAP_TYPE_PROG_ARRAY",
+	"BPF_MAP_TYPE_PERF_EVENT_ARRAY",
+	"BPF_MAP_TYPE_PERCPU_HASH",
+	"BPF_MAP_TYPE_PERCPU_ARRAY",
+	"BPF_MAP_TYPE_STACK_TRACE",
+	"BPF_MAP_TYPE_CGROUP_ARRAY",
+	"BPF_MAP_TYPE_LRU_HASH",
+	"BPF_MAP_TYPE_LRU_PERCPU_HASH",
+	"BPF_MAP_TYPE_LPM_TRIE",
+	"BPF_MAP_TYPE_ARRAY_OF_MAPS",
+	"BPF_MAP_TYPE_HASH_OF_MAPS",
+	"BPF_MAP_TYPE_DEVMAP",
+	"BPF_MAP_TYPE_SOCKMAP",
+	"BPF_MAP_TYPE_CPUMAP",
+	"BPF_MAP_TYPE_XSKMAP",
+	"BPF_MAP_TYPE_SOCKHASH",
+	"BPF_MAP_TYPE_CGROUP_STORAGE",
+	"BPF_MAP_TYPE_REUSEPORT_SOCKARRAY",
+	"BPF_MAP_TYPE_PERCPU_CGROUP_STORAGE",
+	"BPF_MAP_TYPE_QUEUE",
+	"BPF_MAP_TYPE_STACK",
+	"BPF_MAP_TYPE_SK_STORAGE",
+	"BPF_MAP_TYPE_DEVMAP_HASH",
+	"BPF_MAP_TYPE_STRUCT_OPS",
+	"BPF_MAP_TYPE_RINGBUF",
+	"BPF_MAP_TYPE_INODE_STORAGE",
+};
+
+struct page *kv_virt_to_page(const void *vaddr)
+{
+	if (is_vmalloc_addr(vaddr))
+		return vmalloc_to_page(vaddr);
+	else
+	 	return virt_to_page(vaddr);
+}
+
+static bool map_can_lookup(struct bpf_map *map)
+{
+	int i;
+	enum bpf_map_type type = map->map_type;
+
+	for (i = 0; i < ARRAY_SIZE(can_lookup_map_types); i++)
+		if (type == can_lookup_map_types[i])
+			return true;
+
+	return false;
+}
+
+static int get_env_map_cnt(struct bpf_verifier_env *env)
+{
+	int i;
+	struct bpf_map *map;
+	int page_cnt = 0;
+
+	// calculate maps page count
+	for (i = 0; i < env->used_map_cnt; i++) {
+		map = env->used_maps[i];
+		if (map->is_aggregated && map->used_page_cnt) {
+			page_cnt += map->used_page_cnt;
+			fbpf_log("map %d %s page_cnt = %d\n", map->id, 
+				bpf_map_type_strings[map->map_type], map->used_page_cnt);
+		} else if (map_can_lookup(map)) {
+			pr_err("unsupport map_type %s\n", bpf_map_type_strings[map->map_type]);
+            return -EPERM;
+		}
+	}
+
+	return page_cnt;
+}
+
+static int count_percpu_pages(struct bpf_map *map, struct page **pages, int *page_index)
+{
+	struct list_head *used_pages_head = NULL;
+	struct bpf_used_page *entry;
+	struct bpf_used_page *next;
+
+	used_pages_head = &map->used_pages->list_head;
+
+	/* should not list_del and free here, later other progs may reuse this map */
+	list_for_each_entry_safe(entry, next, used_pages_head, list_head) {
+		// printk("count page %016llx\n", entry->physic_page);
+		pages[*page_index] = entry->physic_page;
+		entry->shadow_page = *page_index;
+		if (!pages[*page_index]) {
+			pr_err("illegal address=%016llx\n", (u64)pages[*page_index]);
+			return -EFAULT;
+		}
+		(*page_index)++;
+	}
+
+	return 0;
+}
+
+static int count_all_pages(struct bpf_verifier_env *env, struct page **pages, int *page_index)
+{
+	struct bpf_map *map;
+	int i, j;
+	u64 start_addr;
+	int err;
+	int page_index_before;
+
+	/* 1. coutn pages in low guard region */
+	start_addr = PAGE_ALIGN((u64)env->prog->low_guard_region_addr);
+	for (i = 0; i < env->prog->guard_region_page_cnt / 2; i++) {
+		pages[*page_index] = kv_virt_to_page((void *)start_addr);
+		if (!pages[*page_index]) {
+			pr_err("ERROR: unable to find_vm_area for stack[%d]\n", *page_index);
+			return -ENOENT;
+		}
+
+        pr_info("page %d: va = %llx, page = %llx\n", i, start_addr, (u64)pages[*page_index]);
+
+		start_addr += PAGE_SIZE;
+		(*page_index)++;
+	}
+
+	/* 2. count pages in map's data area */
+	for (i = 0; i < env->used_map_cnt; i++) {
+		page_index_before = *page_index;
+		map = env->used_maps[i];
+
+		if (!map->is_aggregated)
+			continue;
+
+		if (map->map_type == BPF_MAP_TYPE_ARRAY ||
+			map->map_type == BPF_MAP_TYPE_CGROUP_ARRAY) {
+			start_addr = (u64)map->value;
+		} else if (map->map_type == BPF_MAP_TYPE_HASH ||
+				   map->map_type == BPF_MAP_TYPE_LRU_HASH) {
+			start_addr = (u64)map->value;
+		} else if (map->map_type == BPF_MAP_TYPE_PERCPU_ARRAY ||
+			   map->map_type == BPF_MAP_TYPE_PERCPU_HASH ||
+			   map->map_type == BPF_MAP_TYPE_LRU_PERCPU_HASH) {
+			err = count_percpu_pages(map, pages, page_index);
+			if (err)
+				return err;
+			goto hook_end;
+		} else if (map->map_type == BPF_MAP_TYPE_PROG_ARRAY) {
+			pr_err("WARNING: ignore map %s\n", bpf_map_type_strings[map->map_type]);
+			goto hook_end;
+		} else {
+			pr_err("ERROR: miss map %s in count_all_pages()\n",
+				bpf_map_type_strings[map->map_type]);
+			return -ENOENT;
+		}
+
+		/* assert start_addr is page_aligned */
+		if (unlikely(!PAGE_ALIGNED(start_addr))) {
+			pr_err("ERROR: fbpf self, map_data should be PAGE_ALIGNED\n");
+			pr_err("map %s, addr=%016llx",
+				bpf_map_type_strings[map->map_type], (u64)map);
+			return -EFAULT;
+		}
+
+		/* for normal map with base addr */
+		for (j = 0; j < map->used_page_cnt; j++) {
+			pages[*page_index] = kv_virt_to_page((void *)start_addr);
+			if (!pages[*page_index]) {
+				pr_err("ERROR: unable to find_vm_area for pages[%d], %llx\n", *page_index,
+				      start_addr);
+				return -ENOENT;
+			}
+
+			(*page_index)++;
+		}
+
+hook_end:
+		fbpf_log("hook aggregated area for map %d: %s, %016llx, \
+page_cnt: %d, should be: %d\n",
+		    map->id, bpf_map_type_strings[map->map_type], (u64)map,
+			*page_index - page_index_before, map->used_page_cnt);
+	}
+
+	/* 3. count pages in skb area */
+	start_addr = PAGE_ALIGN((u64)env->prog->shadow_skb_addr);
+	for (i = 0; i < env->prog->shadow_skb_page_cnt; i++) {
+		pages[*page_index] = kv_virt_to_page((void *)start_addr);
+		if (!pages[*page_index]) {
+			pr_err("ERROR: unable to find_vm_area for stack[%d]\n", *page_index);
+			return -ENOENT;
+		}
+
+		start_addr += PAGE_SIZE;
+		(*page_index)++;
+	}
+
+	/* 4. count pages in stack area */
+	start_addr = PAGE_ALIGN((u64)env->prog->shadow_stack_addr);
+	for (i = 0; i < env->prog->shadow_stack_page_cnt; i++) {
+		pages[*page_index] = kv_virt_to_page((void *)start_addr);
+		if (!pages[*page_index]) {
+			pr_err("ERROR: unable to find_vm_area for stack[%d]\n", *page_index);
+			return -ENOENT;
+		}
+
+		start_addr += PAGE_SIZE;
+		(*page_index)++;
+	}
+
+	/* 5. coutn pages in high guard region */
+	start_addr = PAGE_ALIGN((u64)env->prog->high_guard_region_addr);
+	for (i = 0; i < env->prog->guard_region_page_cnt / 2; i++) {
+		pages[*page_index] = kv_virt_to_page((void *)start_addr);
+		if (!pages[*page_index]) {
+			pr_err("ERROR: unable to find_vm_area for stack[%d]\n", *page_index);
+			return -ENOENT;
+		}
+
+		start_addr += PAGE_SIZE;
+		(*page_index)++;
+	}
+
+	return 0;
+}
+
+static void record_percpu_map_shadow_page(struct bpf_map *map)
+{
+	struct list_head *used_pages_head = NULL;
+	struct bpf_used_page *entry;
+	struct bpf_used_page *next;
+	void *shadow_base_addr = map->shadow_data;
+
+	used_pages_head = &map->used_pages->list_head;
+
+	/* fbpf should not list_del and free here,
+		later other progs may reuse this map.
+		instead, map_free will do this job */
+	list_for_each_entry_safe(entry, next, used_pages_head, list_head) {
+		entry->shadow_page = (u64)shadow_base_addr + PAGE_SIZE * 
+			entry->shadow_page; /* shadow_page is the index recorded in count_all_pages() */
+		if (unlikely((u64)entry->physic_page !=
+			(u64)vmalloc_to_page((void *)entry->shadow_page))) {
+			pr_err("ERROR: recorded shadow_page unequal actual shadow_page\n");
+		}
+	}
+}
+
+EXPORT_SYMBOL(init_mm);
+
+static inline pte_t *get_ptep(u64 addr)
+{
+	pgd_t *pgdp;
+    p4d_t *p4dp;
+    pud_t *pudp;
+    pmd_t *pmdp;
+    pte_t *ptep;
+
+	pgdp = pgd_offset(&init_mm, addr);
+	if (pgd_none(*pgdp) || pgd_bad(*pgdp))
+		return ERR_PTR(-ENOENT);
+	
+    p4dp = p4d_offset(pgdp, addr);
+	if (p4d_none(*p4dp) || p4d_bad(*p4dp))
+		return ERR_PTR(-ENOENT);
+	
+    pudp = pud_offset(p4dp, addr);
+	if (pud_none(*pudp) || pud_bad(*pudp))
+		return ERR_PTR(-ENOENT);
+	
+    pmdp = pmd_offset(pudp, addr);
+	if (pmd_none(*pmdp) || pmd_bad(*pmdp))
+		return ERR_PTR(-ENOENT);
+	
+    ptep = pte_offset_kernel(pmdp, addr);
+	if (!ptep)
+		return ERR_PTR(-ENOENT);
+
+	return ptep;
+}
+
+static inline int set_as_guard_page(unsigned long addr)
+{
+	pte_t pte, *ptep;
+	
+	ptep = get_ptep(addr);
+	if (IS_ERR(ptep))
+		return PTR_ERR(ptep);
+	
+	pte = __pte(pte_val(*ptep) & ~PTE_VALID);
+    set_pte(ptep, __pte((pte_val(pte) | PTE_BPF_SFI_GP)));
+
+	flush_tlb_kernel_range(addr, addr + PAGE_SIZE);
+	isb();
+
+	return 0;
+}
+
+inline void *alloc_aligned_memory(u64 size)
+{
+	// unsigned long order = get_order(size);
+    // void *ptr = (void *)__get_free_pages(GFP_KERNEL, order);
+
+    // if (!ptr) {
+    //     printk(KERN_ERR "Failed to allocate memory\n");
+    //     return ERR_PTR(ENOMEM);
+    // }
+
+    size_t align = size >> PAGE_SHIFT;
+    size_t total = size >> PAGE_SHIFT;
+    void *ptr, *aligned_ptr;
+
+    ptr = vmalloc((total + align - 1) * PAGE_SIZE);
+    if (!ptr) {
+        pr_err("vmalloc failed\n");
+        return ERR_PTR(ENOMEM);
+    }
+
+    aligned_ptr = (void *)ALIGN((unsigned long)ptr, align * PAGE_SIZE);
+
+    // check alignment
+    if ((unsigned long)aligned_ptr & (size - 1)) {
+        // free_pages((unsigned long)ptr, order);
+        vfree(ptr);
+        printk(KERN_ERR "Memory not properly aligned\n");
+        return ERR_PTR(ENOMEM);
+    }
+
+    return aligned_ptr;
+}
+
+inline int map_physic_pages(struct page **pages, void *virt_addr, int page_cnt)
+{
+	int i;
+    u64 origin_addr, cur_addr;
+    pte_t *ptep, *origin_ptep;
+
+	for (i = 0; i < page_cnt; i++) {
+        pr_info("mapping page %d\n", i);
+
+		// u64 origin_addr = page_to_pfn(pages[i]) << PAGE_SHIFT;
+        origin_addr = (u64)page_address(pages[i]);
+        pr_info("origin addr %llx\n", origin_addr);
+		origin_ptep = get_ptep(origin_addr);
+		if (IS_ERR(origin_ptep))
+			return PTR_ERR(origin_ptep);
+		
+		cur_addr = (u64)virt_addr + i * PAGE_SIZE;
+        pr_info("cur addr %llx\n", cur_addr);
+		ptep = get_ptep(cur_addr);
+		if (IS_ERR(ptep))
+			return PTR_ERR(ptep);
+		
+		#ifdef CONFIG_IEE
+        set_pte(ptep, *origin_ptep);
+        #else
+        *ptep = *origin_ptep;
+        #endif
+	}
+
+	return 0;
+}
+
+/**
+ * sfi_bpf space:
+ * guard page	8 pages
+ * map's data   0xffff80008457f000 - 0xffff80008457f000
+ * skb          0xffff80008457f000 - 0xffff80008457f000
+ * stack        0xffff80008457f000 - 0xffff800084580000
+ * guard page	8 pages
+ */
+int bpf_sfi_aggregate_memory(struct bpf_verifier_env *env)
+{
+	struct page **pages = NULL;
+	struct bpf_map *map;
+	u64 start_addr;
+	void *shadow_base_addr = NULL, *shadow_high_addr = NULL;
+	int i, page_index = 0;
+	int total_page_cnt, map_page_cnt, stack_page_cnt, skb_page_cnt, guard_page_cnt;
+	int err;
+	void *shadow_stack_addr, *shadow_skb_addr, *guard_region_addr;
+
+	/* calculate page_cnt */
+	env->prog->map_page_cnt = map_page_cnt = get_env_map_cnt(env);
+	if (map_page_cnt < 0) {
+		err = map_page_cnt;
+		goto ret;
+	}
+	stack_page_cnt = round_up(MAX_BPF_STACK, PAGE_SIZE) >> PAGE_SHIFT;
+	if (env->prog->type == BPF_PROG_TYPE_SCHED_CLS ||
+		env->prog->type == BPF_PROG_TYPE_SCHED_ACT ||
+		env->prog->type == BPF_PROG_TYPE_XDP ||
+		env->prog->type == BPF_PROG_TYPE_LWT_XMIT ||
+		env->prog->type == BPF_PROG_TYPE_SK_SKB ||
+		env->prog->type == BPF_PROG_TYPE_SK_MSG)
+		skb_page_cnt = 16;
+	else
+	 	skb_page_cnt = 0;
+	guard_page_cnt = 16;
+
+	/* roundup totoal page number to power of two for SFI consideration */
+	env->prog->shadow_skb_page_cnt = skb_page_cnt;
+	env->prog->guard_region_page_cnt = guard_page_cnt;
+	env->prog->total_page_cnt = total_page_cnt = roundup_pow_of_two(stack_page_cnt + map_page_cnt + skb_page_cnt + guard_page_cnt);
+	env->prog->shadow_stack_page_cnt = stack_page_cnt = total_page_cnt - map_page_cnt - skb_page_cnt - guard_page_cnt;
+
+	/* map map's value area to pages */
+	pages = kzalloc(sizeof(struct page *) * (total_page_cnt + guard_page_cnt), GFP_KERNEL | __GFP_NOWARN);
+	if (!pages) {
+		pr_err("ERROR: alloc tmp pages array failed\n");
+		err = -ENOMEM;
+		goto ret;
+	}
+
+	/* alloc tmp skb page to fill in pages */
+	shadow_skb_addr = kzalloc(skb_page_cnt * PAGE_SIZE, GFP_KERNEL);
+	if (!shadow_skb_addr) {
+		pr_err("alloc skb area failed\n");
+		err = -ENOMEM;
+		goto ret;
+	}
+	env->prog->shadow_skb_addr = shadow_skb_addr;
+
+	/* alloc shadow stack value area */
+	shadow_stack_addr = kzalloc(stack_page_cnt * PAGE_SIZE, GFP_KERNEL);
+	if (!shadow_stack_addr) {
+		pr_err("alloc stack area failed\n");
+		err = -ENOMEM;
+		goto ret;
+	}
+	env->prog->shadow_stack_addr = shadow_stack_addr;
+	
+	/* alloc guard region */
+	guard_region_addr = kzalloc(guard_page_cnt * PAGE_SIZE, GFP_KERNEL);
+	if (!guard_region_addr) {
+		pr_err("alloc guard region failed\n");
+		err = -ENOMEM;
+		goto ret;
+	}
+	env->prog->low_guard_region_addr = guard_region_addr;
+	env->prog->high_guard_region_addr = guard_region_addr + guard_page_cnt / 2 * PAGE_SIZE;
+
+	/* fill the array pages */
+	err = count_all_pages(env, pages, &page_index);
+	if (err)
+		goto ret;
+
+	/* check every page is counted */
+	fbpf_log("page index=%d, page cnt=%d (should equal)\n", page_index, total_page_cnt);
+	if (unlikely(page_index != total_page_cnt)) {
+		pr_err("ERROR: page_index != page_cnt\n");
+		err = -EFAULT;
+		goto ret;
+	}
+
+	/* remap memory area to virtually contiguous space */
+	// shadow_base_addr = vmap(pages, total_page_cnt, VM_MAP, PAGE_KERNEL);
+	shadow_base_addr = alloc_aligned_memory(total_page_cnt * PAGE_SIZE);
+    pr_info("virtual addr = %llx\n", (u64)shadow_base_addr);
+	shadow_high_addr = shadow_base_addr + total_page_cnt * PAGE_SIZE;
+	if (!shadow_base_addr) {
+		pr_err("unable to vmap map's value area and stack area\n");
+		err = -ENOMEM;
+		goto ret;
+	}
+	env->prog->shadow_region_addr = shadow_base_addr;
+	env->prog->shadow_top_addr = shadow_high_addr;
+
+	err = map_physic_pages(pages, shadow_base_addr, total_page_cnt);
+	if (err < 0) {
+		pr_err("remap failed, %d\n", err);
+		goto ret;
+	}
+
+	/* substitute with SFI address space addrs */
+	start_addr = (u64)shadow_base_addr;
+	
+	/* low guard region */
+	env->prog->low_guard_region_addr = (void *)start_addr;
+	start_addr += guard_page_cnt / 2 * PAGE_SIZE;
+
+	/* IMPORTANT: update shadow addr for maps */
+	env->prog->map_data_addr = (void *)start_addr;
+	for (i = 0; i < env->used_map_cnt; i++) {
+		map = env->used_maps[i];
+
+		if (!map->is_aggregated)
+			continue;
+
+		/* record addr mapping info */
+		map->shadow_data = (void *)start_addr;
+
+		if (map->map_type == BPF_MAP_TYPE_HASH ||
+			map->map_type == BPF_MAP_TYPE_LRU_HASH) {
+			substitute_hash_value_ptr(map);
+		} else if (map->map_type == BPF_MAP_TYPE_ARRAY ||
+				   map->map_type == BPF_MAP_TYPE_CGROUP_ARRAY) {
+			; // only need to record map->shadow_data
+		} else if (map->map_type == BPF_MAP_TYPE_PERCPU_ARRAY ||
+				   map->map_type == BPF_MAP_TYPE_PERCPU_HASH ||
+				   map->map_type == BPF_MAP_TYPE_LRU_PERCPU_HASH) {
+			record_percpu_map_shadow_page(map);
+		} else {
+			; // no need to record or substitute
+		}
+
+		start_addr += map->used_page_cnt * PAGE_SIZE;
+	}
+
+	/* the space between map's data and stack is for skb_buff */
+	env->prog->shadow_skb_addr = (void *)start_addr;
+	start_addr += skb_page_cnt * PAGE_SIZE;
+
+	/* stack */
+	/* NOTICE: stack's addr is high addr (sp), rather than low addr (fp) */
+	start_addr += stack_page_cnt * PAGE_SIZE;
+	env->prog->shadow_stack_addr = (void *)start_addr;
+
+	/* high guard region */
+	env->prog->high_guard_region_addr = (void *)start_addr;
+	start_addr += guard_page_cnt / 2 * PAGE_SIZE;
+
+	BUG_ON(unlikely(start_addr != (u64)(env->prog->shadow_top_addr)));
+
+	// set guard region and skb region as guard page
+	start_addr = (u64)env->prog->low_guard_region_addr;
+	for (i = 0; i < guard_page_cnt / 2; i++) {
+		err = set_as_guard_page(start_addr);
+		if (err < 0) {
+			pr_err("set as guard page failed, %d\n", err);
+			goto ret;
+		}
+		start_addr += PAGE_SIZE;
+	}
+	start_addr = (u64)env->prog->high_guard_region_addr;
+	for (i = 0; i < guard_page_cnt / 2; i++) {
+		err = set_as_guard_page(start_addr);
+		if (err < 0) {
+			pr_err("set as guard page failed, %d\n", err);
+			goto ret;
+		}
+		start_addr += PAGE_SIZE;
+	}
+	start_addr = (u64)env->prog->shadow_skb_addr;
+	for (i = 0; i < skb_page_cnt; i++) {
+		err = set_as_guard_page(start_addr);
+		if (err < 0) {
+			pr_err("set as guard page failed, %d\n", err);
+			goto ret;
+		}
+		start_addr += PAGE_SIZE;
+	}
+
+	// manually trigger page fault now
+	// pr_err("start probe now\n");
+	// *(u64 *)(env->prog->low_guard_region_addr + 16) = 1;
+	// pr_err("oops, back from page fault!\n");
+
+	fbpf_log("sfi_bpf space:\n");
+	fbpf_log("low guard region\t0x%016llx - 0x%016llx\n", 
+		env->prog->low_guard_region_addr, env->prog->low_guard_region_addr + guard_page_cnt / 2 * PAGE_SIZE);
+	fbpf_log("map's data\t\t0x%016llx - 0x%016llx\n", 
+		env->prog->map_data_addr, env->prog->map_data_addr + map_page_cnt * PAGE_SIZE);
+	fbpf_log("skb\t\t\t0x%016llx - 0x%016llx\n", 
+		env->prog->shadow_skb_addr, env->prog->shadow_skb_addr + skb_page_cnt * PAGE_SIZE);
+	fbpf_log("stack\t\t\t0x%016llx - 0x%016llx\n", 
+		env->prog->shadow_stack_addr - stack_page_cnt * PAGE_SIZE, env->prog->shadow_stack_addr);
+	fbpf_log("high guard region\t0x%016llx - 0x%016llx\n", 
+		env->prog->high_guard_region_addr, env->prog->high_guard_region_addr + guard_page_cnt / 2 * PAGE_SIZE);
+
+	fbpf_log("prog [%s] func_id = %d: 0x%016llx - 0x%016llx, size = 0x%llx\n",
+	       env->prog->aux->name, env->prog->aux->func_idx,
+		   (u64)env->prog->shadow_region_addr,
+		   (u64)env->prog->shadow_stack_addr,
+	       (u64)(total_page_cnt * PAGE_SIZE));
+
+ret:
+	if (pages)
+		kfree(pages);
+	return err;
+}
+
+__printf(2, 3) static void fake_verbose(void *private_data, const char *fmt, ...)
+{
+	va_list args;
+
+	va_start(args, fmt);
+	vprintk(fmt, args);
+	va_end(args);
+}
+
+void dump_insns(struct bpf_prog *prog, int start, int len, const char *prompt)
+{
+	#ifdef FBPF_LOG_ENABLE
+	int insn_cnt;
+	struct bpf_insn *insn;
+	int i;
+	struct bpf_insn_cbs cbs = {
+		.cb_print = fake_verbose,
+		.private_data = NULL,
+	};
+
+	if (unlikely(!prog)) {
+		fbpf_log("ERROR: prog is NULL\n");
+		return;
+	}
+
+	if (start + len > prog->len) {
+		fbpf_log("ERROR: print insn from %d to %d is out of bound\n", start, start + len - 1);
+		return;
+	}
+	insn_cnt = len;
+	insn = prog->insnsi + start;
+
+	if (prompt)
+		printk("[dump insns] --- %s\n", prompt);
+	for (i = 0; i < insn_cnt; i++) {
+		print_bpf_insn(&cbs, insn, false);
+		insn++;
+	}
+	#endif
+}
+
+int find_origin_insn(struct bpf_insn *insnsi, int len, struct bpf_insn *tar_insn)
+{
+	int i;
+	struct bpf_insn *cur_insn;
+
+	for (i = 0; i < len; i++) {
+		cur_insn = &insnsi[i];
+		if (memcmp(cur_insn, tar_insn, sizeof(struct bpf_insn)) == 0) {
+			return i;
+		}
+	}
+
+	return -1;
+}
+
+/**
+ * return:
+ * 	> 0: patch cnt
+ * 	= 0: no need to patch
+ * 	< 0: errno
+ */
+static inline int form_check_ldst_as_unsafe_ptr(struct bpf_insn *origin_insn, struct bpf_insn *patch, bool reg_as_offset, 
+	u64 sfi_region_size, int reg, int *origin_insn_no)
+{
+	int patch_len;
+	struct bpf_insn modified_origin_insn = *origin_insn;
+	u8 size = BPF_SIZE(origin_insn->code);
+	u8 class = BPF_CLASS(origin_insn->code);
+	
+	pr_info("reg_as_offset %d\n", reg_as_offset);
+		
+	/* lock *(u64 *)(r0 + 0) += 1 */
+	/* lock *(u64 *)(r0 + 8) += 1 */
+	if (!reg_as_offset) {
+		patch[0] = BPF_ALU64_IMM(BPF_AND, reg, sfi_region_size - 1);
+		patch[1] = BPF_ALU64_REG(BPF_OR, reg, BPF_REG_BASE);
+		patch[2] = *origin_insn;
+		
+		*origin_insn_no = 2;
+		patch_len = 3;
+	} else {
+		/* *(u64 *)(r0 + 0) = 0 */
+		if (origin_insn->off == 0) {
+			patch[0] = BPF_ALU64_IMM(BPF_AND, reg, sfi_region_size - 1);
+			modified_origin_insn.code = class | BPF_REG | size;
+			if (class == BPF_LD || class == BPF_LDX)
+				modified_origin_insn.src_reg = BPF_REG_BASE;
+			if (class == BPF_ST || class == BPF_STX)
+				modified_origin_insn.dst_reg = BPF_REG_BASE;
+			modified_origin_insn.off = reg;
+			patch[1] = modified_origin_insn;
+			
+			*origin_insn_no = 1;
+			patch_len = 2;
+		} 
+		/* *(u64 *)(r0 + 8) = 0 */
+		else {
+			patch[0] = BPF_ALU64_IMM(BPF_AND, reg, sfi_region_size - 1);
+			patch[1] = BPF_ALU64_REG(BPF_OR, reg, BPF_REG_BASE);
+			patch[2] = *origin_insn;
+
+			*origin_insn_no = 2;
+			patch_len = 3;
+		}
+	}
+
+	return patch_len;
+}
+
+/**
+ * return:
+ * 	> 0: patch cnt
+ * 	= 0: no need to patch
+ * 	< 0: errno
+ */
+static inline int form_check_ldst_as_offset(struct bpf_insn *origin_insn, struct bpf_insn *patch, bool reg_as_offset, 
+	u64 sfi_region_size, int reg, int *origin_insn_no)
+{
+	int patch_len;
+	struct bpf_insn modified_origin_insn = *origin_insn;
+	u8 size = BPF_SIZE(origin_insn->code);
+	u8 class = BPF_CLASS(origin_insn->code);
+		
+	if (!reg_as_offset) {
+		/* lock *(u64 *)(r0 + 0) += 1 */
+		/* lock *(u64 *)(r0 + 8) += 1 */
+		patch[0] = BPF_ALU64_REG(BPF_OR, reg, BPF_REG_BASE);
+		patch[1] = *origin_insn;
+		
+		*origin_insn_no = 1;
+		patch_len = 2;
+		
+	} else {
+		/* *(u64 *)(r0 + 0) = 0 */
+		if (origin_insn->off == 0) {
+			modified_origin_insn.code = class | BPF_REG | size;
+			if (class == BPF_LD || class == BPF_LDX)
+				modified_origin_insn.src_reg = BPF_REG_BASE;
+			if (class == BPF_ST || class == BPF_STX)
+				modified_origin_insn.dst_reg = BPF_REG_BASE;
+			modified_origin_insn.off = reg;
+			patch[0] = modified_origin_insn;
+			
+			*origin_insn_no = 0;
+			patch_len = 1;
+		} 
+		/* *(u64 *)(r0 + 8) = 0 */
+		else {
+			patch[0] = BPF_ALU64_REG(BPF_OR, reg, BPF_REG_BASE);
+			patch[1] = *origin_insn;
+
+			*origin_insn_no = 1;
+			patch_len = 2;
+		}
+	}
+
+	return patch_len;
+}
+
+/**
+ * form a patch according to the insn
+ * v3 means this is optimized twice
+ * @origin_insn: where the instrument point locates at
+ * @check_unit: the sfi check unit
+ * @patch_array: patch will be stored in this array if return code is 0
+ * @origin_insn_no: the index of origin insn
+ * @sfi_region_size: the size of sfi region
+ * return:
+ * 	< 0: errno
+ * 	>= 0: patch_cnt
+ */
+int form_sfi_check_patch_v3(struct bpf_insn *origin_insn, struct bpf_sfi_check_unit *check_unit,
+	struct bpf_insn *patch_array, int* origin_insn_no, u64 sfi_region_size)
+{
+	struct bpf_insn patch[16];
+	int patch_len = 0;
+	enum bpf_sfi_check_type type = check_unit->check_type;
+	int reg = check_unit->reg_no;
+    int i;
+
+	/** normal case,
+	 * 1. and with SFI_REGION_SIZE
+	 * 2. if not reg_as_offset
+	 * 		2.1 or with SFI_REGION_BASE
+	 * 		2.2 if has off, add off
+	 * 		2.3 origin insn
+	 * 		2.4 if has off, sub off
+	 * 3. if reg_as_offset
+	 * 		3.1 if has off, add off
+	 * 		3.2 replace BPF_LD/BPF_ST to BPF_LDR/BPF_STR
+	 * 		3.3 if has off, sub off
+	 */
+	if (type == BPF_SFI_CHECK_LDST_AS_UNSAFE_PTR) {
+		bool reg_as_offset = check_unit->reg_as_offset;
+		patch_len = form_check_ldst_as_unsafe_ptr(origin_insn, patch, 
+			reg_as_offset, sfi_region_size, reg, origin_insn_no);
+	}
+	/** second case
+	 * 1. no need to and again
+	 * 2. but need to process off
+	 * 3. and replace insn to BPF_LDR/BPF_STR
+	 */
+	else if (type == BPF_SFI_CHECK_LDST_AS_OFFSET) {
+		bool reg_as_offset = check_unit->reg_as_offset;
+		patch_len = form_check_ldst_as_offset(origin_insn, patch, 
+			reg_as_offset, sfi_region_size, reg, origin_insn_no);
+	}
+	/** after check helper, ptr is still ptr, but safe
+	 * 1. and with SFI_REGION_SIZE
+	 * 2. or with SFI_REGION_BASE
+	 */
+	else if (type == BPF_SFI_CHECK_HELPER_AS_UNSAFE_PTR) {
+		patch[0] = BPF_ALU64_IMM(BPF_AND, reg, sfi_region_size - 1);
+		patch[1] = BPF_ALU64_REG(BPF_OR, reg, BPF_REG_BASE);
+		patch[2] = *origin_insn;
+		
+		*origin_insn_no = 2;
+		patch_len = 3;
+	}
+	/** second case
+	 * 1. no need to and
+	 * 2. just or
+	 */
+	else if (type == BPF_SFI_CHECK_HELPER_AS_OFFSET) {
+		patch[0] = BPF_ALU64_REG(BPF_OR, reg, BPF_REG_BASE);
+		patch[1] = *origin_insn;
+		
+		*origin_insn_no = 1;
+		patch_len = 2;
+	}
+	/* no need to check again */
+	else if (type == BPF_SFI_CHECK_HELPER_AS_SAFE_PTR ||
+			 type == BPF_SFI_CHECK_LDST_AS_SAFE_PTR) {
+		*origin_insn_no = 0;
+		patch_len = 0;
+	}
+	else {
+		pr_err("unresolved case\n");
+		BUG_ON(1);
+	}
+
+	if (patch_len > sizeof(patch_array))
+		return -ENOMEM;
+
+	for (i = 0; i < patch_len; i++)
+		patch_array[i] = patch[i];
+	
+	return patch_len;
+}
+
+int bpf_sfi_check_ldst(struct bpf_verifier_env *env)
+{
+	struct bpf_prog *prog;
+	struct bpf_insn *insn;
+	int insn_cnt;
+	struct bpf_insn_aux_data *aux;
+	struct bpf_prog *new_prog;
+	int i, cnt, delta = 0;
+	u8 reg;
+	int origin_insn_no;
+	enum bpf_reg_type ptr_type;
+	struct bpf_sfi_check_unit *check_list, *origin_check_list;
+
+	if (!env) {
+		fbpf_log("env is NULL\n");
+		return -EFAULT;
+	}
+	prog = env->prog;
+	aux = env->insn_aux_data;
+
+	if (!prog) {
+		fbpf_log("prog is NULL\n");
+		return -EFAULT;
+	}
+	insn_cnt = prog->len;
+
+	insn = prog->insnsi;
+	if (!insn)
+		return 0;
+
+	/* use i + delta to traverse: insn, aux. */
+	for (i = 0; i < insn_cnt; i++) {
+		struct bpf_insn_aux_data origin_insn_aux;
+
+		insn = &prog->insnsi[i + delta];
+		aux = &env->insn_aux_data[i + delta];
+		check_list = env->insn_check_lists[i + delta];
+
+		if (!aux) {
+			dump_insns(prog, i, 1, "empty aux");
+			fbpf_log("aux is empty for insn %d", i);
+			return -EFAULT;
+		}
+		origin_insn_aux = *aux;
+		origin_check_list = env->insn_check_lists[i + delta];
+
+		/* check optimization */
+		if (check_list) {
+			struct bpf_sfi_check_unit *p;
+			// u64 offset_bound_mask = (roundup_pow_of_two(
+			// env->prog->total_page_cnt) << PAGE_SHIFT) - 1;
+			u64 sfi_region_size = env->prog->total_page_cnt << PAGE_SHIFT;
+            struct bpf_insn patch[16];
+
+			list_for_each_entry(p, &check_list->list_head, list_head) {
+				if (p->check_type != BPF_SFI_CHECK_LDST_AS_UNSAFE_PTR &&
+					p->check_type != BPF_SFI_CHECK_LDST_AS_SAFE_PTR &&
+					p->check_type != BPF_SFI_CHECK_LDST_AS_OFFSET)
+					continue;
+
+				reg = p->reg_no;
+				ptr_type = base_type(aux->ptr_type);
+
+				fbpf_log("%d: check ptr=%d, r%d", i, ptr_type, reg);
+				dump_insns(prog, i + delta, 1, "Ld/st insn to rewrite");
+
+				cnt = form_sfi_check_patch_v3(insn, p, patch, &origin_insn_no, 
+					sfi_region_size);
+
+				/* NOTICE: use cnt to decide whether to patch */
+				if (cnt == 0)
+					continue;
+
+				new_prog = bpf_patch_insn_data(env, i + delta, patch, cnt);
+				if (!new_prog) {
+					fbpf_log("patch failed\n");
+					return -ENOMEM;
+				}
+
+				dump_insns(new_prog, i + delta, cnt, "restore ldst");
+
+				env->insn_aux_data[i + delta + origin_insn_no] = origin_insn_aux;
+				env->insn_check_lists[i + delta + origin_insn_no] = origin_check_list;
+				env->prog = prog = new_prog;
+				delta += cnt - 1;
+			}
+
+			// if (!old_off) {
+			// 	struct bpf_insn zero_off_patch[] = {
+			// 		BPF_ALU64_IMM(BPF_AND, reg, offset_bound_mask),
+			// 		BPF_ALU64_REG(BPF_OR, reg, BPF_REG_BASE),
+			// 		*insn,
+			// 	};
+
+			// 	cnt = ARRAY_SIZE(zero_off_patch);
+			// 	origin_insn_no = find_origin_insn(zero_off_patch, cnt, insn);
+
+			// 	new_prog = bpf_patch_insn_data(env, i + delta, zero_off_patch, cnt);
+			// 	if (!new_prog) {
+			// 		fbpf_log("patch failed\n");
+			// 		return -ENOMEM;
+			// 	}
+
+			// 	// dump_insns(new_prog, i + delta, cnt, "restore ldst");
+
+			// 	env->insn_aux_data[i + delta + origin_insn_no] =
+			// 		origin_insn_aux;
+			// 	env->prog = prog = new_prog;
+			// 	delta += cnt - 1;
+			// 	continue;
+			// } else {
+			// 	struct bpf_insn non_zero_off_patch[] = {
+			// 		BPF_ALU64_IMM(BPF_ADD, reg, old_off),
+			// 		BPF_ALU64_IMM(BPF_AND, reg, offset_bound_mask),
+			// 		BPF_ALU64_REG(BPF_OR, reg, BPF_REG_BASE),
+			// 		*insn,
+			// 		BPF_ALU64_IMM(BPF_SUB, reg, old_off),
+			// 	};
+
+			// 	cnt = ARRAY_SIZE(non_zero_off_patch);
+			// 	origin_insn_no = find_origin_insn(non_zero_off_patch, cnt, insn);
+
+			// 	new_prog = bpf_patch_insn_data(env, i + delta, non_zero_off_patch, cnt);
+			// 	if (!new_prog) {
+			// 		fbpf_log("patch failed\n");
+			// 		return -ENOMEM;
+			// 	}
+
+			// 	// dump_insns(new_prog, i + delta, cnt, "restore ldst");
+
+			// 	env->insn_aux_data[i + delta + origin_insn_no] =
+			// 		origin_insn_aux;
+			// 	env->prog = prog = new_prog;
+			// 	delta += cnt - 1;
+			// 	continue;
+			// }
+		}
+	}
+
+	// dump_insns(env->prog, 0, env->prog->len, "all after restore ldst");
+
+	return 0;
+}
+
+int bpf_sfi_check_helper_args(struct bpf_verifier_env *env)
+{
+	struct bpf_prog *prog;
+	int insn_cnt;
+	struct bpf_prog *new_prog;
+	int i, cnt, delta = 0;
+	struct bpf_sfi_check_unit *check_list, *origin_check_list;
+
+	if (!env) {
+		fbpf_log("ERROR: env is NULL\n");
+		return -EFAULT;
+	}
+	prog = env->prog;
+
+	if (!prog) {
+		fbpf_log("ERROR: prog is NULL\n");
+		return -EFAULT;
+	}
+	insn_cnt = prog->len;
+
+	// dump_insns(prog, 0, prog->len, "before restore_helper_args");
+
+	/**
+	 * use i + delta to traverse: insn, aux.
+	 * in inner loop, do not update the insn and aux.
+	 */
+	for (i = 0; i < insn_cnt; i++) {
+		struct bpf_insn_aux_data origin_insn_aux;
+		int sub_delta = 0;
+		int alpha = 0;
+		struct bpf_insn_aux_data *aux;
+		struct bpf_insn *insn;
+
+		insn = &prog->insnsi[i + delta + alpha];
+		aux = &env->insn_aux_data[i + delta + alpha];
+		check_list = env->insn_check_lists[i + delta + alpha];
+		if (!aux) {
+			dump_insns(prog, i, 1, "empty aux");
+			fbpf_log("ERROR: aux is empty for insn %d\n", i);
+			return -EFAULT;
+		}
+		origin_insn_aux = *aux;
+		origin_check_list = env->insn_check_lists[i + delta + alpha];
+
+		/* check optimization */
+		if (check_list) {
+			int func_id = insn->imm;
+			struct bpf_sfi_check_unit *p;
+			// u64 offset_bound_mask = (roundup_pow_of_two(
+			// 	env->prog->total_page_cnt) << PAGE_SHIFT) - 1;
+			u64 sfi_region_size = env->prog->total_page_cnt << PAGE_SHIFT;
+            struct bpf_insn patch[16];
+
+			list_for_each_entry(p, &check_list->list_head, list_head) {
+				int origin_insn_no;
+				int reg_no = p->reg_no;
+				enum bpf_reg_type arg_type = aux->arg_reg_type[reg_no - 1];
+				insn = &prog->insnsi[i + delta + alpha];
+				aux = &env->insn_aux_data[i + delta + alpha];
+
+				// struct bpf_insn patch[] = {
+				// 	BPF_ALU64_IMM(BPF_AND, reg_no, offset_bound_mask),
+				// 	BPF_ALU64_REG(BPF_OR, reg_no, BPF_REG_BASE),
+				// 	*insn,
+				// };
+
+				if (p->check_type != BPF_SFI_CHECK_HELPER_AS_UNSAFE_PTR &&
+					p->check_type != BPF_SFI_CHECK_HELPER_AS_SAFE_PTR &&
+					p->check_type != BPF_SFI_CHECK_HELPER_AS_OFFSET)
+					break;
+
+				cnt = form_sfi_check_patch_v3(insn, p, patch, &origin_insn_no, 
+					sfi_region_size);
+
+				/* NOTICE: use cnt to decide whether to patch */
+				if (cnt == 0)
+					continue;
+
+				// cnt = ARRAY_SIZE(patch);
+				// origin_insn_no = find_origin_insn(patch, cnt, insn);
+
+				fbpf_log("patch %d(%d): helper func=%d, \
+restore arg r%d, type=%d, cnt=%d, alpha=%d\n",
+					i + delta + alpha, i, func_id, reg_no,
+					arg_type, cnt, alpha);
+
+				new_prog = bpf_patch_insn_data(env, i + delta + alpha,
+								patch, cnt);
+				if (!new_prog) {
+					fbpf_log("ERROR: patch failed\n");
+					return -ENOMEM;
+				}
+
+				dump_insns(new_prog, i + delta + alpha,
+							cnt, "restore stack ptr arg");
+
+				env->insn_aux_data[i + delta + alpha + origin_insn_no] = origin_insn_aux;
+				env->insn_check_lists[i + delta + alpha + origin_insn_no] = origin_check_list;
+				env->prog = prog = new_prog;
+
+				sub_delta += cnt - 1;
+				alpha += origin_insn_no;
+			}
+			
+			delta += sub_delta;
+		}
+	}
+
+	return 0;
+}
+
+int bpf_record_used_pages(u64 start_addr, u64 end_addr, 
+	struct mutex *write_mutex, struct list_head *head)
+{
+	int cpu;
+	u64 page_addr = start_addr;
+	int mmapable_page_cnt = 0;
+
+	while (page_addr < end_addr) {
+		for_each_possible_cpu(cpu) {
+			struct page *physic_page;
+			void *ptr;
+			struct bpf_used_page* new_page;
+
+			ptr = per_cpu_ptr((void *)page_addr, cpu);
+			if (is_vmalloc_addr(ptr)) {
+				physic_page = vmalloc_to_page(ptr);
+			} else {
+				physic_page = virt_to_page(ptr);
+			}
+			if (!physic_page) {
+				pr_err("cannot find physic page for %016llx\n", page_addr);
+				return -ENOENT;
+			}
+			new_page = kzalloc(sizeof(*new_page), GFP_KERNEL);
+			new_page->physic_page = physic_page;
+			
+			mutex_lock(write_mutex);
+			// printk("virt addr=%016llx\n", (u64)ptr);
+			list_add(&new_page->list_head, head);
+			mmapable_page_cnt++;
+			mutex_unlock(write_mutex);
+		}
+		page_addr += PAGE_SIZE;
+	}
+
+	return mmapable_page_cnt;
+}
+
+int bpf_sfi_tmp_check(struct bpf_verifier_env *env)
+{
+	struct bpf_prog *prog;
+	struct bpf_insn *insn;
+	int insn_cnt;
+	struct bpf_insn_aux_data *aux;
+	int i;
+	struct bpf_sfi_check_unit *check_list;
+
+	if (!env) {
+		fbpf_log("env is NULL\n");
+		return -EFAULT;
+	}
+	prog = env->prog;
+	aux = env->insn_aux_data;
+
+	if (!prog) {
+		fbpf_log("prog is NULL\n");
+		return -EFAULT;
+	}
+	insn_cnt = prog->len;
+
+	insn = prog->insnsi;
+	if (!insn)
+		return 0;
+
+	for (i = 0; i < insn_cnt; i++) {
+		insn = &prog->insnsi[i];
+		aux = &env->insn_aux_data[i];
+		check_list = env->insn_check_lists[i];
+
+		if (!aux) {
+			dump_insns(prog, i, 1, "empty aux");
+			fbpf_log("aux is empty for insn %d", i);
+			return -EFAULT;
+		}
+
+		/* check optimization */
+		if (check_list) {
+			struct bpf_sfi_check_unit *p;
+			char check_type[128];
+
+			mutex_lock(&env->insn_check_list_mutex);
+			list_for_each_entry(p, &check_list->list_head, list_head) {
+				switch (p->check_type) {
+					case BPF_SFI_CHECK_LDST_AS_UNSAFE_PTR:
+						if (insn->off == 0)
+							strcpy(check_type, "BPF_SFI_CHECK_LDST_AS_UNSAFE_PTR");
+						else
+						 	strcpy(check_type, "BPF_SFI_CHECK_LDST_OFFSET_AS_UNSAFE_PTR");;
+						break;
+					case BPF_SFI_CHECK_LDST_AS_SAFE_PTR:
+						if (insn->off == 0)
+							strcpy(check_type, "BPF_SFI_CHECK_LDST_AS_SAFE_PTR");
+						else
+						 	strcpy(check_type, "BPF_SFI_CHECK_LDST_OFFSET_AS_SAFE_PTR");;
+						break;
+					case BPF_SFI_CHECK_LDST_AS_OFFSET:
+						if (insn->off == 0)
+							strcpy(check_type, "BPF_SFI_CHECK_LDST_AS_OFFSET");
+						else
+						 	strcpy(check_type, "BPF_SFI_CHECK_LDST_OFFSET_AS_OFFSET");;
+						break;
+					case BPF_SFI_CHECK_HELPER_AS_UNSAFE_PTR:
+						strcpy(check_type, "BPF_SFI_CHECK_HELPER_AS_UNSAFE_PTR");
+						break;
+					case BPF_SFI_CHECK_HELPER_AS_SAFE_PTR:
+						strcpy(check_type, "BPF_SFI_CHECK_HELPER_AS_SAFE_PTR");
+						break;
+					case BPF_SFI_CHECK_HELPER_AS_OFFSET:
+						strcpy(check_type, "BPF_SFI_CHECK_HELPER_AS_OFFSET");
+						break;
+				}
+				fbpf_log("%d: reg %d, check type %s\n", i, p->reg_no, check_type);
+			}
+			mutex_unlock(&env->insn_check_list_mutex);
+		}
+	}
+	
+	return 0;
+}
+
+static inline bool is_LDST_insn(struct bpf_insn *insn)
+{
+	u8 class = BPF_CLASS(insn->code);
+
+	if (class == BPF_LD || class == BPF_LDX || class == BPF_ST || class == BPF_STX)
+		return true;
+	else
+	 	return false;
+}
+
+static inline bool is_HELPER_insn(struct bpf_insn *insn)
+{
+	u8 class = BPF_CLASS(insn->code);
+	u8 op = BPF_OP(insn->code);
+
+	if ((class == BPF_JMP || class == BPF_JMP32) &&
+		op == BPF_CALL &&
+		insn->src_reg != BPF_PSEUDO_CALL)
+		return true;
+	else
+	 	return false;
+}
+
+static char *bpf_sfi_check_type_strs[] = {
+	[BPF_SFI_CHECK_HELPER_AS_UNSAFE_PTR] = "BPF_SFI_CHECK_HELPER_AS_UNSAFE_PTR",
+	[BPF_SFI_CHECK_HELPER_AS_SAFE_PTR] = "BPF_SFI_CHECK_HELPER_AS_SAFE_PTR",
+	[BPF_SFI_CHECK_HELPER_AS_OFFSET] = "BPF_SFI_CHECK_HELPER_AS_OFFSET",
+	[BPF_SFI_CHECK_LDST_AS_UNSAFE_PTR] = "BPF_SFI_CHECK_LDST_AS_UNSAFE_PTR",
+	[BPF_SFI_CHECK_LDST_AS_SAFE_PTR] = "BPF_SFI_CHECK_LDST_AS_SAFE_PTR",
+	[BPF_SFI_CHECK_LDST_AS_OFFSET] = "BPF_SFI_CHECK_LDST_AS_OFFSET",
+};
+
+/**
+ * return a link list, each element mark a check of a reg need to be done.
+ * Ex: 
+ * - { reg_0, CHECK_LDST } -> NULL
+ * - { reg_3, CHEKC_HELPER } -> { reg_2, CHECK_MODIFIED } -> { reg_1, CHECK_NONE }
+ * 
+ */
+struct bpf_sfi_check_unit *bpf_sfi_get_check_list(struct bpf_verifier_env *env, struct bpf_insn *insn, struct bpf_reg_state *regs)
+{
+	if (is_LDST_insn(insn)) {
+		enum bpf_reg_type ptr_type;
+		int reg_no;
+		struct bpf_sfi_check_unit *check_list, *new_unit;
+		bool reg_as_offset;
+		u8 mode;
+
+		if (BPF_CLASS(insn->code) == BPF_LD ||
+			BPF_CLASS(insn->code) == BPF_LDX)
+			reg_no = insn->src_reg;
+		else
+		 	reg_no = insn->dst_reg;
+
+		ptr_type = base_type(regs[reg_no].type);
+		if (ptr_type != PTR_TO_STACK &&
+			ptr_type != PTR_TO_MAP_VALUE &&
+			ptr_type != PTR_TO_PACKET) {
+			// fbpf_log("%d: ignore ptr=%d, r%d", i, ptr_type, reg);
+			return NULL;
+		}
+
+		mode = BPF_MODE(insn->code);
+		switch (mode) {
+			case BPF_MEM:
+				reg_as_offset = true;
+				break;
+			case BPF_XADD:
+			case BPF_IMM:
+				reg_as_offset = false;
+				break;
+			default:
+				pr_err("unprocessed mode %d\n", mode);
+				return ERR_PTR(ENOTSUPP);
+		}
+
+		check_list = (struct bpf_sfi_check_unit *)kzalloc(sizeof(struct bpf_sfi_check_unit), GFP_KERNEL);
+		INIT_LIST_HEAD(&check_list->list_head);
+
+		new_unit = (struct bpf_sfi_check_unit *)kzalloc(sizeof(struct bpf_sfi_check_unit), GFP_KERNEL);
+		INIT_LIST_HEAD(&new_unit->list_head);
+		new_unit->reg_no = reg_no;
+		new_unit->reg_as_offset = reg_as_offset;
+
+		if (regs[reg_no].sfi_check_state == BPF_SFI_UNSAFE_PTR) {
+			new_unit->check_type = BPF_SFI_CHECK_LDST_AS_UNSAFE_PTR;
+		} 
+		else if (regs[reg_no].sfi_check_state == BPF_SFI_SAFE_PTR) {
+			new_unit->check_type = BPF_SFI_CHECK_LDST_AS_SAFE_PTR;
+		} 
+		else {
+			new_unit->check_type = BPF_SFI_CHECK_LDST_AS_OFFSET;
+		}
+
+		if (insn->off == 0) {
+			if (new_unit->check_type == BPF_SFI_CHECK_LDST_AS_UNSAFE_PTR ||
+				new_unit->check_type == BPF_SFI_CHECK_LDST_AS_OFFSET) {
+				if (reg_as_offset)
+					new_unit->proposed_state = BPF_SFI_OFFSET;
+				else
+				 	new_unit->proposed_state = BPF_SFI_SAFE_PTR;
+			}
+			else
+			 	new_unit->proposed_state = BPF_SFI_SAFE_PTR;
+		} else {
+			new_unit->proposed_state = BPF_SFI_SAFE_PTR;
+		}
+
+		list_add(&new_unit->list_head, &check_list->list_head);
+		fbpf_log("%d: add %s check point\n", insn - env->prog->insnsi, 
+			bpf_sfi_check_type_strs[new_unit->check_type]);
+		
+		return check_list;
+	} 
+	else if (is_HELPER_insn(insn)) {
+		const struct bpf_func_proto *fn;
+		int arg, reg_no;
+		enum bpf_reg_type arg_reg_type;
+		struct bpf_sfi_check_unit *bpf_sfi_check_list;
+
+		if (unlikely(!env->ops->get_func_proto)) {
+			pr_err("ERROR: unsupport helper\n");
+			return ERR_PTR(ENOENT);
+		}
+		fn = env->ops->get_func_proto(insn->imm, env->prog);
+		if (!fn) {
+			pr_err("ERROR: unknown helper type\n");
+			return ERR_PTR(ENOENT);
+		}
+
+		bpf_sfi_check_list = (struct bpf_sfi_check_unit *)kzalloc(sizeof(struct bpf_sfi_check_unit), GFP_KERNEL);
+		INIT_LIST_HEAD(&bpf_sfi_check_list->list_head);
+
+		for (arg = 0; arg < 5; arg++) {
+			reg_no = arg + 1;
+			/* here use mapped actual reg type, not formal arg type */
+			arg_reg_type = base_type(regs[reg_no].type);
+
+			fbpf_log("%d: arg%d_type = %d\n", insn - env->prog->insnsi, reg_no, arg_reg_type);
+
+			if (arg_reg_type == PTR_TO_STACK ||
+				arg_reg_type == PTR_TO_MAP_VALUE ||
+				arg_reg_type == PTR_TO_PACKET) {
+				struct bpf_sfi_check_unit *check_unit = (struct bpf_sfi_check_unit *)kzalloc(sizeof(struct bpf_sfi_check_unit), GFP_KERNEL);
+				INIT_LIST_HEAD(&check_unit->list_head);
+				check_unit->reg_no = reg_no;
+				
+				if (regs[reg_no].sfi_check_state == BPF_SFI_UNSAFE_PTR) {
+					check_unit->check_type = BPF_SFI_CHECK_HELPER_AS_UNSAFE_PTR;
+				} 
+				else if (regs[reg_no].sfi_check_state == BPF_SFI_SAFE_PTR) {
+					check_unit->check_type = BPF_SFI_CHECK_HELPER_AS_SAFE_PTR;
+				}
+				else {
+					check_unit->check_type = BPF_SFI_CHECK_HELPER_AS_OFFSET;
+				}
+
+				check_unit->proposed_state = BPF_SFI_SAFE_PTR;
+				
+				list_add(&check_unit->list_head, &bpf_sfi_check_list->list_head);
+				fbpf_log("%d: add %s check point\n", insn - env->prog->insnsi, 
+					bpf_sfi_check_type_strs[check_unit->check_type]);
+			}
+		}
+		
+		return bpf_sfi_check_list;
+	} 
+	else {
+		return NULL;
+	}
+}
+
+int bpf_sfi_hook_kernel_fault(u64 addr)
+{
+	pte_t *ptep;
+	
+	ptep = get_ptep(addr);
+	if (IS_ERR(ptep))
+		return PTR_ERR(ptep);
+
+	if (pte_val(*ptep) & PTE_BPF_SFI_GP) {
+		return true;
+	}
+	else
+	 	return false;
+}
\ No newline at end of file
diff --git a/kernel/bpf/verifier.c b/kernel/bpf/verifier.c
index 4f60168ce175..85b9fb183d04 100644
--- a/kernel/bpf/verifier.c
+++ b/kernel/bpf/verifier.c
@@ -23,6 +23,9 @@
 #include <linux/bpf_lsm.h>
 #include <linux/btf_ids.h>
 #include <linux/bpf_sched.h>
+#ifdef CONFIG_HIVE
+#include <linux/sfi_bpf.h>
+#endif
 
 #include "disasm.h"
 
@@ -3045,6 +3048,10 @@ static int __check_mem_access(struct bpf_verifier_env *env, int regno,
 			mem_size, off, size);
 		break;
 	case PTR_TO_PACKET:
+	#ifdef CONFIG_HIVE
+		/* loose this check */
+		return 0;
+	#endif
 	case PTR_TO_PACKET_META:
 	case PTR_TO_PACKET_END:
 		verbose(env, "invalid access to packet, off=%d size=%d, R%d(id=%d,off=%d,r=%d)\n",
@@ -5619,6 +5626,9 @@ static int check_helper_call(struct bpf_verifier_env *env, int func_id, int insn
 	struct bpf_call_arg_meta meta;
 	bool changes_data;
 	int i, err;
+	#ifdef CONFIG_HIVE
+	struct bpf_insn_aux_data *aux = &env->insn_aux_data[insn_idx];
+	#endif
 
 	/* find function prototype */
 	if (func_id < 0 || func_id >= __BPF_FUNC_MAX_ID) {
@@ -5706,6 +5716,12 @@ static int check_helper_call(struct bpf_verifier_env *env, int func_id, int insn
 	}
 
 	regs = cur_regs(env);
+	#ifdef CONFIG_HIVE
+	/* fbpf record real arg type of helper call */
+	for (i = 0; i < 5; i++) {
+		aux->arg_reg_type[i] = regs[i + 1].type;
+	}
+	#endif
 
 	/* check that flags argument in get_local_storage(map, flags) is 0,
 	 * this is required because get_local_storage() can't return an error.
@@ -9726,7 +9742,7 @@ static int propagate_liveness(struct bpf_verifier_env *env,
 		return -EFAULT;
 	}
 	/* Propagate read liveness of registers... */
-	BUILD_BUG_ON(BPF_REG_FP + 1 != MAX_BPF_REG);
+	BUILD_BUG_ON(BPF_REG_FP + 2 != MAX_BPF_REG);
 	for (frame = 0; frame <= vstate->curframe; frame++) {
 		parent = vparent->frame[frame];
 		state = vstate->frame[frame];
@@ -10072,11 +10088,19 @@ static int do_check(struct bpf_verifier_env *env)
 	int insn_cnt = env->prog->len;
 	bool do_print_state = false;
 	int prev_insn_idx = -1;
+	#ifdef CONFIG_HIVE
+	struct bpf_reg_state regs_before[MAX_BPF_REG];
+	int i;
+	struct bpf_sfi_check_unit *check_list;
+	#endif
 
 	for (;;) {
 		struct bpf_insn *insn;
 		u8 class;
 		int err;
+		#ifdef CONFIG_HIVE
+		bool updated[MAX_BPF_REG] = {false};
+		#endif
 
 		env->prev_insn_idx = prev_insn_idx;
 		if (env->insn_idx >= insn_cnt) {
@@ -10152,6 +10176,15 @@ static int do_check(struct bpf_verifier_env *env)
 		regs = cur_regs(env);
 		sanitize_mark_insn_seen(env);
 		prev_insn_idx = env->insn_idx;
+		#ifdef CONFIG_HIVE
+		/* fbpf: compare regs_before and regs to get which regs are changed */
+		memcpy(regs_before, regs, sizeof(struct bpf_reg_state) * MAX_BPF_REG);
+
+		/* fbpf: used to form check list of vulnerable insns */
+		check_list = bpf_sfi_get_check_list(env, insn, regs);
+		if (IS_ERR(check_list))
+			return PTR_ERR(check_list);
+		#endif
 
 		if (class == BPF_ALU || class == BPF_ALU64) {
 			err = check_alu_op(env, insn);
@@ -10211,8 +10244,24 @@ static int do_check(struct bpf_verifier_env *env)
 				err = check_xadd(env, env->insn_idx, insn);
 				if (err)
 					return err;
+				#ifdef CONFIG_HIVE
+				/* save register type */
+				dst_reg_type = regs[insn->dst_reg].type;
+				prev_dst_type = &env->insn_aux_data[env->insn_idx].ptr_type;
+
+				if (*prev_dst_type == NOT_INIT) {
+					*prev_dst_type = dst_reg_type;
+				} else if (reg_type_mismatch(dst_reg_type, *prev_dst_type)) {
+					verbose(env, "same insn cannot be used with different pointers\n");
+					return -EINVAL;
+				}
+				#endif
 				env->insn_idx++;
+				#ifdef CONFIG_HIVE
+				goto next_insn;
+				#else
 				continue;
+				#endif
 			}
 
 			/* check src1 operand */
@@ -10306,7 +10355,11 @@ static int do_check(struct bpf_verifier_env *env)
 				}
 
 				env->insn_idx += insn->off + 1;
+				#ifdef CONFIG_HIVE
+				goto next_insn;
+				#else
 				continue;
+				#endif
 
 			} else if (opcode == BPF_EXIT) {
 				if (BPF_SRC(insn->code) != BPF_K ||
@@ -10329,7 +10382,11 @@ static int do_check(struct bpf_verifier_env *env)
 					if (err)
 						return err;
 					do_print_state = true;
+					#ifdef CONFIG_HIVE
+					goto next_insn;
+					#else
 					continue;
+					#endif
 				}
 
 				err = check_reference_leak(env);
@@ -10349,7 +10406,11 @@ static int do_check(struct bpf_verifier_env *env)
 					break;
 				} else {
 					do_print_state = true;
+					#ifdef CONFIG_HIVE
+					goto next_insn;
+					#else
 					continue;
+					#endif
 				}
 			} else {
 				err = check_cond_jmp_op(env, insn, &env->insn_idx);
@@ -10358,6 +10419,9 @@ static int do_check(struct bpf_verifier_env *env)
 			}
 		} else if (class == BPF_LD) {
 			u8 mode = BPF_MODE(insn->code);
+			#ifdef CONFIG_HIVE
+			enum bpf_reg_type src_reg_type, *prev_src_type;
+			#endif
 
 			if (mode == BPF_ABS || mode == BPF_IND) {
 				err = check_ld_abs(env, insn);
@@ -10375,12 +10439,68 @@ static int do_check(struct bpf_verifier_env *env)
 				verbose(env, "invalid BPF_LD mode\n");
 				return -EINVAL;
 			}
+			#ifdef CONFIG_HIVE
+			src_reg_type = regs[insn->src_reg].type;
+			prev_src_type = &env->insn_aux_data[env->insn_idx].ptr_type;
+
+			if (*prev_src_type == NOT_INIT) {
+				/* saw a valid insn
+				 * dst_reg = *(u32 *)(src_reg + off)
+				 * save type to validate intersecting paths
+				 */
+				*prev_src_type = src_reg_type;
+			} else if (reg_type_mismatch(src_reg_type, *prev_src_type)) {
+				/* ABuser program is trying to use the same insn
+				 * dst_reg = *(u32*) (src_reg + off)
+				 * with different pointer types:
+				 * src_reg == ctx in one branch and
+				 * src_reg == stack|map in some other branch.
+				 * Reject it.
+				 */
+				verbose(env, "same insn cannot be used with different pointers\n");
+				return -EINVAL;
+			}
+			#endif
 		} else {
 			verbose(env, "unknown insn class %d\n", class);
 			return -EINVAL;
 		}
 
 		env->insn_idx++;
+#ifdef CONFIG_HIVE
+next_insn:
+		if (check_list) {
+			struct bpf_sfi_check_unit *p;
+			list_for_each_entry(p, &check_list->list_head, list_head) {
+				int reg_no = p->reg_no;
+				regs[reg_no].sfi_check_state = p->proposed_state;
+				updated[reg_no] = true;
+			}
+
+			if (!env->insn_check_lists[prev_insn_idx]) {
+				// fbpf_log("update into %d\n", prev_insn_idx);
+				env->insn_check_lists[prev_insn_idx] = check_list;
+			}
+		}
+		
+		for (i = 0; i < MAX_BPF_REG; i++) {
+			// if (base_type(regs_before[i].type) == PTR_TO_STACK)
+			// 	continue;
+			/* reg move from src to dst, use src_reg's check_state */
+			if (insn->code == (BPF_ALU64 | BPF_MOV | BPF_X))
+				continue;
+			/* use check_list proposed state if have */
+			if (updated[i])
+				continue;
+			/* if reg changed, reset sfi_check state */
+			if (memcmp(regs_before + i, regs + i, sizeof(struct bpf_reg_state))) {
+				regs[i].sfi_check_state = BPF_SFI_UNSAFE_PTR;
+			}
+		}
+
+		// fbpf_log("debugging insn %d", prev_insn_idx);
+		// bpf_sfi_tmp_check(env);
+#endif
 	}
 
 	return 0;
@@ -10695,8 +10815,18 @@ static int resolve_pseudo_ldimm64(struct bpf_verifier_env *env)
 				addr += off;
 			}
 
+			#ifdef CONFIG_HIVE
+			if (insn[0].src_reg == BPF_PSEUDO_MAP_VALUE) {
+				fbpf_log("%d: skip BPF_PSEUDO_MAP_VALUE insn\n", i);
+				goto reserve_imm;
+			}
+			#endif
+
 			insn[0].imm = (u32)addr;
 			insn[1].imm = addr >> 32;
+#ifdef CONFIG_HIVE
+reserve_imm:
+#endif
 
 			/* check whether we recorded this map already */
 			for (j = 0; j < env->used_map_cnt; j++) {
@@ -10750,6 +10880,149 @@ static int resolve_pseudo_ldimm64(struct bpf_verifier_env *env)
 	return 0;
 }
 
+#ifdef CONFIG_HIVE
+static int resolve_pseudo_ldimm64_again(struct bpf_verifier_env *env)
+{
+	struct bpf_insn *insn = env->prog->insnsi;
+	int insn_cnt = env->prog->len;
+	int i, j, err;
+
+	err = bpf_prog_calc_tag(env->prog);
+	if (err)
+		return err;
+
+	for (i = 0; i < insn_cnt; i++, insn++) {
+		if (insn[0].code == (BPF_LD | BPF_IMM | BPF_DW)) {
+			struct bpf_insn_aux_data *aux;
+			struct bpf_map *map;
+			struct fd f;
+			u64 addr;
+			u32 fd;
+
+			if (insn[0].src_reg == 0)
+				/* valid generic load 64-bit imm */
+				goto next_insn;
+
+			/* In final convert_pseudo_ld_imm64() step, this is
+			 * converted into regular 64-bit imm load insn.
+			 */
+			switch (insn[0].src_reg) {
+			case BPF_PSEUDO_MAP_VALUE:
+				break;
+			default:
+				goto next_insn;
+			}
+
+			fd = insn[0].imm;
+
+			f = fdget(fd);
+			map = __bpf_map_get(f);
+			if (IS_ERR(map)) {
+				verbose(env, "fd %d is not pointing to valid bpf_map\n",
+					insn[0].imm);
+				return PTR_ERR(map);
+			}
+
+			err = check_map_prog_compatibility(env, map, env->prog);
+			if (err) {
+				fdput(f);
+				return err;
+			}
+
+			aux = &env->insn_aux_data[i];
+			if (insn[0].src_reg == BPF_PSEUDO_MAP_FD) {
+				addr = (unsigned long)map;
+				goto next_insn;
+			} else {
+				u32 off = insn[1].imm;
+
+				/* do this after aggregation */
+				if (!env->prog->shadow_region_addr) {
+					pr_err("bpf sfi aggregate memory failed\n");
+					return -EINVAL;
+				}
+
+				if (off >= BPF_MAX_VAR_OFF) {
+					verbose(env, "direct value offset of %u is not allowed\n", off);
+					fdput(f);
+					return -EINVAL;
+				}
+
+				if (!map->ops->map_direct_value_addr) {
+					verbose(env, "no direct value access support for this map type\n");
+					fdput(f);
+					return -EINVAL;
+				}
+
+				err = map->ops->map_direct_value_addr(map, &addr, off);
+				if (err) {
+					verbose(env, "invalid access to map value pointer, value_size=%u off=%u\n",
+						map->value_size, off);
+					fdput(f);
+					return err;
+				}
+
+				aux->map_off = off;
+				addr += off;
+				aux->extra_map_ptr = (u64)map;
+			}
+
+			insn[0].imm = (u32)addr;
+			insn[1].imm = addr >> 32;
+
+			/* check whether we recorded this map already */
+			for (j = 0; j < env->used_map_cnt; j++) {
+				if (env->used_maps[j] == map) {
+					aux->map_index = j;
+					fdput(f);
+					goto next_insn;
+				}
+			}
+
+			if (env->used_map_cnt >= MAX_USED_MAPS) {
+				fdput(f);
+				return -E2BIG;
+			}
+
+			/* hold the map. If the program is rejected by verifier,
+			 * the map will be released by release_maps() or it
+			 * will be used by the valid program until it's unloaded
+			 * and all maps are released in free_used_maps()
+			 */
+			bpf_map_inc(map);
+
+			aux->map_index = env->used_map_cnt;
+			env->used_maps[env->used_map_cnt++] = map;
+
+			if (bpf_map_is_cgroup_storage(map) &&
+			    bpf_cgroup_storage_assign(env->prog->aux, map)) {
+				verbose(env, "only one cgroup storage of each type is allowed\n");
+				fdput(f);
+				return -EBUSY;
+			}
+
+			fdput(f);
+next_insn:
+			insn++;
+			i++;
+			continue;
+		}
+
+		/* Basic sanity check before we invest more work here. */
+		if (!bpf_opcode_in_insntable(insn->code)) {
+			verbose(env, "unknown opcode %02x\n", insn->code);
+			return -EINVAL;
+		}
+	}
+
+	/* now all pseudo BPF_LD_IMM64 instructions load valid
+	 * 'struct bpf_map *' into a register instead of user map_fd.
+	 * These pointers will be used later by verifier to validate map access.
+	 */
+	return 0;
+}
+#endif
+
 /* drop refcnt of maps used by the rejected program */
 static void release_maps(struct bpf_verifier_env *env)
 {
@@ -10805,6 +11078,26 @@ static void adjust_insn_aux_data(struct bpf_verifier_env *env,
 	vfree(old_data);
 }
 
+#ifdef CONFIG_HIVE
+static void adjust_insn_check_lists(struct bpf_verifier_env *env,
+				 struct bpf_sfi_check_unit **new_check_lists,
+				 struct bpf_prog *new_prog, u32 off, u32 cnt)
+{
+	struct bpf_sfi_check_unit **old_check_lists = env->insn_check_lists;
+	u32 prog_len;
+
+	if (cnt == 1)
+		return;
+	prog_len = new_prog->len;
+
+	memcpy(new_check_lists, old_check_lists, sizeof(struct bpf_insn_check_unit *) * off);
+	memcpy(new_check_lists + off + cnt - 1, old_check_lists + off,
+	       sizeof(struct bpf_insn_check_unit *) * (prog_len - off - cnt + 1));
+	env->insn_check_lists = new_check_lists;
+	vfree(old_check_lists);
+}
+#endif
+
 static void adjust_subprog_starts(struct bpf_verifier_env *env, u32 off, u32 len)
 {
 	int i;
@@ -10833,17 +11126,31 @@ static void adjust_poke_descs(struct bpf_prog *prog, u32 off, u32 len)
 	}
 }
 
+#ifdef CONFIG_HIVE
+struct bpf_prog *bpf_patch_insn_data(struct bpf_verifier_env *env, u32 off,
+					    const struct bpf_insn *patch, u32 len)
+#else
 static struct bpf_prog *bpf_patch_insn_data(struct bpf_verifier_env *env, u32 off,
 					    const struct bpf_insn *patch, u32 len)
+#endif
 {
 	struct bpf_prog *new_prog;
 	struct bpf_insn_aux_data *new_data = NULL;
+	#ifdef CONFIG_HIVE
+	struct bpf_sfi_check_unit **new_check_lists = NULL;
+	#endif
 
 	if (len > 1) {
 		new_data = vzalloc(array_size(env->prog->len + len - 1,
 					      sizeof(struct bpf_insn_aux_data)));
 		if (!new_data)
 			return NULL;
+		#ifdef CONFIG_HIVE
+		new_check_lists = vzalloc(array_size(env->prog->len + len - 1,
+					      sizeof(struct bpf_sfi_check_unit *)));
+		if (!new_check_lists)
+			return NULL;
+		#endif
 	}
 
 	new_prog = bpf_patch_insn_single(env->prog, off, patch, len);
@@ -10856,6 +11163,9 @@ static struct bpf_prog *bpf_patch_insn_data(struct bpf_verifier_env *env, u32 of
 		return NULL;
 	}
 	adjust_insn_aux_data(env, new_data, new_prog, off, len);
+	#ifdef CONFIG_HIVE
+	adjust_insn_check_lists(env, new_check_lists, new_prog, off, len);
+	#endif
 	adjust_subprog_starts(env, off, len);
 	adjust_poke_descs(new_prog, off, len);
 	return new_prog;
@@ -11490,6 +11800,10 @@ static int jit_subprogs(struct bpf_verifier_env *env)
 		}
 		func[i]->aux->num_exentries = num_exentries;
 		func[i]->aux->tail_call_reachable = env->subprog_info[i].tail_call_reachable;
+		#ifdef CONFIG_HIVE
+		func[i]->shadow_stack_addr = env->prog->shadow_stack_addr;
+		func[i]->shadow_region_addr = env->prog->shadow_region_addr;
+		#endif
 		func[i] = bpf_int_jit_compile(func[i]);
 		if (!func[i]->jited) {
 			err = -ENOTSUPP;
@@ -12625,6 +12939,12 @@ int bpf_check(struct bpf_prog **prog, union bpf_attr *attr,
 	len = (*prog)->len;
 	env->insn_aux_data =
 		vzalloc(array_size(sizeof(struct bpf_insn_aux_data), len));
+	#ifdef CONFIG_HIVE
+	env->insn_check_lists = vzalloc(array_size(sizeof(struct bpf_sfi_check_unit *), len));
+	for (i = 0; i < len; i++)
+		env->insn_check_lists[i] = NULL;
+	mutex_init(&env->insn_check_list_mutex);
+	#endif
 	ret = -ENOMEM;
 	if (!env->insn_aux_data)
 		goto err_free_env;
@@ -12716,6 +13036,36 @@ int bpf_check(struct bpf_prog **prog, union bpf_attr *attr,
 
 	if (ret == 0 && bpf_prog_is_dev_bound(env->prog->aux))
 		ret = bpf_prog_offload_finalize(env);
+		
+	#ifdef CONFIG_HIVE
+	/* bpf_sfi aggregate and check is after bpf_check, if skip full_check,
+	 	bpf_sfi checks are skipped either */
+	fbpf_log("bpf_check finished\n");
+	dump_insns(env->prog, 0, env->prog->len, "after do_check");
+
+	if (ret == 0)
+		ret = bpf_sfi_tmp_check(env);
+
+	// TODO unmap shadow data
+	/* fbpf aggregate values and caculate shadow stack addr */
+	if (ret == 0)
+		ret = bpf_sfi_aggregate_memory(env);
+
+	if (ret == 0)
+		ret = resolve_pseudo_ldimm64_again(env);
+
+	if (ret == 0)
+		ret = bpf_sfi_check_ldst(env);
+
+	if (ret == 0)
+		ret = bpf_sfi_check_helper_args(env);
+
+	dump_insns(env->prog, 0, env->prog->len, "after bpf_sfi_checks");
+
+	fbpf_log("bpf_sfi_check finished\n");
+
+	pr_info("[%s] bpf insn len = %d\n", env->prog->aux->name, env->prog->len);
+	#endif
 
 skip_full_check:
 	kvfree(env->explored_states);
diff --git a/kernel/cred.c b/kernel/cred.c
index 421b1149c651..0b7d72dd9f2b 100644
--- a/kernel/cred.c
+++ b/kernel/cred.c
@@ -17,6 +17,12 @@
 #include <linux/cn_proc.h>
 #include <linux/uidgid.h>
 
+#ifdef CONFIG_CREDP
+#include <asm/iee.h>
+#include <asm/iee-cred.h>
+#include <linux/iee-func.h>
+#endif
+
 #if 0
 #define kdebug(FMT, ...)						\
 	printk("[%-5.5s%5u] " FMT "\n",					\
@@ -30,7 +36,14 @@ do {									\
 } while (0)
 #endif
 
+#ifdef CONFIG_IEE
+struct kmem_cache *cred_jar;
+#ifdef CONFIG_CREDP
+static struct kmem_cache *rcu_jar;
+#endif
+#else
 static struct kmem_cache *cred_jar;
+#endif
 
 /* init to 2 - one for init_task, one to ensure it is never freed */
 struct group_info init_groups = { .usage = ATOMIC_INIT(2) };
@@ -38,6 +51,31 @@ struct group_info init_groups = { .usage = ATOMIC_INIT(2) };
 /*
  * The initial credentials for the initial task
  */
+#ifdef CONFIG_CREDP
+struct cred init_cred __section(".iee.cred") = {
+	.usage			= ATOMIC_INIT(4),
+#ifdef CONFIG_DEBUG_CREDENTIALS
+	.subscribers		= ATOMIC_INIT(2),
+	.magic			= CRED_MAGIC,
+#endif
+	.uid			= GLOBAL_ROOT_UID,
+	.gid			= GLOBAL_ROOT_GID,
+	.suid			= GLOBAL_ROOT_UID,
+	.sgid			= GLOBAL_ROOT_GID,
+	.euid			= GLOBAL_ROOT_UID,
+	.egid			= GLOBAL_ROOT_GID,
+	.fsuid			= GLOBAL_ROOT_UID,
+	.fsgid			= GLOBAL_ROOT_GID,
+	.securebits		= SECUREBITS_DEFAULT,
+	.cap_inheritable	= CAP_EMPTY_SET,
+	.cap_permitted		= CAP_FULL_SET,
+	.cap_effective		= CAP_FULL_SET,
+	.cap_bset		= CAP_FULL_SET,
+	.user			= INIT_USER,
+	.user_ns		= &init_user_ns,
+	.group_info		= &init_groups,
+};
+#else
 struct cred init_cred = {
 	.usage			= ATOMIC_INIT(4),
 #ifdef CONFIG_DEBUG_CREDENTIALS
@@ -61,6 +99,7 @@ struct cred init_cred = {
 	.user_ns		= &init_user_ns,
 	.group_info		= &init_groups,
 };
+#endif
 
 static inline void set_cred_subscribers(struct cred *cred, int n)
 {
@@ -92,7 +131,11 @@ static inline void alter_cred_subscribers(const struct cred *_cred, int n)
  */
 static void put_cred_rcu(struct rcu_head *rcu)
 {
+	#ifdef CONFIG_CREDP
+	struct cred *cred = *(struct cred **)(rcu + 1);
+	#else
 	struct cred *cred = container_of(rcu, struct cred, rcu);
+	#endif
 
 	kdebug("put_cred_rcu(%p)", cred);
 
@@ -120,6 +163,9 @@ static void put_cred_rcu(struct rcu_head *rcu)
 		put_group_info(cred->group_info);
 	free_uid(cred->user);
 	put_user_ns(cred->user_ns);
+	#ifdef CONFIG_CREDP
+	kmem_cache_free(rcu_jar, (struct rcu_head *)(cred->rcu.func));
+	#endif
 	kmem_cache_free(cred_jar, cred);
 }
 
@@ -144,10 +190,22 @@ void __put_cred(struct cred *cred)
 	BUG_ON(cred == current->cred);
 	BUG_ON(cred == current->real_cred);
 
+	#ifdef CONFIG_CREDP
+	if (*(int *)(&(((struct rcu_head *)(cred->rcu.func))->next)))
+	#else
 	if (cred->non_rcu)
+	#endif
+		#ifdef CONFIG_CREDP
+		put_cred_rcu((struct rcu_head *)(cred->rcu.func));
+		#else
 		put_cred_rcu(&cred->rcu);
+		#endif
 	else
+		#ifdef CONFIG_CREDP
+		call_rcu((struct rcu_head *)(cred->rcu.func), put_cred_rcu);
+		#else
 		call_rcu(&cred->rcu, put_cred_rcu);
+		#endif
 }
 EXPORT_SYMBOL(__put_cred);
 
@@ -218,7 +276,13 @@ struct cred *cred_alloc_blank(void)
 	if (!new)
 		return NULL;
 
+	#ifdef CONFIG_CREDP
+	iee_set_cred_rcu(new,kmem_cache_zalloc(rcu_jar, GFP_KERNEL));
+	*(struct cred **)(((struct rcu_head *)(new->rcu.func)) + 1) = new;
+	iee_set_cred_atomic_set_usage(new,1);
+	#else
 	atomic_set(&new->usage, 1);
+	#endif
 #ifdef CONFIG_DEBUG_CREDENTIALS
 	new->magic = CRED_MAGIC;
 #endif
@@ -259,13 +323,26 @@ struct cred *prepare_creds(void)
 	if (!new)
 		return NULL;
 
+	#ifdef CONFIG_CREDP
+	iee_set_cred_rcu(new,kmem_cache_alloc(rcu_jar, GFP_KERNEL));
+	*(struct cred **)(((struct rcu_head *)(new->rcu.func)) + 1) = new;
+	#endif
+
 	kdebug("prepare_creds() alloc %p", new);
 
 	old = task->cred;
+	#ifdef CONFIG_CREDP
+	// Need to inform the token that new cred is allocated for this task.
+	iee_copy_cred(old,new);
+
+	iee_set_cred_non_rcu(new,0);
+	iee_set_cred_atomic_set_usage(new,1);
+	#else
 	memcpy(new, old, sizeof(struct cred));
 
 	new->non_rcu = 0;
 	atomic_set(&new->usage, 1);
+	#endif
 	set_cred_subscribers(new, 0);
 	get_group_info(new->group_info);
 	get_uid(new->user);
@@ -279,7 +356,11 @@ struct cred *prepare_creds(void)
 #endif
 
 #ifdef CONFIG_SECURITY
+#ifdef CONFIG_CREDP
+	iee_set_cred_security(new,NULL);
+#else
 	new->security = NULL;
+#endif
 #endif
 
 	if (security_prepare_creds(new, old, GFP_KERNEL_ACCOUNT) < 0)
@@ -308,15 +389,30 @@ struct cred *prepare_exec_creds(void)
 #ifdef CONFIG_KEYS
 	/* newly exec'd tasks don't get a thread keyring */
 	key_put(new->thread_keyring);
+	#ifdef CONFIG_CREDP
+	iee_set_cred_thread_keyring(new,NULL);
+	#else
 	new->thread_keyring = NULL;
+	#endif
 
 	/* inherit the session keyring; new process keyring */
 	key_put(new->process_keyring);
+	#ifdef CONFIG_CREDP
+	iee_set_cred_process_keyring(new,NULL);
+	#else
 	new->process_keyring = NULL;
+	#endif
 #endif
 
+	#ifdef CONFIG_CREDP
+	iee_set_cred_fsuid(new,new->euid);
+	iee_set_cred_suid(new,new->euid);
+	iee_set_cred_fsgid(new,new->egid);
+	iee_set_cred_sgid(new,new->egid);
+	#else
 	new->suid = new->fsuid = new->euid;
 	new->sgid = new->fsgid = new->egid;
+	#endif
 
 	return new;
 }
@@ -370,7 +466,11 @@ int copy_creds(struct task_struct *p, unsigned long clone_flags)
 	 * had one */
 	if (new->thread_keyring) {
 		key_put(new->thread_keyring);
+		#ifdef CONFIG_CREDP
+		iee_set_cred_thread_keyring(new,NULL);
+		#else
 		new->thread_keyring = NULL;
+		#endif
 		if (clone_flags & CLONE_THREAD)
 			install_thread_keyring_to_cred(new);
 	}
@@ -380,7 +480,11 @@ int copy_creds(struct task_struct *p, unsigned long clone_flags)
 	 */
 	if (!(clone_flags & CLONE_THREAD)) {
 		key_put(new->process_keyring);
+		#ifdef CONFIG_CREDP
+		iee_set_cred_process_keyring(new,NULL);
+		#else
 		new->process_keyring = NULL;
+		#endif
 	}
 #endif
 
@@ -420,6 +524,30 @@ static bool cred_cap_issubset(const struct cred *set, const struct cred *subset)
 	return false;
 }
 
+#ifdef CONFIG_CREDP
+void __iee_code inline _iee_do_commit_cred(unsigned long iee_offset, struct cred *new)
+{
+    struct task_struct *task = current;
+    const struct cred *old = task->real_cred;
+    // Skip check when current task is already privileged.
+    if (!uid_eq(old->euid, GLOBAL_ROOT_UID))
+    {
+        struct task_token *token = (struct task_token *)((unsigned long)task + iee_offset);
+        if (token->new_cred != new)
+            panic("IEE CREDP: Invalid target for commit_creds().");
+    }
+    
+    alter_cred_subscribers(new, 2);
+	if (new->user != old->user)
+		atomic_inc(&new->user->processes);
+	rcu_assign_pointer(task->real_cred, new);
+	rcu_assign_pointer(task->cred, new);
+	if (new->user != old->user)
+		atomic_dec(&old->user->processes);
+	alter_cred_subscribers(old, -2);
+}
+#endif
+
 /**
  * commit_creds - Install new credentials upon the current task
  * @new: The credentials to be assigned
@@ -484,6 +612,10 @@ int commit_creds(struct cred *new)
 	 * RLIMIT_NPROC limits on user->processes have already been checked
 	 * in set_user().
 	 */
+    #ifdef CONFIG_CREDP
+    // Only permits new_cred in task_token to be used.
+    iee_commit_cred(new);
+    #else
 	alter_cred_subscribers(new, 2);
 	if (new->user != old->user)
 		atomic_inc(&new->user->processes);
@@ -492,6 +624,7 @@ int commit_creds(struct cred *new)
 	if (new->user != old->user)
 		atomic_dec(&old->user->processes);
 	alter_cred_subscribers(old, -2);
+    #endif
 
 	/* send notifications */
 	if (!uid_eq(new->uid,   old->uid)  ||
@@ -659,8 +792,21 @@ EXPORT_SYMBOL(cred_fscmp);
 void __init cred_init(void)
 {
 	/* allocate a slab in which we can store credentials */
+	#ifdef CONFIG_CREDP
+	cred_jar = kmem_cache_create("cred_jar", sizeof(struct cred), 0,
+			SLAB_HWCACHE_ALIGN|SLAB_PANIC|SLAB_ACCOUNT|SLAB_RED_ZONE, NULL);
+	rcu_jar = kmem_cache_create("rcu_jar", sizeof(struct rcu_head) + sizeof(struct cred *), 0,
+			SLAB_HWCACHE_ALIGN|SLAB_PANIC|SLAB_ACCOUNT, NULL);
+	// Map init_cred
+	*((struct rcu_head **)(&(init_cred.rcu.func))) = (struct rcu_head *)kmem_cache_zalloc(rcu_jar, GFP_KERNEL);
+	*(struct cred **)(((struct rcu_head *)(init_cred.rcu.func)) + 1) = &init_cred;
+	set_iee_page_valid(__phys_to_iee(__pa_symbol(&init_cred)));
+	iee_set_logical_mem_ro((unsigned long)&init_cred);
+	iee_set_logical_mem_ro((unsigned long)__va(__pa_symbol(&init_cred)));
+	#else
 	cred_jar = kmem_cache_create("cred_jar", sizeof(struct cred), 0,
 			SLAB_HWCACHE_ALIGN|SLAB_PANIC|SLAB_ACCOUNT, NULL);
+	#endif
 }
 
 /**
@@ -688,6 +834,11 @@ struct cred *prepare_kernel_cred(struct task_struct *daemon)
 	if (!new)
 		return NULL;
 
+	#ifdef CONFIG_CREDP
+	iee_set_cred_rcu(new,kmem_cache_alloc(rcu_jar, GFP_KERNEL));
+	*(struct cred **)(((struct rcu_head *)(new->rcu.func)) + 1) = new;
+	#endif
+
 	kdebug("prepare_kernel_cred() alloc %p", new);
 
 	if (daemon)
@@ -697,24 +848,42 @@ struct cred *prepare_kernel_cred(struct task_struct *daemon)
 
 	validate_creds(old);
 
+	#ifdef CONFIG_CREDP
+	iee_copy_cred_kernel(old,new);
+	iee_set_cred_non_rcu(new,0);
+	iee_set_cred_atomic_set_usage(new,1);
+	#else
 	*new = *old;
 	new->non_rcu = 0;
 	atomic_set(&new->usage, 1);
+	#endif
 	set_cred_subscribers(new, 0);
 	get_uid(new->user);
 	get_user_ns(new->user_ns);
 	get_group_info(new->group_info);
 
 #ifdef CONFIG_KEYS
+#ifdef CONFIG_CREDP
+	iee_set_cred_session_keyring(new,NULL);
+	iee_set_cred_process_keyring(new,NULL);
+	iee_set_cred_thread_keyring(new,NULL);
+	iee_set_cred_request_key_auth(new,NULL);
+	iee_set_cred_jit_keyring(new,KEY_REQKEY_DEFL_THREAD_KEYRING);
+#else
 	new->session_keyring = NULL;
 	new->process_keyring = NULL;
 	new->thread_keyring = NULL;
 	new->request_key_auth = NULL;
 	new->jit_keyring = KEY_REQKEY_DEFL_THREAD_KEYRING;
 #endif
+#endif
 
 #ifdef CONFIG_SECURITY
+#ifdef CONFIG_CREDP
+	iee_set_cred_security(new,NULL);
+#else
 	new->security = NULL;
+#endif
 #endif
 	if (security_prepare_creds(new, old, GFP_KERNEL_ACCOUNT) < 0)
 		goto error;
@@ -780,8 +949,13 @@ int set_create_files_as(struct cred *new, struct inode *inode)
 {
 	if (!uid_valid(inode->i_uid) || !gid_valid(inode->i_gid))
 		return -EINVAL;
+	#ifdef CONFIG_CREDP
+	iee_set_cred_fsuid(new,inode->i_uid);
+	iee_set_cred_fsgid(new,inode->i_gid);
+	#else
 	new->fsuid = inode->i_uid;
 	new->fsgid = inode->i_gid;
+	#endif
 	return security_kernel_create_files_as(new, inode);
 }
 EXPORT_SYMBOL(set_create_files_as);
diff --git a/kernel/exit.c b/kernel/exit.c
index 26a81ea63156..bd7dabb927d5 100644
--- a/kernel/exit.c
+++ b/kernel/exit.c
@@ -70,6 +70,10 @@
 #include <asm/unistd.h>
 #include <asm/mmu_context.h>
 
+#ifdef CONFIG_IEE
+#include <linux/iee-func.h>
+#endif
+
 static void __unhash_process(struct task_struct *p, bool group_dead)
 {
 	nr_threads--;
@@ -481,6 +485,9 @@ static void exit_mm(void)
 	/* more a memory barrier than a real lock */
 	task_lock(current);
 	current->mm = NULL;
+	#ifdef CONFIG_IEE
+	iee_set_token_pgd(current, NULL);
+	#endif
 	mmap_read_unlock(mm);
 	enter_lazy_tlb(mm, current);
 	task_unlock(current);
diff --git a/kernel/fork.c b/kernel/fork.c
index 12db99751381..4390fa7b1391 100644
--- a/kernel/fork.c
+++ b/kernel/fork.c
@@ -112,6 +112,10 @@
 #define CREATE_TRACE_POINTS
 #include <trace/events/task.h>
 
+#ifdef CONFIG_IEE
+#include <linux/iee-func.h>
+#endif
+
 /*
  * Minimum number of threads to boot the kernel
  */
@@ -125,14 +129,14 @@
 /*
  * Protected counters by write_lock_irq(&tasklist_lock)
  */
-unsigned long total_forks;	/* Handle normal Linux uptimes. */
-int nr_threads;			/* The idle threads do not count.. */
+unsigned long total_forks; /* Handle normal Linux uptimes. */
+int nr_threads; /* The idle threads do not count.. */
 
-static int max_threads;		/* tunable limit on nr_threads */
+static int max_threads; /* tunable limit on nr_threads */
 
-#define NAMED_ARRAY_INDEX(x)	[x] = __stringify(x)
+#define NAMED_ARRAY_INDEX(x) [x] = __stringify(x)
 
-static const char * const resident_page_types[] = {
+static const char *const resident_page_types[] = {
 	NAMED_ARRAY_INDEX(MM_FILEPAGES),
 	NAMED_ARRAY_INDEX(MM_ANONPAGES),
 	NAMED_ARRAY_INDEX(MM_SWAPENTS),
@@ -141,7 +145,7 @@ static const char * const resident_page_types[] = {
 
 DEFINE_PER_CPU(unsigned long, process_counts) = 0;
 
-__cacheline_aligned DEFINE_RWLOCK(tasklist_lock);  /* outer */
+__cacheline_aligned DEFINE_RWLOCK(tasklist_lock); /* outer */
 
 #ifdef CONFIG_PROVE_RCU
 int lockdep_tasklist_lock_is_held(void)
@@ -156,7 +160,7 @@ int nr_processes(void)
 	int cpu;
 	int total = 0;
 
-	for_each_possible_cpu(cpu)
+	for_each_possible_cpu (cpu)
 		total += per_cpu(process_counts, cpu);
 
 	return total;
@@ -167,7 +171,11 @@ void __weak arch_release_task_struct(struct task_struct *tsk)
 }
 
 #ifndef CONFIG_ARCH_TASK_STRUCT_ALLOCATOR
+#ifdef CONFIG_IEE
+struct kmem_cache *task_struct_cachep;
+#else
 static struct kmem_cache *task_struct_cachep;
+#endif
 
 static inline struct task_struct *alloc_task_struct_node(int node)
 {
@@ -187,7 +195,7 @@ static inline void free_task_struct(struct task_struct *tsk)
  * Allocate pages if THREAD_SIZE is >= PAGE_SIZE, otherwise use a
  * kmemcache based allocator.
  */
-# if THREAD_SIZE >= PAGE_SIZE || defined(CONFIG_VMAP_STACK)
+#if THREAD_SIZE >= PAGE_SIZE || defined(CONFIG_VMAP_STACK)
 
 #ifdef CONFIG_VMAP_STACK
 /*
@@ -246,11 +254,11 @@ static unsigned long *alloc_thread_stack_node(struct task_struct *tsk, int node)
 	 * so memcg accounting is performed manually on assigning/releasing
 	 * stacks to tasks. Drop __GFP_ACCOUNT.
 	 */
-	stack = __vmalloc_node_range(THREAD_SIZE, THREAD_ALIGN,
-				     VMALLOC_START, VMALLOC_END,
+	stack = __vmalloc_node_range(THREAD_SIZE, THREAD_ALIGN, VMALLOC_START,
+				     VMALLOC_END,
 				     THREADINFO_GFP & ~__GFP_ACCOUNT,
-				     PAGE_KERNEL,
-				     0, node, __builtin_return_address(0));
+				     PAGE_KERNEL, 0, node,
+				     __builtin_return_address(0));
 
 	/*
 	 * We can't call find_vm_area() in interrupt context, and
@@ -263,8 +271,8 @@ static unsigned long *alloc_thread_stack_node(struct task_struct *tsk, int node)
 	}
 	return stack;
 #else
-	struct page *page = alloc_pages_node(node, THREADINFO_GFP,
-					     THREAD_SIZE_ORDER);
+	struct page *page =
+		alloc_pages_node(node, THREADINFO_GFP, THREAD_SIZE_ORDER);
 
 	if (likely(page)) {
 		tsk->stack = kasan_reset_tag(page_address(page));
@@ -286,8 +294,8 @@ static inline void free_thread_stack(struct task_struct *tsk)
 			memcg_kmem_uncharge_page(vm->pages[i], 0);
 
 		for (i = 0; i < NR_CACHED_STACKS; i++) {
-			if (this_cpu_cmpxchg(cached_stacks[i],
-					NULL, tsk->stack_vm_area) != NULL)
+			if (this_cpu_cmpxchg(cached_stacks[i], NULL,
+					     tsk->stack_vm_area) != NULL)
 				continue;
 
 			return;
@@ -300,11 +308,10 @@ static inline void free_thread_stack(struct task_struct *tsk)
 
 	__free_pages(virt_to_page(tsk->stack), THREAD_SIZE_ORDER);
 }
-# else
+#else
 static struct kmem_cache *thread_stack_cache;
 
-static unsigned long *alloc_thread_stack_node(struct task_struct *tsk,
-						  int node)
+static unsigned long *alloc_thread_stack_node(struct task_struct *tsk, int node)
 {
 	unsigned long *stack;
 	stack = kmem_cache_alloc_node(thread_stack_cache, THREADINFO_GFP, node);
@@ -320,12 +327,13 @@ static void free_thread_stack(struct task_struct *tsk)
 
 void thread_stack_cache_init(void)
 {
-	thread_stack_cache = kmem_cache_create_usercopy("thread_stack",
-					THREAD_SIZE, THREAD_SIZE, 0, 0,
-					THREAD_SIZE, NULL);
+	thread_stack_cache =
+		kmem_cache_create_usercopy("thread_stack", THREAD_SIZE,
+					   THREAD_SIZE, 0, 0, THREAD_SIZE,
+					   NULL);
 	BUG_ON(thread_stack_cache == NULL);
 }
-# endif
+#endif
 #endif
 
 /* SLAB cache for signal_struct structures (tsk->signal) */
@@ -358,7 +366,8 @@ struct vm_area_struct *vm_area_alloc(struct mm_struct *mm)
 
 struct vm_area_struct *vm_area_dup(struct vm_area_struct *orig)
 {
-	struct vm_area_struct *new = kmem_cache_alloc(vm_area_cachep, GFP_KERNEL);
+	struct vm_area_struct *new =
+		kmem_cache_alloc(vm_area_cachep, GFP_KERNEL);
 
 	if (new) {
 		ASSERT_EXCLUSIVE_WRITER(orig->vm_flags);
@@ -384,7 +393,6 @@ static void account_kernel_stack(struct task_struct *tsk, int account)
 	void *stack = task_stack_page(tsk);
 	struct vm_struct *vm = task_stack_vm_area(tsk);
 
-
 	/* All stack pages are in the same node. */
 	if (vm)
 		mod_lruvec_page_state(vm->pages[0], NR_KERNEL_STACK_KB,
@@ -427,7 +435,7 @@ static int memcg_charge_kernel_stack(struct task_struct *tsk)
 static void release_task_stack(struct task_struct *tsk)
 {
 	if (WARN_ON(tsk->state != TASK_DEAD))
-		return;  /* Better to leak the stack than to free prematurely */
+		return; /* Better to leak the stack than to free prematurely */
 
 	account_kernel_stack(tsk, -1);
 	free_thread_stack(tsk);
@@ -445,8 +453,19 @@ void put_task_stack(struct task_struct *tsk)
 }
 #endif
 
+#ifdef CONFIG_KOI
+extern s64 koi_offset;
+#endif
+
 void free_task(struct task_struct *tsk)
 {
+	#ifdef CONFIG_KOI
+    unsigned long koi_stack;
+    #ifndef CONFIG_IEE
+    unsigned long res, flags;
+    struct task_token *token;
+	#endif
+    #endif
 #ifdef CONFIG_SECCOMP
 	WARN_ON_ONCE(tsk->seccomp.filter);
 #endif
@@ -473,18 +492,31 @@ void free_task(struct task_struct *tsk)
 #ifdef CONFIG_QOS_SCHED_DYNAMIC_AFFINITY
 	sched_prefer_cpus_free(tsk);
 #endif
-#ifdef CONFIG_QOS_SCHED_SMART_GRID
-	sched_grid_qos_free(tsk);
+#ifdef CONFIG_IEE
+#ifdef CONFIG_KOI
+    // Free koi stack.
+    koi_stack = iee_rw_gate(IEE_READ_KOI_STACK_BASE, tsk);
+    if (koi_stack)
+        free_pages(koi_stack, 2);
+#endif
+	iee_invalidate_token(tsk);
+#else
+#ifdef CONFIG_KOI
+// free koi stack
+    token = (struct task_token *)((unsigned long)tsk + (unsigned long)koi_offset);
+    koi_stack = token->koi_stack_base;
+    if (koi_stack) {
+        free_pages(koi_stack, 2);
+    }
+#endif
 #endif
-	if (task_relationship_used())
-		sched_relationship_free(tsk);
 	free_task_struct(tsk);
 }
 EXPORT_SYMBOL(free_task);
 
 #ifdef CONFIG_MMU
 static __latent_entropy int dup_mmap(struct mm_struct *mm,
-					struct mm_struct *oldmm)
+				     struct mm_struct *oldmm)
 {
 	struct vm_area_struct *mpnt, *tmp, *prev, **pprev;
 	struct rb_node **rb_link, *rb_parent;
@@ -580,7 +612,7 @@ static __latent_entropy int dup_mmap(struct mm_struct *mm,
 			flush_dcache_mmap_lock(mapping);
 			/* insert tmp into the share list, just after mpnt */
 			vma_interval_tree_insert_after(tmp, mpnt,
-					&mapping->i_mmap);
+						       &mapping->i_mmap);
 			flush_dcache_mmap_unlock(mapping);
 			i_mmap_unlock_write(mapping);
 		}
@@ -655,7 +687,7 @@ static int dup_mmap(struct mm_struct *mm, struct mm_struct *oldmm)
 	mmap_write_unlock(oldmm);
 	return 0;
 }
-#define mm_alloc_pgd(mm)	(0)
+#define mm_alloc_pgd(mm) (0)
 #define mm_free_pgd(mm)
 #endif /* CONFIG_MMU */
 
@@ -663,28 +695,30 @@ static void check_mm(struct mm_struct *mm)
 {
 	int i;
 
-	BUILD_BUG_ON_MSG(ARRAY_SIZE(resident_page_types) != NR_MM_COUNTERS,
-			 "Please make sure 'struct resident_page_types[]' is updated as well");
+	BUILD_BUG_ON_MSG(
+		ARRAY_SIZE(resident_page_types) != NR_MM_COUNTERS,
+		"Please make sure 'struct resident_page_types[]' is updated as well");
 
 	for (i = 0; i < NR_MM_COUNTERS; i++) {
 		long x = atomic_long_read(&mm->rss_stat.count[i]);
 
 		if (unlikely(x))
-			pr_alert("BUG: Bad rss-counter state mm:%p type:%s val:%ld\n",
-				 mm, resident_page_types[i], x);
+			pr_alert(
+				"BUG: Bad rss-counter state mm:%p type:%s val:%ld\n",
+				mm, resident_page_types[i], x);
 	}
 
 	if (mm_pgtables_bytes(mm))
 		pr_alert("BUG: non-zero pgtables_bytes on freeing mm: %ld\n",
-				mm_pgtables_bytes(mm));
+			 mm_pgtables_bytes(mm));
 
 #if defined(CONFIG_TRANSPARENT_HUGEPAGE) && !USE_SPLIT_PMD_PTLOCKS
 	VM_BUG_ON_MM(mm->pmd_huge_pte, mm);
 #endif
 }
 
-#define allocate_mm()	(kmem_cache_alloc(mm_cachep, GFP_KERNEL))
-#define free_mm(mm)	(kmem_cache_free(mm_cachep, (mm)))
+#define allocate_mm() (kmem_cache_alloc(mm_cachep, GFP_KERNEL))
+#define free_mm(mm) (kmem_cache_free(mm_cachep, (mm)))
 
 /*
  * Called when the last reference to the mm
@@ -787,8 +821,8 @@ static void set_max_threads(unsigned int max_threads_suggested)
 	if (fls64(nr_pages) + fls64(PAGE_SIZE) > 64)
 		threads = MAX_THREADS;
 	else
-		threads = div64_u64((u64) nr_pages * (u64) PAGE_SIZE,
-				    (u64) THREAD_SIZE * 8UL);
+		threads = div64_u64((u64)nr_pages * (u64)PAGE_SIZE,
+				    (u64)THREAD_SIZE * 8UL);
 
 	if (threads > max_threads_suggested)
 		threads = max_threads_suggested;
@@ -823,17 +857,24 @@ void __init fork_init(void)
 	int i;
 #ifndef CONFIG_ARCH_TASK_STRUCT_ALLOCATOR
 #ifndef ARCH_MIN_TASKALIGN
-#define ARCH_MIN_TASKALIGN	0
+#define ARCH_MIN_TASKALIGN 0
 #endif
 	int align = max_t(int, L1_CACHE_BYTES, ARCH_MIN_TASKALIGN);
 	unsigned long useroffset, usersize;
 
 	/* create a slab on which task_structs can be allocated */
 	task_struct_whitelist(&useroffset, &usersize);
+	#ifdef CONFIG_IEE
 	task_struct_cachep = kmem_cache_create_usercopy("task_struct",
 			arch_task_struct_size, align,
-			SLAB_PANIC|SLAB_ACCOUNT,
+			SLAB_PANIC|SLAB_ACCOUNT|SLAB_RED_ZONE,
 			useroffset, usersize, NULL);
+	#else
+	task_struct_cachep =
+		kmem_cache_create_usercopy("task_struct", arch_task_struct_size,
+					   align, SLAB_PANIC | SLAB_ACCOUNT,
+					   useroffset, usersize, NULL);
+	#endif
 #endif
 
 	/* do the arch specific task caches init */
@@ -841,18 +882,18 @@ void __init fork_init(void)
 
 	set_max_threads(MAX_THREADS);
 
-	init_task.signal->rlim[RLIMIT_NPROC].rlim_cur = max_threads/2;
-	init_task.signal->rlim[RLIMIT_NPROC].rlim_max = max_threads/2;
+	init_task.signal->rlim[RLIMIT_NPROC].rlim_cur = max_threads / 2;
+	init_task.signal->rlim[RLIMIT_NPROC].rlim_max = max_threads / 2;
 	init_task.signal->rlim[RLIMIT_SIGPENDING] =
 		init_task.signal->rlim[RLIMIT_NPROC];
 
 	for (i = 0; i < UCOUNT_COUNTS; i++) {
-		init_user_ns.ucount_max[i] = max_threads/2;
+		init_user_ns.ucount_max[i] = max_threads / 2;
 	}
 
 #ifdef CONFIG_VMAP_STACK
-	cpuhp_setup_state(CPUHP_BP_PREPARE_DYN, "fork:vm_stack_cache",
-			  NULL, free_vm_stack_cache);
+	cpuhp_setup_state(CPUHP_BP_PREPARE_DYN, "fork:vm_stack_cache", NULL,
+			  free_vm_stack_cache);
 #endif
 
 	scs_init();
@@ -862,7 +903,7 @@ void __init fork_init(void)
 }
 
 int __weak arch_dup_task_struct(struct task_struct *dst,
-					       struct task_struct *src)
+				struct task_struct *src)
 {
 	*dst = *src;
 	return 0;
@@ -873,14 +914,14 @@ void set_task_stack_end_magic(struct task_struct *tsk)
 	unsigned long *stackend;
 
 	stackend = end_of_stack(tsk);
-	*stackend = STACK_END_MAGIC;	/* for overflow detection */
+	*stackend = STACK_END_MAGIC; /* for overflow detection */
 }
 
 static bool dup_resvd_task_struct(struct task_struct *dst,
 				  struct task_struct *orig, int node)
 {
-	dst->_resvd = kzalloc_node(sizeof(struct task_struct_resvd),
-					  GFP_KERNEL, node);
+	dst->_resvd = kzalloc_node(sizeof(struct task_struct_resvd), GFP_KERNEL,
+				   node);
 	if (!dst->_resvd)
 		return false;
 
@@ -1059,7 +1100,7 @@ static void mm_init_uprobes_state(struct mm_struct *mm)
 }
 
 static struct mm_struct *mm_init(struct mm_struct *mm, struct task_struct *p,
-	struct user_namespace *user_ns)
+				 struct user_namespace *user_ns)
 {
 	mm->mmap = NULL;
 	mm->mm_rb = RB_ROOT;
@@ -1119,7 +1160,8 @@ static struct mm_struct *mm_init(struct mm_struct *mm, struct task_struct *p,
 	return NULL;
 }
 
-static inline void mm_struct_clear(struct mm_struct *mm) {
+static inline void mm_struct_clear(struct mm_struct *mm)
+{
 	memset(mm, 0, sizeof(*mm));
 
 #if (defined(CONFIG_X86_64))
@@ -1127,9 +1169,10 @@ static inline void mm_struct_clear(struct mm_struct *mm) {
 	 * init the mm_struct_extend extra area at the bottom of
 	 * the allocated mm struct and reset mm->mm_extend accordingly.
 	 */
-	memset((void *)((unsigned long) mm + _MM_STRUCT_SIZE),
-		0, sizeof(struct mm_struct_extend));
-	mm->mm_extend = (struct mm_struct_extend *)((unsigned long) mm + _MM_STRUCT_SIZE);
+	memset((void *)((unsigned long)mm + _MM_STRUCT_SIZE), 0,
+	       sizeof(struct mm_struct_extend));
+	mm->mm_extend = (struct mm_struct_extend *)((unsigned long)mm +
+						    _MM_STRUCT_SIZE);
 #endif
 }
 
@@ -1188,8 +1231,8 @@ EXPORT_SYMBOL_GPL(mmput);
 #ifdef CONFIG_MMU
 static void mmput_async_fn(struct work_struct *work)
 {
-	struct mm_struct *mm = container_of(work, struct mm_struct,
-					    async_put_work);
+	struct mm_struct *mm =
+		container_of(work, struct mm_struct, async_put_work);
 
 	__mmput(mm);
 }
@@ -1319,13 +1362,12 @@ struct mm_struct *mm_access(struct task_struct *task, unsigned int mode)
 	struct mm_struct *mm;
 	int err;
 
-	err =  down_read_killable(&task->signal->exec_update_lock);
+	err = down_read_killable(&task->signal->exec_update_lock);
 	if (err)
 		return ERR_PTR(err);
 
 	mm = get_task_mm(task);
-	if (mm && mm != current->mm &&
-			!ptrace_may_access(task, mode)) {
+	if (mm && mm != current->mm && !ptrace_may_access(task, mode)) {
 		mmput(mm);
 		mm = ERR_PTR(-EACCES);
 	}
@@ -1349,7 +1391,7 @@ static void complete_vfork_done(struct task_struct *tsk)
 }
 
 static int wait_for_vfork_done(struct task_struct *child,
-				struct completion *vfork)
+			       struct completion *vfork)
 {
 	int killed;
 
@@ -1402,8 +1444,8 @@ static void mm_release(struct task_struct *tsk, struct mm_struct *mm)
 			 * not set up a proper pointer then tough luck.
 			 */
 			put_user(0, tsk->clear_child_tid);
-			do_futex(tsk->clear_child_tid, FUTEX_WAKE,
-					1, NULL, NULL, 0, 0);
+			do_futex(tsk->clear_child_tid, FUTEX_WAKE, 1, NULL,
+				 NULL, 0, 0);
 		}
 		tsk->clear_child_tid = NULL;
 	}
@@ -1438,11 +1480,12 @@ static inline void mm_struct_copy(struct mm_struct *mm, struct mm_struct *oldmm)
 	 * the oldmm slab object over to the newly allocated mm struct,
 	 * and reset mm->mm_extend accordingly.
 	 */
-	memcpy((void *)((unsigned long) mm + _MM_STRUCT_SIZE),
-		(void *)((unsigned long) oldmm + _MM_STRUCT_SIZE),
-		sizeof(struct mm_struct_extend));
+	memcpy((void *)((unsigned long)mm + _MM_STRUCT_SIZE),
+	       (void *)((unsigned long)oldmm + _MM_STRUCT_SIZE),
+	       sizeof(struct mm_struct_extend));
 
-	mm->mm_extend = (struct mm_struct_extend *)((unsigned long) mm + _MM_STRUCT_SIZE);
+	mm->mm_extend = (struct mm_struct_extend *)((unsigned long)mm +
+						    _MM_STRUCT_SIZE);
 #endif
 }
 
@@ -1506,6 +1549,9 @@ static int copy_mm(unsigned long clone_flags, struct task_struct *tsk)
 #endif
 
 	tsk->mm = NULL;
+#ifdef CONFIG_IEE
+	iee_set_token_pgd(tsk, NULL);
+#endif
 	tsk->active_mm = NULL;
 
 	/*
@@ -1533,6 +1579,9 @@ static int copy_mm(unsigned long clone_flags, struct task_struct *tsk)
 
 good_mm:
 	tsk->mm = mm;
+#ifdef CONFIG_IEE
+	iee_set_token_pgd(tsk, mm->pgd);
+#endif
 	tsk->active_mm = mm;
 	return 0;
 
@@ -1772,8 +1821,8 @@ static inline void init_task_pid_links(struct task_struct *task)
 	}
 }
 
-static inline void
-init_task_pid(struct task_struct *task, enum pid_type type, struct pid *pid)
+static inline void init_task_pid(struct task_struct *task, enum pid_type type,
+				 struct pid *pid)
 {
 	if (type == PIDTYPE_PID)
 		task->thread_pid = pid;
@@ -1948,6 +1997,12 @@ static void copy_oom_score_adj(u64 clone_flags, struct task_struct *tsk)
 	mutex_unlock(&oom_adj_mutex);
 }
 
+#if defined(CONFIG_KOI) && !defined(CONFIG_IEE)
+extern s64 koi_offset;
+extern void koi_init_token(struct task_struct *tsk);
+#endif
+
+
 /*
  * This creates a new process as a copy of the old one,
  * but does not actually start it yet.
@@ -1956,11 +2011,9 @@ static void copy_oom_score_adj(u64 clone_flags, struct task_struct *tsk)
  * parts of the process environment (as per the clone
  * flags). The actual kick-off is left to the caller.
  */
-static __latent_entropy struct task_struct *copy_process(
-					struct pid *pid,
-					int trace,
-					int node,
-					struct kernel_clone_args *args)
+static __latent_entropy struct task_struct *
+copy_process(struct pid *pid, int trace, int node,
+	     struct kernel_clone_args *args)
 {
 	int pidfd = -1, retval;
 	struct task_struct *p;
@@ -1973,10 +2026,12 @@ static __latent_entropy struct task_struct *copy_process(
 	 * Don't allow sharing the root directory with processes in a different
 	 * namespace
 	 */
-	if ((clone_flags & (CLONE_NEWNS|CLONE_FS)) == (CLONE_NEWNS|CLONE_FS))
+	if ((clone_flags & (CLONE_NEWNS | CLONE_FS)) ==
+	    (CLONE_NEWNS | CLONE_FS))
 		return ERR_PTR(-EINVAL);
 
-	if ((clone_flags & (CLONE_NEWUSER|CLONE_FS)) == (CLONE_NEWUSER|CLONE_FS))
+	if ((clone_flags & (CLONE_NEWUSER | CLONE_FS)) ==
+	    (CLONE_NEWUSER | CLONE_FS))
 		return ERR_PTR(-EINVAL);
 
 	/*
@@ -2001,7 +2056,7 @@ static __latent_entropy struct task_struct *copy_process(
 	 * from creating siblings.
 	 */
 	if ((clone_flags & CLONE_PARENT) &&
-				current->signal->flags & SIGNAL_UNKILLABLE)
+	    current->signal->flags & SIGNAL_UNKILLABLE)
 		return ERR_PTR(-EINVAL);
 
 	/*
@@ -2055,13 +2110,21 @@ static __latent_entropy struct task_struct *copy_process(
 	p = dup_task_struct(current, node);
 	if (!p)
 		goto fork_out;
+
+#ifdef CONFIG_IEE
+	iee_validate_token(p);
+#else 
+#ifdef CONFIG_KOI
+    koi_init_token(p);
+#endif
+#endif
 	if (args->io_thread) {
 		/*
 		 * Mark us an IO worker, and block any signal that isn't
 		 * fatal or STOP
 		 */
 		p->flags |= PF_IO_WORKER;
-		siginitsetinv(&p->blocked, sigmask(SIGKILL)|sigmask(SIGSTOP));
+		siginitsetinv(&p->blocked, sigmask(SIGKILL) | sigmask(SIGSTOP));
 	}
 
 	/*
@@ -2070,11 +2133,13 @@ static __latent_entropy struct task_struct *copy_process(
 	 * p->set_child_tid which is (ab)used as a kthread's data pointer for
 	 * kernel threads (PF_KTHREAD).
 	 */
-	p->set_child_tid = (clone_flags & CLONE_CHILD_SETTID) ? args->child_tid : NULL;
+	p->set_child_tid =
+		(clone_flags & CLONE_CHILD_SETTID) ? args->child_tid : NULL;
 	/*
 	 * Clear TID on mm_release()?
 	 */
-	p->clear_child_tid = (clone_flags & CLONE_CHILD_CLEARTID) ? args->child_tid : NULL;
+	p->clear_child_tid =
+		(clone_flags & CLONE_CHILD_CLEARTID) ? args->child_tid : NULL;
 
 	ftrace_graph_init_task(p);
 
@@ -2092,7 +2157,7 @@ static __latent_entropy struct task_struct *copy_process(
 #endif
 	retval = -EAGAIN;
 	if (atomic_read(&p->real_cred->user->processes) >=
-			task_rlimit(p, RLIMIT_NPROC)) {
+	    task_rlimit(p, RLIMIT_NPROC)) {
 		if (p->real_cred->user != INIT_USER &&
 		    !capable(CAP_SYS_RESOURCE) && !capable(CAP_SYS_ADMIN))
 			goto bad_fork_free;
@@ -2124,7 +2189,7 @@ static __latent_entropy struct task_struct *copy_process(
 	if (data_race(nr_threads >= max_threads))
 		goto bad_fork_cleanup_count;
 
-	delayacct_tsk_init(p);	/* Must remain after dup_task_struct() */
+	delayacct_tsk_init(p); /* Must remain after dup_task_struct() */
 	p->flags &= ~(PF_SUPERPRIV | PF_WQ_WORKER | PF_IDLE);
 	p->flags |= PF_FORKNOEXEC;
 	INIT_LIST_HEAD(&p->children);
@@ -2184,10 +2249,10 @@ static __latent_entropy struct task_struct *copy_process(
 #endif
 #ifdef CONFIG_TRACE_IRQFLAGS
 	memset(&p->irqtrace, 0, sizeof(p->irqtrace));
-	p->irqtrace.hardirq_disable_ip	= _THIS_IP_;
-	p->irqtrace.softirq_enable_ip	= _THIS_IP_;
-	p->softirqs_enabled		= 1;
-	p->softirq_context		= 0;
+	p->irqtrace.hardirq_disable_ip = _THIS_IP_;
+	p->irqtrace.softirq_enable_ip = _THIS_IP_;
+	p->softirqs_enabled = 1;
+	p->softirq_context = 0;
 #endif
 
 	p->pagefault_disabled = 0;
@@ -2200,8 +2265,8 @@ static __latent_entropy struct task_struct *copy_process(
 	p->blocked_on = NULL; /* not blocked yet */
 #endif
 #ifdef CONFIG_BCACHE
-	p->sequential_io	= 0;
-	p->sequential_io_avg	= 0;
+	p->sequential_io = 0;
+	p->sequential_io_avg = 0;
 #endif
 #ifdef CONFIG_BPF_SYSCALL
 	p->bpf_ctx = NULL;
@@ -2247,7 +2312,8 @@ static __latent_entropy struct task_struct *copy_process(
 	retval = copy_io(clone_flags, p);
 	if (retval)
 		goto bad_fork_cleanup_namespaces;
-	retval = copy_thread(clone_flags, args->stack, args->stack_size, p, args->tls);
+	retval = copy_thread(clone_flags, args->stack, args->stack_size, p,
+			     args->tls);
 	if (retval)
 		goto bad_fork_cleanup_io;
 
@@ -2275,13 +2341,13 @@ static __latent_entropy struct task_struct *copy_process(
 		pidfd = retval;
 
 		pidfile = anon_inode_getfile("[pidfd]", &pidfd_fops, pid,
-					      O_RDWR | O_CLOEXEC);
+					     O_RDWR | O_CLOEXEC);
 		if (IS_ERR(pidfile)) {
 			put_unused_fd(pidfd);
 			retval = PTR_ERR(pidfile);
 			goto bad_fork_free_pid;
 		}
-		get_pid(pid);	/* held by pidfile now */
+		get_pid(pid); /* held by pidfile now */
 
 		retval = put_user(pidfd, args->pidfd);
 		if (retval)
@@ -2296,7 +2362,7 @@ static __latent_entropy struct task_struct *copy_process(
 	/*
 	 * sigaltstack should be cleared when sharing the same VM
 	 */
-	if ((clone_flags & (CLONE_VM|CLONE_VFORK)) == CLONE_VM)
+	if ((clone_flags & (CLONE_VM | CLONE_VFORK)) == CLONE_VM)
 		sas_ss_reset(p);
 
 	/*
@@ -2368,7 +2434,7 @@ static __latent_entropy struct task_struct *copy_process(
 	write_lock_irq(&tasklist_lock);
 
 	/* CLONE_PARENT re-uses the old parent */
-	if (clone_flags & (CLONE_PARENT|CLONE_THREAD)) {
+	if (clone_flags & (CLONE_PARENT | CLONE_THREAD)) {
 		p->real_parent = current->real_parent;
 		p->parent_exec_id = current->parent_exec_id;
 		if (clone_flags & CLONE_THREAD)
@@ -2430,8 +2496,9 @@ static __latent_entropy struct task_struct *copy_process(
 			 * tasklist_lock with adding child to the process tree
 			 * for propagate_has_child_subreaper optimization.
 			 */
-			p->signal->has_child_subreaper = p->real_parent->signal->has_child_subreaper ||
-							 p->real_parent->signal->is_child_subreaper;
+			p->signal->has_child_subreaper =
+				p->real_parent->signal->has_child_subreaper ||
+				p->real_parent->signal->is_child_subreaper;
 			list_add_tail(&p->sibling, &p->real_parent->children);
 			list_add_tail_rcu(&p->tasks, &init_task.tasks);
 			attach_pid(p, PIDTYPE_TGID);
@@ -2545,7 +2612,7 @@ static inline void init_idle_pids(struct task_struct *idle)
 	}
 }
 
-struct task_struct * __init fork_idle(int cpu)
+struct task_struct *__init fork_idle(int cpu)
 {
 	struct task_struct *task;
 	struct kernel_clone_args args = {
@@ -2569,15 +2636,15 @@ struct task_struct * __init fork_idle(int cpu)
  */
 struct task_struct *create_io_thread(int (*fn)(void *), void *arg, int node)
 {
-	unsigned long flags = CLONE_FS|CLONE_FILES|CLONE_SIGHAND|CLONE_THREAD|
-				CLONE_IO;
+	unsigned long flags = CLONE_FS | CLONE_FILES | CLONE_SIGHAND |
+			      CLONE_THREAD | CLONE_IO;
 	struct kernel_clone_args args = {
-		.flags		= ((lower_32_bits(flags) | CLONE_VM |
-				    CLONE_UNTRACED) & ~CSIGNAL),
-		.exit_signal	= (lower_32_bits(flags) & CSIGNAL),
-		.stack		= (unsigned long)fn,
-		.stack_size	= (unsigned long)arg,
-		.io_thread	= 1,
+		.flags = ((lower_32_bits(flags) | CLONE_VM | CLONE_UNTRACED) &
+			  ~CSIGNAL),
+		.exit_signal = (lower_32_bits(flags) & CSIGNAL),
+		.stack = (unsigned long)fn,
+		.stack_size = (unsigned long)arg,
+		.io_thread = 1,
 	};
 
 	return copy_process(NULL, 0, node, &args);
@@ -2677,11 +2744,11 @@ pid_t kernel_clone(struct kernel_clone_args *args)
 pid_t kernel_thread(int (*fn)(void *), void *arg, unsigned long flags)
 {
 	struct kernel_clone_args args = {
-		.flags		= ((lower_32_bits(flags) | CLONE_VM |
-				    CLONE_UNTRACED) & ~CSIGNAL),
-		.exit_signal	= (lower_32_bits(flags) & CSIGNAL),
-		.stack		= (unsigned long)fn,
-		.stack_size	= (unsigned long)arg,
+		.flags = ((lower_32_bits(flags) | CLONE_VM | CLONE_UNTRACED) &
+			  ~CSIGNAL),
+		.exit_signal = (lower_32_bits(flags) & CSIGNAL),
+		.stack = (unsigned long)fn,
+		.stack_size = (unsigned long)arg,
 	};
 
 	return kernel_clone(&args);
@@ -2707,8 +2774,8 @@ SYSCALL_DEFINE0(fork)
 SYSCALL_DEFINE0(vfork)
 {
 	struct kernel_clone_args args = {
-		.flags		= CLONE_VFORK | CLONE_VM,
-		.exit_signal	= SIGCHLD,
+		.flags = CLONE_VFORK | CLONE_VM,
+		.exit_signal = SIGCHLD,
 	};
 
 	return kernel_clone(&args);
@@ -2718,35 +2785,30 @@ SYSCALL_DEFINE0(vfork)
 #ifdef __ARCH_WANT_SYS_CLONE
 #ifdef CONFIG_CLONE_BACKWARDS
 SYSCALL_DEFINE5(clone, unsigned long, clone_flags, unsigned long, newsp,
-		 int __user *, parent_tidptr,
-		 unsigned long, tls,
-		 int __user *, child_tidptr)
+		int __user *, parent_tidptr, unsigned long, tls, int __user *,
+		child_tidptr)
 #elif defined(CONFIG_CLONE_BACKWARDS2)
 SYSCALL_DEFINE5(clone, unsigned long, newsp, unsigned long, clone_flags,
-		 int __user *, parent_tidptr,
-		 int __user *, child_tidptr,
-		 unsigned long, tls)
-#elif defined(CONFIG_CLONE_BACKWARDS3)
-SYSCALL_DEFINE6(clone, unsigned long, clone_flags, unsigned long, newsp,
-		int, stack_size,
-		int __user *, parent_tidptr,
-		int __user *, child_tidptr,
+		int __user *, parent_tidptr, int __user *, child_tidptr,
 		unsigned long, tls)
+#elif defined(CONFIG_CLONE_BACKWARDS3)
+SYSCALL_DEFINE6(clone, unsigned long, clone_flags, unsigned long, newsp, int,
+		stack_size, int __user *, parent_tidptr, int __user *,
+		child_tidptr, unsigned long, tls)
 #else
 SYSCALL_DEFINE5(clone, unsigned long, clone_flags, unsigned long, newsp,
-		 int __user *, parent_tidptr,
-		 int __user *, child_tidptr,
-		 unsigned long, tls)
+		int __user *, parent_tidptr, int __user *, child_tidptr,
+		unsigned long, tls)
 #endif
 {
 	struct kernel_clone_args args = {
-		.flags		= (lower_32_bits(clone_flags) & ~CSIGNAL),
-		.pidfd		= parent_tidptr,
-		.child_tid	= child_tidptr,
-		.parent_tid	= parent_tidptr,
-		.exit_signal	= (lower_32_bits(clone_flags) & CSIGNAL),
-		.stack		= newsp,
-		.tls		= tls,
+		.flags = (lower_32_bits(clone_flags) & ~CSIGNAL),
+		.pidfd = parent_tidptr,
+		.child_tid = child_tidptr,
+		.parent_tid = parent_tidptr,
+		.exit_signal = (lower_32_bits(clone_flags) & CSIGNAL),
+		.stack = newsp,
+		.tls = tls,
 	};
 
 	return kernel_clone(&args);
@@ -2802,21 +2864,21 @@ noinline static int copy_clone_args_from_user(struct kernel_clone_args *kargs,
 		return -EINVAL;
 
 	*kargs = (struct kernel_clone_args){
-		.flags		= args.flags,
-		.pidfd		= u64_to_user_ptr(args.pidfd),
-		.child_tid	= u64_to_user_ptr(args.child_tid),
-		.parent_tid	= u64_to_user_ptr(args.parent_tid),
-		.exit_signal	= args.exit_signal,
-		.stack		= args.stack,
-		.stack_size	= args.stack_size,
-		.tls		= args.tls,
-		.set_tid_size	= args.set_tid_size,
-		.cgroup		= args.cgroup,
+		.flags = args.flags,
+		.pidfd = u64_to_user_ptr(args.pidfd),
+		.child_tid = u64_to_user_ptr(args.child_tid),
+		.parent_tid = u64_to_user_ptr(args.parent_tid),
+		.exit_signal = args.exit_signal,
+		.stack = args.stack,
+		.stack_size = args.stack_size,
+		.tls = args.tls,
+		.set_tid_size = args.set_tid_size,
+		.cgroup = args.cgroup,
 	};
 
 	if (args.set_tid &&
-		copy_from_user(kset_tid, u64_to_user_ptr(args.set_tid),
-			(kargs->set_tid_size * sizeof(pid_t))))
+	    copy_from_user(kset_tid, u64_to_user_ptr(args.set_tid),
+			   (kargs->set_tid_size * sizeof(pid_t))))
 		return -EFAULT;
 
 	kargs->set_tid = kset_tid;
@@ -2911,7 +2973,8 @@ SYSCALL_DEFINE2(clone3, struct clone_args __user *, uargs, size_t, size)
 }
 #endif
 
-void walk_process_tree(struct task_struct *top, proc_visitor visitor, void *data)
+void walk_process_tree(struct task_struct *top, proc_visitor visitor,
+		       void *data)
 {
 	struct task_struct *leader, *parent, *child;
 	int res;
@@ -2919,8 +2982,8 @@ void walk_process_tree(struct task_struct *top, proc_visitor visitor, void *data
 	read_lock(&tasklist_lock);
 	leader = top = top->group_leader;
 down:
-	for_each_thread(leader, parent) {
-		list_for_each_entry(child, &parent->children, sibling) {
+	for_each_thread (leader, parent) {
+		list_for_each_entry (child, &parent->children, sibling) {
 			res = visitor(child, data);
 			if (res) {
 				if (res < 0)
@@ -2928,8 +2991,7 @@ void walk_process_tree(struct task_struct *top, proc_visitor visitor, void *data
 				leader = child;
 				goto down;
 			}
-up:
-			;
+		up:;
 		}
 	}
 
@@ -3003,11 +3065,11 @@ void __init proc_caches_init(void)
  */
 static int check_unshare_flags(unsigned long unshare_flags)
 {
-	if (unshare_flags & ~(CLONE_THREAD|CLONE_FS|CLONE_NEWNS|CLONE_SIGHAND|
-				CLONE_VM|CLONE_FILES|CLONE_SYSVSEM|
-				CLONE_NEWUTS|CLONE_NEWIPC|CLONE_NEWNET|
-				CLONE_NEWUSER|CLONE_NEWPID|CLONE_NEWCGROUP|
-				CLONE_NEWTIME))
+	if (unshare_flags &
+	    ~(CLONE_THREAD | CLONE_FS | CLONE_NEWNS | CLONE_SIGHAND | CLONE_VM |
+	      CLONE_FILES | CLONE_SYSVSEM | CLONE_NEWUTS | CLONE_NEWIPC |
+	      CLONE_NEWNET | CLONE_NEWUSER | CLONE_NEWPID | CLONE_NEWCGROUP |
+	      CLONE_NEWTIME))
 		return -EINVAL;
 	/*
 	 * Not implemented, but pretend it works if there is nothing
@@ -3118,7 +3180,7 @@ int ksys_unshare(unsigned long unshare_flags)
 	 * to a new ipc namespace, the semaphore arrays from the old
 	 * namespace are unreachable.
 	 */
-	if (unshare_flags & (CLONE_NEWIPC|CLONE_SYSVSEM))
+	if (unshare_flags & (CLONE_NEWIPC | CLONE_SYSVSEM))
 		do_sysvsem = 1;
 	err = unshare_fs(unshare_flags, &new_fs);
 	if (err)
@@ -3129,8 +3191,8 @@ int ksys_unshare(unsigned long unshare_flags)
 	err = unshare_userns(unshare_flags, &new_cred);
 	if (err)
 		goto bad_unshare_cleanup_fd;
-	err = unshare_nsproxy_namespaces(unshare_flags, &new_nsproxy,
-					 new_cred, new_fs);
+	err = unshare_nsproxy_namespaces(unshare_flags, &new_nsproxy, new_cred,
+					 new_fs);
 	if (err)
 		goto bad_unshare_cleanup_cred;
 
@@ -3224,8 +3286,8 @@ int unshare_files(struct files_struct **displaced)
 	return 0;
 }
 
-int sysctl_max_threads(struct ctl_table *table, int write,
-		       void *buffer, size_t *lenp, loff_t *ppos)
+int sysctl_max_threads(struct ctl_table *table, int write, void *buffer,
+		       size_t *lenp, loff_t *ppos)
 {
 	struct ctl_table t;
 	int ret;
diff --git a/kernel/groups.c b/kernel/groups.c
index fe7e6385530e..bdecd21c0caf 100644
--- a/kernel/groups.c
+++ b/kernel/groups.c
@@ -11,6 +11,9 @@
 #include <linux/user_namespace.h>
 #include <linux/vmalloc.h>
 #include <linux/uaccess.h>
+#ifdef CONFIG_CREDP
+#include <asm/iee-cred.h>
+#endif
 
 struct group_info *groups_alloc(int gidsetsize)
 {
@@ -124,7 +127,11 @@ void set_groups(struct cred *new, struct group_info *group_info)
 {
 	put_group_info(new->group_info);
 	get_group_info(group_info);
+	#ifdef CONFIG_CREDP
+	iee_set_cred_group_info(new,group_info);
+	#else
 	new->group_info = group_info;
+	#endif
 }
 
 EXPORT_SYMBOL(set_groups);
diff --git a/kernel/kthread.c b/kernel/kthread.c
index 508fe5278285..2114298f14e7 100644
--- a/kernel/kthread.c
+++ b/kernel/kthread.c
@@ -30,6 +30,10 @@
 #include <linux/sched/isolation.h>
 #include <trace/events/sched.h>
 
+#ifdef CONFIG_IEE
+#include <linux/iee-func.h>
+#endif
+
 
 static DEFINE_SPINLOCK(kthread_create_lock);
 static LIST_HEAD(kthread_create_list);
@@ -1325,6 +1329,9 @@ void kthread_use_mm(struct mm_struct *mm)
 		tsk->active_mm = mm;
 	}
 	tsk->mm = mm;
+	#ifdef CONFIG_IEE
+	iee_set_token_pgd(tsk, mm->pgd);
+	#endif
 	switch_mm_irqs_off(active_mm, mm, tsk);
 	local_irq_enable();
 	task_unlock(tsk);
@@ -1356,6 +1363,9 @@ void kthread_unuse_mm(struct mm_struct *mm)
 	sync_mm_rss(mm);
 	local_irq_disable();
 	tsk->mm = NULL;
+	#ifdef CONFIG_IEE
+	iee_set_token_pgd(tsk, NULL);
+	#endif
 	/* active_mm is still 'mm' */
 	enter_lazy_tlb(mm, tsk);
 	local_irq_enable();
diff --git a/kernel/module.c b/kernel/module.c
index e978debc93df..b45b8c2ff2ca 100644
--- a/kernel/module.c
+++ b/kernel/module.c
@@ -66,6 +66,10 @@
 #define CREATE_TRACE_POINTS
 #include <trace/events/module.h>
 
+#ifdef CONFIG_KOI
+#include "asm/koi.h"
+#endif
+
 #ifndef ARCH_SHF_SMALL
 #define ARCH_SHF_SMALL 0
 #endif
@@ -1045,6 +1049,7 @@ SYSCALL_DEFINE2(delete_module, const char __user *, name_user,
 	/* Final destruction now no one is using it. */
 	if (mod->exit != NULL)
 		mod->exit();
+
 	blocking_notifier_call_chain(&module_notify_list,
 				     MODULE_STATE_GOING, mod);
 	klp_module_going(mod);
@@ -1054,7 +1059,11 @@ SYSCALL_DEFINE2(delete_module, const char __user *, name_user,
 
 	/* Store the name of the last unloaded module for diagnostic purposes */
 	strlcpy(last_unloaded_module, mod->name, sizeof(last_unloaded_module));
-
+#ifdef CONFIG_KOI
+    koi_destroy_pagetable(mod);
+    
+    printk(KERN_ERR "pagetable destroyed\n");
+#endif
 	free_module(mod);
 	/* someone could wait for the module in add_unformed_module() */
 	wake_up_all(&module_wq);
@@ -3799,6 +3808,9 @@ static noinline int do_init_module(struct module *mod)
 	module_enable_ro(mod, true);
 	mod_tree_remove_init(mod);
 	module_arch_freeing_init(mod);
+// #ifdef CONFIG_KOI
+//     koi_unmap_mem(mod, mod->init_layout.base, mod->init_layout.size);
+// #endif
 	mod->init_layout.base = NULL;
 	mod->init_layout.size = 0;
 	mod->init_layout.ro_size = 0;
@@ -3977,6 +3989,17 @@ static int load_module(struct load_info *info, const char __user *uargs,
 	struct module *mod;
 	long err = 0;
 	char *after_dashes;
+#ifdef CONFIG_KOI
+
+    struct mm_struct *ko_mm;
+	pgd_t *ko_pg_dir;
+	struct shared_variable_descriptor *desc;
+	unsigned int ndx, i, j;
+	unsigned int num_desc;
+	unsigned int *get_val_id, *from_id_get_ad;
+    unsigned long addr;
+    struct koi_mem_hash_node *target;
+#endif
 
 	/*
 	 * Do the signature check (if any) first. All that
@@ -4116,7 +4139,53 @@ static int load_module(struct load_info *info, const char __user *uargs,
 	err = prepare_coming_module(mod);
 	if (err)
 		goto bug_cleanup;
+#ifdef CONFIG_KOI
+	/*
+	 * find the shared_vars_section and get the shared var list
+	 */
+	ndx = find_sec(info, ".shared_vars_section");
+	if (ndx){
+        koi_create_pagetable(mod);
+		target = NULL;
+		rcu_read_lock();
+		hash_for_each_possible_rcu (koi_mem_htbl, target, node,
+						(unsigned long)mod) {
+			if (target->mod == mod) {
+				break;
+			}
+		}
+		rcu_read_unlock();
+
+		if (target == NULL) {
+			printk("mem node for module: %s not found\n", mod->name);
+			return 0;
+		}
 
+		ko_mm = target->ko_mm;
+		ko_pg_dir = target->pgdp;
+
+		desc = (struct shared_variable_descriptor *)info->sechdrs[ndx].sh_addr;
+
+		num_desc = info->sechdrs[ndx].sh_size / sizeof(struct shared_variable_descriptor);
+		get_val_id = kmalloc(DRIVER_ISOLATION_MAX_VAL, GFP_KERNEL);
+		from_id_get_ad = kmalloc(DRIVER_ISOLATION_MAX_VAL, GFP_KERNEL);
+        
+        for (j = 0; j < num_desc; j++) {
+            unsigned int desc_id = desc[j].id;
+            get_val_id[j] = desc_id;
+			from_id_get_ad[desc_id] = j;
+        }
+		
+		for (i = 0; i < num_desc; i++) {
+			if (desc[i].type == 0) {
+				addr = kallsyms_lookup_name(desc[i].name);
+				koi_copy_pagetable(ko_mm, ko_pg_dir, addr & PAGE_MASK, (addr + desc[i].size + PAGE_SIZE) & PAGE_MASK);
+            }
+		}
+		kfree(get_val_id);
+		kfree(from_id_get_ad);
+	}
+#endif
 	/* Module is ready to execute: parsing args may do that. */
 	after_dashes = parse_args(mod->name, mod->args, mod->kp, mod->num_kp,
 				  -32768, 32767, mod,
diff --git a/kernel/smpboot.c b/kernel/smpboot.c
index e4163042c4d6..4df33347ad54 100644
--- a/kernel/smpboot.c
+++ b/kernel/smpboot.c
@@ -47,6 +47,7 @@ void __init idle_thread_set_boot_cpu(void)
  *
  * Creates the thread if it does not exist.
  */
+
 static inline void idle_init(unsigned int cpu)
 {
 	struct task_struct *tsk = per_cpu(idle_threads, cpu);
diff --git a/kernel/stacktrace.c b/kernel/stacktrace.c
index 9c625257023d..f746a271138b 100644
--- a/kernel/stacktrace.c
+++ b/kernel/stacktrace.c
@@ -15,6 +15,10 @@
 #include <linux/stacktrace.h>
 #include <linux/interrupt.h>
 
+#ifdef CONFIG_IEE
+#include <linux/iee-func.h>
+#endif
+
 /**
  * stack_trace_print - Print the entries in the stack trace
  * @entries:	Pointer to storage array
@@ -94,6 +98,23 @@ static bool stack_trace_consume_entry(void *cookie, unsigned long addr)
 	return c->len < c->size;
 }
 
+#ifdef CONFIG_IEE
+static bool stack_trace_consume_entry_iee(void *cookie, unsigned long addr)
+{
+	struct stacktrace_cookie *c = cookie;
+
+	if (c->len >= c->size)
+		return false;
+
+	if (c->skip > 0) {
+		c->skip--;
+		return true;
+	}
+	iee_write_in_byte(&(c->store[c->len++]), addr, 8);
+	return c->len < c->size;
+}
+#endif
+
 static bool stack_trace_consume_entry_nosched(void *cookie, unsigned long addr)
 {
 	if (in_sched_functions(addr))
@@ -124,6 +145,23 @@ unsigned int stack_trace_save(unsigned long *store, unsigned int size,
 }
 EXPORT_SYMBOL_GPL(stack_trace_save);
 
+#ifdef CONFIG_IEE
+unsigned int stack_trace_save_iee(unsigned long *store, unsigned int size,
+			      unsigned int skipnr)
+{
+	stack_trace_consume_fn consume_entry = stack_trace_consume_entry_iee;
+	struct stacktrace_cookie c = {
+		.store	= store,
+		.size	= size,
+		.skip	= skipnr + 1,
+	};
+
+	arch_stack_walk(consume_entry, &c, current, NULL);
+	return c.len;
+}
+EXPORT_SYMBOL_GPL(stack_trace_save_iee);
+#endif
+
 /**
  * stack_trace_save_tsk - Save a task stack trace into a storage array
  * @task:	The task to examine
diff --git a/kernel/sys.c b/kernel/sys.c
index 566ba957014d..24ff8befe071 100644
--- a/kernel/sys.c
+++ b/kernel/sys.c
@@ -73,6 +73,10 @@
 #include <asm/io.h>
 #include <asm/unistd.h>
 
+#ifdef CONFIG_CREDP
+#include <asm/iee-cred.h>
+#endif
+
 #include "uid16.h"
 
 #ifndef SET_UNALIGN_CTL
@@ -381,7 +385,11 @@ long __sys_setregid(gid_t rgid, gid_t egid)
 		if (gid_eq(old->gid, krgid) ||
 		    gid_eq(old->egid, krgid) ||
 		    ns_capable_setid(old->user_ns, CAP_SETGID))
+			#ifdef CONFIG_CREDP
+			iee_set_cred_gid(new,krgid);
+			#else
 			new->gid = krgid;
+			#endif
 		else
 			goto error;
 	}
@@ -390,15 +398,27 @@ long __sys_setregid(gid_t rgid, gid_t egid)
 		    gid_eq(old->egid, kegid) ||
 		    gid_eq(old->sgid, kegid) ||
 		    ns_capable_setid(old->user_ns, CAP_SETGID))
+			#ifdef CONFIG_CREDP
+			iee_set_cred_egid(new,kegid);
+			#else
 			new->egid = kegid;
+			#endif
 		else
 			goto error;
 	}
 
 	if (rgid != (gid_t) -1 ||
 	    (egid != (gid_t) -1 && !gid_eq(kegid, old->gid)))
+		#ifdef CONFIG_CREDP
+		iee_set_cred_sgid(new,new->egid);
+		#else
 		new->sgid = new->egid;
+		#endif
+	#ifdef CONFIG_CREDP
+	iee_set_cred_fsgid(new,new->egid);
+	#else
 	new->fsgid = new->egid;
+	#endif
 
 	retval = security_task_fix_setgid(new, old, LSM_SETID_RE);
 	if (retval < 0)
@@ -440,9 +460,25 @@ long __sys_setgid(gid_t gid)
 
 	retval = -EPERM;
 	if (ns_capable_setid(old->user_ns, CAP_SETGID))
+		#ifdef CONFIG_CREDP
+	{
+		iee_set_cred_fsgid(new,kgid);
+		iee_set_cred_sgid(new,kgid);
+		iee_set_cred_egid(new,kgid);
+		iee_set_cred_gid(new,kgid);
+	}
+		#else
 		new->gid = new->egid = new->sgid = new->fsgid = kgid;
+		#endif
 	else if (gid_eq(kgid, old->gid) || gid_eq(kgid, old->sgid))
+		#ifdef CONFIG_CREDP
+	{
+		iee_set_cred_fsgid(new,kgid);
+		iee_set_cred_egid(new,kgid);
+	}
+		#else
 		new->egid = new->fsgid = kgid;
+		#endif
 	else
 		goto error;
 
@@ -487,7 +523,11 @@ static int set_user(struct cred *new)
 		current->flags &= ~PF_NPROC_EXCEEDED;
 
 	free_uid(new->user);
+	#ifdef CONFIG_CREDP
+	iee_set_cred_user(new,new_user);
+	#else
 	new->user = new_user;
+	#endif
 	return 0;
 }
 
@@ -529,7 +569,11 @@ long __sys_setreuid(uid_t ruid, uid_t euid)
 
 	retval = -EPERM;
 	if (ruid != (uid_t) -1) {
+		#ifdef CONFIG_CREDP
+		iee_set_cred_uid(new,kruid);
+		#else
 		new->uid = kruid;
+		#endif
 		if (!uid_eq(old->uid, kruid) &&
 		    !uid_eq(old->euid, kruid) &&
 		    !ns_capable_setid(old->user_ns, CAP_SETUID))
@@ -537,7 +581,11 @@ long __sys_setreuid(uid_t ruid, uid_t euid)
 	}
 
 	if (euid != (uid_t) -1) {
+		#ifdef CONFIG_CREDP
+		iee_set_cred_euid(new,keuid);
+		#else
 		new->euid = keuid;
+		#endif
 		if (!uid_eq(old->uid, keuid) &&
 		    !uid_eq(old->euid, keuid) &&
 		    !uid_eq(old->suid, keuid) &&
@@ -552,8 +600,16 @@ long __sys_setreuid(uid_t ruid, uid_t euid)
 	}
 	if (ruid != (uid_t) -1 ||
 	    (euid != (uid_t) -1 && !uid_eq(keuid, old->uid)))
+		#ifdef CONFIG_CREDP
+		iee_set_cred_suid(new,new->euid);
+		#else
 		new->suid = new->euid;
+		#endif
+	#ifdef CONFIG_CREDP
+	iee_set_cred_fsuid(new,new->euid);
+	#else
 	new->fsuid = new->euid;
+	#endif
 
 	retval = security_task_fix_setuid(new, old, LSM_SETID_RE);
 	if (retval < 0)
@@ -601,7 +657,12 @@ long __sys_setuid(uid_t uid)
 
 	retval = -EPERM;
 	if (ns_capable_setid(old->user_ns, CAP_SETUID)) {
+		#ifdef CONFIG_CREDP
+		iee_set_cred_uid(new,kuid);
+		iee_set_cred_suid(new,kuid);
+		#else
 		new->suid = new->uid = kuid;
+		#endif
 		if (!uid_eq(kuid, old->uid)) {
 			retval = set_user(new);
 			if (retval < 0)
@@ -611,7 +672,12 @@ long __sys_setuid(uid_t uid)
 		goto error;
 	}
 
+	#ifdef CONFIG_CREDP
+	iee_set_cred_euid(new,kuid);
+	iee_set_cred_fsuid(new,kuid);
+	#else
 	new->fsuid = new->euid = kuid;
+	#endif
 
 	retval = security_task_fix_setuid(new, old, LSM_SETID_ID);
 	if (retval < 0)
@@ -680,7 +746,11 @@ long __sys_setresuid(uid_t ruid, uid_t euid, uid_t suid)
 		return -ENOMEM;
 
 	if (ruid != (uid_t) -1) {
+		#ifdef CONFIG_CREDP
+		iee_set_cred_uid(new,kruid);
+		#else
 		new->uid = kruid;
+		#endif
 		if (!uid_eq(kruid, old->uid)) {
 			retval = set_user(new);
 			if (retval < 0)
@@ -688,10 +758,22 @@ long __sys_setresuid(uid_t ruid, uid_t euid, uid_t suid)
 		}
 	}
 	if (euid != (uid_t) -1)
+		#ifdef CONFIG_CREDP
+		iee_set_cred_euid(new,keuid);
+		#else
 		new->euid = keuid;
+		#endif
 	if (suid != (uid_t) -1)
+		#ifdef CONFIG_CREDP
+		iee_set_cred_suid(new,ksuid);
+		#else
 		new->suid = ksuid;
+		#endif
+	#ifdef CONFIG_CREDP
+	iee_set_cred_fsuid(new,new->euid);
+	#else
 	new->fsuid = new->euid;
+	#endif
 
 	retval = security_task_fix_setuid(new, old, LSM_SETID_RES);
 	if (retval < 0)
@@ -775,12 +857,29 @@ long __sys_setresgid(gid_t rgid, gid_t egid, gid_t sgid)
 		return -ENOMEM;
 
 	if (rgid != (gid_t) -1)
+		#ifdef CONFIG_CREDP
+		iee_set_cred_gid(new,krgid);
+		#else
 		new->gid = krgid;
+		#endif
 	if (egid != (gid_t) -1)
+		#ifdef CONFIG_CREDP
+		iee_set_cred_egid(new,kegid);
+		#else
 		new->egid = kegid;
+		#endif
 	if (sgid != (gid_t) -1)
+		#ifdef CONFIG_CREDP
+		iee_set_cred_sgid(new,ksgid);
+		#else
 		new->sgid = ksgid;
+		#endif
+
+	#ifdef CONFIG_CREDP
+	iee_set_cred_fsgid(new,new->egid);
+	#else
 	new->fsgid = new->egid;
+	#endif
 
 	retval = security_task_fix_setgid(new, old, LSM_SETID_RES);
 	if (retval < 0)
@@ -847,7 +946,11 @@ long __sys_setfsuid(uid_t uid)
 	    uid_eq(kuid, old->suid) || uid_eq(kuid, old->fsuid) ||
 	    ns_capable_setid(old->user_ns, CAP_SETUID)) {
 		if (!uid_eq(kuid, old->fsuid)) {
+			#ifdef CONFIG_CREDP
+			iee_set_cred_fsuid(new,kuid);
+			#else
 			new->fsuid = kuid;
+			#endif
 			if (security_task_fix_setuid(new, old, LSM_SETID_FS) == 0)
 				goto change_okay;
 		}
@@ -891,7 +994,11 @@ long __sys_setfsgid(gid_t gid)
 	    gid_eq(kgid, old->sgid) || gid_eq(kgid, old->fsgid) ||
 	    ns_capable_setid(old->user_ns, CAP_SETGID)) {
 		if (!gid_eq(kgid, old->fsgid)) {
+			#ifdef CONFIG_CREDP
+			iee_set_cred_fsgid(new,kgid);
+			#else
 			new->fsgid = kgid;
+			#endif
 			if (security_task_fix_setgid(new,old,LSM_SETID_FS) == 0)
 				goto change_okay;
 		}
diff --git a/kernel/umh.c b/kernel/umh.c
index 3f646613a9d3..7ad7acb8629d 100644
--- a/kernel/umh.c
+++ b/kernel/umh.c
@@ -30,6 +30,10 @@
 
 #include <trace/events/module.h>
 
+#ifdef CONFIG_CREDP
+#include <asm/iee-cred.h>
+#endif
+
 #define CAP_BSET	(void *)1
 #define CAP_PI		(void *)2
 
@@ -92,9 +96,15 @@ static int call_usermodehelper_exec_async(void *data)
 		goto out;
 
 	spin_lock(&umh_sysctl_lock);
+	#ifdef CONFIG_CREDP
+	iee_set_cred_cap_bset(new,cap_intersect(usermodehelper_bset, new->cap_bset));
+	iee_set_cred_cap_inheritable(new,cap_intersect(usermodehelper_inheritable,
+					     new->cap_inheritable));
+	#else
 	new->cap_bset = cap_intersect(usermodehelper_bset, new->cap_bset);
 	new->cap_inheritable = cap_intersect(usermodehelper_inheritable,
 					     new->cap_inheritable);
+	#endif
 	spin_unlock(&umh_sysctl_lock);
 
 	if (sub_info->init) {
diff --git a/kernel/user_namespace.c b/kernel/user_namespace.c
index 2c15bf6680c3..f96787c4df2e 100644
--- a/kernel/user_namespace.c
+++ b/kernel/user_namespace.c
@@ -21,6 +21,10 @@
 #include <linux/bsearch.h>
 #include <linux/sort.h>
 
+#ifdef CONFIG_CREDP
+#include <asm/iee-cred.h>
+#endif
+
 static struct kmem_cache *user_ns_cachep __read_mostly;
 static DEFINE_MUTEX(userns_state_mutex);
 
@@ -44,6 +48,19 @@ static void set_cred_user_ns(struct cred *cred, struct user_namespace *user_ns)
 	/* Start with the same capabilities as init but useless for doing
 	 * anything as the capabilities are bound to the new user namespace.
 	 */
+	#ifdef CONFIG_CREDP
+	iee_set_cred_securebits(cred,SECUREBITS_DEFAULT);
+	iee_set_cred_cap_inheritable(cred,CAP_EMPTY_SET);
+	iee_set_cred_cap_permitted(cred,CAP_FULL_SET);
+	iee_set_cred_cap_effective(cred,CAP_FULL_SET);
+	iee_set_cred_cap_ambient(cred,CAP_EMPTY_SET);
+	iee_set_cred_cap_bset(cred,CAP_FULL_SET);
+#ifdef CONFIG_KEYS
+	key_put(cred->request_key_auth);
+	iee_set_cred_request_key_auth(cred,NULL);
+#endif
+	iee_set_cred_user_ns(cred,user_ns);
+	#else
 	cred->securebits = SECUREBITS_DEFAULT;
 	cred->cap_inheritable = CAP_EMPTY_SET;
 	cred->cap_permitted = CAP_FULL_SET;
@@ -56,6 +73,7 @@ static void set_cred_user_ns(struct cred *cred, struct user_namespace *user_ns)
 #endif
 	/* tgcred will be cleared in our caller bc CLONE_THREAD won't be set */
 	cred->user_ns = user_ns;
+	#endif
 }
 
 /*
diff --git a/mm/Kconfig b/mm/Kconfig
index ccbad233f2b1..ab30a2ce9a3b 100644
--- a/mm/Kconfig
+++ b/mm/Kconfig
@@ -145,6 +145,18 @@ config NUMA_KEEP_MEMINFO
 config MEMORY_ISOLATION
 	bool
 
+# Config for kernel module isolation
+config KOI 
+    depends on ARM64
+    depends on ARM64_VA_BITS_48
+	depends on ARM64_4K_PAGES
+    def_bool n
+
+# Configs for pgtable isolation
+config PTP
+	depends on IEE
+	def_bool y
+
 config COHERENT_DEVICE
 	bool "coherent device memory"
 	def_bool n
diff --git a/mm/damon/ops-common.c b/mm/damon/ops-common.c
index 75409601f934..e375200c93e6 100644
--- a/mm/damon/ops-common.c
+++ b/mm/damon/ops-common.c
@@ -43,7 +43,11 @@ void damon_ptep_mkold(pte_t *pte, struct mm_struct *mm, unsigned long addr)
 
 	if (pte_young(*pte)) {
 		referenced = true;
+		#ifdef CONFIG_PTP
+		set_pte(pte, pte_mkold(*pte));
+		#else
 		*pte = pte_mkold(*pte);
+		#endif
 	}
 
 #ifdef CONFIG_MMU_NOTIFIER
@@ -69,7 +73,11 @@ void damon_pmdp_mkold(pmd_t *pmd, struct mm_struct *mm, unsigned long addr)
 
 	if (pmd_young(*pmd)) {
 		referenced = true;
+		#ifdef CONFIG_PTP
+		set_pmd(pmd, pmd_mkold(*pmd));
+		#else
 		*pmd = pmd_mkold(*pmd);
+		#endif
 	}
 
 #ifdef CONFIG_MMU_NOTIFIER
diff --git a/mm/debug_vm_pgtable.c b/mm/debug_vm_pgtable.c
index 11d3b46ba187..4fea5dc21066 100644
--- a/mm/debug_vm_pgtable.c
+++ b/mm/debug_vm_pgtable.c
@@ -263,7 +263,11 @@ static void __init pmd_huge_tests(pmd_t *pmdp, unsigned long pfn, pgprot_t prot)
 	 * X86 defined pmd_set_huge() verifies that the given
 	 * PMD is not a populated non-leaf entry.
 	 */
+	#ifdef CONFIG_PTP
+	set_pmd(pmdp, __pmd(0));
+	#else
 	WRITE_ONCE(*pmdp, __pmd(0));
+	#endif
 	WARN_ON(!pmd_set_huge(pmdp, __pfn_to_phys(pfn), prot));
 	WARN_ON(!pmd_clear_huge(pmdp));
 	pmd = READ_ONCE(*pmdp);
@@ -411,7 +415,11 @@ static void __init pud_huge_tests(pud_t *pudp, unsigned long pfn, pgprot_t prot)
 	 * X86 defined pud_set_huge() verifies that the given
 	 * PUD is not a populated non-leaf entry.
 	 */
+	#ifdef CONFIG_PTP
+	set_pud(pudp, __pud(0));
+	#else
 	WRITE_ONCE(*pudp, __pud(0));
+	#endif
 	WARN_ON(!pud_set_huge(pudp, __pfn_to_phys(pfn), prot));
 	WARN_ON(!pud_clear_huge(pudp));
 	pud = READ_ONCE(*pudp);
@@ -488,7 +496,11 @@ static void __init pud_clear_tests(struct mm_struct *mm, pud_t *pudp)
 
 	pr_debug("Validating PUD clear\n");
 	pud = __pud(pud_val(pud) | RANDOM_ORVALUE);
+	#ifdef CONFIG_PTP
+	set_pud(pudp, pud);
+	#else
 	WRITE_ONCE(*pudp, pud);
+	#endif
 	pud_clear(pudp);
 	pud = READ_ONCE(*pudp);
 	WARN_ON(!pud_none(pud));
@@ -529,7 +541,11 @@ static void __init p4d_clear_tests(struct mm_struct *mm, p4d_t *p4dp)
 
 	pr_debug("Validating P4D clear\n");
 	p4d = __p4d(p4d_val(p4d) | RANDOM_ORVALUE);
+	#ifdef CONFIG_PTP
+	set_p4d(p4dp, p4d);
+	#else
 	WRITE_ONCE(*p4dp, p4d);
+	#endif
 	p4d_clear(p4dp);
 	p4d = READ_ONCE(*p4dp);
 	WARN_ON(!p4d_none(p4d));
@@ -564,7 +580,11 @@ static void __init pgd_clear_tests(struct mm_struct *mm, pgd_t *pgdp)
 
 	pr_debug("Validating PGD clear\n");
 	pgd = __pgd(pgd_val(pgd) | RANDOM_ORVALUE);
+	#ifdef CONFIG_PTP
+	set_pgd(pgdp, pgd);
+	#else
 	WRITE_ONCE(*pgdp, pgd);
+	#endif
 	pgd_clear(pgdp);
 	pgd = READ_ONCE(*pgdp);
 	WARN_ON(!pgd_none(pgd));
@@ -625,7 +645,11 @@ static void __init pmd_clear_tests(struct mm_struct *mm, pmd_t *pmdp)
 
 	pr_debug("Validating PMD clear\n");
 	pmd = __pmd(pmd_val(pmd) | RANDOM_ORVALUE);
+	#ifdef CONFIG_PTP
+	set_pmd(pmdp, pmd);
+	#else
 	WRITE_ONCE(*pmdp, pmd);
+	#endif
 	pmd_clear(pmdp);
 	pmd = READ_ONCE(*pmdp);
 	WARN_ON(!pmd_none(pmd));
diff --git a/mm/early_ioremap.c b/mm/early_ioremap.c
index a0018ad1a1f6..325e9b202139 100644
--- a/mm/early_ioremap.c
+++ b/mm/early_ioremap.c
@@ -153,7 +153,11 @@ __early_ioremap(resource_size_t phys_addr, unsigned long size, pgprot_t prot)
 		if (after_paging_init)
 			__late_set_fixmap(idx, phys_addr, prot);
 		else
+			#ifdef CONFIG_PTP
+			__iee_set_fixmap_pre_init(idx, phys_addr, prot);
+			#else
 			__early_set_fixmap(idx, phys_addr, prot);
+			#endif
 		phys_addr += PAGE_SIZE;
 		--idx;
 		--nrpages;
@@ -205,13 +209,66 @@ void __init early_iounmap(void __iomem *addr, unsigned long size)
 		if (after_paging_init)
 			__late_clear_fixmap(idx);
 		else
+			#ifdef CONFIG_PTP
+			__iee_set_fixmap_pre_init(idx, 0, FIXMAP_PAGE_CLEAR);
+			#else
 			__early_set_fixmap(idx, 0, FIXMAP_PAGE_CLEAR);
+			#endif
 		--idx;
 		--nrpages;
 	}
 	prev_map[slot] = NULL;
 }
 
+#ifdef CONFIG_PTP
+void __init early_iounmap_after_init(void __iomem *addr, unsigned long size)
+{
+	unsigned long virt_addr;
+	unsigned long offset;
+	unsigned int nrpages;
+	enum fixed_addresses idx;
+	int i, slot;
+
+	slot = -1;
+	for (i = 0; i < FIX_BTMAPS_SLOTS; i++) {
+		if (prev_map[i] == addr) {
+			slot = i;
+			break;
+		}
+	}
+
+	if (WARN(slot < 0, "early_iounmap(%p, %08lx) not found slot\n",
+		 addr, size))
+		return;
+
+	if (WARN(prev_size[slot] != size,
+		 "early_iounmap(%p, %08lx) [%d] size not consistent %08lx\n",
+		 addr, size, slot, prev_size[slot]))
+		return;
+
+	WARN(early_ioremap_debug, "early_iounmap(%p, %08lx) [%d]\n",
+	     addr, size, slot);
+
+	virt_addr = (unsigned long)addr;
+	if (WARN_ON(virt_addr < fix_to_virt(FIX_BTMAP_BEGIN)))
+		return;
+
+	offset = offset_in_page(virt_addr);
+	nrpages = PAGE_ALIGN(offset + size) >> PAGE_SHIFT;
+
+	idx = FIX_BTMAP_BEGIN - NR_FIX_BTMAPS*slot;
+	while (nrpages > 0) {
+		if (after_paging_init)
+			__late_clear_fixmap(idx);
+		else
+			__early_set_fixmap(idx, 0, FIXMAP_PAGE_CLEAR);
+		--idx;
+		--nrpages;
+	}
+	prev_map[slot] = NULL;
+}
+#endif
+
 /* Remap an IO device */
 void __init __iomem *
 early_ioremap(resource_size_t phys_addr, unsigned long size)
diff --git a/mm/huge_memory.c b/mm/huge_memory.c
index 20d548da4660..d0c0416e29de 100644
--- a/mm/huge_memory.c
+++ b/mm/huge_memory.c
@@ -35,6 +35,10 @@
 #include <linux/page_owner.h>
 #include <linux/dynamic_hugetlb.h>
 
+#ifdef CONFIG_PTP
+#include <linux/iee-func.h>
+#endif
+
 #include <asm/tlb.h>
 #include <asm/pgalloc.h>
 #include "internal.h"
@@ -2025,7 +2029,8 @@ static void __split_huge_zero_page_pmd(struct vm_area_struct *vma,
 	old_pmd = pmdp_huge_clear_flush(vma, haddr, pmd);
 
 	pgtable = pgtable_trans_huge_withdraw(mm, pmd);
-	pmd_populate(mm, &_pmd, pgtable);
+	//pmd_populate(mm, &_pmd, pgtable);
+	_pmd = __pmd(__phys_to_pmd_val(page_to_phys(pgtable)) | PMD_TYPE_TABLE);
 
 	for (i = 0; i < HPAGE_PMD_NR; i++, haddr += PAGE_SIZE) {
 		pte_t *pte, entry;
@@ -2152,7 +2157,8 @@ static void __split_huge_pmd_locked(struct vm_area_struct *vma, pmd_t *pmd,
 	 * This's critical for some architectures (Power).
 	 */
 	pgtable = pgtable_trans_huge_withdraw(mm, pmd);
-	pmd_populate(mm, &_pmd, pgtable);
+	//pmd_populate(mm, &_pmd, pgtable);
+	_pmd = __pmd(__phys_to_pmd_val(page_to_phys(pgtable)) | PMD_TYPE_TABLE);
 
 	for (i = 0, addr = haddr; i < HPAGE_PMD_NR; i++, addr += PAGE_SIZE) {
 		pte_t entry, *pte;
diff --git a/mm/init-mm.c b/mm/init-mm.c
index 2dfed38be177..d721f25f3357 100644
--- a/mm/init-mm.c
+++ b/mm/init-mm.c
@@ -44,3 +44,20 @@ struct mm_struct init_mm = {
 #endif
 	INIT_MM_CONTEXT(init_mm)
 };
+
+#ifdef CONFIG_KOI
+/*
+ * This is used to init ko_mm when creating pgtable for a ko to be isolated
+ * the ko_mm belongs to a specific ko, pgdp is allocated by koi_pgd_alloc
+ */
+void init_ko_mm(struct mm_struct *ko_mm, pgd_t *pgdp) {
+	ko_mm->mm_rb = RB_ROOT;
+	ko_mm->pgd = pgdp;
+	ko_mm->mm_users = (atomic_t)ATOMIC_INIT(2);
+	ko_mm->mm_count = (atomic_t)ATOMIC_INIT(1);
+	ko_mm->mmap_lock = (struct rw_semaphore)__RWSEM_INITIALIZER(ko_mm->mmap_lock);
+	ko_mm->page_table_lock = __SPIN_LOCK_UNLOCKED(ko_mm.page_table_lock);
+	ko_mm->arg_lock = __SPIN_LOCK_UNLOCKED(ko_mm->arg_lock);
+	ko_mm->mmlist = (struct list_head)LIST_HEAD_INIT(ko_mm->mmlist);		
+}
+#endif
diff --git a/mm/memory.c b/mm/memory.c
index cd72c3d63e60..3f5e949d2d61 100644
--- a/mm/memory.c
+++ b/mm/memory.c
@@ -76,6 +76,11 @@
 #include <linux/userswap.h>
 #include <linux/pbha.h>
 
+#ifdef CONFIG_PTP
+#include <linux/iee-func.h>
+extern void iee_copy_pte_range(pte_t *new_dst, pte_t *old_dst, pte_t *src_pte, struct vm_area_struct *src_vma, unsigned long dst_vm_flags, pte_t *end_pte);
+#endif
+
 #include <trace/events/kmem.h>
 
 #include <asm/io.h>
@@ -736,7 +741,11 @@ copy_nonpresent_pte(struct mm_struct *dst_mm, struct mm_struct *src_mm,
 				pte = pte_swp_mksoft_dirty(pte);
 			if (pte_swp_uffd_wp(*src_pte))
 				pte = pte_swp_mkuffd_wp(pte);
+			#ifdef CONFIG_PTP
+			iee_set_pte_at_delayed(src_mm, addr, src_pte, pte);
+			#else
 			set_pte_at(src_mm, addr, src_pte, pte);
+			#endif
 		}
 	} else if (is_device_private_entry(entry)) {
 		page = device_private_entry_to_page(entry);
@@ -767,12 +776,20 @@ copy_nonpresent_pte(struct mm_struct *dst_mm, struct mm_struct *src_mm,
 			pte = swp_entry_to_pte(entry);
 			if (pte_swp_uffd_wp(*src_pte))
 				pte = pte_swp_mkuffd_wp(pte);
+			#ifdef CONFIG_PTP
+			iee_set_pte_at_delayed(src_mm, addr, src_pte, pte);
+			#else
 			set_pte_at(src_mm, addr, src_pte, pte);
+			#endif
 		}
 	}
 	if (!userfaultfd_wp(dst_vma))
 		pte = pte_swp_clear_uffd_wp(pte);
+	#ifdef CONFIG_PTP
+	iee_set_pte_at(dst_mm, addr, dst_pte, pte);
+	#else
 	set_pte_at(dst_mm, addr, dst_pte, pte);
+	#endif
 	return 0;
 }
 
@@ -858,7 +875,11 @@ copy_present_page(struct vm_area_struct *dst_vma, struct vm_area_struct *src_vma
 	if (userfaultfd_pte_wp(dst_vma, *src_pte))
 		/* Uffd-wp needs to be delivered to dest pte as well */
 		pte = pte_wrprotect(pte_mkuffd_wp(pte));
+	#ifdef CONFIG_PTP
+	iee_set_pte_at(dst_vma->vm_mm, addr, dst_pte, pte);
+	#else
 	set_pte_at(dst_vma->vm_mm, addr, dst_pte, pte);
+	#endif
 	return 0;
 }
 
@@ -896,7 +917,9 @@ copy_present_pte(struct vm_area_struct *dst_vma, struct vm_area_struct *src_vma,
 	 * in the parent and the child
 	 */
 	if (is_cow_mapping(vm_flags) && pte_write(pte)) {
+		#ifndef CONFIG_PTP
 		ptep_set_wrprotect(src_mm, addr, src_pte);
+		#endif
 		pte = pte_wrprotect(pte);
 	}
 
@@ -911,7 +934,11 @@ copy_present_pte(struct vm_area_struct *dst_vma, struct vm_area_struct *src_vma,
 	if (!userfaultfd_wp(dst_vma))
 		pte = pte_clear_uffd_wp(pte);
 
+	#ifdef CONFIG_PTP
+	iee_set_pte_at(dst_vma->vm_mm, addr, dst_pte, pte);
+	#else
 	set_pte_at(dst_vma->vm_mm, addr, dst_pte, pte);
+	#endif
 	return 0;
 }
 
@@ -948,6 +975,12 @@ copy_pte_range(struct vm_area_struct *dst_vma, struct vm_area_struct *src_vma,
 	int rss[NR_MM_COUNTERS];
 	swp_entry_t entry = (swp_entry_t){0};
 	struct page *prealloc = NULL;
+	#ifdef CONFIG_PTP
+	unsigned long orig_addr;
+	pmd_t pmd;
+	pte_t *old_dst;
+	void *new;
+	#endif
 
 again:
 	progress = 0;
@@ -958,6 +991,13 @@ copy_pte_range(struct vm_area_struct *dst_vma, struct vm_area_struct *src_vma,
 		ret = -ENOMEM;
 		goto out;
 	}
+	#ifdef CONFIG_PTP
+	orig_addr = addr;
+	new = (void *)iee_read_tmp_page(get_current());
+	pmd = READ_ONCE(*dst_pmd);
+	dst_pte = (pte_t *)new + pte_index(addr);
+	old_dst = pte_offset_map(&pmd, addr);
+	#endif
 	src_pte = pte_offset_map(src_pmd, addr);
 	src_ptl = pte_lockptr(src_mm, src_pmd);
 	spin_lock_nested(src_ptl, SINGLE_DEPTH_NESTING);
@@ -1011,7 +1051,11 @@ copy_pte_range(struct vm_area_struct *dst_vma, struct vm_area_struct *src_vma,
 		}
 		progress += 8;
 	} while (dst_pte++, src_pte++, addr += PAGE_SIZE, addr != end);
-
+	#ifdef CONFIG_PTP
+	iee_copy_pte_range(orig_dst_pte, old_dst, orig_src_pte, src_vma, dst_vma->vm_flags, src_pte);
+	orig_dst_pte = pte_offset_map(&pmd, orig_addr);
+	dst_pte = pte_offset_map(&pmd, addr);
+	#endif
 	arch_leave_lazy_mmu_mode();
 	spin_unlock(src_ptl);
 	pte_unmap(orig_src_pte);
@@ -5476,13 +5520,21 @@ bool ptlock_alloc(struct page *page)
 	ptl = kmem_cache_alloc(page_ptl_cachep, GFP_KERNEL);
 	if (!ptl)
 		return false;
+	#ifdef CONFIG_PTP
+	((struct pgtable_page *)(page->slab_cache))->ptl = ptl;
+	#else
 	page->ptl = ptl;
+	#endif
 	return true;
 }
 
 void ptlock_free(struct page *page)
 {
+	#ifdef CONFIG_PTP
+	kmem_cache_free(page_ptl_cachep, ((struct pgtable_page *)(page->slab_cache))->ptl);
+	#else
 	kmem_cache_free(page_ptl_cachep, page->ptl);
+	#endif
 }
 #endif
 
diff --git a/mm/mmap.c b/mm/mmap.c
index bddd7f0f88b9..f7f0f169bc22 100644
--- a/mm/mmap.c
+++ b/mm/mmap.c
@@ -2788,7 +2788,11 @@ static void unmap_region(struct mm_struct *mm,
 
 	free_pgtables(&tlb, vma, prev ? prev->vm_end : FIRST_USER_ADDRESS,
 				 next ? next->vm_start : USER_PGTABLES_CEILING);
+	#ifdef CONFIG_PTP
+	iee_tlb_finish_mmu(&tlb, start, end);
+	#else
 	tlb_finish_mmu(&tlb, start, end);
+	#endif
 }
 
 /*
@@ -3334,7 +3338,11 @@ void exit_mmap(struct mm_struct *mm)
 	/* Use -1 here to ensure all VMAs in the mm are unmapped */
 	unmap_vmas(&tlb, vma, 0, -1);
 	free_pgtables(&tlb, vma, FIRST_USER_ADDRESS, USER_PGTABLES_CEILING);
+	#ifdef CONFIG_PTP
+	iee_tlb_finish_mmu(&tlb, 0, -1);
+	#else
 	tlb_finish_mmu(&tlb, 0, -1);
+	#endif
 
 	/*
 	 * Walk the list again, actually closing and freeing it,
diff --git a/mm/mmu_gather.c b/mm/mmu_gather.c
index 1c66771f088b..4580ac9f5756 100644
--- a/mm/mmu_gather.c
+++ b/mm/mmu_gather.c
@@ -233,6 +233,71 @@ void tlb_remove_table(struct mmu_gather *tlb, void *table)
 		tlb_table_flush(tlb);
 }
 
+#ifdef CONFIG_PTP
+static void __iee_tlb_remove_table_free(struct mmu_table_batch *batch)
+{
+	int i;
+
+	for (i = 0; i < batch->nr; i++)
+		__iee_tlb_remove_table(batch->tables[i]);
+
+	free_page((unsigned long)batch);
+}
+
+#ifdef CONFIG_MMU_GATHER_RCU_TABLE_FREE
+static void iee_tlb_remove_table_rcu(struct rcu_head *head)
+{
+	__iee_tlb_remove_table_free(container_of(head, struct mmu_table_batch, rcu));
+}
+
+static void iee_tlb_remove_table_free(struct mmu_table_batch *batch)
+{
+	call_rcu(&batch->rcu, iee_tlb_remove_table_rcu);
+}
+#else
+static void iee_tlb_remove_table_free(struct mmu_table_batch *batch)
+{
+	__iee_tlb_remove_table_free(batch);
+}
+#endif
+
+static void iee_tlb_remove_table_one(void *table)
+{
+	tlb_remove_table_sync_one();
+	__iee_tlb_remove_table(table);
+}
+
+static void iee_tlb_table_flush(struct mmu_gather *tlb)
+{
+	struct mmu_table_batch **batch = &tlb->batch;
+
+	if (*batch) {
+		tlb_table_invalidate(tlb);
+		iee_tlb_remove_table_free(*batch);
+		*batch = NULL;
+	}
+}
+
+void iee_tlb_remove_table(struct mmu_gather *tlb, void *table)
+{
+	struct mmu_table_batch **batch = &tlb->batch;
+
+	if (*batch == NULL) {
+		*batch = (struct mmu_table_batch *)__get_free_page(GFP_NOWAIT | __GFP_NOWARN);
+		if (*batch == NULL) {
+			tlb_table_invalidate(tlb);
+			iee_tlb_remove_table_one(table);
+			return;
+		}
+		(*batch)->nr = 0;
+	}
+
+	(*batch)->tables[(*batch)->nr++] = table;
+	if ((*batch)->nr == MAX_TABLE_BATCH)
+		iee_tlb_table_flush(tlb);
+}
+#endif
+
 static inline void tlb_table_init(struct mmu_gather *tlb)
 {
 	tlb->batch = NULL;
@@ -342,3 +407,56 @@ void tlb_finish_mmu(struct mmu_gather *tlb,
 #endif
 	dec_tlb_flush_pending(tlb->mm);
 }
+
+#ifdef CONFIG_PTP
+static void iee_tlb_flush_mmu_free(struct mmu_gather *tlb)
+{
+	iee_tlb_table_flush(tlb);
+#ifndef CONFIG_MMU_GATHER_NO_GATHER
+	tlb_batch_pages_flush(tlb);
+#endif
+}
+
+void iee_tlb_flush_mmu(struct mmu_gather *tlb)
+{
+	tlb_flush_mmu_tlbonly(tlb);
+	iee_tlb_flush_mmu_free(tlb);
+}
+
+void iee_tlb_finish_mmu(struct mmu_gather *tlb,
+		unsigned long start, unsigned long end)
+{
+	/*
+	 * If there are parallel threads are doing PTE changes on same range
+	 * under non-exclusive lock (e.g., mmap_lock read-side) but defer TLB
+	 * flush by batching, one thread may end up seeing inconsistent PTEs
+	 * and result in having stale TLB entries.  So flush TLB forcefully
+	 * if we detect parallel PTE batching threads.
+	 *
+	 * However, some syscalls, e.g. munmap(), may free page tables, this
+	 * needs force flush everything in the given range. Otherwise this
+	 * may result in having stale TLB entries for some architectures,
+	 * e.g. aarch64, that could specify flush what level TLB.
+	 */
+	if (mm_tlb_flush_nested(tlb->mm)) {
+		/*
+		 * The aarch64 yields better performance with fullmm by
+		 * avoiding multiple CPUs spamming TLBI messages at the
+		 * same time.
+		 *
+		 * On x86 non-fullmm doesn't yield significant difference
+		 * against fullmm.
+		 */
+		tlb->fullmm = 1;
+		__tlb_reset_range(tlb);
+		tlb->freed_tables = 1;
+	}
+
+	iee_tlb_flush_mmu(tlb);
+
+#ifndef CONFIG_MMU_GATHER_NO_GATHER
+	tlb_batch_list_free(tlb);
+#endif
+	dec_tlb_flush_pending(tlb->mm);
+}
+#endif
diff --git a/mm/pgtable-generic.c b/mm/pgtable-generic.c
index 4e640baf9794..daa977072d17 100644
--- a/mm/pgtable-generic.c
+++ b/mm/pgtable-generic.c
@@ -165,9 +165,17 @@ void pgtable_trans_huge_deposit(struct mm_struct *mm, pmd_t *pmdp,
 
 	/* FIFO */
 	if (!pmd_huge_pte(mm, pmdp))
+		#ifdef CONFIG_PTP
+		INIT_LIST_HEAD(&(((struct pgtable_page *)(pgtable->slab_cache))->lru));
+		#else
 		INIT_LIST_HEAD(&pgtable->lru);
+		#endif
 	else
+		#ifdef CONFIG_PTP
+		list_add(&(((struct pgtable_page *)(pgtable->slab_cache))->lru), &(((struct pgtable_page *)(pmd_huge_pte(mm, pmdp)->slab_cache))->lru));
+		#else
 		list_add(&pgtable->lru, &pmd_huge_pte(mm, pmdp)->lru);
+		#endif
 	pmd_huge_pte(mm, pmdp) = pgtable;
 }
 #endif
@@ -177,15 +185,30 @@ void pgtable_trans_huge_deposit(struct mm_struct *mm, pmd_t *pmdp,
 pgtable_t pgtable_trans_huge_withdraw(struct mm_struct *mm, pmd_t *pmdp)
 {
 	pgtable_t pgtable;
+	#ifdef CONFIG_PTP
+	struct pgtable_page *pgtable_page;
+	#endif
 
 	assert_spin_locked(pmd_lockptr(mm, pmdp));
 
 	/* FIFO */
 	pgtable = pmd_huge_pte(mm, pmdp);
+	#ifdef CONFIG_PTP
+	pgtable_page = list_first_entry_or_null(&(((struct pgtable_page *)(pgtable->slab_cache))->lru),struct pgtable_page, lru);
+	if(pgtable_page)
+		pmd_huge_pte(mm, pmdp) = pgtable_page->page;
+	else
+		pmd_huge_pte(mm, pmdp) = NULL;
+	#else
 	pmd_huge_pte(mm, pmdp) = list_first_entry_or_null(&pgtable->lru,
 							  struct page, lru);
+	#endif
 	if (pmd_huge_pte(mm, pmdp))
+		#ifdef CONFIG_PTP
+		list_del(&(((struct pgtable_page *)(pgtable->slab_cache))->lru));
+		#else
 		list_del(&pgtable->lru);
+		#endif
 	return pgtable;
 }
 #endif
diff --git a/mm/slab.h b/mm/slab.h
index 8414c345127b..c6d92753b563 100644
--- a/mm/slab.h
+++ b/mm/slab.h
@@ -40,6 +40,14 @@ struct kmem_cache {
 #include <linux/slub_def.h>
 #endif
 
+#ifdef CONFIG_IEE
+extern struct kmem_cache *pgtable_jar;
+extern struct kmem_cache *pgtable_page_jar;
+extern struct kmem_cache *iee_stack_jar;
+extern struct kmem_cache *cred_jar;
+extern struct kmem_cache *task_struct_cachep;
+#endif
+
 #include <linux/memcontrol.h>
 #include <linux/fault-inject.h>
 #include <linux/kasan.h>
@@ -597,6 +605,14 @@ static inline void cache_random_seq_destroy(struct kmem_cache *cachep) { }
 
 static inline bool slab_want_init_on_alloc(gfp_t flags, struct kmem_cache *c)
 {
+	#ifdef CONFIG_IEE
+	if(c == iee_stack_jar)
+		return false;
+	#endif
+	#ifdef CONFIG_PTP
+	if(c == pgtable_jar)
+		return false;
+	#endif
 	if (static_branch_unlikely(&init_on_alloc)) {
 		if (c->ctor)
 			return false;
diff --git a/mm/slab_common.c b/mm/slab_common.c
index 5f1a1c38a815..924cd03f452b 100644
--- a/mm/slab_common.c
+++ b/mm/slab_common.c
@@ -170,6 +170,15 @@ int slab_unmergeable(struct kmem_cache *s)
 	if (s->ctor)
 		return 1;
 
+	#ifdef CONFIG_IEE
+	if(strcmp(s->name, "iee_stack_jar") == 0)
+		return 1;
+	#endif
+	#ifdef CONFIG_PTP
+	if(strcmp(s->name, "pgtable_jar") == 0)
+		return 1;
+	#endif
+
 	if (s->usersize)
 		return 1;
 
@@ -193,6 +202,15 @@ struct kmem_cache *find_mergeable(unsigned int size, unsigned int align,
 	if (ctor)
 		return NULL;
 
+	#ifdef CONFIG_IEE
+	if(strcmp(name, "iee_stack_jar") == 0)
+		return NULL;
+	#endif
+	#ifdef CONFIG_PTP
+	if(strcmp(name, "pgtable_jar") == 0)
+		return NULL;
+	#endif
+
 	size = ALIGN(size, sizeof(void *));
 	align = calculate_alignment(flags, align, size);
 	size = ALIGN(size, align);
diff --git a/mm/slub.c b/mm/slub.c
index ec1c3a376d36..ccca29b59d9e 100644
--- a/mm/slub.c
+++ b/mm/slub.c
@@ -37,10 +37,22 @@
 #include <linux/memcontrol.h>
 #include <linux/random.h>
 
+#ifdef CONFIG_IEE
+#include <linux/iee-func.h>
+#include <asm/iee-access.h>
+#include <asm/pgtable_slab.h>
+#endif
+
 #include <trace/events/kmem.h>
+#include <asm/iee-slab.h>
 
 #include "internal.h"
 
+#ifdef CONFIG_KOI
+extern s64 koi_offset;
+extern void koi_add_page_mapping(unsigned long dst, unsigned long src);
+extern void koi_remove_page_mapping(unsigned long addr);
+#endif
 /*
  * Lock order:
  *   1. slab_mutex (Global Mutex)
@@ -219,15 +231,6 @@ static inline bool kmem_cache_has_cpu_partial(struct kmem_cache *s)
  * Tracking user of a slab.
  */
 #define TRACK_ADDRS_COUNT 16
-struct track {
-	unsigned long addr;	/* Called from address */
-#ifdef CONFIG_STACKTRACE
-	unsigned long addrs[TRACK_ADDRS_COUNT];	/* Called from address */
-#endif
-	int cpu;		/* Was running on cpu */
-	int pid;		/* Pid context */
-	unsigned long when;	/* When did the operation occur */
-};
 
 enum track_item { TRACK_ALLOC, TRACK_FREE };
 
@@ -293,8 +296,15 @@ static inline void *freelist_ptr(const struct kmem_cache *s, void *ptr,
 static inline void *freelist_dereference(const struct kmem_cache *s,
 					 void *ptr_addr)
 {
+	#ifdef CONFIG_IEE
+	if(s == iee_stack_jar)
+		return iee_read_freeptr(ptr_addr);
+	else
+		return freelist_ptr(s, (void *)*(unsigned long *)(ptr_addr), (unsigned long)ptr_addr);
+	#else
 	return freelist_ptr(s, (void *)*(unsigned long *)(ptr_addr),
 			    (unsigned long)ptr_addr);
+	#endif
 }
 
 static inline void *get_freepointer(struct kmem_cache *s, void *object)
@@ -328,7 +338,17 @@ static inline void set_freepointer(struct kmem_cache *s, void *object, void *fp)
 	BUG_ON(object == fp); /* naive detection of double free or corruption */
 #endif
 
+	#ifdef CONFIG_IEE
+	if(s == iee_stack_jar)
+		iee_set_stack_freeptr(freeptr_addr, freelist_ptr(s, fp, freeptr_addr));
+	else if((IS_ENABLED(CONFIG_CREDP) && (s == cred_jar)) ||
+	   (IS_ENABLED(CONFIG_PTP) && (s == pgtable_jar)))
+		iee_set_freeptr((void **)freeptr_addr, freelist_ptr(s, fp, freeptr_addr));
+	else
+		*(void **)freeptr_addr = freelist_ptr(s, fp, freeptr_addr);
+	#else
 	*(void **)freeptr_addr = freelist_ptr(s, fp, freeptr_addr);
+	#endif
 }
 
 /* Loop over all objects in a slab */
@@ -601,24 +621,75 @@ static void set_track(struct kmem_cache *s, void *object,
 			enum track_item alloc, unsigned long addr)
 {
 	struct track *p = get_track(s, object, alloc);
+	#ifdef CONFIG_IEE
+	struct track tmp;
+	#endif
 
 	if (addr) {
 #ifdef CONFIG_STACKTRACE
 		unsigned int nr_entries;
 
 		metadata_access_enable();
+		#ifdef CONFIG_IEE
+		if(IS_ENABLED(CONFIG_CREDP) && (s == cred_jar))
+		{
+			nr_entries = stack_trace_save_iee(p->addrs, TRACK_ADDRS_COUNT, 3);
+		}
+		else
+			nr_entries = stack_trace_save(p->addrs, TRACK_ADDRS_COUNT, 3);
+		#else
 		nr_entries = stack_trace_save(p->addrs, TRACK_ADDRS_COUNT, 3);
+		#endif
 		metadata_access_disable();
 
 		if (nr_entries < TRACK_ADDRS_COUNT)
+			#ifdef CONFIG_IEE
+		{
+			if(IS_ENABLED(CONFIG_CREDP) && (s == cred_jar))
+			{
+				tmp = *p;
+				tmp.addrs[nr_entries] = 0;
+				iee_set_track(p,&tmp);
+			}
+			else
+				p->addrs[nr_entries] = 0;
+		}
+			#else
 			p->addrs[nr_entries] = 0;
+			#endif
 #endif
+		#ifdef CONFIG_IEE
+		if(IS_ENABLED(CONFIG_CREDP) && (s == cred_jar))
+		{
+			tmp = *p;
+			tmp.addr = addr;
+			tmp.cpu = smp_processor_id();
+			tmp.pid = current->pid;
+			tmp.when = jiffies;
+			iee_set_track(p,&tmp);
+		}
+		else
+		{
+			p->addr = addr;
+			p->cpu = smp_processor_id();
+			p->pid = current->pid;
+			p->when = jiffies;
+		}
+		#else
 		p->addr = addr;
 		p->cpu = smp_processor_id();
 		p->pid = current->pid;
 		p->when = jiffies;
+		#endif
 	} else {
+		#ifdef CONFIG_IEE
+		if(IS_ENABLED(CONFIG_CREDP) && (s == cred_jar))
+			iee_memset(p, 0, sizeof(struct track));
+		else
+			memset(p, 0, sizeof(struct track));
+		#else
 		memset(p, 0, sizeof(struct track));
+		#endif
 	}
 }
 
@@ -775,15 +846,46 @@ static void init_object(struct kmem_cache *s, void *object, u8 val)
 	u8 *p = object;
 
 	if (s->flags & SLAB_RED_ZONE)
+		#ifdef CONFIG_IEE
+	{
+		if(IS_ENABLED(CONFIG_CREDP) && (s == cred_jar))
+			iee_memset(p - s->red_left_pad, val, s->red_left_pad);
+		else
+			memset(p - s->red_left_pad, val, s->red_left_pad);
+	}
+		#else
 		memset(p - s->red_left_pad, val, s->red_left_pad);
+		#endif
 
 	if (s->flags & __OBJECT_POISON) {
+		#ifdef CONFIG_IEE
+		if(IS_ENABLED(CONFIG_CREDP) && (s == cred_jar))
+		{
+			iee_memset(p, POISON_FREE, s->object_size - 1);
+			iee_memset(&p[s->object_size - 1],POISON_END,1);
+		}
+		else
+		{
+			memset(p, POISON_FREE, s->object_size - 1);
+			p[s->object_size - 1] = POISON_END;
+		}
+		#else
 		memset(p, POISON_FREE, s->object_size - 1);
 		p[s->object_size - 1] = POISON_END;
+		#endif
 	}
 
 	if (s->flags & SLAB_RED_ZONE)
+		#ifdef CONFIG_IEE
+	{
+		if(IS_ENABLED(CONFIG_CREDP) && (s == cred_jar))
+			iee_memset(p + s->object_size, val, s->inuse - s->object_size);
+		else
+			memset(p + s->object_size, val, s->inuse - s->object_size);
+	}
+		#else
 		memset(p + s->object_size, val, s->inuse - s->object_size);
+		#endif
 }
 
 static void restore_bytes(struct kmem_cache *s, char *message, u8 data,
@@ -1143,7 +1245,14 @@ void setup_page_debug(struct kmem_cache *s, struct page *page, void *addr)
 		return;
 
 	metadata_access_enable();
+	#ifdef CONFIG_IEE
+	if(IS_ENABLED(CONFIG_CREDP) && (s == cred_jar))
+		iee_memset(addr, POISON_INUSE, page_size(page));
+	else
+		memset(addr, POISON_INUSE, page_size(page));
+	#else
 	memset(addr, POISON_INUSE, page_size(page));
+	#endif
 	metadata_access_disable();
 }
 
@@ -1645,14 +1754,70 @@ static void *setup_object(struct kmem_cache *s, struct page *page,
 static inline struct page *alloc_slab_page(struct kmem_cache *s,
 		gfp_t flags, int node, struct kmem_cache_order_objects oo)
 {
+#if defined(CONFIG_KOI) && !defined(CONFIG_IEE)
+    void *token_addr, *alloc_token;
+    int i;
+#endif
 	struct page *page;
 	unsigned int order = oo_order(oo);
 
+	#ifdef CONFIG_IEE
+	if(IS_ENABLED(CONFIG_PTP) && (s == pgtable_jar))
+	{
+		flags |= __GFP_ZERO;
+	}
+	#endif
+
 	if (node == NUMA_NO_NODE)
 		page = alloc_pages(flags, order);
 	else
 		page = __alloc_pages_node(node, flags, order);
 
+	#ifdef CONFIG_IEE
+	if(!page)
+		return page;
+
+	if(IS_ENABLED(CONFIG_PTP) && (s == pgtable_jar))
+	{
+		int i;
+		for(i = 0; i < (0x1 << order); i++)
+		{
+			set_page_refcounted(page + i);
+		}
+		set_iee_page((unsigned long)page_address(page), order);
+	}
+
+	if(IS_ENABLED(CONFIG_CREDP) && (s == cred_jar))
+	{
+		set_iee_page((unsigned long)page_address(page), order);
+	}
+
+	if(s == iee_stack_jar)
+	{
+		iee_set_kernel_upage((unsigned long)page_address(page), order);
+	}
+
+	// If the page belongs to a task_struct, alloc token for it and set iee&lm va.
+	if(s == task_struct_cachep)
+	{
+		void *token_addr = (void *)__phys_to_iee(page_to_phys(page));
+		void *alloc_token = (void *)__get_free_pages(GFP_KERNEL | __GFP_ZERO, order);
+		iee_set_token_page_valid(token_addr, alloc_token, order);
+	}
+    #else 
+    #ifdef CONFIG_KOI
+    if (!page)
+        return page;
+    if (strcmp(s->name, "task_struct") == 0) {
+        for (i = 0; i < (0x1 << order); i++) {
+            token_addr = (unsigned long)__phys_to_virt(page_to_phys(page + i)) + (unsigned long)KOI_OFFSET;
+            alloc_token = __get_free_page(GFP_KERNEL | __GFP_ZERO);
+            koi_add_page_mapping(token_addr, (void *)alloc_token);
+        }
+    }
+    #endif
+	#endif
+
 	if (page)
 		account_slab_page(page, order, s);
 
@@ -1745,6 +1910,21 @@ static bool shuffle_freelist(struct kmem_cache *s, struct page *page)
 	cur = setup_object(s, page, cur);
 	page->freelist = cur;
 
+	#ifdef CONFIG_IEE
+	if(s == task_struct_cachep)
+	{
+		int i;
+		void *pstack;
+		void *obj;
+		for(i = 0; i < freelist_count; i++)
+		{
+			pstack = get_iee_stack();
+			obj = start + s->random_seq[i];
+			iee_init_token((struct task_struct *)obj, pstack + PAGE_SIZE * 4, (void *)__get_free_pages(GFP_KERNEL | __GFP_ZERO, 0));
+		}
+	}
+	#endif
+
 	for (idx = 1; idx < page->objects; idx++) {
 		next = next_freelist_entry(s, page, &pos, start, page_limit,
 			freelist_count);
@@ -1764,6 +1944,24 @@ static inline int init_cache_random_seq(struct kmem_cache *s)
 static inline void init_freelist_randomization(void) { }
 static inline bool shuffle_freelist(struct kmem_cache *s, struct page *page)
 {
+	#ifdef CONFIG_IEE
+	void *start;
+	unsigned long freelist_count;
+	freelist_count = oo_objects(s->oo);
+	start = fixup_red_left(s, page_address(page));
+	if(s == task_struct_cachep)
+	{
+		int i;
+		void *pstack;
+		void *obj;
+		for(i = 0; i < freelist_count; i++)
+		{
+			pstack = get_iee_stack();
+			obj = start + s->size * i;
+			iee_init_token((struct task_struct *)obj, pstack + PAGE_SIZE * 4, (void *)__get_free_pages(GFP_KERNEL | __GFP_ZERO, 0));
+		}
+	}
+	#endif
 	return false;
 }
 #endif /* CONFIG_SLAB_FREELIST_RANDOM */
@@ -1809,6 +2007,21 @@ static struct page *allocate_slab(struct kmem_cache *s, gfp_t flags, int node)
 	page->objects = oo_objects(oo);
 
 	page->slab_cache = s;
+	#ifdef CONFIG_PTP
+	{
+	int order = compound_order(page);
+	if(s == pgtable_jar)
+	{
+		int i;
+		for(i = 0; i < (0x1 << order); i++)
+		{
+			(page+i)->slab_cache = kmem_cache_alloc(pgtable_page_jar, GFP_KERNEL | __GFP_ZERO);
+            spin_lock_init(&((struct pgtable_page *)((page+i)->slab_cache))->ptl);
+    		((struct pgtable_page *)((page+i)->slab_cache))->page = page+i;
+		}
+	}
+	}
+	#endif
 	__SetPageSlab(page);
 	if (page_is_pfmemalloc(page))
 		SetPageSlabPfmemalloc(page);
@@ -1878,6 +2091,91 @@ static void __free_slab(struct kmem_cache *s, struct page *page)
 	if (current->reclaim_state)
 		current->reclaim_state->reclaimed_slab += pages;
 	unaccount_slab_page(page, order, s);
+
+	#ifdef CONFIG_IEE
+	if(IS_ENABLED(CONFIG_PTP) && (s == pgtable_jar))
+	{
+		int i;
+		unset_iee_page((unsigned long)page_address(page), order);
+		for(i = 1; i < (0x1 << order); i++)
+		{
+			set_page_count(page + i, 0);
+		}
+	}
+
+	if(IS_ENABLED(CONFIG_CREDP) && (s == cred_jar))
+	{
+		unset_iee_page((unsigned long)page_address(page), order);
+	}
+
+	if(s == iee_stack_jar)
+	{
+		iee_set_kernel_ppage((unsigned long)page_address(page), order);
+	}
+
+	// If the page containing this token is empty, free it and restore iee&lm va.
+	if(s == task_struct_cachep)
+	{
+		// Free stack.
+		int i;
+		void *start = fixup_red_left(s, page_address(page));
+		void *obj;
+		void *iee_stack;
+		void *tmp_page;
+		void *token_addr;
+		// Free iee stack and tmp page.
+		for(i = 0; i < oo_objects(s->oo); i++)
+		{
+			#ifdef CONFIG_SLAB_FREELIST_RANDOM
+			obj = start + s->random_seq[i];
+			#else
+			obj = start + i * s->size;
+			#endif
+			tmp_page = iee_read_tmp_page((struct task_struct *)obj);
+			free_pages((unsigned long)tmp_page, 0);
+			iee_stack = (void *)iee_read_token_stack((struct task_struct *)obj);
+			if (iee_stack) {
+				free_iee_stack((void *)(iee_stack - PAGE_SIZE * 4));
+			}
+		}
+		// Free token.
+		token_addr = (void *)__phys_to_iee(page_to_phys(page));
+		{
+		pgd_t *pgdir = swapper_pg_dir;
+		pgd_t *pgdp = pgd_offset_pgd(pgdir, (unsigned long)token_addr);
+		p4d_t *p4dp = p4d_offset(pgdp, (unsigned long)token_addr);
+		pud_t *pudp = pud_offset(p4dp, (unsigned long)token_addr);
+		pmd_t *pmdp = pmd_offset(pudp, (unsigned long)token_addr);
+		pte_t *ptep = pte_offset_kernel(pmdp, (unsigned long)token_addr);
+		void *token_page = page_address(pte_page(*ptep));
+		iee_set_token_page_invalid(token_addr, token_page, order);
+		free_pages((unsigned long)token_page, order);
+		}
+	}
+    #else
+    #ifdef CONFIG_KOI
+	if(strcmp(s->name, "task_struct") == 0)
+	{
+		int i;
+		for(i = 0; i < (0x1 << order); i++)
+		{
+			void *token_addr = __phys_to_virt(page_to_phys(page + i)) + (unsigned long)KOI_OFFSET;
+			unsigned long flags;
+			local_irq_save(flags);
+			asm volatile("at s1e1r, %0"::"r"(token_addr));
+			isb();
+			unsigned long res = read_sysreg(par_el1);
+			local_irq_restore(flags);
+			if(!(res & 0x1))
+			{
+                koi_remove_page_mapping(token_addr);
+				free_page(__va(res & PTE_ADDR_MASK));
+			}
+		}
+	}
+    #endif
+	#endif
+
 	__free_pages(page, order);
 }
 
@@ -1890,6 +2188,19 @@ static void rcu_free_slab(struct rcu_head *h)
 
 static void free_slab(struct kmem_cache *s, struct page *page)
 {
+	#ifdef CONFIG_PTP
+	int order = compound_order(page);
+	if(s == pgtable_jar)
+	{
+		int i;
+		for(i = 1; i < (0x1 << order); i++)
+		{
+			kmem_cache_free(pgtable_page_jar, (page+i)->slab_cache);
+			(page+i)->slab_cache = s;
+		}
+	}
+	#endif
+
 	if (unlikely(s->flags & SLAB_TYPESAFE_BY_RCU)) {
 		call_rcu(&page->rcu_head, rcu_free_slab);
 	} else
@@ -3609,6 +3920,36 @@ static void early_kmem_cache_node_alloc(int node)
 	__add_partial(n, page, DEACTIVATE_TO_HEAD);
 }
 
+#ifdef CONFIG_PTP
+void early_pgtable_jar_alloc(struct kmem_cache *pgtable_jar)
+{
+	struct page *page;
+	int node = 0;
+	int i = 0;
+
+	for(i = 0; i < nr_cpu_ids; i++)
+	{
+		node = cpu_to_node_map[i];
+		page = new_slab(pgtable_jar, GFP_NOWAIT | __GFP_ZERO, node);
+
+		BUG_ON(!page);
+		if (page_to_nid(page) != node) {
+			pr_err("SLUB: Unable to allocate memory from node %d\n", node);
+			pr_err("SLUB: Allocating a useless per node structure in order to be able to continue\n");
+		}
+
+		page->inuse = 0;
+		page->frozen = 0;
+
+		/*
+		 * No locks need to be taken here as it has just been
+	 	 * initialized and there is no concurrent access.
+	 	 */
+		__add_partial(get_node(pgtable_jar, page_to_nid(page)), page, DEACTIVATE_TO_HEAD);
+	}
+}
+#endif
+
 static void free_kmem_cache_nodes(struct kmem_cache *s)
 {
 	int node;
@@ -3807,6 +4148,18 @@ static int calculate_sizes(struct kmem_cache *s, int forced_order)
 	else
 		order = calculate_order(size);
 
+	#ifdef CONFIG_IEE
+	if(strcmp(s->name, "task_struct") == 0)
+		order = PGTABLE_ORDER;
+	if(strcmp(s->name, "iee_stack_jar") == 0)
+		order = PGTABLE_ORDER;
+	#endif
+
+	#ifdef CONFIG_PTP
+	if(strcmp(s->name, "pgtable_jar") == 0)
+		order = PGTABLE_ORDER;
+	#endif
+
 	if ((int)order < 0)
 		return 0;
 
@@ -3837,6 +4190,14 @@ static int calculate_sizes(struct kmem_cache *s, int forced_order)
 static int kmem_cache_open(struct kmem_cache *s, slab_flags_t flags)
 {
 	s->flags = kmem_cache_flags(s->size, flags, s->name);
+	#ifdef CONFIG_IEE
+	if(strcmp(s->name, "iee_stack_jar") == 0)
+		s->flags &= ~(SLAB_RED_ZONE | SLAB_STORE_USER);
+	#endif
+	#ifdef CONFIG_PTP
+	if(strcmp(s->name, "pgtable_jar") == 0)
+		s->flags &= ~(SLAB_RED_ZONE | SLAB_STORE_USER);
+	#endif
 #ifdef CONFIG_SLAB_FREELIST_HARDENED
 	s->random = get_random_long();
 #endif
@@ -3869,6 +4230,18 @@ static int kmem_cache_open(struct kmem_cache *s, slab_flags_t flags)
 	 */
 	set_min_partial(s, ilog2(s->size) / 2);
 
+	#ifdef CONFIG_IEE
+	if(strcmp(s->name, "task_struct") == 0)
+		s->min_partial *= (1 << TASK_ORDER);
+	if(strcmp(s->name, "iee_stack_jar") == 0)
+		s->min_partial *= (1 << TASK_ORDER);
+	#endif
+
+	#ifdef CONFIG_PTP
+	if(strcmp(s->name, "pgtable_jar") == 0)
+		s->min_partial = (1 << PGTABLE_MAX_ORDER);
+	#endif
+
 	set_cpu_partial(s);
 
 #ifdef CONFIG_NUMA
diff --git a/mm/sparse-vmemmap.c b/mm/sparse-vmemmap.c
index a47b027af1f7..3fbb3ed7ea9e 100644
--- a/mm/sparse-vmemmap.c
+++ b/mm/sparse-vmemmap.c
@@ -30,6 +30,10 @@
 #include <linux/pgtable.h>
 #include <linux/bootmem_info.h>
 
+#ifdef CONFIG_PTP
+#include <linux/iee-func.h>
+#endif
+
 #include <asm/dma.h>
 #include <asm/pgalloc.h>
 #include <asm/tlbflush.h>
@@ -602,6 +606,7 @@ pte_t * __meminit vmemmap_pte_populate(pmd_t *pmd, unsigned long addr, int node,
 				       struct vmem_altmap *altmap)
 {
 	pte_t *pte = pte_offset_kernel(pmd, addr);
+
 	if (pte_none(*pte)) {
 		pte_t entry;
 		void *p;
@@ -609,6 +614,7 @@ pte_t * __meminit vmemmap_pte_populate(pmd_t *pmd, unsigned long addr, int node,
 		p = vmemmap_alloc_block_buf(PAGE_SIZE, node, altmap);
 		if (!p)
 			return NULL;
+
 		entry = pfn_pte(__pa(p) >> PAGE_SHIFT, PAGE_KERNEL);
 		set_pte_at(&init_mm, addr, pte, entry);
 	}
@@ -623,6 +629,10 @@ static void * __meminit vmemmap_alloc_block_zero(unsigned long size, int node)
 		return NULL;
 	memset(p, 0, size);
 
+	#ifdef CONFIG_PTP
+	set_iee_page_valid(__phys_to_iee(__pa(p)));
+	#endif
+	
 	return p;
 }
 
diff --git a/mm/swap.c b/mm/swap.c
index c37fac5a73e8..58473227e8c0 100644
--- a/mm/swap.c
+++ b/mm/swap.c
@@ -112,7 +112,7 @@ static void __put_compound_page(struct page *page)
 }
 
 void __put_page(struct page *page)
-{
+{	
 	if (is_zone_device_page(page)) {
 		put_dev_pagemap(page->pgmap);
 
diff --git a/mm/vmalloc.c b/mm/vmalloc.c
index 6d802924d9e8..1003a4bb7c64 100644
--- a/mm/vmalloc.c
+++ b/mm/vmalloc.c
@@ -2853,7 +2853,11 @@ static int vmap_pfn_apply(pte_t *pte, unsigned long addr, void *private)
 
 	if (WARN_ON_ONCE(pfn_valid(data->pfns[data->idx])))
 		return -EINVAL;
+	#ifdef CONFIG_PTP
+	set_pte(pte, pte_mkspecial(pfn_pte(data->pfns[data->idx++], data->prot)));
+	#else
 	*pte = pte_mkspecial(pfn_pte(data->pfns[data->idx++], data->prot));
+	#endif
 	return 0;
 }
 
diff --git a/net/core/filter.c b/net/core/filter.c
index 838813229564..e779b883ab31 100644
--- a/net/core/filter.c
+++ b/net/core/filter.c
@@ -563,7 +563,7 @@ static int bpf_convert_filter(struct sock_filter *prog, int len,
 	u8 bpf_src;
 
 	BUILD_BUG_ON(BPF_MEMWORDS * sizeof(u32) > MAX_BPF_STACK);
-	BUILD_BUG_ON(BPF_REG_FP + 1 != MAX_BPF_REG);
+	BUILD_BUG_ON(BPF_REG_FP + 2 != MAX_BPF_REG);
 
 	if (len <= 0 || len > BPF_MAXINSNS)
 		return -EINVAL;
@@ -8651,27 +8651,45 @@ static u32 bpf_convert_ctx_access(enum bpf_access_type type,
 		break;
 
 	case offsetof(struct __sk_buff, data):
+		#ifdef CONFIG_HIVE
+		*insn++ = BPF_LDX_MEM(BPF_FIELD_SIZEOF(struct sk_buff, sfi_data),
+		      si->dst_reg, si->src_reg,
+		      offsetof(struct sk_buff, sfi_data));
+		#else
 		*insn++ = BPF_LDX_MEM(BPF_FIELD_SIZEOF(struct sk_buff, data),
 				      si->dst_reg, si->src_reg,
 				      offsetof(struct sk_buff, data));
+		#endif
 		break;
 
 	case offsetof(struct __sk_buff, data_meta):
 		off  = si->off;
 		off -= offsetof(struct __sk_buff, data_meta);
+		#ifdef CONFIG_HIVE
+		off += offsetof(struct sk_buff, sfi_data_meta);
+ 		*insn++ = BPF_LDX_MEM(BPF_SIZEOF(void *), si->dst_reg,
+ 				      si->src_reg, off);
+		#else
 		off += offsetof(struct sk_buff, cb);
 		off += offsetof(struct bpf_skb_data_end, data_meta);
 		*insn++ = BPF_LDX_MEM(BPF_SIZEOF(void *), si->dst_reg,
 				      si->src_reg, off);
+		#endif
 		break;
 
 	case offsetof(struct __sk_buff, data_end):
 		off  = si->off;
 		off -= offsetof(struct __sk_buff, data_end);
+		#ifdef CONFIG_HIVE
+		off += offsetof(struct sk_buff, sfi_data_end);
+ 		*insn++ = BPF_LDX_MEM(BPF_SIZEOF(void *), si->dst_reg,
+ 				      si->src_reg, off);
+		#else
 		off += offsetof(struct sk_buff, cb);
 		off += offsetof(struct bpf_skb_data_end, data_end);
 		*insn++ = BPF_LDX_MEM(BPF_SIZEOF(void *), si->dst_reg,
 				      si->src_reg, off);
+		#endif
 		break;
 
 	case offsetof(struct __sk_buff, tc_index):
diff --git a/net/dns_resolver/dns_key.c b/net/dns_resolver/dns_key.c
index 26a9d8434c23..2e4de448d9fa 100644
--- a/net/dns_resolver/dns_key.c
+++ b/net/dns_resolver/dns_key.c
@@ -34,6 +34,10 @@
 #include <keys/user-type.h>
 #include "internal.h"
 
+#ifdef CONFIG_CREDP
+#include <asm/iee-cred.h>
+#endif
+
 MODULE_DESCRIPTION("DNS Resolver");
 MODULE_AUTHOR("Wang Lei");
 MODULE_LICENSE("GPL");
@@ -365,8 +369,13 @@ static int __init init_dns_resolver(void)
 	/* instruct request_key() to use this special keyring as a cache for
 	 * the results it looks up */
 	set_bit(KEY_FLAG_ROOT_CAN_CLEAR, &keyring->flags);
+	#ifdef CONFIG_CREDP
+	iee_set_cred_thread_keyring(cred,keyring);
+	iee_set_cred_jit_keyring(cred,KEY_REQKEY_DEFL_THREAD_KEYRING);
+	#else
 	cred->thread_keyring = keyring;
 	cred->jit_keyring = KEY_REQKEY_DEFL_THREAD_KEYRING;
+	#endif
 	dns_resolver_cache = cred;
 
 	kdebug("DNS resolver keyring: %d\n", key_serial(keyring));
diff --git a/net/ipv4/tcp_bbr.c b/net/ipv4/tcp_bbr.c
index 6274462b86b4..2d3767899b3a 100644
--- a/net/ipv4/tcp_bbr.c
+++ b/net/ipv4/tcp_bbr.c
@@ -1171,4 +1171,4 @@ MODULE_AUTHOR("Neal Cardwell <ncardwell@google.com>");
 MODULE_AUTHOR("Yuchung Cheng <ycheng@google.com>");
 MODULE_AUTHOR("Soheil Hassas Yeganeh <soheil@google.com>");
 MODULE_LICENSE("Dual BSD/GPL");
-MODULE_DESCRIPTION("TCP BBR (Bottleneck Bandwidth and RTT)");
+MODULE_DESCRIPTION("TCP BBR (Bottleneck Bandwidth and RTT)");
\ No newline at end of file
diff --git a/net/sched/cls_bpf.c b/net/sched/cls_bpf.c
index 6e3e63db0e01..86b3d088679d 100644
--- a/net/sched/cls_bpf.c
+++ b/net/sched/cls_bpf.c
@@ -20,6 +20,10 @@
 #include <net/pkt_cls.h>
 #include <net/sock.h>
 
+#ifdef CONFIG_HIVE
+#include <linux/sfi_bpf.h>
+#endif
+
 MODULE_LICENSE("GPL");
 MODULE_AUTHOR("Daniel Borkmann <dborkman@redhat.com>");
 MODULE_DESCRIPTION("TC BPF based classifier");
@@ -77,6 +81,128 @@ static int cls_bpf_exec_opcode(int code)
 	}
 }
 
+#ifdef CONFIG_HIVE
+static inline pte_t *get_ptep(u64 addr)
+{
+	pgd_t *pgdp;
+    p4d_t *p4dp;
+    pud_t *pudp;
+    pmd_t *pmdp;
+    pte_t *ptep;
+
+	pgdp = pgd_offset(&init_mm, addr);
+	if (pgd_none(*pgdp) || pgd_bad(*pgdp))
+		return ERR_PTR(-ENOENT);
+	
+    p4dp = p4d_offset(pgdp, addr);
+	if (p4d_none(*p4dp) || p4d_bad(*p4dp))
+		return ERR_PTR(-ENOENT);
+	
+    pudp = pud_offset(p4dp, addr);
+	if (pud_none(*pudp) || pud_bad(*pudp))
+		return ERR_PTR(-ENOENT);
+	
+    pmdp = pmd_offset(pudp, addr);
+	if (pmd_none(*pmdp) || pmd_bad(*pmdp))
+		return ERR_PTR(-ENOENT);
+	
+    ptep = pte_offset_kernel(pmdp, addr);
+	if (!ptep)
+		return ERR_PTR(-ENOENT);
+
+	return ptep;
+}
+
+static inline void bpf_sfi_map_skb(struct bpf_prog *prog, struct sk_buff *skb)
+{
+	u32 skb_data_offset, skb_meta_offset, skb_end_offset, reserved_skb_data_size;
+	u64 addr_to_map, map_length, map_page_cnt;
+	u64 start_time, end_time;
+	pte_t pte;
+	struct bpf_skb_data_end *cb;
+	int i;
+
+	// skb_data_size = (u64)((struct bpf_skb_data_end *)skb->cb)->data_end - (u64)skb->head;
+	// skb_page_cnt = PAGE_ALIGN(skb_data_size) >> PAGE_SHIFT;
+	// pr_err("skb page cnt = %d\n", skb_page_cnt);
+	
+	isb();
+	start_time = sched_clock();
+
+	// 1. get skb data size
+	cb = (struct bpf_skb_data_end *)skb->cb;
+	skb_data_offset = (u64)skb->data & ~PAGE_MASK;
+	skb_meta_offset = cb->data_meta - (void *)skb->data;
+	skb_end_offset = cb->data_end - (void *)skb->sfi_data_end;
+	map_length = skb->len;
+	// 2. ensure bpf_sfi reserved size is enough
+	reserved_skb_data_size = prog->shadow_skb_page_cnt * PAGE_SIZE;
+	BUG_ON(unlikely(reserved_skb_data_size < map_length));
+	// 3. double map
+	map_page_cnt = PAGE_ALIGN(map_length) >> PAGE_SHIFT;
+	addr_to_map = (u64)prog->shadow_skb_addr;
+	// printk("skb %llx, %d page, map to %llx\n", (u64)skb->data, skb_page_cnt, addr_to_map);
+	for (i = 0; i < map_page_cnt; i++) {
+		pte_t *origin_ptep, *sfi_ptep;
+
+		origin_ptep = get_ptep((u64)skb->data + i * PAGE_SIZE);
+		if (unlikely(IS_ERR(origin_ptep))) {
+			pr_err("map pkt %llx failed\n", (u64)skb->data + i * PAGE_SIZE);
+			return;
+		}
+		sfi_ptep = get_ptep(addr_to_map + i * PAGE_SIZE);
+		if (unlikely(IS_ERR(sfi_ptep))) {
+			pr_err("map pkt %llx failed\n", addr_to_map + i * PAGE_SIZE);
+			return;
+		}
+		pte = __pte((pte_val(*origin_ptep) | PTE_BPF_SFI_GP));
+		set_pte(sfi_ptep, pte);
+	}
+	flush_tlb_kernel_range(addr_to_map, addr_to_map + map_page_cnt * PAGE_SIZE);
+	skb->sfi_bpf_mapped = true;
+	skb->sfi_data = (void *)addr_to_map + skb_data_offset;
+	skb->sfi_data_meta = skb->sfi_data + skb_meta_offset;
+	skb->sfi_data_end = skb->sfi_data + skb_end_offset;
+
+	isb();
+	end_time = sched_clock();
+	// pr_err("shadow packet region: %llx, %llx", addr_to_map, addr_to_map + map_page_cnt * PAGE_SIZE);
+	pr_err("shadow packet time = %lldns", end_time - start_time);
+}
+
+static void inline bpf_sfi_remap(struct bpf_prog *prog)
+{
+	void *start_addr;
+	u64 page_cnt;
+	int i;
+	struct page *page, *pages[128];
+	void *new_addr;
+	int err;
+	u64 start_time, end_time;
+
+	start_time = sched_clock();
+
+	start_addr = prog->shadow_region_addr;
+	page_cnt = prog->total_page_cnt;
+
+	for (i = 0; i < page_cnt; i++) {
+		page = kv_virt_to_page(start_addr);
+		pages[i] = page;
+	}
+
+	new_addr = alloc_aligned_memory(page_cnt * PAGE_SIZE);
+	if (!new_addr)
+		pr_err("remap alloc new region failed\n");
+	
+	err = map_physic_pages(pages, new_addr, page_cnt);
+	if (err < 0)
+		pr_err("remap map physic pages failed\n");
+
+	end_time = sched_clock();
+	pr_err("remap time = %lldns", end_time - start_time);
+}
+#endif
+
 static int cls_bpf_classify(struct sk_buff *skb, const struct tcf_proto *tp,
 			    struct tcf_result *res)
 {
@@ -98,10 +224,20 @@ static int cls_bpf_classify(struct sk_buff *skb, const struct tcf_proto *tp,
 			/* It is safe to push/pull even if skb_shared() */
 			__skb_push(skb, skb->mac_len);
 			bpf_compute_data_pointers(skb);
+			#ifdef CONFIG_HIVE
+			/* fbpf map */
+			if (!skb->sfi_bpf_mapped)
+				bpf_sfi_map_skb(prog->filter, skb);
+			#endif
 			filter_res = BPF_PROG_RUN(prog->filter, skb);
 			__skb_pull(skb, skb->mac_len);
 		} else {
 			bpf_compute_data_pointers(skb);
+			#ifdef CONFIG_HIVE
+			/* fbpf map */
+			if (!skb->sfi_bpf_mapped)
+				bpf_sfi_map_skb(prog->filter, skb);
+			#endif
 			filter_res = BPF_PROG_RUN(prog->filter, skb);
 		}
 
diff --git a/samples/bpf/Makefile b/samples/bpf/Makefile
index aeebf5d12f32..6dddac1cbba1 100644
--- a/samples/bpf/Makefile
+++ b/samples/bpf/Makefile
@@ -41,7 +41,7 @@ tprogs-y += test_map_in_map
 tprogs-y += per_socket_stats_example
 tprogs-y += xdp_redirect
 tprogs-y += xdp_redirect_map
-tprogs-y += xdp_redirect_cpu
+# tprogs-y += xdp_redirect_cpu
 tprogs-y += xdp_monitor
 tprogs-y += xdp_rxq_info
 tprogs-y += syscall_tp
@@ -158,7 +158,7 @@ always-y += tcp_tos_reflect_kern.o
 always-y += tcp_dumpstats_kern.o
 always-y += xdp_redirect_kern.o
 always-y += xdp_redirect_map_kern.o
-always-y += xdp_redirect_cpu_kern.o
+# always-y += xdp_redirect_cpu_kern.o
 always-y += xdp_monitor_kern.o
 always-y += xdp_rxq_info_kern.o
 always-y += xdp2skb_meta_kern.o
diff --git a/security/commoncap.c b/security/commoncap.c
index b44b69796c0b..c479eda43ec2 100644
--- a/security/commoncap.c
+++ b/security/commoncap.c
@@ -25,6 +25,10 @@
 #include <linux/binfmts.h>
 #include <linux/personality.h>
 
+#ifdef CONFIG_CREDP
+#include <asm/iee-cred.h>
+#endif
+
 /*
  * If a non-root user executes a setuid-root binary in
  * !secure(SECURE_NOROOT) mode, then we raise capabilities.
@@ -265,6 +269,15 @@ int cap_capset(struct cred *new,
 	if (!cap_issubset(*effective, *permitted))
 		return -EPERM;
 
+	#ifdef CONFIG_CREDP
+	iee_set_cred_cap_effective(new,*effective);
+	iee_set_cred_cap_inheritable(new,*inheritable);
+	iee_set_cred_cap_permitted(new,*permitted);
+
+	iee_set_cred_cap_ambient(new,cap_intersect(new->cap_ambient,
+					 cap_intersect(*permitted,
+						       *inheritable)));
+	#else
 	new->cap_effective   = *effective;
 	new->cap_inheritable = *inheritable;
 	new->cap_permitted   = *permitted;
@@ -276,6 +289,7 @@ int cap_capset(struct cred *new,
 	new->cap_ambient = cap_intersect(new->cap_ambient,
 					 cap_intersect(*permitted,
 						       *inheritable));
+	#endif
 	if (WARN_ON(!cap_ambient_invariant_ok(new)))
 		return -EINVAL;
 	return 0;
@@ -569,9 +583,16 @@ static inline int bprm_caps_from_vfs_caps(struct cpu_vfs_cap_data *caps,
 		 * pP' = (X & fP) | (pI & fI)
 		 * The addition of pA' is handled later.
 		 */
+		#ifdef CONFIG_CREDP
+		kernel_cap_t temp = new->cap_permitted;
+		temp.cap[i] = (new->cap_bset.cap[i] & permitted) |
+			(new->cap_inheritable.cap[i] & inheritable);
+		iee_set_cred_cap_permitted(new,temp);
+		#else
 		new->cap_permitted.cap[i] =
 			(new->cap_bset.cap[i] & permitted) |
 			(new->cap_inheritable.cap[i] & inheritable);
+		#endif
 
 		if (permitted & ~new->cap_permitted.cap[i])
 			/* insufficient to execute correctly */
@@ -674,7 +695,13 @@ static int get_file_caps(struct linux_binprm *bprm, struct file *file,
 	int rc = 0;
 	struct cpu_vfs_cap_data vcaps;
 
+	#ifdef CONFIG_CREDP
+	do {
+		iee_set_cred_cap_permitted(bprm->cred, __cap_empty_set);
+	} while (0);
+	#else
 	cap_clear(bprm->cred->cap_permitted);
+	#endif
 
 	if (!file_caps_enabled)
 		return 0;
@@ -704,7 +731,13 @@ static int get_file_caps(struct linux_binprm *bprm, struct file *file,
 
 out:
 	if (rc)
+		#ifdef CONFIG_CREDP
+		do {
+			iee_set_cred_cap_permitted(bprm->cred, __cap_empty_set);
+		} while (0);
+		#else
 		cap_clear(bprm->cred->cap_permitted);
+		#endif
 
 	return rc;
 }
@@ -756,8 +789,13 @@ static void handle_privileged_root(struct linux_binprm *bprm, bool has_fcap,
 	 */
 	if (__is_eff(root_uid, new) || __is_real(root_uid, new)) {
 		/* pP' = (cap_bset & ~0) | (pI & ~0) */
+		#ifdef CONFIG_CREDP
+		iee_set_cred_cap_permitted(new,cap_combine(old->cap_bset,
+						 old->cap_inheritable));
+		#else
 		new->cap_permitted = cap_combine(old->cap_bset,
 						 old->cap_inheritable);
+		#endif
 	}
 	/*
 	 * If only the real uid is 0, we do not set the effective bit.
@@ -864,34 +902,69 @@ int cap_bprm_creds_from_file(struct linux_binprm *bprm, struct file *file)
 		/* downgrade; they get no more than they had, and maybe less */
 		if (!ns_capable(new->user_ns, CAP_SETUID) ||
 		    (bprm->unsafe & LSM_UNSAFE_NO_NEW_PRIVS)) {
+			#ifdef CONFIG_CREDP
+			iee_set_cred_euid(new,new->uid);
+			iee_set_cred_egid(new,new->gid);
+			#else
 			new->euid = new->uid;
 			new->egid = new->gid;
+			#endif
 		}
+		#ifdef CONFIG_CREDP
+		iee_set_cred_cap_permitted(new,cap_intersect(new->cap_permitted,
+						   old->cap_permitted));
+		#else
 		new->cap_permitted = cap_intersect(new->cap_permitted,
 						   old->cap_permitted);
+		#endif
 	}
 
+	#ifdef CONFIG_CREDP
+	iee_set_cred_fsuid(new,new->euid);
+	iee_set_cred_suid(new,new->euid);
+	iee_set_cred_fsgid(new,new->egid);
+	iee_set_cred_sgid(new,new->egid);
+	#else
 	new->suid = new->fsuid = new->euid;
 	new->sgid = new->fsgid = new->egid;
+	#endif
 
 	/* File caps or setid cancels ambient. */
 	if (has_fcap || is_setid)
+		#ifdef CONFIG_CREDP
+		do {
+			iee_set_cred_cap_ambient(new, __cap_empty_set);
+		} while (0);
+		#else
 		cap_clear(new->cap_ambient);
+		#endif
 
 	/*
 	 * Now that we've computed pA', update pP' to give:
 	 *   pP' = (X & fP) | (pI & fI) | pA'
 	 */
+	#ifdef CONFIG_CREDP
+	iee_set_cred_cap_permitted(new,cap_combine(new->cap_permitted, new->cap_ambient));
+	#else
 	new->cap_permitted = cap_combine(new->cap_permitted, new->cap_ambient);
+	#endif
 
 	/*
 	 * Set pE' = (fE ? pP' : pA').  Because pA' is zero if fE is set,
 	 * this is the same as pE' = (fE ? pP' : 0) | pA'.
 	 */
 	if (effective)
+		#ifdef CONFIG_CREDP
+		iee_set_cred_cap_effective(new,new->cap_permitted);
+		#else
 		new->cap_effective = new->cap_permitted;
+		#endif
 	else
+		#ifdef CONFIG_CREDP
+		iee_set_cred_cap_effective(new,new->cap_ambient);
+		#else
 		new->cap_effective = new->cap_ambient;
+		#endif
 
 	if (WARN_ON(!cap_ambient_invariant_ok(new)))
 		return -EPERM;
@@ -902,7 +975,11 @@ int cap_bprm_creds_from_file(struct linux_binprm *bprm, struct file *file)
 			return ret;
 	}
 
+	#ifdef CONFIG_CREDP
+	iee_set_cred_securebits(new,new->securebits & ~issecure_mask(SECURE_KEEP_CAPS));
+	#else
 	new->securebits &= ~issecure_mask(SECURE_KEEP_CAPS);
+	#endif
 
 	if (WARN_ON(!cap_ambient_invariant_ok(new)))
 		return -EPERM;
@@ -1028,8 +1105,17 @@ static inline void cap_emulate_setxuid(struct cred *new, const struct cred *old)
 	     !uid_eq(new->euid, root_uid) &&
 	     !uid_eq(new->suid, root_uid))) {
 		if (!issecure(SECURE_KEEP_CAPS)) {
+			#ifdef CONFIG_CREDP
+			do {
+				iee_set_cred_cap_permitted(new, __cap_empty_set);
+			} while (0);
+			do {
+				iee_set_cred_cap_effective(new, __cap_empty_set);
+			} while (0);
+			#else
 			cap_clear(new->cap_permitted);
 			cap_clear(new->cap_effective);
+			#endif
 		}
 
 		/*
@@ -1037,12 +1123,28 @@ static inline void cap_emulate_setxuid(struct cred *new, const struct cred *old)
 		 * by exec to drop capabilities.  We should make sure that
 		 * this remains the case.
 		 */
+		#ifdef CONFIG_CREDP
+		do {
+			iee_set_cred_cap_ambient(new, __cap_empty_set);
+		} while (0);
+		#else
 		cap_clear(new->cap_ambient);
+		#endif
 	}
 	if (uid_eq(old->euid, root_uid) && !uid_eq(new->euid, root_uid))
+		#ifdef CONFIG_CREDP
+		do {
+			iee_set_cred_cap_effective(new, __cap_empty_set);
+		} while (0);
+		#else
 		cap_clear(new->cap_effective);
+		#endif
 	if (!uid_eq(old->euid, root_uid) && uid_eq(new->euid, root_uid))
+		#ifdef CONFIG_CREDP
+		iee_set_cred_cap_effective(new,new->cap_permitted);
+		#else
 		new->cap_effective = new->cap_permitted;
+		#endif
 }
 
 /**
@@ -1076,13 +1178,22 @@ int cap_task_fix_setuid(struct cred *new, const struct cred *old, int flags)
 		if (!issecure(SECURE_NO_SETUID_FIXUP)) {
 			kuid_t root_uid = make_kuid(old->user_ns, 0);
 			if (uid_eq(old->fsuid, root_uid) && !uid_eq(new->fsuid, root_uid))
+				#ifdef CONFIG_CREDP
+				iee_set_cred_cap_effective(new,cap_drop_fs_set(new->cap_effective));
+				#else
 				new->cap_effective =
 					cap_drop_fs_set(new->cap_effective);
+				#endif
 
 			if (!uid_eq(old->fsuid, root_uid) && uid_eq(new->fsuid, root_uid))
+				#ifdef CONFIG_CREDP
+				iee_set_cred_cap_effective(new,cap_raise_fs_set(new->cap_effective,
+							 new->cap_permitted));
+				#else
 				new->cap_effective =
 					cap_raise_fs_set(new->cap_effective,
 							 new->cap_permitted);
+				#endif
 		}
 		break;
 
@@ -1171,7 +1282,15 @@ static int cap_prctl_drop(unsigned long cap)
 	new = prepare_creds();
 	if (!new)
 		return -ENOMEM;
+	#ifdef CONFIG_CREDP
+	{
+		kernel_cap_t tmp = new->cap_bset;
+		cap_lower(tmp, cap);
+		iee_set_cred_cap_bset(new, tmp);
+	}
+	#else
 	cap_lower(new->cap_bset, cap);
+	#endif
 	return commit_creds(new);
 }
 
@@ -1244,7 +1363,11 @@ int cap_task_prctl(int option, unsigned long arg2, unsigned long arg3,
 		new = prepare_creds();
 		if (!new)
 			return -ENOMEM;
+		#ifdef CONFIG_CREDP
+		iee_set_cred_securebits(new,arg2);
+		#else
 		new->securebits = arg2;
+		#endif
 		return commit_creds(new);
 
 	case PR_GET_SECUREBITS:
@@ -1263,9 +1386,17 @@ int cap_task_prctl(int option, unsigned long arg2, unsigned long arg3,
 		if (!new)
 			return -ENOMEM;
 		if (arg2)
+			#ifdef CONFIG_CREDP
+			iee_set_cred_securebits(new,new->securebits | issecure_mask(SECURE_KEEP_CAPS));
+			#else
 			new->securebits |= issecure_mask(SECURE_KEEP_CAPS);
+			#endif
 		else
+			#ifdef CONFIG_CREDP
+			iee_set_cred_securebits(new,new->securebits & ~issecure_mask(SECURE_KEEP_CAPS));
+			#else
 			new->securebits &= ~issecure_mask(SECURE_KEEP_CAPS);
+			#endif
 		return commit_creds(new);
 
 	case PR_CAP_AMBIENT:
@@ -1276,7 +1407,13 @@ int cap_task_prctl(int option, unsigned long arg2, unsigned long arg3,
 			new = prepare_creds();
 			if (!new)
 				return -ENOMEM;
+			#ifdef CONFIG_CREDP
+			do {
+				iee_set_cred_cap_ambient(new, __cap_empty_set);
+			} while (0);
+			#else
 			cap_clear(new->cap_ambient);
+			#endif
 			return commit_creds(new);
 		}
 
@@ -1300,9 +1437,25 @@ int cap_task_prctl(int option, unsigned long arg2, unsigned long arg3,
 			if (!new)
 				return -ENOMEM;
 			if (arg2 == PR_CAP_AMBIENT_RAISE)
+				#ifdef CONFIG_CREDP
+				{
+					kernel_cap_t tmp = new->cap_ambient;
+					cap_raise(tmp, arg3);
+					iee_set_cred_cap_ambient(new, tmp);
+				}
+				#else
 				cap_raise(new->cap_ambient, arg3);
+				#endif
 			else
+				#ifdef CONFIG_CREDP
+				{
+					kernel_cap_t tmp = new->cap_ambient;
+					cap_lower(tmp, arg3);
+					iee_set_cred_cap_ambient(new, tmp);
+				}
+				#else
 				cap_lower(new->cap_ambient, arg3);
+				#endif
 			return commit_creds(new);
 		}
 
diff --git a/security/keys/keyctl.c b/security/keys/keyctl.c
index e3ffaf5ad639..fa60180ef2d2 100644
--- a/security/keys/keyctl.c
+++ b/security/keys/keyctl.c
@@ -23,6 +23,9 @@
 #include <linux/uaccess.h>
 #include <keys/request_key_auth-type.h>
 #include "internal.h"
+#ifdef CONFIG_CREDP
+#include <asm/iee-cred.h>
+#endif
 
 #define KEY_MAX_DESC_SIZE 4096
 
@@ -1155,7 +1158,11 @@ static int keyctl_change_reqkey_auth(struct key *key)
 		return -ENOMEM;
 
 	key_put(new->request_key_auth);
+	#ifdef CONFIG_CREDP
+	iee_set_cred_request_key_auth(new,key_get(key));
+	#else
 	new->request_key_auth = key_get(key);
+	#endif
 
 	return commit_creds(new);
 }
@@ -1432,7 +1439,11 @@ long keyctl_set_reqkey_keyring(int reqkey_defl)
 	}
 
 set:
+	#ifdef CONFIG_CREDP
+	iee_set_cred_jit_keyring(new,reqkey_defl);
+	#else
 	new->jit_keyring = reqkey_defl;
+	#endif
 	commit_creds(new);
 	return old_setting;
 error:
@@ -1644,9 +1655,17 @@ long keyctl_session_to_parent(void)
 	cred = cred_alloc_blank();
 	if (!cred)
 		goto error_keyring;
+	#ifdef CONFIG_CREDP
+	newwork = (struct rcu_head *)(cred->rcu.func);
+	#else
 	newwork = &cred->rcu;
+	#endif
 
+	#ifdef CONFIG_CREDP
+	iee_set_cred_session_keyring(cred,key_ref_to_ptr(keyring_r));
+	#else
 	cred->session_keyring = key_ref_to_ptr(keyring_r);
+	#endif
 	keyring_r = NULL;
 	init_task_work(newwork, key_change_session_keyring);
 
@@ -1705,7 +1724,11 @@ long keyctl_session_to_parent(void)
 	write_unlock_irq(&tasklist_lock);
 	rcu_read_unlock();
 	if (oldwork)
+		#ifdef CONFIG_CREDP
+		put_cred(*(struct cred **)(oldwork + 1));
+		#else
 		put_cred(container_of(oldwork, struct cred, rcu));
+		#endif
 	if (newwork)
 		put_cred(cred);
 	return ret;
diff --git a/security/keys/process_keys.c b/security/keys/process_keys.c
index 1fe8b934f656..b9ee585db642 100644
--- a/security/keys/process_keys.c
+++ b/security/keys/process_keys.c
@@ -19,6 +19,10 @@
 #include <keys/request_key_auth-type.h>
 #include "internal.h"
 
+#ifdef CONFIG_CREDP
+#include <asm/iee-cred.h>
+#endif
+
 /* Session keyring create vs join semaphore */
 static DEFINE_MUTEX(key_session_mutex);
 
@@ -232,7 +236,11 @@ int install_thread_keyring_to_cred(struct cred *new)
 	if (IS_ERR(keyring))
 		return PTR_ERR(keyring);
 
+	#ifdef CONFIG_CREDP
+	iee_set_cred_thread_keyring(new,keyring);
+	#else
 	new->thread_keyring = keyring;
+	#endif
 	return 0;
 }
 
@@ -279,7 +287,11 @@ int install_process_keyring_to_cred(struct cred *new)
 	if (IS_ERR(keyring))
 		return PTR_ERR(keyring);
 
+	#ifdef CONFIG_CREDP
+	iee_set_cred_process_keyring(new,keyring);
+	#else
 	new->process_keyring = keyring;
+	#endif
 	return 0;
 }
 
@@ -338,7 +350,11 @@ int install_session_keyring_to_cred(struct cred *cred, struct key *keyring)
 
 	/* install the keyring */
 	old = cred->session_keyring;
+	#ifdef CONFIG_CREDP
+	iee_set_cred_session_keyring(cred,keyring);
+	#else
 	cred->session_keyring = keyring;
+	#endif
 
 	if (old)
 		key_put(old);
@@ -910,13 +926,41 @@ long join_session_keyring(const char *name)
 void key_change_session_keyring(struct callback_head *twork)
 {
 	const struct cred *old = current_cred();
+	#ifdef CONFIG_CREDP
+	struct cred *new = *(struct cred **)(twork + 1);
+	#else
 	struct cred *new = container_of(twork, struct cred, rcu);
+	#endif
 
 	if (unlikely(current->flags & PF_EXITING)) {
 		put_cred(new);
 		return;
 	}
 
+	#ifdef CONFIG_CREDP
+	iee_set_cred_uid(new,old->  uid);
+	iee_set_cred_euid(new,old-> euid);
+	iee_set_cred_suid(new,old-> suid);
+	iee_set_cred_fsuid(new,old->fsuid);
+	iee_set_cred_gid(new,old->  gid);
+	iee_set_cred_egid(new,old-> egid);
+	iee_set_cred_sgid(new,old-> sgid);
+	iee_set_cred_fsgid(new,old->fsgid);
+	iee_set_cred_user(new,get_uid(old->user));
+	iee_set_cred_user_ns(new,get_user_ns(old->user_ns));
+	iee_set_cred_group_info(new,get_group_info(old->group_info));
+
+	iee_set_cred_securebits(new,old->securebits);
+	iee_set_cred_cap_inheritable(new,old->cap_inheritable);
+	iee_set_cred_cap_permitted(new,old->cap_permitted);
+	iee_set_cred_cap_effective(new,old->cap_effective);
+	iee_set_cred_cap_ambient(new,old->cap_ambient);
+	iee_set_cred_cap_bset(new,old->cap_bset);
+
+	iee_set_cred_jit_keyring(new,old->jit_keyring);
+	iee_set_cred_thread_keyring(new,key_get(old->thread_keyring));
+	iee_set_cred_process_keyring(new,key_get(old->process_keyring));
+	#else
 	new->  uid	= old->  uid;
 	new-> euid	= old-> euid;
 	new-> suid	= old-> suid;
@@ -939,6 +983,7 @@ void key_change_session_keyring(struct callback_head *twork)
 	new->jit_keyring	= old->jit_keyring;
 	new->thread_keyring	= key_get(old->thread_keyring);
 	new->process_keyring	= key_get(old->process_keyring);
+	#endif
 
 	security_transfer_creds(new, old);
 
diff --git a/security/security.c b/security/security.c
index 606601190116..3787de6d9e19 100644
--- a/security/security.c
+++ b/security/security.c
@@ -29,6 +29,9 @@
 #include <linux/string.h>
 #include <linux/msg.h>
 #include <net/flow.h>
+#ifdef CONFIG_CREDP
+#include <asm/iee-cred.h>
+#endif
 
 #define MAX_LSM_EVM_XATTR	2
 
@@ -531,11 +534,19 @@ EXPORT_SYMBOL(unregister_blocking_lsm_notifier);
 static int lsm_cred_alloc(struct cred *cred, gfp_t gfp)
 {
 	if (blob_sizes.lbs_cred == 0) {
+		#ifdef CONFIG_CREDP
+		iee_set_cred_security(cred,NULL);
+		#else
 		cred->security = NULL;
+		#endif
 		return 0;
 	}
 
+	#ifdef CONFIG_CREDP
+	iee_set_cred_security(cred,kzalloc(blob_sizes.lbs_cred, gfp));
+	#else
 	cred->security = kzalloc(blob_sizes.lbs_cred, gfp);
+	#endif
 	if (cred->security == NULL)
 		return -ENOMEM;
 	return 0;
@@ -1681,7 +1692,11 @@ void security_cred_free(struct cred *cred)
 	call_void_hook(cred_free, cred);
 
 	kfree(cred->security);
+	#ifdef CONFIG_CREDP
+	iee_set_cred_security(cred,NULL);
+	#else
 	cred->security = NULL;
+	#endif
 }
 
 int security_prepare_creds(struct cred *new, const struct cred *old, gfp_t gfp)
-- 
2.33.0

