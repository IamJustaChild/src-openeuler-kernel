diff --git a/fs/nfs/client.c b/fs/nfs/client.c
index 7d02dc52209d..50820a8a684a 100644
--- a/fs/nfs/client.c
+++ b/fs/nfs/client.c
@@ -48,7 +48,7 @@
 #include "callback.h"
 #include "delegation.h"
 #include "iostat.h"
-#include "internal.h"
+#include "enfs_adapter.h"
 #include "fscache.h"
 #include "pnfs.h"
 #include "nfs.h"
@@ -255,6 +255,7 @@ void nfs_free_client(struct nfs_client *clp)
 	put_nfs_version(clp->cl_nfs_mod);
 	kfree(clp->cl_hostname);
 	kfree(clp->cl_acceptor);
+	nfs_free_multi_path_client(clp);
 	kfree(clp);
 }
 EXPORT_SYMBOL_GPL(nfs_free_client);
@@ -330,6 +331,9 @@ static struct nfs_client *nfs_match_client(const struct nfs_client_initdata *dat
 							   sap))
 				continue;
 
+		if (!nfs_multipath_client_match(clp, data))
+			continue;
+
 		refcount_inc(&clp->cl_count);
 		return clp;
 	}
@@ -512,6 +516,9 @@ int nfs_create_rpc_client(struct nfs_client *clp,
 		.program	= &nfs_program,
 		.version	= clp->rpc_ops->version,
 		.authflavor	= flavor,
+#if IS_ENABLED(CONFIG_ENFS)
+		.multipath_option = cl_init->enfs_option,
+#endif
 	};
 
 	if (test_bit(NFS_CS_DISCRTRY, &clp->cl_flags))
@@ -634,6 +641,13 @@ struct nfs_client *nfs_init_client(struct nfs_client *clp,
 	/* the client is already initialised */
 	if (clp->cl_cons_state == NFS_CS_READY)
 		return clp;
+	error = nfs_create_multi_path_client(clp, cl_init);
+	if (error < 0) {
+		dprintk("%s: create failed.%d!\n", __func__, error);
+		nfs_put_client(clp);
+		clp = ERR_PTR(error);
+		return clp;
+	}
 
 	/*
 	 * Create a client RPC handle for doing FSSTAT with UNIX auth only
@@ -666,6 +680,9 @@ static int nfs_init_server(struct nfs_server *server,
 		.net = data->net,
 		.timeparms = &timeparms,
 		.init_flags = (1UL << NFS_CS_REUSEPORT),
+#if IS_ENABLED(CONFIG_ENFS)
+		.enfs_option = data->enfs_option,
+#endif
 	};
 	struct nfs_client *clp;
 	int error;
diff --git a/fs/nfs/enfs_adapter.c b/fs/nfs/enfs_adapter.c
new file mode 100644
index 000000000000..7f471f2072c4
--- /dev/null
+++ b/fs/nfs/enfs_adapter.c
@@ -0,0 +1,230 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Client-side ENFS adapter.
+ *
+ * Copyright (c) 2023. Huawei Technologies Co., Ltd. All rights reserved.
+ */
+#include <linux/types.h>
+#include <linux/sunrpc/clnt.h>
+#include <linux/nfs.h>
+#include <linux/nfs4.h>
+#include <linux/nfs3.h>
+#include <linux/nfs_fs.h>
+#include <linux/nfs_fs_sb.h>
+#include <linux/sunrpc/sched.h>
+#include <linux/nfs_iostat.h>
+#include "enfs_adapter.h"
+#include "iostat.h"
+
+struct enfs_adapter_ops __rcu *enfs_adapter;
+
+int enfs_adapter_register(struct enfs_adapter_ops *ops)
+{
+	struct enfs_adapter_ops *old;
+
+	old = cmpxchg((struct enfs_adapter_ops **)&enfs_adapter, NULL, ops);
+	if (old == NULL || old == ops)
+		return 0;
+	pr_err("regist %s ops %p failed. old %p\n", __func__, ops, old);
+	return -EPERM;
+}
+EXPORT_SYMBOL_GPL(enfs_adapter_register);
+
+int enfs_adapter_unregister(struct enfs_adapter_ops *ops)
+{
+	struct enfs_adapter_ops *old;
+
+	old = cmpxchg((struct enfs_adapter_ops **)&enfs_adapter, ops, NULL);
+	if (old == ops || old == NULL)
+		return 0;
+	pr_err("unregist %s ops %p failed. old %p\n", __func__, ops, old);
+	return -EPERM;
+}
+EXPORT_SYMBOL_GPL(enfs_adapter_unregister);
+
+struct enfs_adapter_ops *nfs_multipath_router_get(void)
+{
+	struct enfs_adapter_ops *ops;
+
+	rcu_read_lock();
+	ops = rcu_dereference(enfs_adapter);
+	if (ops == NULL) {
+		rcu_read_unlock();
+		return NULL;
+	}
+	if (!try_module_get(ops->owner))
+		ops = NULL;
+	rcu_read_unlock();
+	return ops;
+}
+
+void nfs_multipath_router_put(struct enfs_adapter_ops *ops)
+{
+	if (ops)
+		module_put(ops->owner);
+}
+
+bool is_valid_option(enum nfsmultipathoptions option)
+{
+	if (option < REMOTEADDR || option >= INVALID_OPTION) {
+		pr_warn("%s: ENFS invalid option %d\n", __func__, option);
+		return false;
+	}
+
+	return true;
+}
+
+int enfs_parse_mount_options(enum nfsmultipathoptions option, char *str,
+			struct nfs_parsed_mount_data *mnt)
+{
+
+    //parseMultiPathOptions(getNfsMultiPathOpt(token), string, mnt);
+
+	int rc;
+	struct enfs_adapter_ops *ops;
+
+	ops = nfs_multipath_router_get();
+	if ((ops == NULL) || (ops->parse_mount_options == NULL) ||
+		!is_valid_option(option)) {
+		nfs_multipath_router_put(ops);
+		dfprintk(MOUNT,
+		"NFS: parsing nfs mount option enfs not load[%s]\n"
+		,  __func__);
+		return -EOPNOTSUPP;
+	}
+    // nfs_multipath_parse_options
+	dfprintk(MOUNT, "NFS:   parsing nfs mount option '%s' type: %d[%s]\n"
+			, str, option, __func__);
+	rc = ops->parse_mount_options(option, str, &mnt->enfs_option, mnt->net);
+	nfs_multipath_router_put(ops);
+	return rc;
+}
+
+void enfs_free_mount_options(struct nfs_parsed_mount_data *data)
+{
+	struct enfs_adapter_ops *ops;
+
+	if (data->enfs_option == NULL)
+		return;
+
+	ops = nfs_multipath_router_get();
+	if ((ops == NULL) || (ops->free_mount_options == NULL)) {
+		nfs_multipath_router_put(ops);
+		return;
+	}
+	ops->free_mount_options((void *)&data->enfs_option);
+	nfs_multipath_router_put(ops);
+}
+
+int nfs_create_multi_path_client(struct nfs_client *client,
+			const struct nfs_client_initdata *cl_init)
+{
+	int ret = 0;
+	struct enfs_adapter_ops *ops;
+
+	if (cl_init->enfs_option == NULL)
+		return 0;
+
+	ops = nfs_multipath_router_get();
+	if (ops != NULL && ops->client_info_init != NULL)
+		ret = ops->client_info_init(
+			(void *)&client->cl_multipath_data, cl_init);
+	nfs_multipath_router_put(ops);
+
+	return ret;
+}
+EXPORT_SYMBOL_GPL(nfs_create_multi_path_client);
+
+void nfs_free_multi_path_client(struct nfs_client *clp)
+{
+	struct enfs_adapter_ops *ops;
+
+	if (clp->cl_multipath_data == NULL)
+		return;
+
+	ops = nfs_multipath_router_get();
+	if (ops != NULL && ops->client_info_free != NULL)
+		ops->client_info_free(clp->cl_multipath_data);
+	nfs_multipath_router_put(ops);
+}
+
+int nfs_multipath_client_match(struct nfs_client *clp,
+			const struct nfs_client_initdata *sap)
+{
+	int ret = true;
+	struct enfs_adapter_ops *ops;
+
+	pr_info("%s src %p dst %p\n.", __func__,
+	clp->cl_multipath_data, sap->enfs_option);
+
+	if (clp->cl_multipath_data == NULL && sap->enfs_option == NULL)
+		return true;
+
+	if ((clp->cl_multipath_data == NULL && sap->enfs_option) ||
+		(clp->cl_multipath_data && sap->enfs_option == NULL)) {
+		pr_err("not match client src %p dst %p\n.",
+				clp->cl_multipath_data, sap->enfs_option);
+		return false;
+	}
+
+	ops = nfs_multipath_router_get();
+	if (ops != NULL && ops->client_info_match != NULL)
+		ret = ops->client_info_match(clp->cl_multipath_data,
+					sap->enfs_option);
+	nfs_multipath_router_put(ops);
+
+	return ret;
+}
+
+int nfs4_multipath_client_match(struct nfs_client *src, struct nfs_client *dst)
+{
+	int ret = true;
+	struct enfs_adapter_ops *ops;
+
+	if (src->cl_multipath_data == NULL && dst->cl_multipath_data == NULL)
+		return true;
+
+	if (src->cl_multipath_data == NULL || dst->cl_multipath_data == NULL)
+		return false;
+
+	ops = nfs_multipath_router_get();
+	if (ops != NULL && ops->nfs4_client_info_match != NULL)
+		ret = ops->nfs4_client_info_match(src->cl_multipath_data,
+					src->cl_multipath_data);
+	nfs_multipath_router_put(ops);
+
+	return ret;
+}
+EXPORT_SYMBOL_GPL(nfs4_multipath_client_match);
+
+void nfs_multipath_show_client_info(struct seq_file *mount_option,
+			struct nfs_server *server)
+{
+	struct enfs_adapter_ops *ops;
+
+	if (mount_option == NULL || server == NULL ||
+		server->client == NULL ||
+		server->nfs_client->cl_multipath_data == NULL)
+		return;
+
+	ops = nfs_multipath_router_get();
+	if (ops != NULL && ops->client_info_show != NULL)
+		ops->client_info_show(mount_option, server);
+	nfs_multipath_router_put(ops);
+}
+
+int nfs_remount_iplist(struct nfs_client *nfs_client, void *enfs_option)
+{
+	int ret = 0;
+	struct enfs_adapter_ops *ops;
+
+	if (nfs_client == NULL || nfs_client->cl_rpcclient == NULL)
+		return 0;
+
+	ops = nfs_multipath_router_get();
+	if (ops != NULL && ops->remount_ip_list != NULL)
+		ret = ops->remount_ip_list(nfs_client, enfs_option);
+	nfs_multipath_router_put(ops);
+	return ret;
+}
+EXPORT_SYMBOL_GPL(nfs_remount_iplist);
diff --git a/fs/nfs/enfs_adapter.h b/fs/nfs/enfs_adapter.h
new file mode 100644
index 000000000000..752544e18056
--- /dev/null
+++ b/fs/nfs/enfs_adapter.h
@@ -0,0 +1,101 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ *  Client-side ENFS adapt header.
+ *
+ *  Copyright (c) 2023. Huawei Technologies Co., Ltd. All rights reserved.
+ */
+#ifndef _NFS_MULTIPATH_H_
+#define _NFS_MULTIPATH_H_
+
+#include "internal.h"
+
+#if IS_ENABLED(CONFIG_ENFS)
+enum nfsmultipathoptions {
+	REMOTEADDR,
+	LOCALADDR,
+	REMOTEDNSNAME,
+	REMOUNTREMOTEADDR,
+	REMOUNTLOCALADDR,
+	INVALID_OPTION
+};
+
+
+struct enfs_adapter_ops {
+	const char *name;
+	struct module *owner;
+	int (*parse_mount_options)(enum nfsmultipathoptions option,
+		char *str, void **enfs_option, struct net *net_ns);
+
+	void (*free_mount_options)(void **data);
+
+	int (*client_info_init)(void **data,
+				const struct nfs_client_initdata *cl_init);
+	void (*client_info_free)(void *data);
+	int (*client_info_match)(void *src, void *dst);
+	int (*nfs4_client_info_match)(void *src, void *dst);
+	void (*client_info_show)(struct seq_file *mount_option, void *data);
+	int (*remount_ip_list)(struct nfs_client *nfs_client,
+						void *enfs_option);
+};
+
+int enfs_parse_mount_options(enum nfsmultipathoptions option, char *str,
+			struct nfs_parsed_mount_data *mnt);
+void enfs_free_mount_options(struct nfs_parsed_mount_data *data);
+int nfs_create_multi_path_client(struct nfs_client *client,
+			const struct nfs_client_initdata *cl_init);
+void nfs_free_multi_path_client(struct nfs_client *clp);
+int nfs_multipath_client_match(struct nfs_client *clp,
+			const struct nfs_client_initdata *sap);
+int nfs4_multipath_client_match(struct nfs_client *src, struct nfs_client *dst);
+void nfs_multipath_show_client_info(struct seq_file *mount_option,
+			struct nfs_server *server);
+int enfs_adapter_register(struct enfs_adapter_ops *ops);
+int enfs_adapter_unregister(struct enfs_adapter_ops *ops);
+int nfs_remount_iplist(struct nfs_client *nfs_client, void *enfs_option);
+int nfs4_create_multi_path(struct nfs_server *server,
+	struct nfs_parsed_mount_data *data,
+	const struct rpc_timeout *timeparms);
+
+#else
+static inline
+void nfs_free_multi_path_client(struct nfs_client *clp)
+{
+
+}
+
+static inline
+int nfs_multipath_client_match(struct nfs_client *clp,
+			const struct nfs_client_initdata *sap)
+{
+	return 1;
+}
+
+static inline
+int nfs_create_multi_path_client(struct nfs_client *client,
+			const struct nfs_client_initdata *cl_init)
+{
+	return 0;
+}
+
+static inline
+void nfs_multipath_show_client_info(struct seq_file *mount_option,
+			struct nfs_server *server)
+{
+
+}
+
+static inline
+int nfs4_multipath_client_match(struct nfs_client *src,
+			struct nfs_client *dst)
+{
+	return 1;
+}
+
+static inline
+void enfs_free_mount_options(struct nfs_parsed_mount_data *data)
+{
+
+}
+
+#endif // CONFIG_ENFS
+#endif // _NFS_MULTIPATH_H_
diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index 0ce5a90640c4..c696693edc7b 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -93,6 +93,9 @@ struct nfs_client_initdata {
 	u32 minorversion;
 	struct net *net;
 	const struct rpc_timeout *timeparms;
+#if IS_ENABLED(CONFIG_ENFS)
+	void *enfs_option; /* struct multipath_mount_options * */
+#endif
 };
 
 /*
@@ -135,6 +138,9 @@ struct nfs_parsed_mount_data {
 
 	struct security_mnt_opts lsm_opts;
 	struct net		*net;
+#if IS_ENABLED(CONFIG_ENFS)
+	void *enfs_option; /* struct multipath_mount_options * */
+#endif
 };
 
 /* mount_clnt.c */
diff --git a/fs/nfs/nfs4client.c b/fs/nfs/nfs4client.c
index 1350ea673672..4aa6e1f961f7 100644
--- a/fs/nfs/nfs4client.c
+++ b/fs/nfs/nfs4client.c
@@ -10,7 +10,7 @@
 #include <linux/sunrpc/xprt.h>
 #include <linux/sunrpc/bc_xprt.h>
 #include <linux/sunrpc/rpc_pipe_fs.h>
-#include "internal.h"
+#include "enfs_adapter.h"
 #include "callback.h"
 #include "delegation.h"
 #include "nfs4session.h"
@@ -225,6 +225,16 @@ struct nfs_client *nfs4_alloc_client(const struct nfs_client_initdata *cl_init)
 	__set_bit(NFS_CS_DISCRTRY, &clp->cl_flags);
 	__set_bit(NFS_CS_NO_RETRANS_TIMEOUT, &clp->cl_flags);
 
+#if IS_ENABLED(CONFIG_ENFS)
+	err = nfs_create_multi_path_client(clp, cl_init);
+	if (err < 0) {
+		dprintk("%s: create failed.%d\n", __func__, err);
+		nfs_put_client(clp);
+		clp = ERR_PTR(err);
+		return clp;
+	}
+#endif
+
 	/*
 	 * Set up the connection to the server before we add add to the
 	 * global list.
@@ -529,6 +539,9 @@ static int nfs4_match_client(struct nfs_client  *pos,  struct nfs_client *new,
 	if (!nfs4_match_client_owner_id(pos, new))
 		return 1;
 
+	if (!nfs4_multipath_client_match(pos, new))
+		return 1;
+
 	return 0;
 }
 
@@ -860,7 +873,7 @@ static int nfs4_set_client(struct nfs_server *server,
 		const size_t addrlen,
 		const char *ip_addr,
 		int proto, const struct rpc_timeout *timeparms,
-		u32 minorversion, struct net *net)
+		u32 minorversion, struct net *net, void *enfs_option)
 {
 	struct nfs_client_initdata cl_init = {
 		.hostname = hostname,
@@ -872,6 +885,9 @@ static int nfs4_set_client(struct nfs_server *server,
 		.minorversion = minorversion,
 		.net = net,
 		.timeparms = timeparms,
+#if IS_ENABLED(CONFIG_ENFS)
+		.enfs_option = enfs_option,
+#endif
 	};
 	struct nfs_client *clp;
 
@@ -1042,6 +1058,30 @@ static int nfs4_server_common_setup(struct nfs_server *server,
 	return error;
 }
 
+int nfs4_create_multi_path(struct nfs_server *server,
+			struct nfs_parsed_mount_data *data,
+			const struct rpc_timeout *timeparms)
+{
+	struct nfs_client_initdata cl_init = {
+		.hostname = data->nfs_server.hostname,
+		.addr = (const struct sockaddr *)&data->nfs_server.address,
+		.addrlen = data->nfs_server.addrlen,
+		.ip_addr = data->client_address,
+		.nfs_mod = &nfs_v4,
+		.proto = data->nfs_server.protocol,
+		.minorversion = data->minorversion,
+		.net = data->net,
+		.timeparms = timeparms,
+#if IS_ENABLED(CONFIG_ENFS)
+		.enfs_option = data->enfs_option,
+#endif // CONFIG_ENFS
+	};
+
+	return nfs_create_multi_path_client(server->nfs_client, &cl_init);
+
+}
+EXPORT_SYMBOL_GPL(nfs4_create_multi_path);
+
 /*
  * Create a version 4 volume record
  */
@@ -1050,6 +1090,7 @@ static int nfs4_init_server(struct nfs_server *server,
 {
 	struct rpc_timeout timeparms;
 	int error;
+	void *enfs_option = NULL;
 
 	nfs_init_timeout_values(&timeparms, data->nfs_server.protocol,
 			data->timeo, data->retrans);
@@ -1067,6 +1108,10 @@ static int nfs4_init_server(struct nfs_server *server,
 	else
 		data->selected_flavor = RPC_AUTH_UNIX;
 
+#if IS_ENABLED(CONFIG_ENFS)
+	enfs_option = data->enfs_option;
+#endif
+
 	/* Get a client record */
 	error = nfs4_set_client(server,
 			data->nfs_server.hostname,
@@ -1076,7 +1121,7 @@ static int nfs4_init_server(struct nfs_server *server,
 			data->nfs_server.protocol,
 			&timeparms,
 			data->minorversion,
-			data->net);
+			data->net, enfs_option);
 	if (error < 0)
 		return error;
 
@@ -1161,7 +1206,7 @@ struct nfs_server *nfs4_create_referral_server(struct nfs_clone_mount *data,
 				XPRT_TRANSPORT_RDMA,
 				parent_server->client->cl_timeout,
 				parent_client->cl_mvops->minor_version,
-				parent_client->cl_net);
+				parent_client->cl_net, NULL);
 	if (!error)
 		goto init_server;
 #endif	/* IS_ENABLED(CONFIG_SUNRPC_XPRT_RDMA) */
@@ -1174,7 +1219,7 @@ struct nfs_server *nfs4_create_referral_server(struct nfs_clone_mount *data,
 				XPRT_TRANSPORT_TCP,
 				parent_server->client->cl_timeout,
 				parent_client->cl_mvops->minor_version,
-				parent_client->cl_net);
+				parent_client->cl_net, NULL);
 	if (error < 0)
 		goto error;
 
@@ -1269,7 +1314,7 @@ int nfs4_update_server(struct nfs_server *server, const char *hostname,
 	set_bit(NFS_MIG_TSM_POSSIBLE, &server->mig_status);
 	error = nfs4_set_client(server, hostname, sap, salen, buf,
 				clp->cl_proto, clnt->cl_timeout,
-				clp->cl_minorversion, net);
+				clp->cl_minorversion, net, NULL);
 	clear_bit(NFS_MIG_TSM_POSSIBLE, &server->mig_status);
 	if (error != 0) {
 		nfs_server_insert_lists(server);
diff --git a/fs/nfs/super.c b/fs/nfs/super.c
index a05e1eb2c3fd..83cd294aca15 100644
--- a/fs/nfs/super.c
+++ b/fs/nfs/super.c
@@ -61,7 +61,7 @@
 #include "callback.h"
 #include "delegation.h"
 #include "iostat.h"
-#include "internal.h"
+#include "enfs_adapter.h"
 #include "fscache.h"
 #include "nfs4session.h"
 #include "pnfs.h"
@@ -113,6 +113,12 @@ enum {
 
 	/* Special mount options */
 	Opt_userspace, Opt_deprecated, Opt_sloppy,
+#if IS_ENABLED(CONFIG_ENFS)
+	Opt_remote_iplist,
+	Opt_local_iplist,
+	Opt_remote_dnslist,
+	Opt_enfs_info,
+#endif
 
 	Opt_err
 };
@@ -183,6 +189,13 @@ static const match_table_t nfs_mount_option_tokens = {
 	{ Opt_fscache_uniq, "fsc=%s" },
 	{ Opt_local_lock, "local_lock=%s" },
 
+#if IS_ENABLED(CONFIG_ENFS)
+	{ Opt_remote_iplist, "remoteaddrs=%s" },
+	{ Opt_local_iplist, "localaddrs=%s" },
+	{ Opt_remote_dnslist, "remotednsname=%s" },
+	{ Opt_enfs_info, "enfs_info=%s" },
+#endif
+
 	/* The following needs to be listed after all other options */
 	{ Opt_nfsvers, "v%s" },
 
@@ -365,6 +378,21 @@ static struct shrinker acl_shrinker = {
 	.seeks		= DEFAULT_SEEKS,
 };
 
+#if IS_ENABLED(CONFIG_ENFS)
+enum nfsmultipathoptions getNfsMultiPathOpt(int token)
+{
+	switch (token) {
+	case Opt_remote_iplist:
+		return REMOUNTREMOTEADDR;
+	case Opt_local_iplist:
+		return REMOUNTLOCALADDR;
+	case Opt_remote_dnslist:
+		return REMOTEDNSNAME;
+	}
+	return INVALID_OPTION;
+}
+#endif
+
 /*
  * Register the NFS filesystems
  */
@@ -758,6 +786,9 @@ int nfs_show_options(struct seq_file *m, struct dentry *root)
 	seq_printf(m, ",addr=%s",
 			rpc_peeraddr2str(nfss->nfs_client->cl_rpcclient,
 							RPC_DISPLAY_ADDR));
+
+	nfs_multipath_show_client_info(m, nfss);
+
 	rcu_read_unlock();
 
 	return 0;
@@ -853,6 +884,8 @@ int nfs_show_stats(struct seq_file *m, struct dentry *root)
 	seq_puts(m, root->d_sb->s_flags & SB_NODIRATIME ? ",nodiratime" : "");
 	nfs_show_mount_options(m, nfss, 1);
 
+	nfs_multipath_show_client_info(m, nfss);
+
 	seq_printf(m, "\n\tage:\t%lu", (jiffies - nfss->mount_time) / HZ);
 
 	show_implementation_id(m, nfss);
@@ -977,6 +1010,7 @@ static void nfs_free_parsed_mount_data(struct nfs_parsed_mount_data *data)
 		kfree(data->nfs_server.export_path);
 		kfree(data->nfs_server.hostname);
 		kfree(data->fscache_uniq);
+		enfs_free_mount_options(data);
 		security_free_mnt_opts(&data->lsm_opts);
 		kfree(data);
 	}
@@ -1641,7 +1675,34 @@ static int nfs_parse_mount_options(char *raw,
 				return 0;
 			};
 			break;
-
+#if IS_ENABLED(CONFIG_ENFS)
+		case Opt_remote_iplist:
+		case Opt_local_iplist:
+		case Opt_remote_dnslist:
+			string = match_strdup(args);
+			if (string == NULL)
+				goto out_nomem;
+			rc = enfs_parse_mount_options(getNfsMultiPathOpt(token),
+							string, mnt);
+			kfree(string);
+			switch (rc) {
+			case  0:
+				break;
+			case -ENOMEM:
+				goto out_nomem;
+			case -ENOSPC:
+				goto out_limit;
+			case -EINVAL:
+				goto out_invalid_address;
+			case -ENOTSUPP:
+				goto out_invalid_address;
+			case -EOPNOTSUPP:
+				goto out_invalid_address;
+			}
+			break;
+		case Opt_enfs_info:
+			break;
+#endif
 		/*
 		 * Special options
 		 */
@@ -1720,6 +1781,11 @@ static int nfs_parse_mount_options(char *raw,
 	free_secdata(secdata);
 	printk(KERN_INFO "NFS: security options invalid: %d\n", rc);
 	return 0;
+#if IS_ENABLED(CONFIG_ENFS)
+out_limit:
+	dprintk("NFS: param is more than supported limit: %d\n", rc);
+	return 0;
+#endif
 }
 
 /*
@@ -2335,6 +2401,14 @@ nfs_remount(struct super_block *sb, int *flags, char *raw_data)
 	if (!nfs_parse_mount_options((char *)options, data))
 		goto out;
 
+#if IS_ENABLED(CONFIG_ENFS)
+	if (data->enfs_option) {
+		error = nfs_remount_iplist(nfss->nfs_client, data->enfs_option);
+		if (error)
+			goto out;
+	}
+#endif
+
 	/*
 	 * noac is a special case. It implies -o sync, but that's not
 	 * necessarily reflected in the mtab options. do_remount_sb
@@ -2347,6 +2421,11 @@ nfs_remount(struct super_block *sb, int *flags, char *raw_data)
 	/* compare new mount options with old ones */
 	error = nfs_compare_remount_data(nfss, data);
 out:
+#if IS_ENABLED(CONFIG_ENFS)
+	/* release remount option member */
+	if (data->enfs_option)
+		enfs_free_mount_options(data);
+#endif
 	nfs_free_parsed_mount_data(data);
 	return error;
 }
diff --git a/include/linux/nfs_fs_sb.h b/include/linux/nfs_fs_sb.h
index 7023ae64e3d7..2c19678afe8d 100644
--- a/include/linux/nfs_fs_sb.h
+++ b/include/linux/nfs_fs_sb.h
@@ -123,6 +123,11 @@ struct nfs_client {
 
 	struct net		*cl_net;
 	struct list_head	pending_cb_stateids;
+
+#if IS_ENABLED(CONFIG_ENFS)
+	/* multi path private structure (struct multipath_client_info *) */
+	void *cl_multipath_data;
+#endif
 };
 
 /*
