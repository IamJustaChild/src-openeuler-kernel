From 85614b8e199dd6eb39929752ea4547ee00668709 Mon Sep 17 00:00:00 2001
From: liyulei <liyulei@kylinos.cn>
Date: Wed, 14 Dec 2022 11:33:30 +0800
Subject: [PATCH] apply preempt RT patch

---
 .../Expedited-Grace-Periods.rst               |     4 +-
 .../RCU/Design/Requirements/Requirements.rst  |    26 +-
 Documentation/RCU/checklist.rst               |     2 +-
 Documentation/RCU/rcubarrier.rst              |     6 +-
 Documentation/RCU/stallwarn.rst               |     4 +-
 Documentation/RCU/whatisRCU.rst               |    10 +-
 .../admin-guide/kernel-parameters.txt         |    11 +
 Documentation/driver-api/io-mapping.rst       |    92 +-
 Module.symvers.rej                            | 15893 ++++++++++++++++
 arch/Kconfig                                  |     8 +-
 arch/alpha/include/asm/kmap_types.h           |    15 -
 arch/alpha/include/asm/spinlock_types.h       |     4 -
 arch/arc/Kconfig                              |     1 +
 arch/arc/include/asm/highmem.h                |    26 +-
 arch/arc/include/asm/kmap_types.h             |    14 -
 arch/arc/mm/highmem.c                         |    54 +-
 arch/arm/Kconfig                              |     6 +-
 arch/arm/include/asm/fixmap.h                 |     4 +-
 arch/arm/include/asm/hardirq.h                |    11 +-
 arch/arm/include/asm/highmem.h                |    34 +-
 arch/arm/include/asm/irq.h                    |     2 +
 arch/arm/include/asm/kmap_types.h             |    10 -
 arch/arm/include/asm/spinlock_types.h         |     4 -
 arch/arm/include/asm/thread_info.h            |    10 +-
 arch/arm/kernel/asm-offsets.c                 |     1 +
 arch/arm/kernel/entry-armv.S                  |    19 +-
 arch/arm/kernel/entry-common.S                |     9 +-
 arch/arm/kernel/signal.c                      |     3 +-
 arch/arm/kernel/smp.c                         |     2 -
 arch/arm/mm/Makefile                          |     1 -
 arch/arm/mm/cache-feroceon-l2.c               |     6 +-
 arch/arm/mm/cache-xsc3l2.c                    |     4 +-
 arch/arm/mm/fault.c                           |     3 +
 arch/arm/mm/highmem.c                         |   121 -
 arch/arm64/Kconfig                            |     3 +
 arch/arm64/include/asm/hardirq.h              |     7 +-
 arch/arm64/include/asm/preempt.h              |    28 +-
 arch/arm64/include/asm/spinlock_types.h       |     4 -
 arch/arm64/include/asm/thread_info.h          |     7 +-
 arch/arm64/kernel/asm-offsets.c               |     1 +
 arch/arm64/kernel/entry.S                     |    13 +-
 arch/arm64/kernel/fpsimd.c                    |    18 +-
 arch/arm64/kernel/ipi_nmi.c                   |     2 -
 arch/arm64/kernel/signal.c                    |     2 +-
 arch/arm64/kvm/arm.c                          |     6 +-
 arch/csky/Kconfig                             |     1 +
 arch/csky/include/asm/fixmap.h                |     4 +-
 arch/csky/include/asm/highmem.h               |     6 +-
 arch/csky/mm/highmem.c                        |    75 +-
 arch/hexagon/include/asm/spinlock_types.h     |     4 -
 arch/ia64/include/asm/kmap_types.h            |    13 -
 arch/ia64/include/asm/spinlock_types.h        |     4 -
 arch/ia64/kernel/time.c                       |    20 +-
 arch/microblaze/Kconfig                       |     1 +
 arch/microblaze/include/asm/fixmap.h          |     4 +-
 arch/microblaze/include/asm/highmem.h         |     6 +-
 arch/microblaze/mm/Makefile                   |     1 -
 arch/microblaze/mm/highmem.c                  |    78 -
 arch/microblaze/mm/init.c                     |     6 -
 arch/mips/Kconfig                             |     1 +
 arch/mips/include/asm/fixmap.h                |     4 +-
 arch/mips/include/asm/highmem.h               |     6 +-
 arch/mips/include/asm/kmap_types.h            |    13 -
 arch/mips/kernel/crash_dump.c                 |    42 +-
 arch/mips/mm/highmem.c                        |    77 -
 arch/mips/mm/init.c                           |     4 -
 arch/nds32/Kconfig.cpu                        |     1 +
 arch/nds32/include/asm/fixmap.h               |     4 +-
 arch/nds32/include/asm/highmem.h              |    22 +-
 arch/nds32/mm/Makefile                        |     1 -
 arch/nds32/mm/highmem.c                       |    48 -
 arch/openrisc/mm/init.c                       |     1 -
 arch/openrisc/mm/ioremap.c                    |     1 -
 arch/parisc/include/asm/hardirq.h             |     1 -
 arch/parisc/include/asm/kmap_types.h          |    13 -
 arch/powerpc/Kconfig                          |     4 +
 arch/powerpc/include/asm/cmpxchg.h            |     2 +-
 arch/powerpc/include/asm/fixmap.h             |     4 +-
 arch/powerpc/include/asm/highmem.h            |     7 +-
 arch/powerpc/include/asm/kmap_types.h         |    13 -
 .../include/asm/simple_spinlock_types.h       |     2 +-
 arch/powerpc/include/asm/spinlock_types.h     |     4 -
 arch/powerpc/include/asm/stackprotector.h     |     4 +
 arch/powerpc/include/asm/thread_info.h        |    17 +-
 arch/powerpc/kernel/asm-offsets.c             |     1 +
 arch/powerpc/kernel/entry_32.S                |    23 +-
 arch/powerpc/kernel/exceptions-64e.S          |    16 +-
 arch/powerpc/kernel/irq.c                     |     2 +
 arch/powerpc/kernel/misc_32.S                 |     2 +
 arch/powerpc/kernel/misc_64.S                 |     2 +
 arch/powerpc/kernel/nvram_64.c                |    12 +-
 arch/powerpc/kernel/syscall_64.c              |    10 +-
 arch/powerpc/kernel/time.c                    |    56 +-
 arch/powerpc/kernel/traps.c                   |     8 +-
 arch/powerpc/kernel/watchdog.c                |     5 -
 arch/powerpc/kexec/crash.c                    |     3 -
 arch/powerpc/kvm/Kconfig                      |     1 +
 arch/powerpc/mm/Makefile                      |     1 -
 arch/powerpc/mm/highmem.c                     |    67 -
 arch/powerpc/mm/mem.c                         |     7 -
 arch/powerpc/platforms/powernv/opal-kmsg.c    |     3 +-
 arch/powerpc/platforms/pseries/iommu.c        |    31 +-
 arch/powerpc/xmon/xmon.c                      |     6 +-
 arch/s390/Kconfig                             |     1 +
 arch/s390/include/asm/spinlock_types.h        |     4 -
 arch/s390/include/asm/vtime.h                 |     1 -
 arch/s390/kernel/vtime.c                      |    51 +-
 arch/sh/include/asm/fixmap.h                  |     8 -
 arch/sh/include/asm/hardirq.h                 |    14 +-
 arch/sh/include/asm/kmap_types.h              |    15 -
 arch/sh/include/asm/spinlock_types.h          |     4 -
 arch/sh/kernel/irq.c                          |     4 +-
 arch/sh/kernel/traps.c                        |     2 +-
 arch/sh/mm/init.c                             |     8 -
 arch/sparc/Kconfig                            |     1 +
 arch/sparc/include/asm/highmem.h              |     8 +-
 arch/sparc/include/asm/kmap_types.h           |    11 -
 arch/sparc/include/asm/vaddrs.h               |     4 +-
 arch/sparc/kernel/irq_64.c                    |     2 +
 arch/sparc/mm/Makefile                        |     3 -
 arch/sparc/mm/highmem.c                       |   115 -
 arch/sparc/mm/srmmu.c                         |     2 -
 arch/um/include/asm/fixmap.h                  |     1 -
 arch/um/include/asm/hardirq.h                 |    17 +-
 arch/um/include/asm/kmap_types.h              |    13 -
 arch/um/kernel/kmsg_dump.c                    |    13 +-
 arch/x86/Kconfig                              |     3 +
 arch/x86/crypto/aesni-intel_glue.c            |    22 +-
 arch/x86/crypto/cast5_avx_glue.c              |    21 +-
 arch/x86/crypto/glue_helper.c                 |    26 +-
 arch/x86/include/asm/fixmap.h                 |     5 +-
 arch/x86/include/asm/fpu/api.h                |    13 +-
 arch/x86/include/asm/highmem.h                |    13 +-
 arch/x86/include/asm/iomap.h                  |    13 +-
 arch/x86/include/asm/kmap_types.h             |    13 -
 arch/x86/include/asm/paravirt_types.h         |     1 -
 arch/x86/include/asm/preempt.h                |    37 +-
 arch/x86/include/asm/signal.h                 |    13 +
 arch/x86/include/asm/stackprotector.h         |     8 +-
 arch/x86/include/asm/thread_info.h            |    11 +
 arch/x86/kernel/crash_dump_32.c               |    48 +-
 arch/x86/kernel/fpu/core.c                    |    13 +
 arch/x86/kernel/irq_32.c                      |     2 +
 arch/x86/kernel/irq_64.c                      |     2 +
 arch/x86/kvm/x86.c                            |     7 +
 arch/x86/mm/highmem_32.c                      |    59 -
 arch/x86/mm/init_32.c                         |    15 -
 arch/x86/mm/iomap_32.c                        |    57 +-
 arch/xtensa/Kconfig                           |     1 +
 arch/xtensa/include/asm/fixmap.h              |     4 +-
 arch/xtensa/include/asm/highmem.h             |    12 +-
 arch/xtensa/include/asm/spinlock_types.h      |     4 -
 arch/xtensa/mm/highmem.c                      |    46 +-
 block/blk-mq.c                                |   124 +-
 crypto/cryptd.c                               |    12 +-
 drivers/atm/eni.c                             |     2 +-
 drivers/block/zram/zram_drv.c                 |    36 +
 drivers/block/zram/zram_drv.h                 |     1 +
 drivers/char/tpm/tpm-dev-common.c             |     1 -
 drivers/char/tpm/tpm_tis.c                    |    29 +-
 drivers/firewire/ohci.c                       |     4 +-
 drivers/firmware/efi/efi.c                    |     5 +-
 drivers/gpu/drm/i915/display/intel_sprite.c   |    15 +-
 .../gpu/drm/i915/gem/i915_gem_execbuffer.c    |     7 +-
 drivers/gpu/drm/i915/gt/intel_breadcrumbs.c   |     5 +-
 drivers/gpu/drm/i915/gt/intel_engine_pm.c     |     8 +-
 drivers/gpu/drm/i915/i915_gem.c               |    40 +-
 drivers/gpu/drm/i915/i915_irq.c               |     2 +
 drivers/gpu/drm/i915/i915_trace.h             |     6 +-
 drivers/gpu/drm/i915/selftests/i915_gem.c     |     4 +-
 drivers/gpu/drm/i915/selftests/i915_gem_gtt.c |     8 +-
 .../drm/nouveau/nvkm/subdev/devinit/fbmem.h   |     8 +-
 drivers/gpu/drm/qxl/qxl_image.c               |    18 +-
 drivers/gpu/drm/qxl/qxl_ioctl.c               |    27 +-
 drivers/gpu/drm/qxl/qxl_object.c              |    12 +-
 drivers/gpu/drm/qxl/qxl_object.h              |     4 +-
 drivers/gpu/drm/qxl/qxl_release.c             |     4 +-
 drivers/gpu/drm/radeon/radeon_display.c       |     2 +
 drivers/gpu/drm/ttm/ttm_bo_util.c             |    20 +-
 drivers/gpu/drm/vmwgfx/vmwgfx_blit.c          |    30 +-
 drivers/hv/hyperv_vmbus.h                     |     1 +
 drivers/hv/vmbus_drv.c                        |     8 +-
 drivers/leds/trigger/Kconfig                  |     1 +
 drivers/md/raid5.c                            |     7 +-
 drivers/md/raid5.h                            |     1 +
 drivers/mtd/mtdoops.c                         |     5 +-
 drivers/net/arcnet/arc-rimi.c                 |     4 +-
 drivers/net/arcnet/arcdevice.h                |     6 +
 drivers/net/arcnet/arcnet.c                   |    66 +-
 drivers/net/arcnet/com20020-isa.c             |     4 +-
 drivers/net/arcnet/com20020-pci.c             |     2 +-
 drivers/net/arcnet/com20020_cs.c              |     2 +-
 drivers/net/arcnet/com90io.c                  |     4 +-
 drivers/net/arcnet/com90xx.c                  |     4 +-
 drivers/net/ethernet/chelsio/cxgb/common.h    |     6 +-
 drivers/net/ethernet/chelsio/cxgb/cxgb2.c     |    54 +-
 drivers/net/ethernet/chelsio/cxgb/sge.c       |    53 +-
 drivers/net/ethernet/chelsio/cxgb/sge.h       |     3 +-
 drivers/net/ethernet/chelsio/cxgb/subr.c      |    64 +-
 drivers/net/ethernet/dlink/sundance.c         |     2 +-
 drivers/net/ethernet/jme.c                    |    10 +-
 drivers/net/ethernet/jme.h                    |     2 +-
 drivers/net/wireless/ath/ath9k/beacon.c       |     2 +-
 drivers/pci/controller/pci-hyperv.c           |     2 +-
 drivers/scsi/fcoe/fcoe.c                      |    16 +-
 drivers/scsi/fcoe/fcoe_ctlr.c                 |     4 +-
 drivers/scsi/libfc/fc_exch.c                  |     4 +-
 drivers/tty/serial/8250/8250.h                |    47 +-
 drivers/tty/serial/8250/8250_core.c           |    17 +-
 drivers/tty/serial/8250/8250_fsl.c            |     9 +
 drivers/tty/serial/8250/8250_ingenic.c        |     7 +
 drivers/tty/serial/8250/8250_mtk.c            |    29 +-
 drivers/tty/serial/8250/8250_port.c           |    93 +-
 drivers/tty/serial/amba-pl011.c               |    17 +-
 drivers/tty/serial/omap-serial.c              |    12 +-
 drivers/tty/tty_buffer.c                      |     2 -
 fs/afs/dir_silly.c                            |     2 +-
 fs/aio.c                                      |     3 +-
 fs/btrfs/ctree.h                              |     1 -
 fs/cifs/readdir.c                             |     2 +-
 fs/dcache.c                                   |    39 +-
 fs/eventfd.c                                  |    12 +-
 fs/fscache/internal.h                         |     1 -
 fs/fscache/main.c                             |     6 -
 fs/fscache/object.c                           |    13 +-
 fs/fuse/readdir.c                             |     2 +-
 fs/inode.c                                    |     2 +-
 fs/namei.c                                    |     4 +-
 fs/namespace.c                                |     8 +-
 fs/nfs/dir.c                                  |     4 +-
 fs/nfs/unlink.c                               |     4 +-
 fs/proc/array.c                               |     4 +-
 fs/proc/base.c                                |     3 +-
 fs/proc/proc_sysctl.c                         |     2 +-
 fs/pstore/platform.c                          |     5 +-
 include/asm-generic/Kbuild                    |     2 +-
 include/asm-generic/hardirq.h                 |     6 +-
 include/asm-generic/kmap_size.h               |    12 +
 include/asm-generic/kmap_types.h              |    11 -
 include/asm-generic/preempt.h                 |     3 +
 include/linux/blkdev.h                        |     2 +-
 include/linux/bottom_half.h                   |     8 +-
 include/linux/console.h                       |    11 +
 include/linux/cpuhotplug.h                    |     1 +
 include/linux/cpumask.h                       |     6 +
 include/linux/dcache.h                        |     4 +-
 include/linux/debug_locks.h                   |     3 +-
 include/linux/delay.h                         |     6 +
 include/linux/entry-common.h                  |     2 +-
 include/linux/eventfd.h                       |    11 +-
 include/linux/fs.h                            |     2 +-
 include/linux/hardirq.h                       |     7 +-
 include/linux/highmem-internal.h              |   222 +
 include/linux/highmem.h                       |   294 +-
 include/linux/interrupt.h                     |    34 +-
 include/linux/io-mapping.h                    |    28 +-
 include/linux/irq_cpustat.h                   |    28 -
 include/linux/irq_work.h                      |    13 +
 include/linux/irqdesc.h                       |     1 +
 include/linux/irqflags.h                      |    23 +-
 include/linux/kernel.h                        |    26 +-
 include/linux/kmsg_dump.h                     |    52 +-
 include/linux/local_lock_internal.h           |   111 +-
 include/linux/mm_types.h                      |     4 +
 include/linux/mutex.h                         |    34 +-
 include/linux/mutex_rt.h                      |   130 +
 include/linux/nfs_xdr.h                       |     2 +-
 include/linux/notifier.h                      |     6 +-
 include/linux/pid.h                           |     1 +
 include/linux/preempt.h                       |   190 +-
 include/linux/printk.h                        |    30 +-
 include/linux/rbtree.h                        |    27 +-
 include/linux/rbtree_type.h                   |    31 +
 include/linux/rcupdate.h                      |    10 +-
 include/linux/rtmutex.h                       |    46 +-
 include/linux/rwlock_rt.h                     |   109 +
 include/linux/rwlock_types.h                  |     4 +
 include/linux/rwlock_types_rt.h               |    56 +
 include/linux/rwsem-rt.h                      |    70 +
 include/linux/rwsem.h                         |    12 +
 include/linux/sched.h                         |   124 +-
 include/linux/sched/hotplug.h                 |     2 +
 include/linux/sched/mm.h                      |    11 +
 include/linux/sched/rt.h                      |     8 -
 include/linux/sched/wake_q.h                  |    13 +-
 include/linux/serial_8250.h                   |     5 +
 include/linux/shmem_fs.h                      |     2 +-
 include/linux/signal.h                        |     1 +
 include/linux/skbuff.h                        |     7 +
 include/linux/smp.h                           |     3 +
 include/linux/spinlock.h                      |    12 +-
 include/linux/spinlock_api_smp.h              |     4 +-
 include/linux/spinlock_rt.h                   |   155 +
 include/linux/spinlock_types.h                |    92 +-
 include/linux/spinlock_types_nort.h           |    39 +
 include/linux/spinlock_types_raw.h            |    65 +
 include/linux/spinlock_types_rt.h             |    38 +
 include/linux/spinlock_types_up.h             |     2 +-
 include/linux/stop_machine.h                  |     5 +
 include/linux/thread_info.h                   |    12 +-
 include/linux/trace_events.h                  |    65 +-
 include/linux/u64_stats_sync.h                |    42 +-
 include/linux/vmstat.h                        |     4 +
 include/linux/vtime.h                         |    42 +-
 include/linux/wait.h                          |     1 +
 include/linux/ww_mutex.h                      |     8 +
 include/net/gen_stats.h                       |    11 +-
 include/net/net_seq_lock.h                    |    15 +
 include/net/netns/xfrm.h                      |     2 +-
 include/net/sch_generic.h                     |    27 +-
 include/trace/events/sched.h                  |    12 +
 init/Kconfig                                  |     7 +-
 kernel/Kconfig.locks                          |     2 +-
 kernel/Kconfig.preempt                        |     7 +
 kernel/cgroup/cpuset.c                        |    82 +-
 kernel/cgroup/rstat.c                         |     5 +-
 kernel/cpu.c                                  |     9 +-
 kernel/debug/kdb/kdb_main.c                   |    10 +-
 kernel/entry/common.c                         |    14 +-
 kernel/exit.c                                 |     2 +-
 kernel/fork.c                                 |    28 +-
 kernel/futex.c                                |    87 +-
 kernel/irq/manage.c                           |    11 +-
 kernel/irq/spurious.c                         |     8 +
 kernel/irq_work.c                             |   136 +-
 kernel/kexec_core.c                           |     1 -
 kernel/ksysfs.c                               |    12 +
 kernel/kthread.c                              |    16 +-
 kernel/locking/Makefile                       |    10 +-
 kernel/locking/lockdep.c                      |     2 +
 kernel/locking/mutex-rt.c                     |   224 +
 kernel/locking/rtmutex-debug.c                |   102 -
 kernel/locking/rtmutex-debug.h                |    11 -
 kernel/locking/rtmutex.c                      |   942 +-
 kernel/locking/rtmutex.h                      |     7 -
 kernel/locking/rtmutex_common.h               |    36 +-
 kernel/locking/rwlock-rt.c                    |   334 +
 kernel/locking/rwsem-rt.c                     |   317 +
 kernel/locking/rwsem.c                        |     6 +
 kernel/locking/spinlock.c                     |     7 +
 kernel/locking/spinlock_debug.c               |     5 +
 kernel/notifier.c                             |    12 +-
 kernel/panic.c                                |    33 +-
 kernel/printk/Makefile                        |     1 -
 kernel/printk/internal.h                      |    37 -
 kernel/printk/printk.c                        |  1680 +-
 kernel/printk/printk_safe.c                   |   349 +-
 kernel/ptrace.c                               |    32 +-
 kernel/rcu/Kconfig                            |     4 +-
 kernel/rcu/tree.c                             |     4 +-
 kernel/rcu/update.c                           |     4 +-
 kernel/sched/core.c                           |  1266 +-
 kernel/sched/cpudeadline.c                    |     4 +-
 kernel/sched/cpupri.c                         |     4 +-
 kernel/sched/cputime.c                        |    36 +-
 kernel/sched/deadline.c                       |    47 +-
 kernel/sched/fair.c                           |    16 +-
 kernel/sched/features.h                       |     8 +
 kernel/sched/rt.c                             |    81 +-
 kernel/sched/sched.h                          |    81 +-
 kernel/sched/swait.c                          |     1 +
 kernel/sched/topology.c                       |     1 +
 kernel/signal.c                               |   105 +-
 kernel/smp.c                                  |    14 +-
 kernel/softirq.c                              |   428 +-
 kernel/stop_machine.c                         |    27 +-
 kernel/time/hrtimer.c                         |    30 +
 kernel/time/tick-sched.c                      |     2 +-
 kernel/time/timer.c                           |     9 +-
 kernel/trace/trace.c                          |    93 +-
 kernel/trace/trace.h                          |    19 -
 kernel/trace/trace_events.c                   |     2 +
 kernel/trace/trace_output.c                   |    19 +-
 kernel/workqueue.c                            |    12 +-
 lib/Kconfig.debug                             |     2 +-
 lib/bug.c                                     |     1 +
 lib/cpumask.c                                 |    18 +
 lib/debugobjects.c                            |     5 +-
 lib/dump_stack.c                              |     2 +
 lib/irq_poll.c                                |     5 +
 lib/locking-selftest.c                        |    51 +
 lib/nmi_backtrace.c                           |     6 -
 lib/scatterlist.c                             |     2 +-
 lib/smp_processor_id.c                        |     5 +
 lib/test_lockup.c                             |    16 +
 mm/Kconfig                                    |     5 +-
 mm/highmem.c                                  |   262 +-
 mm/memcontrol.c                               |    65 +-
 mm/page_alloc.c                               |   184 +-
 mm/shmem.c                                    |    31 +-
 mm/slab.c                                     |    90 +-
 mm/slab.h                                     |     2 +-
 mm/slub.c                                     |   148 +-
 mm/vmalloc.c                                  |    13 +-
 mm/vmstat.c                                   |    12 +
 mm/workingset.c                               |     5 +-
 mm/z3fold.c                                   |    17 +-
 mm/zsmalloc.c                                 |    85 +-
 mm/zswap.c                                    |     1 +
 net/Kconfig                                   |     2 +-
 net/core/dev.c                                |    33 +-
 net/core/gen_estimator.c                      |     6 +-
 net/core/gen_stats.c                          |    12 +-
 net/core/sock.c                               |     6 +-
 net/sched/sch_api.c                           |     2 +-
 net/sched/sch_generic.c                       |    10 +
 net/sunrpc/svc_xprt.c                         |     4 +-
 net/xfrm/xfrm_state.c                         |     3 +-
 408 files changed, 24888 insertions(+), 4822 deletions(-)
 create mode 100644 Module.symvers.rej
 delete mode 100644 arch/alpha/include/asm/kmap_types.h
 delete mode 100644 arch/arc/include/asm/kmap_types.h
 delete mode 100644 arch/arm/include/asm/kmap_types.h
 delete mode 100644 arch/arm/mm/highmem.c
 delete mode 100644 arch/ia64/include/asm/kmap_types.h
 delete mode 100644 arch/microblaze/mm/highmem.c
 delete mode 100644 arch/mips/include/asm/kmap_types.h
 delete mode 100644 arch/nds32/mm/highmem.c
 delete mode 100644 arch/parisc/include/asm/kmap_types.h
 delete mode 100644 arch/powerpc/include/asm/kmap_types.h
 delete mode 100644 arch/powerpc/mm/highmem.c
 delete mode 100644 arch/sh/include/asm/kmap_types.h
 delete mode 100644 arch/sparc/include/asm/kmap_types.h
 delete mode 100644 arch/sparc/mm/highmem.c
 delete mode 100644 arch/um/include/asm/kmap_types.h
 delete mode 100644 arch/x86/include/asm/kmap_types.h
 create mode 100644 include/asm-generic/kmap_size.h
 delete mode 100644 include/asm-generic/kmap_types.h
 create mode 100644 include/linux/highmem-internal.h
 delete mode 100644 include/linux/irq_cpustat.h
 create mode 100644 include/linux/mutex_rt.h
 create mode 100644 include/linux/rbtree_type.h
 create mode 100644 include/linux/rwlock_rt.h
 create mode 100644 include/linux/rwlock_types_rt.h
 create mode 100644 include/linux/rwsem-rt.h
 create mode 100644 include/linux/spinlock_rt.h
 create mode 100644 include/linux/spinlock_types_nort.h
 create mode 100644 include/linux/spinlock_types_raw.h
 create mode 100644 include/linux/spinlock_types_rt.h
 create mode 100644 include/net/net_seq_lock.h
 create mode 100644 kernel/locking/mutex-rt.c
 create mode 100644 kernel/locking/rwlock-rt.c
 create mode 100644 kernel/locking/rwsem-rt.c

diff --git a/Documentation/RCU/Design/Expedited-Grace-Periods/Expedited-Grace-Periods.rst b/Documentation/RCU/Design/Expedited-Grace-Periods/Expedited-Grace-Periods.rst
index 72f0f6fbd53c..6f89cf1e567d 100644
--- a/Documentation/RCU/Design/Expedited-Grace-Periods/Expedited-Grace-Periods.rst
+++ b/Documentation/RCU/Design/Expedited-Grace-Periods/Expedited-Grace-Periods.rst
@@ -38,7 +38,7 @@ sections.
 RCU-preempt Expedited Grace Periods
 ===================================
 
-``CONFIG_PREEMPT=y`` kernels implement RCU-preempt.
+``CONFIG_PREEMPTION=y`` kernels implement RCU-preempt.
 The overall flow of the handling of a given CPU by an RCU-preempt
 expedited grace period is shown in the following diagram:
 
@@ -112,7 +112,7 @@ things.
 RCU-sched Expedited Grace Periods
 ---------------------------------
 
-``CONFIG_PREEMPT=n`` kernels implement RCU-sched. The overall flow of
+``CONFIG_PREEMPTION=n`` kernels implement RCU-sched. The overall flow of
 the handling of a given CPU by an RCU-sched expedited grace period is
 shown in the following diagram:
 
diff --git a/Documentation/RCU/Design/Requirements/Requirements.rst b/Documentation/RCU/Design/Requirements/Requirements.rst
index 1ae79a10a8de..17d38480ef5c 100644
--- a/Documentation/RCU/Design/Requirements/Requirements.rst
+++ b/Documentation/RCU/Design/Requirements/Requirements.rst
@@ -78,7 +78,7 @@ RCU treats a nested set as one big RCU read-side critical section.
 Production-quality implementations of ``rcu_read_lock()`` and
 ``rcu_read_unlock()`` are extremely lightweight, and in fact have
 exactly zero overhead in Linux kernels built for production use with
-``CONFIG_PREEMPT=n``.
+``CONFIG_PREEMPTION=n``.
 
 This guarantee allows ordering to be enforced with extremely low
 overhead to readers, for example:
@@ -1182,7 +1182,7 @@ and has become decreasingly so as memory sizes have expanded and memory
 costs have plummeted. However, as I learned from Matt Mackall's
 `bloatwatch <http://elinux.org/Linux_Tiny-FAQ>`__ efforts, memory
 footprint is critically important on single-CPU systems with
-non-preemptible (``CONFIG_PREEMPT=n``) kernels, and thus `tiny
+non-preemptible (``CONFIG_PREEMPTION=n``) kernels, and thus `tiny
 RCU <https://lkml.kernel.org/g/20090113221724.GA15307@linux.vnet.ibm.com>`__
 was born. Josh Triplett has since taken over the small-memory banner
 with his `Linux kernel tinification <https://tiny.wiki.kernel.org/>`__
@@ -1498,7 +1498,7 @@ limitations.
 
 Implementations of RCU for which ``rcu_read_lock()`` and
 ``rcu_read_unlock()`` generate no code, such as Linux-kernel RCU when
-``CONFIG_PREEMPT=n``, can be nested arbitrarily deeply. After all, there
+``CONFIG_PREEMPTION=n``, can be nested arbitrarily deeply. After all, there
 is no overhead. Except that if all these instances of
 ``rcu_read_lock()`` and ``rcu_read_unlock()`` are visible to the
 compiler, compilation will eventually fail due to exhausting memory,
@@ -1771,7 +1771,7 @@ implementation can be a no-op.
 
 However, once the scheduler has spawned its first kthread, this early
 boot trick fails for ``synchronize_rcu()`` (as well as for
-``synchronize_rcu_expedited()``) in ``CONFIG_PREEMPT=y`` kernels. The
+``synchronize_rcu_expedited()``) in ``CONFIG_PREEMPTION=y`` kernels. The
 reason is that an RCU read-side critical section might be preempted,
 which means that a subsequent ``synchronize_rcu()`` really does have to
 wait for something, as opposed to simply returning immediately.
@@ -2010,7 +2010,7 @@ the following:
        5 rcu_read_unlock();
        6 do_something_with(v, user_v);
 
-If the compiler did make this transformation in a ``CONFIG_PREEMPT=n`` kernel
+If the compiler did make this transformation in a ``CONFIG_PREEMPTION=n`` kernel
 build, and if ``get_user()`` did page fault, the result would be a quiescent
 state in the middle of an RCU read-side critical section.  This misplaced
 quiescent state could result in line 4 being a use-after-free access,
@@ -2289,10 +2289,10 @@ decides to throw at it.
 
 The Linux kernel is used for real-time workloads, especially in
 conjunction with the `-rt
-patchset <https://rt.wiki.kernel.org/index.php/Main_Page>`__. The
+patchset <https://wiki.linuxfoundation.org/realtime/>`__. The
 real-time-latency response requirements are such that the traditional
 approach of disabling preemption across RCU read-side critical sections
-is inappropriate. Kernels built with ``CONFIG_PREEMPT=y`` therefore use
+is inappropriate. Kernels built with ``CONFIG_PREEMPTION=y`` therefore use
 an RCU implementation that allows RCU read-side critical sections to be
 preempted. This requirement made its presence known after users made it
 clear that an earlier `real-time
@@ -2414,7 +2414,7 @@ includes ``rcu_read_lock_bh()``, ``rcu_read_unlock_bh()``,
 ``call_rcu_bh()``, ``rcu_barrier_bh()``, and
 ``rcu_read_lock_bh_held()``. However, the update-side APIs are now
 simple wrappers for other RCU flavors, namely RCU-sched in
-CONFIG_PREEMPT=n kernels and RCU-preempt otherwise.
+CONFIG_PREEMPTION=n kernels and RCU-preempt otherwise.
 
 Sched Flavor (Historical)
 ~~~~~~~~~~~~~~~~~~~~~~~~~
@@ -2432,11 +2432,11 @@ not have this property, given that any point in the code outside of an
 RCU read-side critical section can be a quiescent state. Therefore,
 *RCU-sched* was created, which follows “classic” RCU in that an
 RCU-sched grace period waits for pre-existing interrupt and NMI
-handlers. In kernels built with ``CONFIG_PREEMPT=n``, the RCU and
+handlers. In kernels built with ``CONFIG_PREEMPTION=n``, the RCU and
 RCU-sched APIs have identical implementations, while kernels built with
-``CONFIG_PREEMPT=y`` provide a separate implementation for each.
+``CONFIG_PREEMPTION=y`` provide a separate implementation for each.
 
-Note well that in ``CONFIG_PREEMPT=y`` kernels,
+Note well that in ``CONFIG_PREEMPTION=y`` kernels,
 ``rcu_read_lock_sched()`` and ``rcu_read_unlock_sched()`` disable and
 re-enable preemption, respectively. This means that if there was a
 preemption attempt during the RCU-sched read-side critical section,
@@ -2599,10 +2599,10 @@ userspace execution also delimit tasks-RCU read-side critical sections.
 
 The tasks-RCU API is quite compact, consisting only of
 ``call_rcu_tasks()``, ``synchronize_rcu_tasks()``, and
-``rcu_barrier_tasks()``. In ``CONFIG_PREEMPT=n`` kernels, trampolines
+``rcu_barrier_tasks()``. In ``CONFIG_PREEMPTION=n`` kernels, trampolines
 cannot be preempted, so these APIs map to ``call_rcu()``,
 ``synchronize_rcu()``, and ``rcu_barrier()``, respectively. In
-``CONFIG_PREEMPT=y`` kernels, trampolines can be preempted, and these
+``CONFIG_PREEMPTION=y`` kernels, trampolines can be preempted, and these
 three APIs are therefore implemented by separate functions that check
 for voluntary context switches.
 
diff --git a/Documentation/RCU/checklist.rst b/Documentation/RCU/checklist.rst
index 2efed9926c3f..7ed4956043bd 100644
--- a/Documentation/RCU/checklist.rst
+++ b/Documentation/RCU/checklist.rst
@@ -214,7 +214,7 @@ over a rather long period of time, but improvements are always welcome!
 	the rest of the system.
 
 7.	As of v4.20, a given kernel implements only one RCU flavor,
-	which is RCU-sched for PREEMPT=n and RCU-preempt for PREEMPT=y.
+	which is RCU-sched for PREEMPTION=n and RCU-preempt for PREEMPTION=y.
 	If the updater uses call_rcu() or synchronize_rcu(),
 	then the corresponding readers my use rcu_read_lock() and
 	rcu_read_unlock(), rcu_read_lock_bh() and rcu_read_unlock_bh(),
diff --git a/Documentation/RCU/rcubarrier.rst b/Documentation/RCU/rcubarrier.rst
index f64f4413a47c..3b4a24877496 100644
--- a/Documentation/RCU/rcubarrier.rst
+++ b/Documentation/RCU/rcubarrier.rst
@@ -9,7 +9,7 @@ RCU (read-copy update) is a synchronization mechanism that can be thought
 of as a replacement for read-writer locking (among other things), but with
 very low-overhead readers that are immune to deadlock, priority inversion,
 and unbounded latency. RCU read-side critical sections are delimited
-by rcu_read_lock() and rcu_read_unlock(), which, in non-CONFIG_PREEMPT
+by rcu_read_lock() and rcu_read_unlock(), which, in non-CONFIG_PREEMPTION
 kernels, generate no code whatsoever.
 
 This means that RCU writers are unaware of the presence of concurrent
@@ -329,10 +329,10 @@ Answer: This cannot happen. The reason is that on_each_cpu() has its last
 	to smp_call_function() and further to smp_call_function_on_cpu(),
 	causing this latter to spin until the cross-CPU invocation of
 	rcu_barrier_func() has completed. This by itself would prevent
-	a grace period from completing on non-CONFIG_PREEMPT kernels,
+	a grace period from completing on non-CONFIG_PREEMPTION kernels,
 	since each CPU must undergo a context switch (or other quiescent
 	state) before the grace period can complete. However, this is
-	of no use in CONFIG_PREEMPT kernels.
+	of no use in CONFIG_PREEMPTION kernels.
 
 	Therefore, on_each_cpu() disables preemption across its call
 	to smp_call_function() and also across the local call to
diff --git a/Documentation/RCU/stallwarn.rst b/Documentation/RCU/stallwarn.rst
index c9ab6af4d3be..e97d1b4876ef 100644
--- a/Documentation/RCU/stallwarn.rst
+++ b/Documentation/RCU/stallwarn.rst
@@ -25,7 +25,7 @@ warnings:
 
 -	A CPU looping with bottom halves disabled.
 
--	For !CONFIG_PREEMPT kernels, a CPU looping anywhere in the kernel
+-	For !CONFIG_PREEMPTION kernels, a CPU looping anywhere in the kernel
 	without invoking schedule().  If the looping in the kernel is
 	really expected and desirable behavior, you might need to add
 	some calls to cond_resched().
@@ -44,7 +44,7 @@ warnings:
 	result in the ``rcu_.*kthread starved for`` console-log message,
 	which will include additional debugging information.
 
--	A CPU-bound real-time task in a CONFIG_PREEMPT kernel, which might
+-	A CPU-bound real-time task in a CONFIG_PREEMPTION kernel, which might
 	happen to preempt a low-priority task in the middle of an RCU
 	read-side critical section.   This is especially damaging if
 	that low-priority task is not permitted to run on any other CPU,
diff --git a/Documentation/RCU/whatisRCU.rst b/Documentation/RCU/whatisRCU.rst
index fb3ff76c3e73..3b2b1479fd0f 100644
--- a/Documentation/RCU/whatisRCU.rst
+++ b/Documentation/RCU/whatisRCU.rst
@@ -684,7 +684,7 @@ Quick Quiz #1:
 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
 This section presents a "toy" RCU implementation that is based on
 "classic RCU".  It is also short on performance (but only for updates) and
-on features such as hotplug CPU and the ability to run in CONFIG_PREEMPT
+on features such as hotplug CPU and the ability to run in CONFIG_PREEMPTION
 kernels.  The definitions of rcu_dereference() and rcu_assign_pointer()
 are the same as those shown in the preceding section, so they are omitted.
 ::
@@ -740,7 +740,7 @@ Quick Quiz #2:
 Quick Quiz #3:
 		If it is illegal to block in an RCU read-side
 		critical section, what the heck do you do in
-		PREEMPT_RT, where normal spinlocks can block???
+		CONFIG_PREEMPT_RT, where normal spinlocks can block???
 
 :ref:`Answers to Quick Quiz <8_whatisRCU>`
 
@@ -1094,7 +1094,7 @@ Quick Quiz #2:
 		overhead is **negative**.
 
 Answer:
-		Imagine a single-CPU system with a non-CONFIG_PREEMPT
+		Imagine a single-CPU system with a non-CONFIG_PREEMPTION
 		kernel where a routing table is used by process-context
 		code, but can be updated by irq-context code (for example,
 		by an "ICMP REDIRECT" packet).	The usual way of handling
@@ -1121,10 +1121,10 @@ Answer:
 Quick Quiz #3:
 		If it is illegal to block in an RCU read-side
 		critical section, what the heck do you do in
-		PREEMPT_RT, where normal spinlocks can block???
+		CONFIG_PREEMPT_RT, where normal spinlocks can block???
 
 Answer:
-		Just as PREEMPT_RT permits preemption of spinlock
+		Just as CONFIG_PREEMPT_RT permits preemption of spinlock
 		critical sections, it permits preemption of RCU
 		read-side critical sections.  It also permits
 		spinlocks blocking while in RCU read-side critical
diff --git a/Documentation/admin-guide/kernel-parameters.txt b/Documentation/admin-guide/kernel-parameters.txt
index 8a1a25216da6..4779442505d5 100644
--- a/Documentation/admin-guide/kernel-parameters.txt
+++ b/Documentation/admin-guide/kernel-parameters.txt
@@ -4345,6 +4345,10 @@
 			value, meaning that RCU_SOFTIRQ is used by default.
 			Specify rcutree.use_softirq=0 to use rcuc kthreads.
 
+			But note that CONFIG_PREEMPT_RT=y kernels disable
+			this kernel boot parameter, forcibly setting it
+			to zero.
+
 	rcutree.rcu_fanout_exact= [KNL]
 			Disable autobalancing of the rcu_node combining
 			tree.  This is used by rcutorture, and might
@@ -4723,6 +4727,13 @@
 			only normal grace-period primitives.  No effect
 			on CONFIG_TINY_RCU kernels.
 
+			But note that CONFIG_PREEMPT_RT=y kernels enables
+			this kernel boot parameter, forcibly setting
+			it to the value one, that is, converting any
+			post-boot attempt at an expedited RCU grace
+			period to instead use normal non-expedited
+			grace-period processing.
+
 	rcupdate.rcu_task_ipi_delay= [KNL]
 			Set time in jiffies during which RCU tasks will
 			avoid sending IPIs, starting with the beginning
diff --git a/Documentation/driver-api/io-mapping.rst b/Documentation/driver-api/io-mapping.rst
index a966239f04e4..a7830c59481f 100644
--- a/Documentation/driver-api/io-mapping.rst
+++ b/Documentation/driver-api/io-mapping.rst
@@ -20,78 +20,64 @@ A mapping object is created during driver initialization using::
 mappable, while 'size' indicates how large a mapping region to
 enable. Both are in bytes.
 
-This _wc variant provides a mapping which may only be used
-with the io_mapping_map_atomic_wc or io_mapping_map_wc.
+This _wc variant provides a mapping which may only be used with
+io_mapping_map_local_wc() or io_mapping_map_wc().
 
-With this mapping object, individual pages can be mapped either atomically
-or not, depending on the necessary scheduling environment. Of course, atomic
-maps are more efficient::
+With this mapping object, individual pages can be mapped either temporarily
+or long term, depending on the requirements. Of course, temporary maps are
+more efficient.
 
-	void *io_mapping_map_atomic_wc(struct io_mapping *mapping,
-				       unsigned long offset)
+	void *io_mapping_map_local_wc(struct io_mapping *mapping,
+				      unsigned long offset)
 
-'offset' is the offset within the defined mapping region.
-Accessing addresses beyond the region specified in the
-creation function yields undefined results. Using an offset
-which is not page aligned yields an undefined result. The
-return value points to a single page in CPU address space.
+'offset' is the offset within the defined mapping region.  Accessing
+addresses beyond the region specified in the creation function yields
+undefined results. Using an offset which is not page aligned yields an
+undefined result. The return value points to a single page in CPU address
+space.
 
-This _wc variant returns a write-combining map to the
-page and may only be used with mappings created by
-io_mapping_create_wc
+This _wc variant returns a write-combining map to the page and may only be
+used with mappings created by io_mapping_create_wc()
 
-Note that the task may not sleep while holding this page
-mapped.
+Temporary mappings are only valid in the context of the caller. The mapping
+is not guaranteed to be globaly visible.
 
-::
+io_mapping_map_local_wc() has a side effect on X86 32bit as it disables
+migration to make the mapping code work. No caller can rely on this side
+effect.
 
-	void io_mapping_unmap_atomic(void *vaddr)
+Nested mappings need to be undone in reverse order because the mapping
+code uses a stack for keeping track of them::
 
-'vaddr' must be the value returned by the last
-io_mapping_map_atomic_wc call. This unmaps the specified
-page and allows the task to sleep once again.
+ addr1 = io_mapping_map_local_wc(map1, offset1);
+ addr2 = io_mapping_map_local_wc(map2, offset2);
+ ...
+ io_mapping_unmap_local(addr2);
+ io_mapping_unmap_local(addr1);
 
-If you need to sleep while holding the lock, you can use the non-atomic
-variant, although they may be significantly slower.
+The mappings are released with::
 
-::
+	void io_mapping_unmap_local(void *vaddr)
+
+'vaddr' must be the value returned by the last io_mapping_map_local_wc()
+call. This unmaps the specified mapping and undoes eventual side effects of
+the mapping function.
+
+If you need to sleep while holding a mapping, you can use the regular
+variant, although this may be significantly slower::
 
 	void *io_mapping_map_wc(struct io_mapping *mapping,
 				unsigned long offset)
 
-This works like io_mapping_map_atomic_wc except it allows
-the task to sleep while holding the page mapped.
+This works like io_mapping_map_local_wc() except it has no side effects and
+the pointer is globaly visible.
 
-
-::
+The mappings are released with::
 
 	void io_mapping_unmap(void *vaddr)
 
-This works like io_mapping_unmap_atomic, except it is used
-for pages mapped with io_mapping_map_wc.
+Use for pages mapped with io_mapping_map_wc().
 
 At driver close time, the io_mapping object must be freed::
 
 	void io_mapping_free(struct io_mapping *mapping)
-
-Current Implementation
-======================
-
-The initial implementation of these functions uses existing mapping
-mechanisms and so provides only an abstraction layer and no new
-functionality.
-
-On 64-bit processors, io_mapping_create_wc calls ioremap_wc for the whole
-range, creating a permanent kernel-visible mapping to the resource. The
-map_atomic and map functions add the requested offset to the base of the
-virtual address returned by ioremap_wc.
-
-On 32-bit processors with HIGHMEM defined, io_mapping_map_atomic_wc uses
-kmap_atomic_pfn to map the specified page in an atomic fashion;
-kmap_atomic_pfn isn't really supposed to be used with device pages, but it
-provides an efficient mapping for this usage.
-
-On 32-bit processors without HIGHMEM defined, io_mapping_map_atomic_wc and
-io_mapping_map_wc both use ioremap_wc, a terribly inefficient function which
-performs an IPI to inform all processors about the new mapping. This results
-in a significant performance penalty.
diff --git a/Module.symvers.rej b/Module.symvers.rej
new file mode 100644
index 000000000000..fa8330a76b30
--- /dev/null
+++ b/Module.symvers.rej
@@ -0,0 +1,15893 @@
+--- Module.symvers
++++ Module.symvers
+@@ -0,0 +1,15890 @@
++0x55417264	unregister_vt_notifier	vmlinux	EXPORT_SYMBOL_GPL	
++0x0fd3f6a2	set_anon_super	vmlinux	EXPORT_SYMBOL	
++0x5b31daf3	__cleancache_invalidate_page	vmlinux	EXPORT_SYMBOL	
++0x01ccec91	kmem_cache_alloc	vmlinux	EXPORT_SYMBOL	
++0x5efdd68b	__tracepoint_mmap_lock_released	vmlinux	EXPORT_SYMBOL	
++0x373d0252	replace_page_cache_page	vmlinux	EXPORT_SYMBOL_GPL	
++0xae1051b0	net_cls_cgrp_subsys_enabled_key	vmlinux	EXPORT_SYMBOL_GPL	
++0x191b70f9	xdp_attachment_setup	vmlinux	EXPORT_SYMBOL_GPL	
++0xec237e4f	xps_needed	vmlinux	EXPORT_SYMBOL	
++0xc0d9381f	of_get_property	vmlinux	EXPORT_SYMBOL	
++0x4f6db683	i2c_put_adapter	vmlinux	EXPORT_SYMBOL	
++0xc953a559	rtc_class_open	vmlinux	EXPORT_SYMBOL_GPL	
++0x5324f565	dma_fence_default_wait	vmlinux	EXPORT_SYMBOL	
++0xa9a04e91	dma_fence_get_stub	vmlinux	EXPORT_SYMBOL	
++0x2227e214	request_firmware	vmlinux	EXPORT_SYMBOL	
++0xe1cd11d6	dev_pm_enable_wake_irq	vmlinux	EXPORT_SYMBOL_GPL	
++0x0e4262c6	__siphash_unaligned	vmlinux	EXPORT_SYMBOL	
++0x7e2de03c	irq_to_desc	vmlinux	EXPORT_SYMBOL	
++0x3c49275c	netpoll_poll_enable	vmlinux	EXPORT_SYMBOL	
++0x3cc1ac44	dev_mc_sync	vmlinux	EXPORT_SYMBOL	
++0xdcdc73ea	dev_uc_sync	vmlinux	EXPORT_SYMBOL	
++0x9932f711	hwmon_device_unregister	vmlinux	EXPORT_SYMBOL_GPL	
++0x96db17d2	device_set_of_node_from_dev	vmlinux	EXPORT_SYMBOL_GPL	
++0xc8594d3d	reset_control_acquire	vmlinux	EXPORT_SYMBOL_GPL	
++0xe113bbbc	csum_partial	vmlinux	EXPORT_SYMBOL	
++0x80ca5026	_bin2bcd	vmlinux	EXPORT_SYMBOL	
++0xfbaaf01e	console_lock	vmlinux	EXPORT_SYMBOL	
++0xcc52b204	tcp_v4_mtu_reduced	vmlinux	EXPORT_SYMBOL	
++0x213cbb86	mbox_send_message	vmlinux	EXPORT_SYMBOL_GPL	
++0x759139cb	of_pci_check_probe_only	vmlinux	EXPORT_SYMBOL_GPL	
++0xc49d1595	xas_set_mark	vmlinux	EXPORT_SYMBOL_GPL	
++0x78e66728	xas_get_mark	vmlinux	EXPORT_SYMBOL_GPL	
++0x9a73b032	ZSTD_initDStream_usingDDict	vmlinux	EXPORT_SYMBOL	
++0x139f2189	__kfifo_alloc	vmlinux	EXPORT_SYMBOL	
++0xc1aa530b	nf_log_register	vmlinux	EXPORT_SYMBOL	
++0x5f98bdb6	nf_hooks_needed	vmlinux	EXPORT_SYMBOL	
++0x2768e970	serial8250_do_shutdown	vmlinux	EXPORT_SYMBOL_GPL	
++0x4f85f962	phy_reset	vmlinux	EXPORT_SYMBOL_GPL	
++0x3854774b	kstrtoll	vmlinux	EXPORT_SYMBOL	
++0x255cf517	__rwsem_init	vmlinux	EXPORT_SYMBOL	
++0x2717d265	nfnl_ct_hook	vmlinux	EXPORT_SYMBOL_GPL	
++0xabc8746a	spi_mem_driver_register_with_owner	vmlinux	EXPORT_SYMBOL_GPL	
++0x9f8b3b8e	device_del	vmlinux	EXPORT_SYMBOL_GPL	
++0xfc042448	device_add	vmlinux	EXPORT_SYMBOL_GPL	
++0xce3f4641	crypto_hash_walk_done	vmlinux	EXPORT_SYMBOL_GPL	
++0xdd391eff	profile_event_unregister	vmlinux	EXPORT_SYMBOL_GPL	
++0x0c3690fc	_raw_spin_lock_bh	vmlinux	EXPORT_SYMBOL	
++0xdbf1632a	init_uts_ns	vmlinux	EXPORT_SYMBOL_GPL	
++0xfa004625	dst_release	vmlinux	EXPORT_SYMBOL	
++0xdedae58b	dst_discard_out	vmlinux	EXPORT_SYMBOL	
++0x94cdc245	sock_no_mmap	vmlinux	EXPORT_SYMBOL	
++0x3d20b71e	DWC_IN_BH	vmlinux	EXPORT_SYMBOL	
++0xde5a9488	dev_lstats_read	vmlinux	EXPORT_SYMBOL	
++0xacb4d88c	clk_rate_exclusive_put	vmlinux	EXPORT_SYMBOL_GPL	
++0x461d16ca	sg_nents	vmlinux	EXPORT_SYMBOL	
++0xce65521e	sysfs_update_group	vmlinux	EXPORT_SYMBOL_GPL	
++0xa38602cd	drain_workqueue	vmlinux	EXPORT_SYMBOL_GPL	
++0xf0e5edcc	xdr_page_pos	vmlinux	EXPORT_SYMBOL_GPL	
++0x425694d4	tcp_initialize_rcv_mss	vmlinux	EXPORT_SYMBOL	
++0x54e6fcdd	net_enable_timestamp	vmlinux	EXPORT_SYMBOL	
++0x63c3dc6d	sockfd_lookup	vmlinux	EXPORT_SYMBOL	
++0xecb5c825	cpufreq_disable_fast_switch	vmlinux	EXPORT_SYMBOL_GPL	
++0x0e76741e	dma_fence_signal	vmlinux	EXPORT_SYMBOL	
++0xc668aa95	fb_validate_mode	vmlinux	EXPORT_SYMBOL	
++0x8b910be2	errseq_sample	vmlinux	EXPORT_SYMBOL	
++0x6bc3fbc0	__unregister_chrdev	vmlinux	EXPORT_SYMBOL	
++0xe4971ade	tracing_alloc_snapshot	vmlinux	EXPORT_SYMBOL_GPL	
++0xb487ed0d	srcu_notifier_chain_register	vmlinux	EXPORT_SYMBOL_GPL	
++0x482ac5a4	g_token_size	vmlinux	EXPORT_SYMBOL_GPL	
++0x8ebb2bb1	ping_seq_next	vmlinux	EXPORT_SYMBOL_GPL	
++0x1e18ea5c	dev_graft_qdisc	vmlinux	EXPORT_SYMBOL	
++0x43bb9a78	badblocks_store	vmlinux	EXPORT_SYMBOL_GPL	
++0xa851973a	raw_notifier_call_chain	vmlinux	EXPORT_SYMBOL_GPL	
++0xa96a69ad	__dev_direct_xmit	vmlinux	EXPORT_SYMBOL	
++0x602b40a5	skb_ensure_writable	vmlinux	EXPORT_SYMBOL	
++0xdef2e488	skb_splice_bits	vmlinux	EXPORT_SYMBOL_GPL	
++0xac356667	of_thermal_get_ntrips	vmlinux	EXPORT_SYMBOL_GPL	
++0xe1e65bf3	scsi_target_quiesce	vmlinux	EXPORT_SYMBOL	
++0x549a856f	transport_class_register	vmlinux	EXPORT_SYMBOL_GPL	
++0xc4efd786	serdev_device_write	vmlinux	EXPORT_SYMBOL_GPL	
++0x275a1479	regulator_bulk_unregister_supply_alias	vmlinux	EXPORT_SYMBOL_GPL	
++0x7c9ca58f	__sg_page_iter_next	vmlinux	EXPORT_SYMBOL	
++0x99f2d00a	sysfs_emit_at	vmlinux	EXPORT_SYMBOL_GPL	
++0x41ae5858	nfs_ssc_register	vmlinux	EXPORT_SYMBOL_GPL	
++0x9788adf4	mr_table_alloc	vmlinux	EXPORT_SYMBOL	
++0x77bcfc98	input_handler_for_each_handle	vmlinux	EXPORT_SYMBOL	
++0xb7adf972	fwnode_find_reference	vmlinux	EXPORT_SYMBOL_GPL	
++0xd5d5bf29	transport_class_unregister	vmlinux	EXPORT_SYMBOL_GPL	
++0x12f6f69c	fb_videomode_to_var	vmlinux	EXPORT_SYMBOL	
++0xd65e6469	jbd2_journal_try_to_free_buffers	vmlinux	EXPORT_SYMBOL	
++0xefa2c27d	register_tracepoint_module_notifier	vmlinux	EXPORT_SYMBOL_GPL	
++0x3621447f	down_write_killable	vmlinux	EXPORT_SYMBOL	
++0xaad8c7d6	default_wake_function	vmlinux	EXPORT_SYMBOL	
++0xcbca757b	sdhci_runtime_suspend_host	vmlinux	EXPORT_SYMBOL_GPL	
++0x7043b378	input_mt_assign_slots	vmlinux	EXPORT_SYMBOL	
++0x9b90caae	pci_bus_read_config_byte	vmlinux	EXPORT_SYMBOL	
++0x1805e23f	blkcg_root	vmlinux	EXPORT_SYMBOL_GPL	
++0xedb1557d	mount_subtree	vmlinux	EXPORT_SYMBOL	
++0x5e117f3c	iget_locked	vmlinux	EXPORT_SYMBOL	
++0xefffdd65	__traceiter_br_fdb_update	vmlinux	EXPORT_SYMBOL_GPL	
++0xc76ccc5c	of_graph_get_next_endpoint	vmlinux	EXPORT_SYMBOL	
++0x916949da	class_interface_register	vmlinux	EXPORT_SYMBOL_GPL	
++0x85a537a1	clk_hw_unregister_fixed_factor	vmlinux	EXPORT_SYMBOL_GPL	
++0xf38eed7f	blk_queue_max_write_zeroes_sectors	vmlinux	EXPORT_SYMBOL	
++0x45b848e4	key_type_keyring	vmlinux	EXPORT_SYMBOL	
++0x30b6b16f	nfs_sb_active	vmlinux	EXPORT_SYMBOL_GPL	
++0xae39f80e	dst_cache_init	vmlinux	EXPORT_SYMBOL_GPL	
++0x3b52505a	ir_raw_event_handle	vmlinux	EXPORT_SYMBOL_GPL	
++0x07b160a9	rc_keyup	vmlinux	EXPORT_SYMBOL_GPL	
++0x63b8acd2	spi_get_device_id	vmlinux	EXPORT_SYMBOL_GPL	
++0x58b590bc	class_interface_unregister	vmlinux	EXPORT_SYMBOL_GPL	
++0xa45260a7	of_get_named_gpio_flags	vmlinux	EXPORT_SYMBOL_GPL	
++0xd8a37775	nfs_revalidate_inode	vmlinux	EXPORT_SYMBOL_GPL	
++0xa207b547	fscache_operation_init	vmlinux	EXPORT_SYMBOL	
++0xc617f82c	unregister_oom_notifier	vmlinux	EXPORT_SYMBOL_GPL	
++0x9340d40c	xdr_decode_word	vmlinux	EXPORT_SYMBOL_GPL	
++0x4dac77f0	xdr_encode_netobj	vmlinux	EXPORT_SYMBOL_GPL	
++0xcb422259	i2c_generic_scl_recovery	vmlinux	EXPORT_SYMBOL_GPL	
++0x012fa472	tty_register_device	vmlinux	EXPORT_SYMBOL	
++0xbb4f4766	simple_write_to_buffer	vmlinux	EXPORT_SYMBOL	
++0xbe118c52	__tracepoint_mmap_lock_acquire_returned	vmlinux	EXPORT_SYMBOL	
++0x9bf7a874	__srcu_read_unlock	vmlinux	EXPORT_SYMBOL_GPL	
++0x5f6c87e6	_mutex_lock_interruptible	vmlinux	EXPORT_SYMBOL	
++0xc2e587d1	reset_devices	vmlinux	EXPORT_SYMBOL	
++0xab47ca60	of_find_all_nodes	vmlinux	EXPORT_SYMBOL	
++0x564838f7	mmc_app_cmd	vmlinux	EXPORT_SYMBOL_GPL	
++0xa13aab75	dma_resv_add_shared_fence	vmlinux	EXPORT_SYMBOL	
++0x8f4c28fb	regulator_map_voltage_linear	vmlinux	EXPORT_SYMBOL_GPL	
++0x5a9f1d63	memmove	vmlinux	EXPORT_SYMBOL	
++0xf3107926	sha224_update	vmlinux	EXPORT_SYMBOL	
++0xc5f7e801	sg_last	vmlinux	EXPORT_SYMBOL	
++0xfaa1702f	pnfs_layout_mark_request_commit	vmlinux	EXPORT_SYMBOL_GPL	
++0xd88c5a1a	param_get_string	vmlinux	EXPORT_SYMBOL	
++0x7a833964	rpc_d_lookup_sb	vmlinux	EXPORT_SYMBOL_GPL	
++0xaace836d	tc_setup_cb_add	vmlinux	EXPORT_SYMBOL	
++0x21ce3ed1	dev_fetch_sw_netstats	vmlinux	EXPORT_SYMBOL_GPL	
++0xf5f20821	devm_thermal_zone_of_sensor_unregister	vmlinux	EXPORT_SYMBOL_GPL	
++0xe39d0794	usb_phy_roothub_exit	vmlinux	EXPORT_SYMBOL_GPL	
++0xc93ee1e7	usb_phy_roothub_init	vmlinux	EXPORT_SYMBOL_GPL	
++0xdfdf5482	pm_clk_remove	vmlinux	EXPORT_SYMBOL_GPL	
++0x2052cca1	bdev_check_media_change	vmlinux	EXPORT_SYMBOL	
++0xe9569c81	crypto_cipher_decrypt_one	vmlinux	EXPORT_SYMBOL_GPL	
++0x684c0aa9	jbd2_journal_start_commit	vmlinux	EXPORT_SYMBOL	
++0x76d3cd60	laptop_mode	vmlinux	EXPORT_SYMBOL	
++0xaaf4e419	generic_file_direct_write	vmlinux	EXPORT_SYMBOL	
++0x229ab84e	end_page_writeback	vmlinux	EXPORT_SYMBOL	
++0x89e19e58	skb_recv_datagram	vmlinux	EXPORT_SYMBOL	
++0xe8cdcdf6	clk_hw_round_rate	vmlinux	EXPORT_SYMBOL_GPL	
++0xba60520e	generic_file_readonly_mmap	vmlinux	EXPORT_SYMBOL	
++0xd06524ba	raw_notifier_chain_unregister	vmlinux	EXPORT_SYMBOL_GPL	
++0xb917b6d7	return_address	vmlinux	EXPORT_SYMBOL_GPL	
++0x0d542439	__ipv6_addr_type	vmlinux	EXPORT_SYMBOL	
++0x0b7d7b2b	unregister_qdisc	vmlinux	EXPORT_SYMBOL	
++0xc1655f9a	extcon_set_property_capability	vmlinux	EXPORT_SYMBOL_GPL	
++0x16646822	extcon_get_property_capability	vmlinux	EXPORT_SYMBOL_GPL	
++0x0bf07c57	sdhci_suspend_host	vmlinux	EXPORT_SYMBOL_GPL	
++0x460e7646	cpufreq_table_index_unsorted	vmlinux	EXPORT_SYMBOL_GPL	
++0x30d9241f	dev_pm_opp_detach_genpd	vmlinux	EXPORT_SYMBOL_GPL	
++0x7fadbbed	usb_autopm_get_interface	vmlinux	EXPORT_SYMBOL_GPL	
++0x916bb564	phy_device_register	vmlinux	EXPORT_SYMBOL	
++0x75a1645f	of_genpd_add_provider_onecell	vmlinux	EXPORT_SYMBOL_GPL	
++0xa3c28642	pci_map_rom	vmlinux	EXPORT_SYMBOL	
++0xb9e53732	crypto_shash_finup	vmlinux	EXPORT_SYMBOL_GPL	
++0x1a252d2e	crypto_shash_final	vmlinux	EXPORT_SYMBOL_GPL	
++0xc5f07d1d	crypto_ahash_finup	vmlinux	EXPORT_SYMBOL_GPL	
++0x6d14b48a	crypto_ahash_final	vmlinux	EXPORT_SYMBOL_GPL	
++0x221eab6d	scatterwalk_copychunks	vmlinux	EXPORT_SYMBOL_GPL	
++0xc703ae0d	pin_user_pages_unlocked	vmlinux	EXPORT_SYMBOL	
++0x052c9aed	ktime_get_real_fast_ns	vmlinux	EXPORT_SYMBOL_GPL	
++0xfe12bffb	devm_irq_alloc_generic_chip	vmlinux	EXPORT_SYMBOL_GPL	
++0x276718f6	rpc_free	vmlinux	EXPORT_SYMBOL_GPL	
++0x7b7a21e1	sock_diag_put_meminfo	vmlinux	EXPORT_SYMBOL_GPL	
++0x64bbc288	string_unescape	vmlinux	EXPORT_SYMBOL	
++0xc6cb465a	__kfifo_max_r	vmlinux	EXPORT_SYMBOL	
++0xabc3d6e5	vm_insert_page	vmlinux	EXPORT_SYMBOL	
++0x5c2ecdd1	bpf_prog_sub	vmlinux	EXPORT_SYMBOL_GPL	
++0x1422e987	irq_domain_add_legacy	vmlinux	EXPORT_SYMBOL_GPL	
++0x0345f993	irq_chip_disable_parent	vmlinux	EXPORT_SYMBOL_GPL	
++0x363a36e8	register_console	vmlinux	EXPORT_SYMBOL	
++0xadfc3280	inet_reqsk_alloc	vmlinux	EXPORT_SYMBOL	
++0x22a230bc	sock_no_socketpair	vmlinux	EXPORT_SYMBOL	
++0x2aadad1a	efi_capsule_update	vmlinux	EXPORT_SYMBOL_GPL	
++0x9c293bab	input_ff_event	vmlinux	EXPORT_SYMBOL_GPL	
++0xf1088be7	devm_gpio_request	vmlinux	EXPORT_SYMBOL_GPL	
++0x14f3b1e8	__traceiter_wbc_writepage	vmlinux	EXPORT_SYMBOL_GPL	
++0x4bc69a30	__filemap_set_wb_err	vmlinux	EXPORT_SYMBOL	
++0x3192d768	cpufreq_remove_update_util_hook	vmlinux	EXPORT_SYMBOL_GPL	
++0x5bd4ff88	flow_action_cookie_create	vmlinux	EXPORT_SYMBOL	
++0xeb07b6ed	dev_addr_del	vmlinux	EXPORT_SYMBOL	
++0x92afe387	gnet_stats_start_copy	vmlinux	EXPORT_SYMBOL	
++0xbe66b89e	devm_of_platform_depopulate	vmlinux	EXPORT_SYMBOL_GPL	
++0x33f0768c	cpufreq_quick_get_max	vmlinux	EXPORT_SYMBOL	
++0x0618e60b	iscsi_is_session_online	vmlinux	EXPORT_SYMBOL_GPL	
++0x1c5ff742	clk_get_phase	vmlinux	EXPORT_SYMBOL_GPL	
++0xb7329c06	clk_set_phase	vmlinux	EXPORT_SYMBOL_GPL	
++0x0be663cd	nfs_retry_commit	vmlinux	EXPORT_SYMBOL_GPL	
++0xd192d0be	nfs_client_init_status	vmlinux	EXPORT_SYMBOL_GPL	
++0x82a35977	__traceiter_sched_update_nr_running_tp	vmlinux	EXPORT_SYMBOL_GPL	
++0x46013233	net_dec_ingress_queue	vmlinux	EXPORT_SYMBOL_GPL	
++0xab72aa7e	usb_gadget_set_state	vmlinux	EXPORT_SYMBOL_GPL	
++0x4ab60373	platform_device_del	vmlinux	EXPORT_SYMBOL_GPL	
++0x6d21ac2c	platform_device_put	vmlinux	EXPORT_SYMBOL_GPL	
++0xd36dc10c	get_random_u32	vmlinux	EXPORT_SYMBOL	
++0xe3ff2c41	get_random_u64	vmlinux	EXPORT_SYMBOL	
++0x5db1a934	devm_clk_hw_register_clkdev	vmlinux	EXPORT_SYMBOL	
++0x15bdb607	pci_get_dsn	vmlinux	EXPORT_SYMBOL_GPL	
++0x14fe597c	__xa_alloc	vmlinux	EXPORT_SYMBOL	
++0x556b5d62	__kfifo_dma_in_prepare_r	vmlinux	EXPORT_SYMBOL	
++0xf0ebf9e4	blk_mq_stop_hw_queues	vmlinux	EXPORT_SYMBOL	
++0x43270b2c	__fat_fs_error	vmlinux	EXPORT_SYMBOL_GPL	
++0x2e1b51c2	bpf_preload_ops	vmlinux	EXPORT_SYMBOL_GPL	
++0x995d1071	prof_on	vmlinux	EXPORT_SYMBOL_GPL	
++0xee43fa6e	devm_free_irq	vmlinux	EXPORT_SYMBOL	
++0xd3777ffb	rpc_exit	vmlinux	EXPORT_SYMBOL_GPL	
++0xde909761	kernel_accept	vmlinux	EXPORT_SYMBOL	
++0x60f373fc	kset_create_and_add	vmlinux	EXPORT_SYMBOL_GPL	
++0x6fff261f	__arch_clear_user	vmlinux	EXPORT_SYMBOL	
++0xee799005	pcim_iounmap	vmlinux	EXPORT_SYMBOL	
++0x92b2cca1	mm_kobj	vmlinux	EXPORT_SYMBOL_GPL	
++0x6b4df253	set_bdi_congested	vmlinux	EXPORT_SYMBOL	
++0x1a9b0249	wb_writeout_inc	vmlinux	EXPORT_SYMBOL_GPL	
++0x1db2435e	do_wait_intr	vmlinux	EXPORT_SYMBOL	
++0x9aaff899	usb_gadget_map_request	vmlinux	EXPORT_SYMBOL_GPL	
++0xad40689e	driver_find	vmlinux	EXPORT_SYMBOL_GPL	
++0xaa160e36	serdev_device_wait_until_sent	vmlinux	EXPORT_SYMBOL_GPL	
++0xc16fa88b	devm_gpio_request_one	vmlinux	EXPORT_SYMBOL_GPL	
++0x896b4c79	gpiod_set_value_cansleep	vmlinux	EXPORT_SYMBOL_GPL	
++0x2412bb9f	sbitmap_queue_resize	vmlinux	EXPORT_SYMBOL_GPL	
++0xc5777fca	linear_range_get_selector_low_array	vmlinux	EXPORT_SYMBOL_GPL	
++0x96dcd475	devm_ioremap_resource	vmlinux	EXPORT_SYMBOL	
++0x2d3f7e78	sg_miter_start	vmlinux	EXPORT_SYMBOL	
++0x8df61353	disk_has_partitions	vmlinux	EXPORT_SYMBOL_GPL	
++0x2d4ac90e	freq_qos_remove_request	vmlinux	EXPORT_SYMBOL_GPL	
++0xed656e30	udp_encap_disable	vmlinux	EXPORT_SYMBOL	
++0x2d617b7c	tso_build_data	vmlinux	EXPORT_SYMBOL	
++0x238df0b2	sock_zerocopy_alloc	vmlinux	EXPORT_SYMBOL_GPL	
++0x8375aa6a	DWC_MSLEEP	vmlinux	EXPORT_SYMBOL	
++0x77a126b2	dma_buf_map_attachment	vmlinux	EXPORT_SYMBOL_GPL	
++0xa9f0b4b1	tty_mode_ioctl	vmlinux	EXPORT_SYMBOL_GPL	
++0xaad7533d	fb_class	vmlinux	EXPORT_SYMBOL	
++0x0c2ca998	load_nls	vmlinux	EXPORT_SYMBOL	
++0xc774e02f	nfs_show_stats	vmlinux	EXPORT_SYMBOL_GPL	
++0x659ded26	xfrm_flush_gc	vmlinux	EXPORT_SYMBOL	
++0x4859b8bb	rtc_year_days	vmlinux	EXPORT_SYMBOL	
++0xd3fcdcfd	dwc_cc_name	vmlinux	EXPORT_SYMBOL	
++0x99168a46	ehci_cf_port_reset_rwsem	vmlinux	EXPORT_SYMBOL_GPL	
++0xfbad3cf0	scsi_normalize_sense	vmlinux	EXPORT_SYMBOL	
++0x2047b07f	__pm_runtime_use_autosuspend	vmlinux	EXPORT_SYMBOL_GPL	
++0xb2f35c6a	xxh64	vmlinux	EXPORT_SYMBOL	
++0x8888f1fe	xxh32	vmlinux	EXPORT_SYMBOL	
++0x65c00e10	bio_advance	vmlinux	EXPORT_SYMBOL	
++0x9278402f	from_kuid	vmlinux	EXPORT_SYMBOL	
++0xc46d283e	add_timer_on	vmlinux	EXPORT_SYMBOL_GPL	
++0x73a3a883	ip6_local_out	vmlinux	EXPORT_SYMBOL_GPL	
++0x582ed8ca	vchiq_bulk_receive	vmlinux	EXPORT_SYMBOL	
++0xd3a5b8da	of_mdio_find_device	vmlinux	EXPORT_SYMBOL	
++0xb3dfea32	pm_runtime_set_autosuspend_delay	vmlinux	EXPORT_SYMBOL_GPL	
++0xfb6eedf9	power_group_name	vmlinux	EXPORT_SYMBOL_GPL	
++0xeaf13ac7	devm_platform_get_and_ioremap_resource	vmlinux	EXPORT_SYMBOL_GPL	
++0x9484d8e1	pci_slots_kset	vmlinux	EXPORT_SYMBOL_GPL	
++0xbbce15bc	pci_find_next_ext_capability	vmlinux	EXPORT_SYMBOL_GPL	
++0x6ba4ee38	klist_iter_exit	vmlinux	EXPORT_SYMBOL_GPL	
++0x74b5ea68	lcm_not_zero	vmlinux	EXPORT_SYMBOL_GPL	
++0x0474edef	kstrtou16_from_user	vmlinux	EXPORT_SYMBOL	
++0x7d74d522	kstrtoull_from_user	vmlinux	EXPORT_SYMBOL	
++0xe12c0f82	crypto_skcipher_decrypt	vmlinux	EXPORT_SYMBOL_GPL	
++0xbaf22757	kvfree_call_rcu	vmlinux	EXPORT_SYMBOL_GPL	
++0x68cd57c5	xdr_init_decode	vmlinux	EXPORT_SYMBOL_GPL	
++0x99f018c4	nvmem_cell_read	vmlinux	EXPORT_SYMBOL_GPL	
++0xfed11ed1	usb_mon_deregister	vmlinux	EXPORT_SYMBOL_GPL	
++0xa23493b9	device_unregister	vmlinux	EXPORT_SYMBOL_GPL	
++0xcf37414b	nfs_remove_bad_delegation	vmlinux	EXPORT_SYMBOL_GPL	
++0xd3a5e3da	jbd2_journal_load	vmlinux	EXPORT_SYMBOL	
++0xf8d0da4e	seq_escape_mem_ascii	vmlinux	EXPORT_SYMBOL	
++0x4b03e1a0	vmf_insert_mixed_prot	vmlinux	EXPORT_SYMBOL	
++0x34a7b142	__SCK__tp_func_rpm_suspend	vmlinux	EXPORT_SYMBOL_GPL	
++0x3d254272	rt_spin_trylock	vmlinux	EXPORT_SYMBOL	
++0x25b1e2f1	iw_handler_set_thrspy	vmlinux	EXPORT_SYMBOL	
++0x42bf6115	xfrm_state_add	vmlinux	EXPORT_SYMBOL	
++0x3a3d1cd3	ping_rcv	vmlinux	EXPORT_SYMBOL_GPL	
++0x0900b488	__netlink_kernel_create	vmlinux	EXPORT_SYMBOL	
++0x31bbe785	of_property_read_u64_index	vmlinux	EXPORT_SYMBOL_GPL	
++0x310a16e5	of_property_read_u32_index	vmlinux	EXPORT_SYMBOL_GPL	
++0x395db397	regulator_is_enabled	vmlinux	EXPORT_SYMBOL_GPL	
++0xd762bc30	btree_remove	vmlinux	EXPORT_SYMBOL_GPL	
++0x3523e172	iov_iter_bvec	vmlinux	EXPORT_SYMBOL	
++0x0a942481	iov_iter_kvec	vmlinux	EXPORT_SYMBOL	
++0x6e075aa0	led_get_default_pattern	vmlinux	EXPORT_SYMBOL_GPL	
++0xbaa7ad99	scsicam_bios_param	vmlinux	EXPORT_SYMBOL	
++0x3026d6ca	serdev_controller_remove	vmlinux	EXPORT_SYMBOL_GPL	
++0x0f885212	pci_generic_config_read32	vmlinux	EXPORT_SYMBOL_GPL	
++0x514d2f37	fscrypt_ioctl_get_key_status	vmlinux	EXPORT_SYMBOL_GPL	
++0x2cd1cd78	I_BDEV	vmlinux	EXPORT_SYMBOL	
++0x7729cbdd	task_handoff_register	vmlinux	EXPORT_SYMBOL_GPL	
++0x9618fb6e	irq_create_fwspec_mapping	vmlinux	EXPORT_SYMBOL_GPL	
++0xf9298c58	tty_port_tty_set	vmlinux	EXPORT_SYMBOL	
++0xcdc449ee	tty_port_tty_get	vmlinux	EXPORT_SYMBOL	
++0x686b226f	devm_regulator_get	vmlinux	EXPORT_SYMBOL_GPL	
++0x4f1cd128	security_tun_dev_create	vmlinux	EXPORT_SYMBOL	
++0xbb756f04	fs_context_for_mount	vmlinux	EXPORT_SYMBOL	
++0x38a9f7c5	in6addr_loopback	vmlinux	EXPORT_SYMBOL	
++0x3b355456	inet_csk_route_child_sock	vmlinux	EXPORT_SYMBOL_GPL	
++0x41797322	tcf_exts_terse_dump	vmlinux	EXPORT_SYMBOL	
++0xae6e8d89	netdev_set_num_tc	vmlinux	EXPORT_SYMBOL	
++0x5859b41e	skb_dump	vmlinux	EXPORT_SYMBOL	
++0xd022d194	mipi_dsi_dcs_get_power_mode	vmlinux	EXPORT_SYMBOL	
++0x1dc6c93b	lookup_user_key	vmlinux	EXPORT_SYMBOL	
++0x413e6139	vfs_path_lookup	vmlinux	EXPORT_SYMBOL	
++0xd03eaf4c	schedule_hrtimeout_range	vmlinux	EXPORT_SYMBOL_GPL	
++0x1bb2f26e	usb_sg_wait	vmlinux	EXPORT_SYMBOL_GPL	
++0x4af9931f	usb_sg_init	vmlinux	EXPORT_SYMBOL_GPL	
++0x00918987	usb_urb_ep_type_check	vmlinux	EXPORT_SYMBOL_GPL	
++0x3f461736	jbd2_journal_flush	vmlinux	EXPORT_SYMBOL	
++0x68eb14ea	invalidate_bdev	vmlinux	EXPORT_SYMBOL	
++0x944375db	_totalram_pages	vmlinux	EXPORT_SYMBOL	
++0x9aeacb87	ring_buffer_iter_empty	vmlinux	EXPORT_SYMBOL_GPL	
++0x3ff488f7	put_pid_ns	vmlinux	EXPORT_SYMBOL_GPL	
++0x38440dc6	tcp_twsk_unique	vmlinux	EXPORT_SYMBOL_GPL	
++0x21196ac8	netdev_info	vmlinux	EXPORT_SYMBOL	
++0x6c61ce70	num_registered_fb	vmlinux	EXPORT_SYMBOL	
++0x8ff638f6	pci_stop_root_bus	vmlinux	EXPORT_SYMBOL_GPL	
++0x7f798164	kobject_uevent	vmlinux	EXPORT_SYMBOL_GPL	
++0x63be49b5	__fscrypt_prepare_rename	vmlinux	EXPORT_SYMBOL_GPL	
++0xf60326ac	vfs_ioctl	vmlinux	EXPORT_SYMBOL	
++0x38017e18	sched_set_fifo	vmlinux	EXPORT_SYMBOL_GPL	
++0xb7f4f2fd	xdr_buf_from_iov	vmlinux	EXPORT_SYMBOL_GPL	
++0xb34d14f0	inet_send_prepare	vmlinux	EXPORT_SYMBOL_GPL	
++0x80be98ce	of_n_addr_cells	vmlinux	EXPORT_SYMBOL	
++0xbf40e6bd	mmc_retune_timer_stop	vmlinux	EXPORT_SYMBOL	
++0x584a31ab	__SCK__tp_func_iscsi_dbg_session	vmlinux	EXPORT_SYMBOL_GPL	
++0x83dfe84e	regmap_get_raw_write_max	vmlinux	EXPORT_SYMBOL_GPL	
++0xfb4a9bd6	pci_bus_write_config_dword	vmlinux	EXPORT_SYMBOL	
++0xb8009c45	fscrypt_prepare_new_inode	vmlinux	EXPORT_SYMBOL_GPL	
++0xd159586c	net_prio_cgrp_subsys_enabled_key	vmlinux	EXPORT_SYMBOL_GPL	
++0x81d1ed81	dst_cache_get_ip6	vmlinux	EXPORT_SYMBOL_GPL	
++0xcd759467	netdev_lower_state_changed	vmlinux	EXPORT_SYMBOL	
++0xad663155	tty_hung_up_p	vmlinux	EXPORT_SYMBOL	
++0x2aea796c	blk_cleanup_queue	vmlinux	EXPORT_SYMBOL	
++0x61fbad46	iomap_is_partially_uptodate	vmlinux	EXPORT_SYMBOL_GPL	
++0xd27789f5	generic_setlease	vmlinux	EXPORT_SYMBOL	
++0x7d93f951	dev_pm_opp_get_voltage	vmlinux	EXPORT_SYMBOL_GPL	
++0x2733eaf7	scsi_dev_info_list_add_keyed	vmlinux	EXPORT_SYMBOL	
++0x9dfd1261	pcim_enable_device	vmlinux	EXPORT_SYMBOL	
++0x5a49dbc9	timerqueue_del	vmlinux	EXPORT_SYMBOL_GPL	
++0x2f89d2b1	nf_register_net_hooks	vmlinux	EXPORT_SYMBOL	
++0x9656463a	usb_driver_release_interface	vmlinux	EXPORT_SYMBOL_GPL	
++0x96db5581	pm_genpd_init	vmlinux	EXPORT_SYMBOL_GPL	
++0x4da48f47	dev_err_probe	vmlinux	EXPORT_SYMBOL_GPL	
++0x0120d4ef	proc_mkdir_data	vmlinux	EXPORT_SYMBOL_GPL	
++0x9eaac714	mpage_writepages	vmlinux	EXPORT_SYMBOL	
++0xc3669972	write_one_page	vmlinux	EXPORT_SYMBOL	
++0x7a81541b	async_synchronize_cookie	vmlinux	EXPORT_SYMBOL_GPL	
++0xa3d9f33f	udp6_set_csum	vmlinux	EXPORT_SYMBOL	
++0xb7f0fce2	inet_add_protocol	vmlinux	EXPORT_SYMBOL	
++0xcd6f2dc9	nf_log_buf_add	vmlinux	EXPORT_SYMBOL_GPL	
++0xb184b9a0	n_tty_ioctl_helper	vmlinux	EXPORT_SYMBOL	
++0xc2f52274	__lshrti3	vmlinux	EXPORT_SYMBOL	
++0xc838c3f5	__ashrti3	vmlinux	EXPORT_SYMBOL	
++0x21bba8d8	nlmsvc_ops	vmlinux	EXPORT_SYMBOL_GPL	
++0xf1d2aaa6	sync_blockdev	vmlinux	EXPORT_SYMBOL	
++0x497cc698	nobh_write_end	vmlinux	EXPORT_SYMBOL	
++0xab6abdb7	dma_map_sg_attrs	vmlinux	EXPORT_SYMBOL	
++0x89708770	tcf_idr_release	vmlinux	EXPORT_SYMBOL	
++0x6e720ff2	rtnl_unlock	vmlinux	EXPORT_SYMBOL	
++0x8d263979	sock_rfree	vmlinux	EXPORT_SYMBOL	
++0xcba7b6d3	kernel_recvmsg	vmlinux	EXPORT_SYMBOL	
++0x0beac0c4	sdhci_alloc_host	vmlinux	EXPORT_SYMBOL_GPL	
++0x5dc111ef	usb_hub_find_child	vmlinux	EXPORT_SYMBOL_GPL	
++0x609b23ae	phy_request_interrupt	vmlinux	EXPORT_SYMBOL	
++0xf092a1c3	__root_device_register	vmlinux	EXPORT_SYMBOL_GPL	
++0xba8c609d	__next_node_in	vmlinux	EXPORT_SYMBOL	
++0xc0a3d105	find_next_bit	vmlinux	EXPORT_SYMBOL	
++0xf8d07858	bitmap_from_arr32	vmlinux	EXPORT_SYMBOL	
++0xd8a55d67	disk_part_iter_init	vmlinux	EXPORT_SYMBOL_GPL	
++0x27649bdc	nfs_server_remove_lists	vmlinux	EXPORT_SYMBOL_GPL	
++0xc220c10f	dquot_reclaim_space_nodirty	vmlinux	EXPORT_SYMBOL	
++0x6028828c	freeze_bdev	vmlinux	EXPORT_SYMBOL	
++0x4ae6042c	clockevents_unbind_device	vmlinux	EXPORT_SYMBOL_GPL	
++0x54db79ec	srcu_batches_completed	vmlinux	EXPORT_SYMBOL_GPL	
++0x8021ec81	skb_kill_datagram	vmlinux	EXPORT_SYMBOL	
++0x0090b46e	kfree_skb	vmlinux	EXPORT_SYMBOL	
++0x07ed4486	phy_resume	vmlinux	EXPORT_SYMBOL	
++0x533c198f	__SCK__tp_func_nfs4_pnfs_write	vmlinux	EXPORT_SYMBOL_GPL	
++0x44eed603	kernel_kobj	vmlinux	EXPORT_SYMBOL_GPL	
++0xacf7455c	atomic_notifier_chain_register	vmlinux	EXPORT_SYMBOL_GPL	
++0xe2312548	param_get_long	vmlinux	EXPORT_SYMBOL	
++0xe28d3c9b	udp_seq_next	vmlinux	EXPORT_SYMBOL	
++0x95b93608	ip_sock_set_freebind	vmlinux	EXPORT_SYMBOL	
++0x4c6d5917	i2c_smbus_read_i2c_block_data_or_emulated	vmlinux	EXPORT_SYMBOL	
++0x06dd3938	stmpe811_adc_common_init	vmlinux	EXPORT_SYMBOL_GPL	
++0xb2a1d5b5	regulator_get_voltage	vmlinux	EXPORT_SYMBOL_GPL	
++0x5383c48b	amba_driver_unregister	vmlinux	EXPORT_SYMBOL	
++0x84502a47	blk_status_to_errno	vmlinux	EXPORT_SYMBOL_GPL	
++0xbef4048b	nfs_atomic_open	vmlinux	EXPORT_SYMBOL_GPL	
++0x9b496b21	posix_acl_alloc	vmlinux	EXPORT_SYMBOL	
++0xe822b4c5	kernel_read_file_from_fd	vmlinux	EXPORT_SYMBOL_GPL	
++0x9cfdb5a6	svc_set_num_threads	vmlinux	EXPORT_SYMBOL_GPL	
++0x9769fef9	rtnl_delete_link	vmlinux	EXPORT_SYMBOL_GPL	
++0xf23f3787	__kfree_skb	vmlinux	EXPORT_SYMBOL	
++0xebfcf973	led_compose_name	vmlinux	EXPORT_SYMBOL_GPL	
++0x00b84c2c	DWC_IN_IRQ	vmlinux	EXPORT_SYMBOL	
++0x86e6a605	tty_port_register_device	vmlinux	EXPORT_SYMBOL_GPL	
++0xea795f68	dma_async_device_channel_register	vmlinux	EXPORT_SYMBOL_GPL	
++0xc9822234	clk_register_clkdev	vmlinux	EXPORT_SYMBOL	
++0x733fb227	pci_find_parent_resource	vmlinux	EXPORT_SYMBOL	
++0xbbf29a37	pinctrl_get_group_pins	vmlinux	EXPORT_SYMBOL_GPL	
++0xbfe2cfd7	nfs_permission	vmlinux	EXPORT_SYMBOL_GPL	
++0x8b4edd1f	sysfs_update_groups	vmlinux	EXPORT_SYMBOL_GPL	
++0x4877bec8	register_trace_event	vmlinux	EXPORT_SYMBOL_GPL	
++0x3661c5a3	__hw_addr_unsync_dev	vmlinux	EXPORT_SYMBOL	
++0x7df3303c	gpiod_get_raw_array_value	vmlinux	EXPORT_SYMBOL_GPL	
++0x14c85fe5	dma_set_coherent_mask	vmlinux	EXPORT_SYMBOL	
++0xc2cf8004	tcp_reno_undo_cwnd	vmlinux	EXPORT_SYMBOL_GPL	
++0x91ae25a8	ip_defrag	vmlinux	EXPORT_SYMBOL	
++0x1b26ce1d	register_qdisc	vmlinux	EXPORT_SYMBOL	
++0x7794d84f	mmc_can_discard	vmlinux	EXPORT_SYMBOL	
++0xa3bcf874	scsi_flush_work	vmlinux	EXPORT_SYMBOL_GPL	
++0xfc179793	fbcon_rotate_ccw	vmlinux	EXPORT_SYMBOL	
++0x8d6de45d	idr_destroy	vmlinux	EXPORT_SYMBOL	
++0x66569a6c	ida_destroy	vmlinux	EXPORT_SYMBOL	
++0x47c20f8a	refcount_dec_not_one	vmlinux	EXPORT_SYMBOL	
++0xc21604b1	public_key_verify_signature	vmlinux	EXPORT_SYMBOL_GPL	
++0xa3b958ce	reset_hung_task_detector	vmlinux	EXPORT_SYMBOL_GPL	
++0x8c9a86f5	xdr_stream_decode_string_dup	vmlinux	EXPORT_SYMBOL_GPL	
++0xa354b3fd	xprt_wait_for_buffer_space	vmlinux	EXPORT_SYMBOL_GPL	
++0x6e6d3bdd	default_qdisc_ops	vmlinux	EXPORT_SYMBOL	
++0x27dc9471	__tracepoint_br_fdb_update	vmlinux	EXPORT_SYMBOL_GPL	
++0xa4350eaa	free_netdev	vmlinux	EXPORT_SYMBOL	
++0x34592f37	aead_register_instance	vmlinux	EXPORT_SYMBOL_GPL	
++0xbc25f7cc	free_contig_range	vmlinux	EXPORT_SYMBOL	
++0xc9ec4e21	free_percpu	vmlinux	EXPORT_SYMBOL_GPL	
++0xf4ea6fb1	__SCK__tp_func_xdp_bulk_tx	vmlinux	EXPORT_SYMBOL_GPL	
++0xf8029fdb	netdev_class_remove_file_ns	vmlinux	EXPORT_SYMBOL	
++0x9299dea7	metadata_dst_free	vmlinux	EXPORT_SYMBOL_GPL	
++0xc7331dfc	__zerocopy_sg_from_iter	vmlinux	EXPORT_SYMBOL	
++0x048fc1c1	sk_setup_caps	vmlinux	EXPORT_SYMBOL_GPL	
++0x72d267dc	nvmem_del_cell_lookups	vmlinux	EXPORT_SYMBOL_GPL	
++0x363d5d0d	bcm_phy_write_shadow	vmlinux	EXPORT_SYMBOL_GPL	
++0x049fca30	spi_sync_locked	vmlinux	EXPORT_SYMBOL_GPL	
++0x29b52585	scsi_host_get	vmlinux	EXPORT_SYMBOL	
++0x33daf7c8	regulator_bulk_get	vmlinux	EXPORT_SYMBOL_GPL	
++0x3737d9a9	ZSTD_DStreamWorkspaceBound	vmlinux	EXPORT_SYMBOL	
++0x424d3620	zlib_inflateIncomp	vmlinux	EXPORT_SYMBOL	
++0x517d61df	iomap_releasepage	vmlinux	EXPORT_SYMBOL_GPL	
++0x6a5fa363	sigprocmask	vmlinux	EXPORT_SYMBOL	
++0x21494e5d	__skb_flow_get_ports	vmlinux	EXPORT_SYMBOL	
++0x4ab54444	sk_stream_wait_connect	vmlinux	EXPORT_SYMBOL	
++0x2c97f8a2	of_reconfig_notifier_register	vmlinux	EXPORT_SYMBOL_GPL	
++0x820e3a4c	phy_set_sym_pause	vmlinux	EXPORT_SYMBOL	
++0x33d27241	arizona_dev_exit	vmlinux	EXPORT_SYMBOL_GPL	
++0x97144ec5	arizona_dev_init	vmlinux	EXPORT_SYMBOL_GPL	
++0x3f1dc09d	devres_alloc_node	vmlinux	EXPORT_SYMBOL_GPL	
++0xca130956	mm_vc_mem_base	vmlinux	EXPORT_SYMBOL	
++0xc47a3ba7	devm_hwrng_register	vmlinux	EXPORT_SYMBOL_GPL	
++0xb6362134	nfs4_mark_deviceid_available	vmlinux	EXPORT_SYMBOL_GPL	
++0xfa428194	sock_no_sendmsg	vmlinux	EXPORT_SYMBOL	
++0x4c634fbe	extcon_unregister_notifier	vmlinux	EXPORT_SYMBOL_GPL	
++0xd17d2a22	phy_basic_features	vmlinux	EXPORT_SYMBOL_GPL	
++0xf98d8599	nvme_remove_namespaces	vmlinux	EXPORT_SYMBOL_GPL	
++0xcb40bb64	idr_alloc	vmlinux	EXPORT_SYMBOL_GPL	
++0x843db521	jbd2_journal_update_sb_errno	vmlinux	EXPORT_SYMBOL	
++0x5ace9ad2	vfs_unlink	vmlinux	EXPORT_SYMBOL	
++0x090150bf	vmalloc_hugepage	vmlinux	EXPORT_SYMBOL	
++0x40d46c1a	get_task_exe_file	vmlinux	EXPORT_SYMBOL	
++0x3cbc6eff	xfrm_input_unregister_afinfo	vmlinux	EXPORT_SYMBOL	
++0xa2918f4e	tcp_req_err	vmlinux	EXPORT_SYMBOL	
++0x7886b259	__skb_gro_checksum_complete	vmlinux	EXPORT_SYMBOL	
++0xb2405efc	secure_tcp_seq	vmlinux	EXPORT_SYMBOL_GPL	
++0xb8f8e43b	of_get_child_by_name	vmlinux	EXPORT_SYMBOL	
++0x001d5e6a	dt_init_idle_driver	vmlinux	EXPORT_SYMBOL_GPL	
++0x90a9c120	cpufreq_frequency_table_get_index	vmlinux	EXPORT_SYMBOL_GPL	
++0x7396fc7a	DWC_WAITQ_ALLOC	vmlinux	EXPORT_SYMBOL	
++0x2cc46a6a	phy_aneg_done	vmlinux	EXPORT_SYMBOL	
++0xdcb3120a	key_revoke	vmlinux	EXPORT_SYMBOL	
++0x598a8c6e	nfs_mkdir	vmlinux	EXPORT_SYMBOL_GPL	
++0x3e18a1d1	pipe_unlock	vmlinux	EXPORT_SYMBOL	
++0xdcfcd330	irq_generic_chip_ops	vmlinux	EXPORT_SYMBOL_GPL	
++0x3a2e77f4	xprt_reserve_xprt_cong	vmlinux	EXPORT_SYMBOL_GPL	
++0x10de64d7	genlmsg_multicast_allns	vmlinux	EXPORT_SYMBOL	
++0x56df0c72	__sock_recv_wifi_status	vmlinux	EXPORT_SYMBOL_GPL	
++0xd2d959d9	devm_mbox_controller_register	vmlinux	EXPORT_SYMBOL_GPL	
++0x183b881d	efivar_entry_delete	vmlinux	EXPORT_SYMBOL_GPL	
++0x1b512d75	dev_pm_opp_adjust_voltage	vmlinux	EXPORT_SYMBOL_GPL	
++0x6415d85d	bus_rescan_devices	vmlinux	EXPORT_SYMBOL_GPL	
++0x0eb3aff5	put_tty_driver	vmlinux	EXPORT_SYMBOL	
++0xcaf7a0d9	gpiod_toggle_active_low	vmlinux	EXPORT_SYMBOL_GPL	
++0xb79dfba0	bio_iov_iter_get_pages	vmlinux	EXPORT_SYMBOL_GPL	
++0x976a1571	debugfs_read_file_bool	vmlinux	EXPORT_SYMBOL_GPL	
++0x53012944	__tracepoint_rpm_resume	vmlinux	EXPORT_SYMBOL_GPL	
++0xed60d775	rt_spin_trylock_bh	vmlinux	EXPORT_SYMBOL	
++0xb9c1f7cd	queue_work_on	vmlinux	EXPORT_SYMBOL	
++0xa612ccf4	ioport_resource	vmlinux	EXPORT_SYMBOL	
++0xd5774372	dst_cache_set_ip6	vmlinux	EXPORT_SYMBOL_GPL	
++0xc7a4fbed	rtnl_lock	vmlinux	EXPORT_SYMBOL	
++0xbc5a1a13	arizona_set_irq_wake	vmlinux	EXPORT_SYMBOL_GPL	
++0xebd51d25	pci_probe_reset_bus	vmlinux	EXPORT_SYMBOL_GPL	
++0x9e9eab95	devcgroup_check_permission	vmlinux	EXPORT_SYMBOL	
++0x02765b10	debugfs_create_bool	vmlinux	EXPORT_SYMBOL_GPL	
++0x72c3c8c1	nfs_release_request	vmlinux	EXPORT_SYMBOL_GPL	
++0xc2067c15	__fscache_maybe_release_page	vmlinux	EXPORT_SYMBOL	
++0xb2084927	generic_file_splice_read	vmlinux	EXPORT_SYMBOL	
++0x422ef236	get_tree_single_reconf	vmlinux	EXPORT_SYMBOL	
++0x7e7e3f58	ring_buffer_reset_cpu	vmlinux	EXPORT_SYMBOL_GPL	
++0x4cb9ff2b	__irq_domain_add	vmlinux	EXPORT_SYMBOL_GPL	
++0x8dc4203a	prepare_kernel_cred	vmlinux	EXPORT_SYMBOL	
++0x015af7f4	system_state	vmlinux	EXPORT_SYMBOL	
++0xc0ca4a61	__icmp_send	vmlinux	EXPORT_SYMBOL	
++0xbebafddc	udp_push_pending_frames	vmlinux	EXPORT_SYMBOL	
++0xf04b22ad	hidinput_connect	vmlinux	EXPORT_SYMBOL_GPL	
++0x0b36440d	__platform_driver_probe	vmlinux	EXPORT_SYMBOL_GPL	
++0x45558f56	clk_unregister_fixed_factor	vmlinux	EXPORT_SYMBOL_GPL	
++0x15bed7a5	LZ4_decompress_safe_partial	vmlinux	EXPORT_SYMBOL	
++0x3b056e9f	rhashtable_destroy	vmlinux	EXPORT_SYMBOL_GPL	
++0x7e52e3d1	pnfs_update_layout	vmlinux	EXPORT_SYMBOL_GPL	
++0xc7396af6	nfs_access_zap_cache	vmlinux	EXPORT_SYMBOL_GPL	
++0x7010a74d	del_timer_sync	vmlinux	EXPORT_SYMBOL	
++0x8dfdd5cc	param_ops_uint	vmlinux	EXPORT_SYMBOL	
++0x2210d45d	of_parse_phandle_with_fixed_args	vmlinux	EXPORT_SYMBOL	
++0xc5a3367a	__tracepoint_dma_fence_emit	vmlinux	EXPORT_SYMBOL	
++0x5fd49269	con_set_default_unimap	vmlinux	EXPORT_SYMBOL	
++0xc2ed909f	fb_deferred_io_open	vmlinux	EXPORT_SYMBOL_GPL	
++0x7358784a	gpiod_unexport	vmlinux	EXPORT_SYMBOL_GPL	
++0x7a95e5ae	do_settimeofday64	vmlinux	EXPORT_SYMBOL	
++0x1303e583	devm_request_resource	vmlinux	EXPORT_SYMBOL	
++0x77c93bd3	__qdisc_calculate_pkt_len	vmlinux	EXPORT_SYMBOL	
++0x744c22ae	dev_get_by_index	vmlinux	EXPORT_SYMBOL	
++0x080da8a1	hid_compare_device_paths	vmlinux	EXPORT_SYMBOL_GPL	
++0xd8b1bde5	dma_buf_unmap_attachment	vmlinux	EXPORT_SYMBOL_GPL	
++0x5bd2bc42	serial8250_rpm_get_tx	vmlinux	EXPORT_SYMBOL_GPL	
++0xab97931c	xa_delete_node	vmlinux	EXPORT_SYMBOL_GPL	
++0x3539f11b	match_strlcpy	vmlinux	EXPORT_SYMBOL	
++0xc9827693	__bpf_call_base	vmlinux	EXPORT_SYMBOL_GPL	
++0x09dac374	inet6_hash	vmlinux	EXPORT_SYMBOL_GPL	
++0x7a8e2978	init_net	vmlinux	EXPORT_SYMBOL	
++0x05224f28	cpufreq_freq_attr_scaling_boost_freqs	vmlinux	EXPORT_SYMBOL_GPL	
++0xd74cbf27	usb_of_get_companion_dev	vmlinux	EXPORT_SYMBOL_GPL	
++0x29caa706	__phy_modify_mmd_changed	vmlinux	EXPORT_SYMBOL_GPL	
++0xa727512e	class_create_file_ns	vmlinux	EXPORT_SYMBOL_GPL	
++0x77a41eef	regulator_force_disable	vmlinux	EXPORT_SYMBOL_GPL	
++0x53667c85	pci_stop_and_remove_bus_device_locked	vmlinux	EXPORT_SYMBOL_GPL	
++0x4a33b97e	textsearch_find_continuous	vmlinux	EXPORT_SYMBOL	
++0xf11c5f38	__crypto_alloc_tfm	vmlinux	EXPORT_SYMBOL_GPL	
++0x4c3300f3	key_unlink	vmlinux	EXPORT_SYMBOL	
++0xbd2dee47	keyring_search	vmlinux	EXPORT_SYMBOL	
++0x0294c6a2	nfs_callback_nr_threads	vmlinux	EXPORT_SYMBOL_GPL	
++0xaf83a91b	configfs_unregister_subsystem	vmlinux	EXPORT_SYMBOL	
++0x41ed3cec	eventfd_ctx_remove_wait_queue	vmlinux	EXPORT_SYMBOL_GPL	
++0xde9fb23b	generic_delete_inode	vmlinux	EXPORT_SYMBOL	
++0xa9ac2e38	vm_insert_pages	vmlinux	EXPORT_SYMBOL	
++0xab9bd884	perf_register_guest_info_callbacks	vmlinux	EXPORT_SYMBOL_GPL	
++0xc80ab559	swake_up_one	vmlinux	EXPORT_SYMBOL	
++0xd941b7c3	dma_fence_remove_callback	vmlinux	EXPORT_SYMBOL	
++0xff28b362	gpiod_direction_output_raw	vmlinux	EXPORT_SYMBOL_GPL	
++0x7274beaf	pinctrl_pm_select_idle_state	vmlinux	EXPORT_SYMBOL_GPL	
++0xee91879b	rb_first_postorder	vmlinux	EXPORT_SYMBOL	
++0x9d059dd3	dev_change_proto_down	vmlinux	EXPORT_SYMBOL	
++0x0db2fb05	sock_gettstamp	vmlinux	EXPORT_SYMBOL	
++0x7d62abea	sock_bindtoindex	vmlinux	EXPORT_SYMBOL	
++0x7530a073	mmc_wait_for_req	vmlinux	EXPORT_SYMBOL	
++0xcbde2e66	regulator_set_voltage	vmlinux	EXPORT_SYMBOL_GPL	
++0x573c5c21	lockref_put_or_lock	vmlinux	EXPORT_SYMBOL	
++0xc826f11f	lockref_get_or_lock	vmlinux	EXPORT_SYMBOL	
++0x3f261a63	tasklet_unlock_wait	vmlinux	EXPORT_SYMBOL_GPL	
++0xcc7d3803	sdhci_reset	vmlinux	EXPORT_SYMBOL_GPL	
++0xc19b304b	i2c_smbus_write_i2c_block_data	vmlinux	EXPORT_SYMBOL	
++0xc43a9d37	vchan_tx_desc_free	vmlinux	EXPORT_SYMBOL_GPL	
++0x2560d30d	of_clk_del_provider	vmlinux	EXPORT_SYMBOL_GPL	
++0x62905b99	of_clk_add_provider	vmlinux	EXPORT_SYMBOL_GPL	
++0xf2c43f3f	zlib_deflate	vmlinux	EXPORT_SYMBOL	
++0x11e08f96	trace_seq_putmem_hex	vmlinux	EXPORT_SYMBOL_GPL	
++0xca431c05	wake_bit_function	vmlinux	EXPORT_SYMBOL	
++0xde1b147b	inet_csk_route_req	vmlinux	EXPORT_SYMBOL_GPL	
++0xba2d6c0d	qdisc_get_rtab	vmlinux	EXPORT_SYMBOL	
++0xb43154fa	dev_change_proto_down_generic	vmlinux	EXPORT_SYMBOL	
++0x352edea1	skb_orphan_partial	vmlinux	EXPORT_SYMBOL	
++0xff7bbe94	hid_set_field	vmlinux	EXPORT_SYMBOL_GPL	
++0x18f150cf	sdhci_set_data_timeout_irq	vmlinux	EXPORT_SYMBOL_GPL	
++0xf9e87fdb	soc_device_match	vmlinux	EXPORT_SYMBOL_GPL	
++0x54385ba1	bus_remove_file	vmlinux	EXPORT_SYMBOL_GPL	
++0xe875bbbd	mipi_dsi_dcs_set_column_address	vmlinux	EXPORT_SYMBOL	
++0xd45c70d9	locks_lock_inode_wait	vmlinux	EXPORT_SYMBOL	
++0x4be4ae00	locks_release_private	vmlinux	EXPORT_SYMBOL_GPL	
++0x521422cf	__fscrypt_encrypt_symlink	vmlinux	EXPORT_SYMBOL_GPL	
++0xbd7fa085	mempool_resize	vmlinux	EXPORT_SYMBOL	
++0xae2d4d20	__ftrace_vprintk	vmlinux	EXPORT_SYMBOL_GPL	
++0xd295a2b9	xfrm_unregister_km	vmlinux	EXPORT_SYMBOL	
++0x6f4eaf27	in_dev_finish_destroy	vmlinux	EXPORT_SYMBOL	
++0xdb4a4dc0	of_find_node_by_phandle	vmlinux	EXPORT_SYMBOL	
++0x1afaa35f	hid_destroy_device	vmlinux	EXPORT_SYMBOL_GPL	
++0x0fb6b606	nvme_wait_freeze	vmlinux	EXPORT_SYMBOL_GPL	
++0xbd45fecc	device_get_next_child_node	vmlinux	EXPORT_SYMBOL_GPL	
++0x87b8798d	sg_next	vmlinux	EXPORT_SYMBOL	
++0x0b07abe2	unshare_fs_struct	vmlinux	EXPORT_SYMBOL_GPL	
++0x1ca4a930	smp_call_function_any	vmlinux	EXPORT_SYMBOL_GPL	
++0xb46b76bc	freq_qos_add_request	vmlinux	EXPORT_SYMBOL_GPL	
++0x2c790d4a	__tracepoint_sched_util_est_cfs_tp	vmlinux	EXPORT_SYMBOL_GPL	
++0x3dceb04a	unix_inq_len	vmlinux	EXPORT_SYMBOL_GPL	
++0x136209db	power_supply_reg_notifier	vmlinux	EXPORT_SYMBOL_GPL	
++0xf4af8ee0	usbnet_suspend	vmlinux	EXPORT_SYMBOL_GPL	
++0x04082b55	mdiobus_scan	vmlinux	EXPORT_SYMBOL	
++0x8effb505	phy_gbit_features	vmlinux	EXPORT_SYMBOL_GPL	
++0xa2416c10	tty_port_carrier_raised	vmlinux	EXPORT_SYMBOL	
++0x1e987337	regulator_set_voltage_time_sel	vmlinux	EXPORT_SYMBOL_GPL	
++0x5acc78f3	crypto_enqueue_request_head	vmlinux	EXPORT_SYMBOL_GPL	
++0x5415ec69	nfs_pageio_init_write	vmlinux	EXPORT_SYMBOL_GPL	
++0xa46232d7	__brelse	vmlinux	EXPORT_SYMBOL	
++0xbe6ce6b7	pipe_lock	vmlinux	EXPORT_SYMBOL	
++0x9328460c	trace_array_init_printk	vmlinux	EXPORT_SYMBOL_GPL	
++0x7de53067	rpc_init_rtt	vmlinux	EXPORT_SYMBOL_GPL	
++0x060b8144	scsi_device_set_state	vmlinux	EXPORT_SYMBOL	
++0x79539ef0	of_genpd_parse_idle_states	vmlinux	EXPORT_SYMBOL_GPL	
++0x73c7bc7e	gpiod_get_direction	vmlinux	EXPORT_SYMBOL_GPL	
++0x020dbf27	bitmap_alloc	vmlinux	EXPORT_SYMBOL	
++0x941f2aaa	eventfd_ctx_put	vmlinux	EXPORT_SYMBOL_GPL	
++0xa0d84f2f	mark_buffer_async_write	vmlinux	EXPORT_SYMBOL	
++0xf02aa937	wait_for_completion_interruptible_timeout	vmlinux	EXPORT_SYMBOL	
++0xfbc4f89e	io_schedule_timeout	vmlinux	EXPORT_SYMBOL	
++0x28e23139	xfrm_probe_algs	vmlinux	EXPORT_SYMBOL_GPL	
++0x579ab225	ip_route_me_harder	vmlinux	EXPORT_SYMBOL	
++0xa4bb29e5	inet_sock_destruct	vmlinux	EXPORT_SYMBOL	
++0xdb4054cb	skb_udp_tunnel_segment	vmlinux	EXPORT_SYMBOL	
++0x92b72b0f	nf_reinject	vmlinux	EXPORT_SYMBOL	
++0x68474f4e	mmc_add_host	vmlinux	EXPORT_SYMBOL	
++0x550f3e05	i2c_freq_mode_string	vmlinux	EXPORT_SYMBOL_GPL	
++0x84a005f1	iscsi_get_router_state_name	vmlinux	EXPORT_SYMBOL_GPL	
++0x0727a89c	dev_pm_qos_update_request	vmlinux	EXPORT_SYMBOL_GPL	
++0x0bf72ef1	tty_chars_in_buffer	vmlinux	EXPORT_SYMBOL	
++0x815588a6	clk_enable	vmlinux	EXPORT_SYMBOL_GPL	
++0x5c4265f6	blk_unregister_region	vmlinux	EXPORT_SYMBOL	
++0x5dc95469	elv_rqhash_del	vmlinux	EXPORT_SYMBOL_GPL	
++0x1495099a	unregister_nls	vmlinux	EXPORT_SYMBOL	
++0x819711b9	bpf_prog_get_type_dev	vmlinux	EXPORT_SYMBOL_GPL	
++0x885528a6	ring_buffer_discard_commit	vmlinux	EXPORT_SYMBOL_GPL	
++0xa8686bee	thermal_zone_of_get_sensor_id	vmlinux	EXPORT_SYMBOL_GPL	
++0xadd49272	thermal_zone_get_slope	vmlinux	EXPORT_SYMBOL_GPL	
++0x7a41b9f2	usb_ep_set_maxpacket_limit	vmlinux	EXPORT_SYMBOL_GPL	
++0xc17515d7	usb_hcds_loaded	vmlinux	EXPORT_SYMBOL_GPL	
++0x1b0c5999	usbnet_write_cmd_nopm	vmlinux	EXPORT_SYMBOL_GPL	
++0x12fd8bfe	regmap_write_async	vmlinux	EXPORT_SYMBOL_GPL	
++0xc52ce9c6	phy_exit	vmlinux	EXPORT_SYMBOL_GPL	
++0xb812273d	verify_signature	vmlinux	EXPORT_SYMBOL_GPL	
++0x99697af0	skcipher_register_instance	vmlinux	EXPORT_SYMBOL_GPL	
++0x157f9b02	__fscache_check_consistency	vmlinux	EXPORT_SYMBOL	
++0x4b7ded4d	fscrypt_setup_filename	vmlinux	EXPORT_SYMBOL	
++0x92fef60c	tcf_qevent_init	vmlinux	EXPORT_SYMBOL	
++0x4497b3ae	skb_pull_rcsum	vmlinux	EXPORT_SYMBOL_GPL	
++0xfacb4d85	bcm_phy_read_shadow	vmlinux	EXPORT_SYMBOL_GPL	
++0xd218d443	__scsi_device_lookup_by_target	vmlinux	EXPORT_SYMBOL	
++0x1fa1d95c	sha256_zero_message_hash	vmlinux	EXPORT_SYMBOL_GPL	
++0x8fa2e2ce	nfs_instantiate	vmlinux	EXPORT_SYMBOL_GPL	
++0x1431f58c	fscrypt_has_permitted_context	vmlinux	EXPORT_SYMBOL	
++0x3a74e484	__tracepoint_sched_util_est_se_tp	vmlinux	EXPORT_SYMBOL_GPL	
++0xdeb52606	current_work	vmlinux	EXPORT_SYMBOL	
++0xfc03d97a	page_is_ram	vmlinux	EXPORT_SYMBOL_GPL	
++0x142affdf	netpoll_send_skb	vmlinux	EXPORT_SYMBOL	
++0xe99e5772	devm_i2c_new_dummy_device	vmlinux	EXPORT_SYMBOL_GPL	
++0x63297954	usb_amd_pt_check_port	vmlinux	EXPORT_SYMBOL_GPL	
++0x79532f88	usbnet_set_msglevel	vmlinux	EXPORT_SYMBOL_GPL	
++0xaac82c60	usbnet_get_msglevel	vmlinux	EXPORT_SYMBOL_GPL	
++0x79c7b809	nvme_init_ctrl	vmlinux	EXPORT_SYMBOL_GPL	
++0x2c31dff0	tty_buffer_lock_exclusive	vmlinux	EXPORT_SYMBOL_GPL	
++0xc616c8b0	radix_tree_gang_lookup	vmlinux	EXPORT_SYMBOL	
++0x8135ff6a	crypto_alloc_acomp_node	vmlinux	EXPORT_SYMBOL_GPL	
++0x1bde7171	sysfs_file_change_owner	vmlinux	EXPORT_SYMBOL_GPL	
++0xd01754da	locks_alloc_lock	vmlinux	EXPORT_SYMBOL_GPL	
++0xb121390a	probe_irq_on	vmlinux	EXPORT_SYMBOL	
++0xeff203cc	cache_create_net	vmlinux	EXPORT_SYMBOL_GPL	
++0xfcbe94e3	svc_generic_init_request	vmlinux	EXPORT_SYMBOL_GPL	
++0x1beb9c04	svc_prepare_thread	vmlinux	EXPORT_SYMBOL_GPL	
++0xc8db46bd	xfrm_state_lookup	vmlinux	EXPORT_SYMBOL	
++0xe720ea6f	tcp_parse_options	vmlinux	EXPORT_SYMBOL	
++0x78fbadd5	sk_filter_trim_cap	vmlinux	EXPORT_SYMBOL	
++0x09af585d	rps_may_expire_flow	vmlinux	EXPORT_SYMBOL	
++0xb7892357	i2c_smbus_write_block_data	vmlinux	EXPORT_SYMBOL	
++0x0ed1887b	usb_stor_suspend	vmlinux	EXPORT_SYMBOL_GPL	USB_STORAGE
++0x8ef9d4a8	key_move	vmlinux	EXPORT_SYMBOL	
++0x4de9ec61	fscache_mark_pages_cached	vmlinux	EXPORT_SYMBOL	
++0x5cac049e	rpc_unlink	vmlinux	EXPORT_SYMBOL_GPL	
++0xb4e6da83	pskb_trim_rcsum_slow	vmlinux	EXPORT_SYMBOL	
++0xcf9b558d	touchscreen_set_mt_pos	vmlinux	EXPORT_SYMBOL	
++0xf90fea09	locks_in_grace	vmlinux	EXPORT_SYMBOL_GPL	
++0x6ce7df5f	module_refcount	vmlinux	EXPORT_SYMBOL	
++0x9468ea70	schedule_hrtimeout_range_clock	vmlinux	EXPORT_SYMBOL_GPL	
++0xf77555cd	__memcpy_toio	vmlinux	EXPORT_SYMBOL	
++0x4e8c4822	sunrpc_destroy_cache_detail	vmlinux	EXPORT_SYMBOL_GPL	
++0x0be84338	inet_ctl_sock_create	vmlinux	EXPORT_SYMBOL_GPL	
++0x8a52e41f	power_supply_find_ocv2cap_table	vmlinux	EXPORT_SYMBOL_GPL	
++0xfb3e9c6b	usbnet_link_change	vmlinux	EXPORT_SYMBOL	
++0x57d6b76a	fwnode_get_nth_parent	vmlinux	EXPORT_SYMBOL_GPL	
++0x0886b26d	firmware_kobj	vmlinux	EXPORT_SYMBOL_GPL	
++0xde201b0e	__tty_insert_flip_char	vmlinux	EXPORT_SYMBOL	
++0x19b2afdc	pci_store_saved_state	vmlinux	EXPORT_SYMBOL_GPL	
++0x86b4e772	unpin_user_page_range_dirty_lock	vmlinux	EXPORT_SYMBOL	
++0x7af6b26d	handle_edge_irq	vmlinux	EXPORT_SYMBOL	
++0xfe8ab06d	l3mdev_update_flow	vmlinux	EXPORT_SYMBOL_GPL	
++0xa7c6076c	xfrm_msg_min	vmlinux	EXPORT_SYMBOL_GPL	
++0xf91e7daa	devm_extcon_dev_free	vmlinux	EXPORT_SYMBOL_GPL	
++0xa26936b4	usb_autopm_put_interface_async	vmlinux	EXPORT_SYMBOL_GPL	
++0xa7da3ea4	usb_lock_device_for_reset	vmlinux	EXPORT_SYMBOL_GPL	
++0xf1eee591	phy_ethtool_nway_reset	vmlinux	EXPORT_SYMBOL	
++0x7ad1ded1	pinctrl_register_mappings	vmlinux	EXPORT_SYMBOL_GPL	
++0x1bc5eebe	pinctrl_gpio_direction_input	vmlinux	EXPORT_SYMBOL_GPL	
++0x18e60984	__do_once_start	vmlinux	EXPORT_SYMBOL	
++0x616234fe	__account_locked_vm	vmlinux	EXPORT_SYMBOL_GPL	
++0x4b23aa53	___pskb_trim	vmlinux	EXPORT_SYMBOL	
++0x5269e01f	__pskb_copy_fclone	vmlinux	EXPORT_SYMBOL	
++0x74014c18	sdio_retune_crc_enable	vmlinux	EXPORT_SYMBOL_GPL	
++0x7c73aae4	tty_driver_flush_buffer	vmlinux	EXPORT_SYMBOL	
++0xdef7c893	fb_match_mode	vmlinux	EXPORT_SYMBOL	
++0x6ce8bf2c	pci_setup_cardbus	vmlinux	EXPORT_SYMBOL	
++0x85df9b6c	strsep	vmlinux	EXPORT_SYMBOL	
++0xe2d5255a	strcmp	vmlinux	EXPORT_SYMBOL	
++0x71a88b7c	__cleancache_invalidate_fs	vmlinux	EXPORT_SYMBOL	
++0xbd0b5fda	iomem_resource	vmlinux	EXPORT_SYMBOL	
++0x4533c29c	devm_kfree	vmlinux	EXPORT_SYMBOL_GPL	
++0xdd686d24	mipi_dsi_driver_unregister	vmlinux	EXPORT_SYMBOL	
++0xfd4437ed	hdmi_infoframe_log	vmlinux	EXPORT_SYMBOL	
++0xbe2c1175	gpiochip_set_nested_irqchip	vmlinux	EXPORT_SYMBOL_GPL	
++0x544f76f1	vfs_create	vmlinux	EXPORT_SYMBOL	
++0x6c456b80	tcp_sock_set_syncnt	vmlinux	EXPORT_SYMBOL	
++0x1dccb31d	mmc_cqe_post_req	vmlinux	EXPORT_SYMBOL	
++0x0f67a889	devm_device_add_group	vmlinux	EXPORT_SYMBOL_GPL	
++0x2d0484e9	clk_register_divider_table	vmlinux	EXPORT_SYMBOL_GPL	
++0xb9056bb6	remove_conflicting_framebuffers	vmlinux	EXPORT_SYMBOL	
++0x034878d0	nla_reserve_64bit	vmlinux	EXPORT_SYMBOL	
++0x21042d86	sb_min_blocksize	vmlinux	EXPORT_SYMBOL	
++0x6695808f	vmalloc_hugepage_user	vmlinux	EXPORT_SYMBOL	
++0x2ad91f6e	ir_raw_gen_pl	vmlinux	EXPORT_SYMBOL	
++0x9e12e343	ir_raw_gen_pd	vmlinux	EXPORT_SYMBOL	
++0x189e11ff	dma_fence_get_status	vmlinux	EXPORT_SYMBOL	
++0xbdafde49	regulator_get_mode	vmlinux	EXPORT_SYMBOL_GPL	
++0xab3329af	page_cache_prev_miss	vmlinux	EXPORT_SYMBOL	
++0xae3ff239	trace_hardirqs_on_caller	vmlinux	EXPORT_SYMBOL	
++0xf353a698	register_module_notifier	vmlinux	EXPORT_SYMBOL	
++0x25a0ad3e	tcp_rate_check_app_limited	vmlinux	EXPORT_SYMBOL_GPL	
++0x58fdf423	register_fib_notifier	vmlinux	EXPORT_SYMBOL	
++0xdaffd6ef	cpuidle_disable_device	vmlinux	EXPORT_SYMBOL_GPL	
++0xc7208c3a	serial8250_resume_port	vmlinux	EXPORT_SYMBOL	
++0x2cb85e6c	remap_vmalloc_hugepage_range_partial	vmlinux	EXPORT_SYMBOL	
++0x85a2c517	vm_map_pages_zero	vmlinux	EXPORT_SYMBOL	
++0x8e6df3d2	inet_csk_clone_lock	vmlinux	EXPORT_SYMBOL_GPL	
++0xabb8dbd8	hid_input_report	vmlinux	EXPORT_SYMBOL_GPL	
++0x04db7a39	dev_pm_opp_register_notifier	vmlinux	EXPORT_SYMBOL	
++0xdcf2a52b	pcix_set_mmrbc	vmlinux	EXPORT_SYMBOL	
++0x46916736	gpiod_export_link	vmlinux	EXPORT_SYMBOL_GPL	
++0x586dd9c7	gpiochip_generic_config	vmlinux	EXPORT_SYMBOL_GPL	
++0x1ea50485	unregister_sysctl_table	vmlinux	EXPORT_SYMBOL	
++0x7988b735	lwtunnel_xmit	vmlinux	EXPORT_SYMBOL_GPL	
++0x99ec25e3	of_find_property	vmlinux	EXPORT_SYMBOL	
++0x1fe397e8	usb_gadget_map_request_by_dev	vmlinux	EXPORT_SYMBOL_GPL	
++0x3a2eef2f	__DWC_ALLOC_ATOMIC	vmlinux	EXPORT_SYMBOL	
++0xdbf91a76	devm_clk_release_clkdev	vmlinux	EXPORT_SYMBOL	
++0x7d39bd06	klist_prev	vmlinux	EXPORT_SYMBOL_GPL	
++0xb8b215a3	sbitmap_add_wait_queue	vmlinux	EXPORT_SYMBOL_GPL	
++0x3b321462	LZ4_setStreamDecode	vmlinux	EXPORT_SYMBOL	
++0xea3c1517	del_gendisk	vmlinux	EXPORT_SYMBOL	
++0xe2d4b3ab	block_write_full_page	vmlinux	EXPORT_SYMBOL	
++0x885a31e7	xfrm_register_type	vmlinux	EXPORT_SYMBOL	
++0x437a0d6d	__sock_tx_timestamp	vmlinux	EXPORT_SYMBOL	
++0x9305f8e6	cpufreq_get	vmlinux	EXPORT_SYMBOL	
++0x0e2ff2ed	DWC_MDELAY	vmlinux	EXPORT_SYMBOL	
++0x0625ad66	DWC_UDELAY	vmlinux	EXPORT_SYMBOL	
++0x96925c80	usbnet_stop	vmlinux	EXPORT_SYMBOL_GPL	
++0x882f5336	pci_set_vpd_size	vmlinux	EXPORT_SYMBOL	
++0x849e332a	devm_gpiod_get_index	vmlinux	EXPORT_SYMBOL_GPL	
++0xff614a08	lockd_up	vmlinux	EXPORT_SYMBOL_GPL	
++0xc669ac27	__traceiter_ff_layout_commit_error	vmlinux	EXPORT_SYMBOL_GPL	
++0xa9e582d3	fat_sync_inode	vmlinux	EXPORT_SYMBOL_GPL	
++0xc4887537	clear_bdi_congested	vmlinux	EXPORT_SYMBOL	
++0xdb204e5a	walk_iomem_res_desc	vmlinux	EXPORT_SYMBOL_GPL	
++0x9688de8b	memstart_addr	vmlinux	EXPORT_SYMBOL	
++0xd52d713a	fscrypt_decrypt_pagecache_blocks	vmlinux	EXPORT_SYMBOL	
++0x70ebd380	fscrypt_encrypt_pagecache_blocks	vmlinux	EXPORT_SYMBOL	
++0x82768fdc	__blockdev_direct_IO	vmlinux	EXPORT_SYMBOL	
++0x824a57ef	migrate_page	vmlinux	EXPORT_SYMBOL	
++0x68952493	rcu_note_context_switch	vmlinux	EXPORT_SYMBOL_GPL	
++0xe5a8d3b1	unix_destruct_scm	vmlinux	EXPORT_SYMBOL	
++0x6aa27a9b	thermal_zone_device_update	vmlinux	EXPORT_SYMBOL_GPL	
++0x5133982a	rc_map_get	vmlinux	EXPORT_SYMBOL_GPL	
++0xbc149d65	dev_fwnode	vmlinux	EXPORT_SYMBOL_GPL	
++0xf2e442c9	regulator_map_voltage_iterate	vmlinux	EXPORT_SYMBOL_GPL	
++0xabc640f3	list_lru_isolate	vmlinux	EXPORT_SYMBOL_GPL	
++0xbd7b7f05	bpf_prog_alloc	vmlinux	EXPORT_SYMBOL_GPL	
++0x594b577c	km_new_mapping	vmlinux	EXPORT_SYMBOL	
++0xcbd96cc3	phy_attach_direct	vmlinux	EXPORT_SYMBOL	
++0xfbeeb13c	phy_gbit_all_ports_features	vmlinux	EXPORT_SYMBOL_GPL	
++0xbb9e9819	iscsi_get_port_state_name	vmlinux	EXPORT_SYMBOL_GPL	
++0x9dd5658f	iscsi_get_port_speed_name	vmlinux	EXPORT_SYMBOL_GPL	
++0x998f9558	of_clk_get_parent_name	vmlinux	EXPORT_SYMBOL_GPL	
++0x47229b5c	gpio_request	vmlinux	EXPORT_SYMBOL_GPL	
++0x3283e6b0	prandom_seed_full_state	vmlinux	EXPORT_SYMBOL	
++0xf84f1576	blk_queue_write_cache	vmlinux	EXPORT_SYMBOL_GPL	
++0xe9ac2b06	generic_block_bmap	vmlinux	EXPORT_SYMBOL	
++0x868784cb	__symbol_get	vmlinux	EXPORT_SYMBOL_GPL	
++0x6ef6b54f	ktime_get_boot_fast_ns	vmlinux	EXPORT_SYMBOL_GPL	
++0x4507f4a8	cpuhp_tasks_frozen	vmlinux	EXPORT_SYMBOL_GPL	
++0x14982c38	__ip_dev_find	vmlinux	EXPORT_SYMBOL	
++0x56906d37	__DWC_ALLOC	vmlinux	EXPORT_SYMBOL	
++0xa51df23b	__bcm_phy_write_rdb	vmlinux	EXPORT_SYMBOL_GPL	
++0xba685928	spi_delay_to_ns	vmlinux	EXPORT_SYMBOL_GPL	
++0xef69f4f9	sbitmap_any_bit_set	vmlinux	EXPORT_SYMBOL_GPL	
++0x652ce9aa	nla_memcmp	vmlinux	EXPORT_SYMBOL	
++0xf1db1704	nla_memcpy	vmlinux	EXPORT_SYMBOL	
++0x8a837c0b	nfs_put_client	vmlinux	EXPORT_SYMBOL_GPL	
++0x29a75228	kmem_cache_free	vmlinux	EXPORT_SYMBOL	
++0x163a7006	netdev_set_sb_channel	vmlinux	EXPORT_SYMBOL	
++0xab7def78	DWC_WRITE_REG32	vmlinux	EXPORT_SYMBOL	
++0xe1457893	get_cpu_device	vmlinux	EXPORT_SYMBOL_GPL	
++0x923b1276	dmaengine_get	vmlinux	EXPORT_SYMBOL	
++0x1a35151f	amba_device_register	vmlinux	EXPORT_SYMBOL	
++0xa555911f	pci_restore_msi_state	vmlinux	EXPORT_SYMBOL_GPL	
++0xc6835435	pcie_capability_clear_and_set_dword	vmlinux	EXPORT_SYMBOL	
++0xc21f07df	pnfs_add_commit_array	vmlinux	EXPORT_SYMBOL_GPL	
++0x72128656	vfs_fadvise	vmlinux	EXPORT_SYMBOL	
++0x38d44882	prepare_to_wait	vmlinux	EXPORT_SYMBOL	
++0xe13c8a56	__request_region	vmlinux	EXPORT_SYMBOL	
++0x97f55c8b	of_irq_get_byname	vmlinux	EXPORT_SYMBOL_GPL	
++0xa9439cf4	DWC_WAITQ_WAIT	vmlinux	EXPORT_SYMBOL	
++0xf81046f6	fixed_phy_set_link_update	vmlinux	EXPORT_SYMBOL_GPL	
++0xeaf50ece	xa_destroy	vmlinux	EXPORT_SYMBOL	
++0x4048e68b	bdev_read_only	vmlinux	EXPORT_SYMBOL	
++0xf0009fee	put_pages_list	vmlinux	EXPORT_SYMBOL	
++0x55051546	from_kprojid	vmlinux	EXPORT_SYMBOL	
++0x4af1da14	skb_copy_datagram_iter	vmlinux	EXPORT_SYMBOL	
++0x40362936	sock_wfree	vmlinux	EXPORT_SYMBOL	
++0x75a7d2cf	dev_pm_opp_get_sharing_cpus	vmlinux	EXPORT_SYMBOL_GPL	
++0xd859d796	i2c_new_ancillary_device	vmlinux	EXPORT_SYMBOL_GPL	
++0x803ddbb6	__posix_acl_create	vmlinux	EXPORT_SYMBOL	
++0x091eb9b4	round_jiffies	vmlinux	EXPORT_SYMBOL_GPL	
++0x6d4888e6	inet_proto_csum_replace16	vmlinux	EXPORT_SYMBOL	
++0x9f4b233a	usb_gadget_wakeup	vmlinux	EXPORT_SYMBOL_GPL	
++0xea1fc356	nvme_start_admin_queue	vmlinux	EXPORT_SYMBOL_GPL	
++0x6a05b65b	fb_videomode_from_videomode	vmlinux	EXPORT_SYMBOL_GPL	
++0x04be8ccd	crypto_sha512_finup	vmlinux	EXPORT_SYMBOL	
++0xf96f04c4	__SCK__tp_func_nfs_fsync_enter	vmlinux	EXPORT_SYMBOL_GPL	
++0x36a7edd1	dquot_commit	vmlinux	EXPORT_SYMBOL	
++0x06176101	__block_write_full_page	vmlinux	EXPORT_SYMBOL	
++0xdae64577	truncate_inode_pages	vmlinux	EXPORT_SYMBOL	
++0x6c639dce	fib_nh_common_release	vmlinux	EXPORT_SYMBOL_GPL	
++0x050ba2ad	nf_queue_entry_free	vmlinux	EXPORT_SYMBOL_GPL	
++0x9485fc2f	input_flush_device	vmlinux	EXPORT_SYMBOL	
++0xafb9ef65	iscsi_conn_login_event	vmlinux	EXPORT_SYMBOL_GPL	
++0x5aa79cb2	regmap_bulk_write	vmlinux	EXPORT_SYMBOL_GPL	
++0x138bdd96	cpumask_next	vmlinux	EXPORT_SYMBOL	
++0xd7293ffc	percpu_ref_reinit	vmlinux	EXPORT_SYMBOL_GPL	
++0x97053622	sysfs_notify	vmlinux	EXPORT_SYMBOL_GPL	
++0x15ade1cc	filter_irq_stacks	vmlinux	EXPORT_SYMBOL_GPL	
++0xbc660501	inet_hash	vmlinux	EXPORT_SYMBOL_GPL	
++0x8859bd4a	mm_account_pinned_pages	vmlinux	EXPORT_SYMBOL_GPL	
++0x56fbb130	no_hash_pointers	vmlinux	EXPORT_SYMBOL_GPL	
++0x9a1dfd65	strpbrk	vmlinux	EXPORT_SYMBOL	
++0x2129d3dc	pkcs7_free_message	vmlinux	EXPORT_SYMBOL_GPL	
++0x5497eaae	seq_lseek	vmlinux	EXPORT_SYMBOL	
++0xf70e4a4d	preempt_schedule_notrace	vmlinux	EXPORT_SYMBOL_GPL	
++0x087ee847	inet_csk_reqsk_queue_add	vmlinux	EXPORT_SYMBOL	
++0xcd0ef4ef	sdhci_add_host	vmlinux	EXPORT_SYMBOL_GPL	
++0xd245c8bb	dma_resv_reserve_shared	vmlinux	EXPORT_SYMBOL	
++0x85a49dc7	pci_vpd_find_info_keyword	vmlinux	EXPORT_SYMBOL_GPL	
++0x63a7c28c	bitmap_find_free_region	vmlinux	EXPORT_SYMBOL	
++0x736388f6	blk_mq_queue_inflight	vmlinux	EXPORT_SYMBOL_GPL	
++0xaa36d2b6	kernfs_find_and_get_ns	vmlinux	EXPORT_SYMBOL_GPL	
++0x56b36146	vlan_vid_add	vmlinux	EXPORT_SYMBOL	
++0x71fa908a	cache_flush	vmlinux	EXPORT_SYMBOL_GPL	
++0xaa6736b9	bc_svc_process	vmlinux	EXPORT_SYMBOL_GPL	
++0x9c5849c9	ipv6_proxy_select_ident	vmlinux	EXPORT_SYMBOL_GPL	
++0x1cbdc598	xfrm_parse_spi	vmlinux	EXPORT_SYMBOL	
++0x17cc1aca	udp_gro_receive	vmlinux	EXPORT_SYMBOL	
++0x1dd04e01	napi_schedule_prep	vmlinux	EXPORT_SYMBOL	
++0x241b709f	vchiq_open_service	vmlinux	EXPORT_SYMBOL	
++0x2d5d3c19	of_graph_parse_endpoint	vmlinux	EXPORT_SYMBOL	
++0x2d516fb8	of_property_read_variable_u8_array	vmlinux	EXPORT_SYMBOL_GPL	
++0x86cb5a40	leds_list_lock	vmlinux	EXPORT_SYMBOL_GPL	
++0x2f4d8f62	regulator_set_mode	vmlinux	EXPORT_SYMBOL_GPL	
++0x787c882b	lzo1x_1_compress	vmlinux	EXPORT_SYMBOL_GPL	
++0xe5f0b714	set_disk_ro	vmlinux	EXPORT_SYMBOL	
++0x88ab6fe3	kgdb_active	vmlinux	EXPORT_SYMBOL_GPL	
++0x368c7665	svc_alien_sock	vmlinux	EXPORT_SYMBOL_GPL	
++0x5a6cdb52	nf_ct_zone_dflt	vmlinux	EXPORT_SYMBOL_GPL	
++0x0849a4fb	bus_find_device	vmlinux	EXPORT_SYMBOL_GPL	
++0x081b9345	sg_alloc_table_from_pages	vmlinux	EXPORT_SYMBOL	
++0xe8b910ff	blk_rq_unprep_clone	vmlinux	EXPORT_SYMBOL_GPL	
++0xe512fbaf	bpf_offload_dev_netdev_unregister	vmlinux	EXPORT_SYMBOL_GPL	
++0x1f85cd56	trace_raw_output_prep	vmlinux	EXPORT_SYMBOL	
++0xa55ebce6	relay_switch_subbuf	vmlinux	EXPORT_SYMBOL_GPL	
++0xcc8ea35e	rpc_create	vmlinux	EXPORT_SYMBOL_GPL	
++0x5c699441	xfrm_aalg_get_byid	vmlinux	EXPORT_SYMBOL_GPL	
++0xdd8ad9e0	tcp_create_openreq_child	vmlinux	EXPORT_SYMBOL	
++0x8534af20	sk_common_release	vmlinux	EXPORT_SYMBOL	
++0xe833c2aa	led_trigger_register	vmlinux	EXPORT_SYMBOL_GPL	
++0xc942058f	nvme_set_queue_count	vmlinux	EXPORT_SYMBOL_GPL	
++0xe03d6fc8	sched_autogroup_create_attach	vmlinux	EXPORT_SYMBOL	
++0x1a36aa52	lwtunnel_valid_encap_type_attr	vmlinux	EXPORT_SYMBOL_GPL	
++0x3b7a2272	skb_prepare_seq_read	vmlinux	EXPORT_SYMBOL	
++0xaf92677c	skb_queue_head	vmlinux	EXPORT_SYMBOL	
++0x79d9be8a	sk_reset_timer	vmlinux	EXPORT_SYMBOL	
++0xd8942ddf	usb_phy_gen_create_phy	vmlinux	EXPORT_SYMBOL_GPL	
++0xee2a787b	regulator_bulk_enable	vmlinux	EXPORT_SYMBOL_GPL	
++0xbc59b308	devm_irq_setup_generic_chip	vmlinux	EXPORT_SYMBOL_GPL	
++0x1da62ca7	irq_get_irq_data	vmlinux	EXPORT_SYMBOL_GPL	
++0x8fcf6cde	atomic_notifier_call_chain_robust	vmlinux	EXPORT_SYMBOL_GPL	
++0x52c42742	inet_frag_pull_head	vmlinux	EXPORT_SYMBOL	
++0x3b870e7b	tcp_seq_next	vmlinux	EXPORT_SYMBOL	
++0xbae29566	netdev_has_upper_dev	vmlinux	EXPORT_SYMBOL	
++0x09a34a2b	crc_itu_t	vmlinux	EXPORT_SYMBOL	
++0x1aafb92a	iov_iter_npages	vmlinux	EXPORT_SYMBOL	
++0x999fdc46	bio_alloc_bioset	vmlinux	EXPORT_SYMBOL	
++0x1b700d37	put_vaddr_frames	vmlinux	EXPORT_SYMBOL	
++0x9bfdb07c	irq_domain_translate_onecell	vmlinux	EXPORT_SYMBOL_GPL	
++0x39b900d9	of_irq_parse_one	vmlinux	EXPORT_SYMBOL_GPL	
++0xf9ff5fd0	usb_driver_set_configuration	vmlinux	EXPORT_SYMBOL_GPL	
++0x6112cd4a	mii_ethtool_sset	vmlinux	EXPORT_SYMBOL	
++0xc25c4719	mii_ethtool_gset	vmlinux	EXPORT_SYMBOL	
++0x2c5726bc	class_compat_create_link	vmlinux	EXPORT_SYMBOL_GPL	
++0xced0741f	mipi_dsi_set_maximum_return_packet_size	vmlinux	EXPORT_SYMBOL	
++0x35563064	serdev_device_set_baudrate	vmlinux	EXPORT_SYMBOL_GPL	
++0x1a772767	__devm_reset_control_get	vmlinux	EXPORT_SYMBOL_GPL	
++0xa08bda0b	crypto_cipher_setkey	vmlinux	EXPORT_SYMBOL_GPL	
++0x00332e69	dump_emit	vmlinux	EXPORT_SYMBOL	
++0x19715b5e	vfs_cancel_lock	vmlinux	EXPORT_SYMBOL_GPL	
++0x8a72ea7a	__kernel_write	vmlinux	EXPORT_SYMBOL_GPL	
++0xbd628752	__tracepoint_mmap_lock_start_locking	vmlinux	EXPORT_SYMBOL	
++0xad357133	__traceiter_kmalloc_node	vmlinux	EXPORT_SYMBOL	
++0x287fcdad	__static_key_deferred_flush	vmlinux	EXPORT_SYMBOL_GPL	
++0x4ce28695	kthread_cancel_work_sync	vmlinux	EXPORT_SYMBOL_GPL	
++0x0535bb27	svc_fill_write_vector	vmlinux	EXPORT_SYMBOL_GPL	
++0x006defbb	netdev_pick_tx	vmlinux	EXPORT_SYMBOL	
++0xa47e725e	release_sock	vmlinux	EXPORT_SYMBOL	
++0x05e9ed25	dev_pm_opp_disable	vmlinux	EXPORT_SYMBOL_GPL	
++0x50e7193a	__i2c_first_dynamic_bus_num	vmlinux	EXPORT_SYMBOL_GPL	
++0x14999890	DWC_MUTEX_FREE	vmlinux	EXPORT_SYMBOL	
++0x87ff1dd5	phy_validate_pause	vmlinux	EXPORT_SYMBOL	
++0xd2c89c2c	pm_clk_suspend	vmlinux	EXPORT_SYMBOL_GPL	
++0xd3a639d2	textsearch_destroy	vmlinux	EXPORT_SYMBOL	
++0xbfba0f2a	__netlink_ns_capable	vmlinux	EXPORT_SYMBOL	
++0xa7ad47ff	__sk_receive_skb	vmlinux	EXPORT_SYMBOL	
++0x622893ea	usbnet_status_stop	vmlinux	EXPORT_SYMBOL_GPL	
++0x970865b0	mdiobus_setup_mdiodev_from_board_info	vmlinux	EXPORT_SYMBOL	
++0x38e5bc5a	clk_set_rate_range	vmlinux	EXPORT_SYMBOL_GPL	
++0x2c82c36a	security_secmark_relabel_packet	vmlinux	EXPORT_SYMBOL	
++0x489984ef	sync_inode	vmlinux	EXPORT_SYMBOL	
++0xc8dcc62a	krealloc	vmlinux	EXPORT_SYMBOL	
++0xcc5c2df4	trace_print_symbols_seq	vmlinux	EXPORT_SYMBOL	
++0x4462d35e	cpufreq_get_hw_max_freq	vmlinux	EXPORT_SYMBOL	
++0x31274b9a	input_register_device	vmlinux	EXPORT_SYMBOL	
++0x31266931	con_debug_leave	vmlinux	EXPORT_SYMBOL_GPL	
++0xa21bfa00	crypto_inst_setname	vmlinux	EXPORT_SYMBOL_GPL	
++0x67ba90be	security_file_ioctl	vmlinux	EXPORT_SYMBOL_GPL	
++0x653ef86b	__invalidate_device	vmlinux	EXPORT_SYMBOL	
++0x7c16d951	seq_put_decimal_ull	vmlinux	EXPORT_SYMBOL	
++0x51390c96	rcu_barrier_tasks_rude	vmlinux	EXPORT_SYMBOL_GPL	
++0x23cb60c6	led_classdev_unregister	vmlinux	EXPORT_SYMBOL_GPL	
++0xa1b78028	spi_split_transfers_maxsize	vmlinux	EXPORT_SYMBOL_GPL	
++0xaa9968dd	devm_regmap_field_alloc	vmlinux	EXPORT_SYMBOL_GPL	
++0x1163f0a7	blk_max_low_pfn	vmlinux	EXPORT_SYMBOL	
++0xb70fc0bb	__fscache_write_page	vmlinux	EXPORT_SYMBOL	
++0xe2ca611f	register_sysctl_table	vmlinux	EXPORT_SYMBOL	
++0x67b78eb3	seq_hlist_next_rcu	vmlinux	EXPORT_SYMBOL	
++0x73abb180	alloc_contig_range	vmlinux	EXPORT_SYMBOL	
++0x7d1bb1d4	tnum_strn	vmlinux	EXPORT_SYMBOL_GPL	
++0xf3c49650	xdr_stream_decode_string	vmlinux	EXPORT_SYMBOL_GPL	
++0xaf25ffad	rpc_clnt_xprt_switch_has_addr	vmlinux	EXPORT_SYMBOL_GPL	
++0xbc0e94ae	mr_mfc_find_any	vmlinux	EXPORT_SYMBOL	
++0x5f49dfd8	ipv4_redirect	vmlinux	EXPORT_SYMBOL_GPL	
++0x0664aa32	flow_block_cb_priv	vmlinux	EXPORT_SYMBOL	
++0xb2a84f66	flow_block_cb_free	vmlinux	EXPORT_SYMBOL	
++0x6c303b45	netdev_adjacent_change_prepare	vmlinux	EXPORT_SYMBOL	
++0x9942bb0a	__netif_set_xps_queue	vmlinux	EXPORT_SYMBOL_GPL	
++0x2c9726b2	nvme_cancel_admin_tagset	vmlinux	EXPORT_SYMBOL_GPL	
++0xd3f0ce4f	__traceiter_dma_fence_emit	vmlinux	EXPORT_SYMBOL	
++0x2ada772d	tty_flip_buffer_push	vmlinux	EXPORT_SYMBOL	
++0x1a736627	nfs_sops	vmlinux	EXPORT_SYMBOL_GPL	
++0xbf59c419	posix_acl_init	vmlinux	EXPORT_SYMBOL	
++0x3102d70b	frontswap_curr_pages	vmlinux	EXPORT_SYMBOL	
++0xe613a798	inet_addr_is_any	vmlinux	EXPORT_SYMBOL	
++0x018e73aa	hidinput_calc_abs_res	vmlinux	EXPORT_SYMBOL_GPL	
++0x6289a9c5	dev_pm_opp_get_freq	vmlinux	EXPORT_SYMBOL_GPL	
++0xc2891702	uart_get_divisor	vmlinux	EXPORT_SYMBOL	
++0xa89aa963	pinctrl_utils_add_map_mux	vmlinux	EXPORT_SYMBOL_GPL	
++0xaaa4b9bc	hchacha_block_generic	vmlinux	EXPORT_SYMBOL	
++0x676a5a64	io_cgrp_subsys	vmlinux	EXPORT_SYMBOL_GPL	
++0x2c319188	bio_copy_data	vmlinux	EXPORT_SYMBOL	
++0x03952887	ktime_add_safe	vmlinux	EXPORT_SYMBOL_GPL	
++0xf9a482f9	msleep	vmlinux	EXPORT_SYMBOL	
++0x880eb97d	sunrpc_cache_lookup_rcu	vmlinux	EXPORT_SYMBOL_GPL	
++0xafc26c12	validate_xmit_xfrm	vmlinux	EXPORT_SYMBOL_GPL	
++0x4f7e9687	cookie_timestamp_decode	vmlinux	EXPORT_SYMBOL	
++0xc0554a65	unregister_netdev	vmlinux	EXPORT_SYMBOL	
++0x7585344a	skb_flow_dissect_hash	vmlinux	EXPORT_SYMBOL	
++0xcdcf7d3f	__DWC_ERROR	vmlinux	EXPORT_SYMBOL	
++0xc3ffd644	__bforget	vmlinux	EXPORT_SYMBOL	
++0x4922cb53	generic_file_write_iter	vmlinux	EXPORT_SYMBOL	
++0x0bc4f757	__audit_inode_child	vmlinux	EXPORT_SYMBOL_GPL	
++0x6e5bd40a	param_set_ullong	vmlinux	EXPORT_SYMBOL	
++0x1057aeb9	xdr_reserve_space	vmlinux	EXPORT_SYMBOL_GPL	
++0x72099ee7	inet6_add_protocol	vmlinux	EXPORT_SYMBOL	
++0x40d8b381	free_fib_info	vmlinux	EXPORT_SYMBOL_GPL	
++0xbfc748d0	raw_unhash_sk	vmlinux	EXPORT_SYMBOL_GPL	
++0x6ef3f2a0	sock_no_listen	vmlinux	EXPORT_SYMBOL	
++0xace13882	rc_map_unregister	vmlinux	EXPORT_SYMBOL_GPL	
++0x92d9614d	input_mt_destroy_slots	vmlinux	EXPORT_SYMBOL	
++0x530f4ff8	usb_unpoison_anchored_urbs	vmlinux	EXPORT_SYMBOL_GPL	
++0x462e0009	of_phy_deregister_fixed_link	vmlinux	EXPORT_SYMBOL	
++0x468b2c9f	phy_support_sym_pause	vmlinux	EXPORT_SYMBOL	
++0x935bb9a9	scsi_device_lookup_by_target	vmlinux	EXPORT_SYMBOL	
++0x79aa04a2	get_random_bytes	vmlinux	EXPORT_SYMBOL	
++0xb788fb30	gic_pmr_sync	vmlinux	EXPORT_SYMBOL	
++0xadcba50b	ZSTD_findFrameCompressedSize	vmlinux	EXPORT_SYMBOL	
++0xcd9cd2ff	wakeme_after_rcu	vmlinux	EXPORT_SYMBOL_GPL	
++0xab600421	probe_irq_off	vmlinux	EXPORT_SYMBOL	
++0x04a3945e	rpcauth_unregister	vmlinux	EXPORT_SYMBOL_GPL	
++0x33147c49	nf_route	vmlinux	EXPORT_SYMBOL_GPL	
++0xce359c1a	tcf_exts_destroy	vmlinux	EXPORT_SYMBOL	
++0x4b7f3a78	dev_get_iflink	vmlinux	EXPORT_SYMBOL	
++0x9c2ae406	input_enable_softrepeat	vmlinux	EXPORT_SYMBOL	
++0xd099df9b	regcache_sync_region	vmlinux	EXPORT_SYMBOL_GPL	
++0xecba0637	pm_runtime_allow	vmlinux	EXPORT_SYMBOL_GPL	
++0x53c089f5	property_entries_dup	vmlinux	EXPORT_SYMBOL_GPL	
++0xc3577986	do_unbind_con_driver	vmlinux	EXPORT_SYMBOL_GPL	
++0xdaf4dfb3	fb_mode_option	vmlinux	EXPORT_SYMBOL_GPL	
++0xf1361941	pci_vpd_find_tag	vmlinux	EXPORT_SYMBOL_GPL	
++0xd8f03c65	crypto_alloc_tfm_node	vmlinux	EXPORT_SYMBOL_GPL	
++0xf1a3f3cd	nfs_setattr_update_inode	vmlinux	EXPORT_SYMBOL_GPL	
++0x9fa8d745	iomap_truncate_page	vmlinux	EXPORT_SYMBOL_GPL	
++0xe1a25c4b	seq_vprintf	vmlinux	EXPORT_SYMBOL	
++0xc7620fb4	xprt_request_get_cong	vmlinux	EXPORT_SYMBOL_GPL	
++0x39c32aca	__SCK__tp_func_neigh_event_send_done	vmlinux	EXPORT_SYMBOL_GPL	
++0x3c2b68f7	of_changeset_apply	vmlinux	EXPORT_SYMBOL_GPL	
++0x2838bb61	sdio_unregister_driver	vmlinux	EXPORT_SYMBOL_GPL	
++0x67cebee8	uart_xchar_out	vmlinux	EXPORT_SYMBOL_GPL	
++0xdf51db0c	regulator_get	vmlinux	EXPORT_SYMBOL_GPL	
++0xd0481b8a	pci_write_config_word	vmlinux	EXPORT_SYMBOL	
++0xa75fd2f2	blk_rq_prep_clone	vmlinux	EXPORT_SYMBOL_GPL	
++0x4bf70915	crypto_alloc_shash	vmlinux	EXPORT_SYMBOL_GPL	
++0xc2e4f438	crypto_alloc_ahash	vmlinux	EXPORT_SYMBOL_GPL	
++0xf1ab37b0	crypto_alg_extsize	vmlinux	EXPORT_SYMBOL_GPL	
++0x3f1c53a2	__traceiter_pnfs_mds_fallback_write_done	vmlinux	EXPORT_SYMBOL_GPL	
++0x38b0b887	irq_chip_enable_parent	vmlinux	EXPORT_SYMBOL_GPL	
++0x0a578091	ipv6_mc_check_mld	vmlinux	EXPORT_SYMBOL	
++0x0e3284d1	inet6_register_icmp_sender	vmlinux	EXPORT_SYMBOL	
++0x1dfd2fb4	xfrm_state_afinfo_get_rcu	vmlinux	EXPORT_SYMBOL_GPL	
++0x03499f77	tcf_action_check_ctrlact	vmlinux	EXPORT_SYMBOL	
++0xe4b99cd1	vlan_ioctl_set	vmlinux	EXPORT_SYMBOL	
++0x474a3218	of_alias_get_id	vmlinux	EXPORT_SYMBOL_GPL	
++0xa5bda8a1	efi_capsule_supported	vmlinux	EXPORT_SYMBOL_GPL	
++0x53b315f9	devm_of_mdiobus_register	vmlinux	EXPORT_SYMBOL	
++0x12a4e128	__arch_copy_from_user	vmlinux	EXPORT_SYMBOL	
++0x8a8c80b1	__page_mapcount	vmlinux	EXPORT_SYMBOL_GPL	
++0x6a037cf1	mempool_kfree	vmlinux	EXPORT_SYMBOL	
++0x75d0deb9	nsecs_to_jiffies64	vmlinux	EXPORT_SYMBOL	
++0x74b0f9be	of_graph_get_remote_port_parent	vmlinux	EXPORT_SYMBOL	
++0x0b3ccfd5	usb_wakeup_enabled_descendants	vmlinux	EXPORT_SYMBOL_GPL	
++0x63050621	scsi_scan_target	vmlinux	EXPORT_SYMBOL	
++0xcd25de69	subsys_dev_iter_exit	vmlinux	EXPORT_SYMBOL_GPL	
++0x9f0927b2	subsys_dev_iter_init	vmlinux	EXPORT_SYMBOL_GPL	
++0xe3d77f89	mipi_dsi_host_unregister	vmlinux	EXPORT_SYMBOL	
++0x262ea374	of_pinctrl_get	vmlinux	EXPORT_SYMBOL_GPL	
++0x40d84a37	ZSTD_getFrameParams	vmlinux	EXPORT_SYMBOL	
++0xe091c977	list_sort	vmlinux	EXPORT_SYMBOL	
++0x850760b5	__fscache_invalidate	vmlinux	EXPORT_SYMBOL	
++0x53f627a3	register_quota_format	vmlinux	EXPORT_SYMBOL	
++0x76c497d3	remove_arg_zero	vmlinux	EXPORT_SYMBOL	
++0x5b56860c	vm_munmap	vmlinux	EXPORT_SYMBOL	
++0x0b79ba12	remap_pfn_range	vmlinux	EXPORT_SYMBOL	
++0x92c759c6	phy_register_fixup	vmlinux	EXPORT_SYMBOL	
++0x5948c60a	device_bind_driver	vmlinux	EXPORT_SYMBOL_GPL	
++0x530f5993	device_store_ulong	vmlinux	EXPORT_SYMBOL_GPL	
++0x961e03d8	uart_try_toggle_sysrq	vmlinux	EXPORT_SYMBOL_GPL	
++0xb22e16d5	radix_tree_maybe_preload	vmlinux	EXPORT_SYMBOL	
++0x3393176a	iomap_writepage	vmlinux	EXPORT_SYMBOL_GPL	
++0x83c2e2cf	file_update_time	vmlinux	EXPORT_SYMBOL	
++0xb8cd3a7f	nf_logger_put	vmlinux	EXPORT_SYMBOL_GPL	
++0x5742623a	dev_mc_init	vmlinux	EXPORT_SYMBOL	
++0x3a69cb86	dev_uc_init	vmlinux	EXPORT_SYMBOL	
++0x865029ac	__hw_addr_sync	vmlinux	EXPORT_SYMBOL	
++0x04797ce2	devm_gpiod_get_optional	vmlinux	EXPORT_SYMBOL_GPL	
++0x360b4baa	kobject_uevent_env	vmlinux	EXPORT_SYMBOL_GPL	
++0xaa19e4aa	_kstrtol	vmlinux	EXPORT_SYMBOL	
++0xac7385e3	pagevec_lookup_range_nr_tag	vmlinux	EXPORT_SYMBOL	
++0x06680c08	perf_trace_run_bpf_submit	vmlinux	EXPORT_SYMBOL_GPL	
++0x600a2858	relay_file_operations	vmlinux	EXPORT_SYMBOL_GPL	
++0x47ac2d76	init_timer_key	vmlinux	EXPORT_SYMBOL	
++0x71a2c57c	rpc_wake_up_status	vmlinux	EXPORT_SYMBOL_GPL	
++0xfb0780aa	dev_set_mac_address_user	vmlinux	EXPORT_SYMBOL	
++0x8ed05a54	put_cmsg	vmlinux	EXPORT_SYMBOL	
++0xafb080fe	skb_free_datagram	vmlinux	EXPORT_SYMBOL	
++0x27e7d3e8	skb_vlan_push	vmlinux	EXPORT_SYMBOL	
++0xecbc8c72	sound_class	vmlinux	EXPORT_SYMBOL	
++0xe597edc6	of_fdt_unflatten_tree	vmlinux	EXPORT_SYMBOL_GPL	
++0xb34b080e	usb_set_configuration	vmlinux	EXPORT_SYMBOL_GPL	
++0x01d0b075	pci_wake_from_d3	vmlinux	EXPORT_SYMBOL	
++0xce784e33	gpiod_set_consumer_name	vmlinux	EXPORT_SYMBOL_GPL	
++0x9e612a7f	vfs_clone_file_range	vmlinux	EXPORT_SYMBOL	
++0x6e59f821	__tracepoint_wbc_writepage	vmlinux	EXPORT_SYMBOL_GPL	
++0x54892e0f	filp_close	vmlinux	EXPORT_SYMBOL	
++0xa5f569f9	truncate_setsize	vmlinux	EXPORT_SYMBOL	
++0x2e3bcce2	wait_for_completion_interruptible	vmlinux	EXPORT_SYMBOL	
++0xfc59afd0	cpu_suspend	vmlinux	EXPORT_SYMBOL_GPL	
++0xc8363be0	svcauth_gss_register_pseudoflavor	vmlinux	EXPORT_SYMBOL_GPL	
++0x7f7cbb81	svcauth_gss_flavor	vmlinux	EXPORT_SYMBOL_GPL	
++0x9a3ca7b7	mmc_gpio_set_cd_wake	vmlinux	EXPORT_SYMBOL	
++0x8917244d	__phy_modify_mmd	vmlinux	EXPORT_SYMBOL_GPL	
++0x1d5099b4	iscsi_add_conn	vmlinux	EXPORT_SYMBOL_GPL	
++0x67b27ec1	tty_std_termios	vmlinux	EXPORT_SYMBOL	
++0x44b920e0	pci_create_root_bus	vmlinux	EXPORT_SYMBOL_GPL	
++0x16568ecd	d_obtain_root	vmlinux	EXPORT_SYMBOL	
++0xd7e74de1	dma_direct_set_offset	vmlinux	EXPORT_SYMBOL_GPL	
++0xe2e0c7c6	__flush_icache_range	vmlinux	EXPORT_SYMBOL	
++0x93bb701d	rpc_task_timeout	vmlinux	EXPORT_SYMBOL_GPL	
++0x101fa882	mr_table_dump	vmlinux	EXPORT_SYMBOL	
++0x1c6a54bf	ether_setup	vmlinux	EXPORT_SYMBOL	
++0x9aab3a4f	usb_deregister_device_driver	vmlinux	EXPORT_SYMBOL_GPL	
++0x8b8280bb	usbnet_nway_reset	vmlinux	EXPORT_SYMBOL_GPL	
++0x4ec409d0	device_create_file	vmlinux	EXPORT_SYMBOL_GPL	
++0x48bfdbff	__break_lease	vmlinux	EXPORT_SYMBOL	
++0xaede94de	fc_mount	vmlinux	EXPORT_SYMBOL	
++0x2b7bb4e6	list_lru_add	vmlinux	EXPORT_SYMBOL_GPL	
++0x5f3d9e5e	param_ops_bint	vmlinux	EXPORT_SYMBOL	
++0x0dc6b3b3	param_set_bool	vmlinux	EXPORT_SYMBOL	
++0x4d4ccc77	param_ops_byte	vmlinux	EXPORT_SYMBOL	
++0x7e6543eb	xprt_free	vmlinux	EXPORT_SYMBOL_GPL	
++0x13c00336	xfrm_lookup_with_ifid	vmlinux	EXPORT_SYMBOL	
++0xccfb9e07	dst_default_metrics	vmlinux	EXPORT_SYMBOL	
++0x42c81db2	sock_dequeue_err_skb	vmlinux	EXPORT_SYMBOL	
++0x5441d1ac	dev_pm_opp_remove_all_dynamic	vmlinux	EXPORT_SYMBOL_GPL	
++0x850f00e0	fwnode_property_read_u64_array	vmlinux	EXPORT_SYMBOL_GPL	
++0xab81fde7	fwnode_property_read_u32_array	vmlinux	EXPORT_SYMBOL_GPL	
++0xf61aba53	fwnode_property_read_u16_array	vmlinux	EXPORT_SYMBOL_GPL	
++0xa951950a	nfs_alloc_inode	vmlinux	EXPORT_SYMBOL_GPL	
++0xc9c236e7	would_dump	vmlinux	EXPORT_SYMBOL	
++0x7d885b6b	truncate_inode_pages_range	vmlinux	EXPORT_SYMBOL	
++0x6ea9363b	force_sig	vmlinux	EXPORT_SYMBOL	
++0x156aa433	mmc_card_is_blockaddr	vmlinux	EXPORT_SYMBOL	
++0x01b12bfb	usb_ep_free_request	vmlinux	EXPORT_SYMBOL_GPL	
++0x6e89a560	regmap_irq_chip_get_base	vmlinux	EXPORT_SYMBOL_GPL	
++0xf0f750b5	fwnode_get_next_parent	vmlinux	EXPORT_SYMBOL_GPL	
++0x8232cddd	xas_load	vmlinux	EXPORT_SYMBOL_GPL	
++0x05240ee7	percpu_counter_batch	vmlinux	EXPORT_SYMBOL	
++0xd40dd6b2	nfs4_pnfs_ds_put	vmlinux	EXPORT_SYMBOL_GPL	
++0x4b0c3abc	nfs4_fs_type	vmlinux	EXPORT_SYMBOL_GPL	
++0x13c463ca	d_path	vmlinux	EXPORT_SYMBOL	
++0x4d80f27f	__traceiter_xdp_bulk_tx	vmlinux	EXPORT_SYMBOL_GPL	
++0x5727b032	skb_page_frag_refill	vmlinux	EXPORT_SYMBOL	
++0x4688a7e4	usb_phy_set_charger_state	vmlinux	EXPORT_SYMBOL_GPL	
++0xab8b7f4b	sdev_prefix_printk	vmlinux	EXPORT_SYMBOL	
++0x13d928f5	__SCK__tp_func_kmem_cache_alloc	vmlinux	EXPORT_SYMBOL	
++0xa2c66632	usbnet_resume	vmlinux	EXPORT_SYMBOL_GPL	
++0x9c01f047	genphy_read_abilities	vmlinux	EXPORT_SYMBOL	
++0x8cc95dbb	sdev_evt_send	vmlinux	EXPORT_SYMBOL_GPL	
++0x5b3055ad	csum_and_copy_to_iter	vmlinux	EXPORT_SYMBOL	
++0xceec8abd	__mb_cache_entry_free	vmlinux	EXPORT_SYMBOL	
++0xe0ee26f3	igrab	vmlinux	EXPORT_SYMBOL	
++0x91f036f7	rtnl_notify	vmlinux	EXPORT_SYMBOL	
++0x329e5b1c	__rtnl_link_register	vmlinux	EXPORT_SYMBOL_GPL	
++0xfbcdf4c6	zerocopy_sg_from_iter	vmlinux	EXPORT_SYMBOL	
++0x7474ad59	sock_recvmsg	vmlinux	EXPORT_SYMBOL	
++0x5a84c17e	mmc_can_secure_erase_trim	vmlinux	EXPORT_SYMBOL	
++0x5054f854	thermal_zone_get_offset	vmlinux	EXPORT_SYMBOL_GPL	
++0x42041512	i2c_get_dma_safe_msg_buf	vmlinux	EXPORT_SYMBOL_GPL	
++0x2acca045	usb_hcd_unmap_urb_for_dma	vmlinux	EXPORT_SYMBOL_GPL	
++0xa9d5cac4	phy_select_page	vmlinux	EXPORT_SYMBOL_GPL	
++0xa1ec7058	serial8250_em485_stop_tx	vmlinux	EXPORT_SYMBOL_GPL	
++0x60593e8b	pci_back_from_sleep	vmlinux	EXPORT_SYMBOL	
++0x4934bdd0	crypto_check_attr_type	vmlinux	EXPORT_SYMBOL_GPL	
++0x484a1fd7	linkwatch_fire_event	vmlinux	EXPORT_SYMBOL	
++0x8b13a8b8	hid_snto32	vmlinux	EXPORT_SYMBOL_GPL	
++0x141672bd	watchdog_init_timeout	vmlinux	EXPORT_SYMBOL_GPL	
++0xcc328a5c	reservation_ww_class	vmlinux	EXPORT_SYMBOL	
++0x7e2eb4e9	dev_pm_set_dedicated_wake_irq	vmlinux	EXPORT_SYMBOL_GPL	
++0x5f8ea0d6	rhashtable_walk_peek	vmlinux	EXPORT_SYMBOL_GPL	
++0x8c770b18	_copy_from_iter	vmlinux	EXPORT_SYMBOL	
++0x7e5f8efa	fs_bio_set	vmlinux	EXPORT_SYMBOL	
++0x93171393	__get_task_comm	vmlinux	EXPORT_SYMBOL_GPL	
++0x8d522714	__rcu_read_lock	vmlinux	EXPORT_SYMBOL_GPL	
++0x27479d14	param_free_charp	vmlinux	EXPORT_SYMBOL	
++0xf1b929a8	ethtool_rx_flow_rule_create	vmlinux	EXPORT_SYMBOL	
++0x4fe1eddf	unregister_netevent_notifier	vmlinux	EXPORT_SYMBOL_GPL	
++0x95411410	devm_thermal_add_hwmon_sysfs	vmlinux	EXPORT_SYMBOL_GPL	
++0x2c9522c3	input_mt_report_slot_state	vmlinux	EXPORT_SYMBOL	
++0xcbb66f9f	platform_get_irq_optional	vmlinux	EXPORT_SYMBOL_GPL	
++0xd15bdbb9	clk_mux_determine_rate_flags	vmlinux	EXPORT_SYMBOL_GPL	
++0x9d1a5e3a	__memcpy	vmlinux	EXPORT_SYMBOL	
++0x14b76437	alloc_nfs_open_context	vmlinux	EXPORT_SYMBOL_GPL	
++0xcfc7b4e4	rcu_barrier_tasks_trace	vmlinux	EXPORT_SYMBOL_GPL	
++0x43ade47c	rpc_queue_upcall	vmlinux	EXPORT_SYMBOL_GPL	
++0x6a74ce6c	hiddev_hid_event	vmlinux	EXPORT_SYMBOL_GPL	
++0xd5227f94	sdhci_remove_host	vmlinux	EXPORT_SYMBOL_GPL	
++0x769cefb5	percpu_ref_switch_to_atomic	vmlinux	EXPORT_SYMBOL_GPL	
++0xa3228d90	__blkg_prfill_u64	vmlinux	EXPORT_SYMBOL_GPL	
++0x07591717	vmf_insert_pfn	vmlinux	EXPORT_SYMBOL	
++0xb35ac2d9	unix_gc_lock	vmlinux	EXPORT_SYMBOL	
++0x8aae88bb	nf_queue_nf_hook_drop	vmlinux	EXPORT_SYMBOL_GPL	
++0xb2988bab	spi_controller_suspend	vmlinux	EXPORT_SYMBOL_GPL	
++0x9641a6c7	of_dma_controller_free	vmlinux	EXPORT_SYMBOL_GPL	
++0x36041127	pwm_put	vmlinux	EXPORT_SYMBOL_GPL	
++0x659ae585	debugfs_create_x8	vmlinux	EXPORT_SYMBOL_GPL	
++0x2f66f406	cgroup_get_from_path	vmlinux	EXPORT_SYMBOL_GPL	
++0xe5cbb753	irq_domain_xlate_twocell	vmlinux	EXPORT_SYMBOL_GPL	
++0x91afefad	irq_domain_xlate_onecell	vmlinux	EXPORT_SYMBOL_GPL	
++0x65a53dea	fib_info_nh_uses_dev	vmlinux	EXPORT_SYMBOL_GPL	
++0xef444415	power_supply_get_drvdata	vmlinux	EXPORT_SYMBOL_GPL	
++0x58ea6721	uart_write_wakeup	vmlinux	EXPORT_SYMBOL	
++0x40111955	pci_bus_read_config_word	vmlinux	EXPORT_SYMBOL	
++0x465e24ff	ucs2_utf8size	vmlinux	EXPORT_SYMBOL	
++0xbad1ba6c	netdev_lower_get_next	vmlinux	EXPORT_SYMBOL	
++0x859b67b2	skb_append	vmlinux	EXPORT_SYMBOL	
++0xbe58a618	sdhci_start_signal_voltage_switch	vmlinux	EXPORT_SYMBOL_GPL	
++0x31c7970f	pciserial_suspend_ports	vmlinux	EXPORT_SYMBOL_GPL	
++0x995f5c62	nfs_pgio_current_mirror	vmlinux	EXPORT_SYMBOL_GPL	
++0xb146d9aa	read_cache_page_gfp	vmlinux	EXPORT_SYMBOL	
++0xeff1f61b	sk_stream_error	vmlinux	EXPORT_SYMBOL	
++0xc0e8f2ef	usb_stor_CB_reset	vmlinux	EXPORT_SYMBOL_GPL	USB_STORAGE
++0x88a9e90a	pci_ioremap_wc_bar	vmlinux	EXPORT_SYMBOL_GPL	
++0x374f4f19	disk_start_io_acct	vmlinux	EXPORT_SYMBOL	
++0x5adc2e7f	crypto_sha1_finup	vmlinux	EXPORT_SYMBOL	
++0x7cd013a8	__SCK__tp_func_pnfs_mds_fallback_pg_get_mirror_count	vmlinux	EXPORT_SYMBOL_GPL	
++0xc3d0489d	audit_log_start	vmlinux	EXPORT_SYMBOL	
++0xe4a758f1	netdev_crit	vmlinux	EXPORT_SYMBOL	
++0xb6fddb31	netdev_bonding_info_change	vmlinux	EXPORT_SYMBOL	
++0xfb2d8460	devm_nvmem_unregister	vmlinux	EXPORT_SYMBOL	
++0xc6c82739	of_console_check	vmlinux	EXPORT_SYMBOL_GPL	
++0x1038b474	sdhci_get_property	vmlinux	EXPORT_SYMBOL_GPL	
++0x4a15414b	usb_bus_idr_lock	vmlinux	EXPORT_SYMBOL_GPL	
++0xdcb764ad	memset	vmlinux	EXPORT_SYMBOL	
++0x0e2dbbd7	sysfs_create_files	vmlinux	EXPORT_SYMBOL_GPL	
++0x9e309d76	dquot_get_state	vmlinux	EXPORT_SYMBOL	
++0xac0c9fa4	sget	vmlinux	EXPORT_SYMBOL	
++0x3a2f2a5b	devm_usb_get_phy_by_node	vmlinux	EXPORT_SYMBOL_GPL	
++0x506cb132	component_master_add_with_match	vmlinux	EXPORT_SYMBOL_GPL	
++0x93afedc8	tty_save_termios	vmlinux	EXPORT_SYMBOL_GPL	
++0xd7b920ff	pcie_get_mps	vmlinux	EXPORT_SYMBOL	
++0x4efcf021	mpi_normalize	vmlinux	EXPORT_SYMBOL_GPL	
++0xdc3fcbc9	__sw_hweight8	vmlinux	EXPORT_SYMBOL	
++0x3a13f54a	sgl_alloc	vmlinux	EXPORT_SYMBOL	
++0xcd9256ab	nfs4_sequence_done	vmlinux	EXPORT_SYMBOL_GPL	
++0xeb44339a	free_pages_exact	vmlinux	EXPORT_SYMBOL	
++0xedc6f27a	devm_spi_mem_dirmap_destroy	vmlinux	EXPORT_SYMBOL_GPL	
++0x2a5ef4e6	nvme_disable_ctrl	vmlinux	EXPORT_SYMBOL_GPL	
++0x093d312a	gpiochip_request_own_desc	vmlinux	EXPORT_SYMBOL_GPL	
++0xee92f4f7	pinctrl_pm_select_default_state	vmlinux	EXPORT_SYMBOL_GPL	
++0xde839588	debugfs_create_atomic_t	vmlinux	EXPORT_SYMBOL_GPL	
++0xafe433b2	nfs4_mark_deviceid_unavailable	vmlinux	EXPORT_SYMBOL_GPL	
++0x4a044dca	__fscache_uncache_all_inode_pages	vmlinux	EXPORT_SYMBOL	
++0x064db9a5	mark_mounts_for_expiry	vmlinux	EXPORT_SYMBOL_GPL	
++0xfa123cf6	bdi_put	vmlinux	EXPORT_SYMBOL	
++0xe79f2980	file_check_and_advance_wb_err	vmlinux	EXPORT_SYMBOL	
++0x6f545be5	inet_csk_reqsk_queue_drop_and_put	vmlinux	EXPORT_SYMBOL	
++0xfdd765e4	nvme_cleanup_cmd	vmlinux	EXPORT_SYMBOL_GPL	
++0x6d340f64	tty_termios_input_baud_rate	vmlinux	EXPORT_SYMBOL	
++0x0312b3b0	reset_controller_add_lookup	vmlinux	EXPORT_SYMBOL_GPL	
++0x56951291	regulator_bulk_set_supply_names	vmlinux	EXPORT_SYMBOL_GPL	
++0x6cbbfc54	__arch_copy_to_user	vmlinux	EXPORT_SYMBOL	
++0xce07cfe2	__arch_copy_in_user	vmlinux	EXPORT_SYMBOL	
++0x0d5f931e	vfs_get_fsid	vmlinux	EXPORT_SYMBOL	
++0x69964f8b	d_set_d_op	vmlinux	EXPORT_SYMBOL	
++0xb93bf294	ns_capable_noaudit	vmlinux	EXPORT_SYMBOL	
++0xc6b1fdbe	xfrm_aalg_get_byidx	vmlinux	EXPORT_SYMBOL_GPL	
++0x63ea2f74	unregister_tcf_proto_ops	vmlinux	EXPORT_SYMBOL	
++0x5e3730c8	__dev_get_by_flags	vmlinux	EXPORT_SYMBOL	
++0xfecb73c0	DWC_EXCEPTION	vmlinux	EXPORT_SYMBOL	
++0x0bf0e4a2	__SCK__tp_func_spi_transfer_stop	vmlinux	EXPORT_SYMBOL	
++0xc7d1613b	devm_regulator_get_exclusive	vmlinux	EXPORT_SYMBOL_GPL	
++0x912d42ee	pci_cfg_access_unlock	vmlinux	EXPORT_SYMBOL_GPL	
++0x922f45a6	__bitmap_clear	vmlinux	EXPORT_SYMBOL	
++0xb6936ffe	_bcd2bin	vmlinux	EXPORT_SYMBOL	
++0xbf00f574	finalize_exec	vmlinux	EXPORT_SYMBOL	
++0x821009e5	dma_sync_single_for_device	vmlinux	EXPORT_SYMBOL	
++0x2a1bb9e3	udp_table	vmlinux	EXPORT_SYMBOL	
++0x8e609ee5	mmc_erase_group_aligned	vmlinux	EXPORT_SYMBOL	
++0x7ac722bd	phy_all_ports_features_array	vmlinux	EXPORT_SYMBOL_GPL	
++0xea657b79	iterate_dir	vmlinux	EXPORT_SYMBOL	
++0x4d3a0696	__SCK__tp_func_rpm_idle	vmlinux	EXPORT_SYMBOL_GPL	
++0xcc0f4126	trace_event_buffer_reserve	vmlinux	EXPORT_SYMBOL_GPL	
++0x98ee62b2	ring_buffer_record_disable_cpu	vmlinux	EXPORT_SYMBOL_GPL	
++0xd29d8d16	ethnl_cable_test_amplitude	vmlinux	EXPORT_SYMBOL_GPL	
++0x5d95d127	skb_coalesce_rx_frag	vmlinux	EXPORT_SYMBOL	
++0x863670e0	power_supply_am_i_supplied	vmlinux	EXPORT_SYMBOL_GPL	
++0xb514f9f8	regcache_mark_dirty	vmlinux	EXPORT_SYMBOL_GPL	
++0xb08f419e	transport_configure_device	vmlinux	EXPORT_SYMBOL_GPL	
++0xfb6ce791	nla_put	vmlinux	EXPORT_SYMBOL	
++0x3ed2647d	gen_pool_first_fit_align	vmlinux	EXPORT_SYMBOL	
++0xf23fcb99	__kfifo_in	vmlinux	EXPORT_SYMBOL	
++0x79fda174	register_shrinker	vmlinux	EXPORT_SYMBOL	
++0xc506d998	__traceiter_pelt_thermal_tp	vmlinux	EXPORT_SYMBOL_GPL	
++0x2904fd3a	xprt_wait_for_reply_request_rtt	vmlinux	EXPORT_SYMBOL_GPL	
++0xdaca86ae	register_sound_dsp	vmlinux	EXPORT_SYMBOL	
++0x3aea782f	mdio_find_bus	vmlinux	EXPORT_SYMBOL	
++0x617b026c	hwrng_register	vmlinux	EXPORT_SYMBOL_GPL	
++0x8f124437	misc_register	vmlinux	EXPORT_SYMBOL	
++0xbe919eee	__xa_alloc_cyclic	vmlinux	EXPORT_SYMBOL	
++0x3d7c018a	blk_post_runtime_suspend	vmlinux	EXPORT_SYMBOL	
++0x51a45844	block_invalidatepage	vmlinux	EXPORT_SYMBOL	
++0xd889a599	may_umount_tree	vmlinux	EXPORT_SYMBOL	
++0xf842394f	d_set_fallthru	vmlinux	EXPORT_SYMBOL	
++0x7a944007	rcu_idle_enter	vmlinux	EXPORT_SYMBOL_GPL	
++0xdf9208c0	alloc_workqueue	vmlinux	EXPORT_SYMBOL_GPL	
++0x28fb91d0	udp_lib_get_port	vmlinux	EXPORT_SYMBOL	
++0x9fe4ec94	ip_route_input_noref	vmlinux	EXPORT_SYMBOL	
++0x6087e1fd	netdev_walk_all_lower_dev_rcu	vmlinux	EXPORT_SYMBOL_GPL	
++0xa4e813e5	tty_ldisc_ref	vmlinux	EXPORT_SYMBOL_GPL	
++0x3042188f	devm_ioport_map	vmlinux	EXPORT_SYMBOL	
++0x1fe1e1ad	locks_end_grace	vmlinux	EXPORT_SYMBOL_GPL	
++0x96b4446f	fscrypt_decrypt_bio	vmlinux	EXPORT_SYMBOL	
++0x868ba724	file_modified	vmlinux	EXPORT_SYMBOL	
++0x91d54c57	kernel_write	vmlinux	EXPORT_SYMBOL	
++0x9e1b59de	__devm_irq_alloc_descs	vmlinux	EXPORT_SYMBOL_GPL	
++0xd47dbad4	rpc_put_sb_net	vmlinux	EXPORT_SYMBOL_GPL	
++0xbc412629	rtnl_af_unregister	vmlinux	EXPORT_SYMBOL_GPL	
++0xbfee3ad5	loop_unregister_transfer	vmlinux	EXPORT_SYMBOL	
++0x894b02fd	class_dev_iter_exit	vmlinux	EXPORT_SYMBOL_GPL	
++0xd0cae0ad	device_find_child_by_name	vmlinux	EXPORT_SYMBOL_GPL	
++0x4bfbd727	__of_phy_provider_register	vmlinux	EXPORT_SYMBOL_GPL	
++0x4ec4f9a7	phy_create	vmlinux	EXPORT_SYMBOL_GPL	
++0x56dba7eb	nfs_show_devname	vmlinux	EXPORT_SYMBOL_GPL	
++0xd9b74f30	iget_failed	vmlinux	EXPORT_SYMBOL	
++0x8e92f7c4	static_key_slow_inc	vmlinux	EXPORT_SYMBOL_GPL	
++0x9fb06450	trace_get_event_file	vmlinux	EXPORT_SYMBOL_GPL	
++0xce678a59	xdr_decode_netobj	vmlinux	EXPORT_SYMBOL_GPL	
++0x5c82016e	__SCK__tp_func_napi_poll	vmlinux	EXPORT_SYMBOL_GPL	
++0xda23d5c3	usb_phy_generic_register	vmlinux	EXPORT_SYMBOL_GPL	
++0xc1086e0c	sysrq_toggle_support	vmlinux	EXPORT_SYMBOL_GPL	
++0x9ab00ab6	devm_clk_bulk_get_optional	vmlinux	EXPORT_SYMBOL_GPL	
++0x30e5697f	pci_restore_state	vmlinux	EXPORT_SYMBOL	
++0x652032cb	mac_pton	vmlinux	EXPORT_SYMBOL	
++0xf331236f	btree_geo32	vmlinux	EXPORT_SYMBOL_GPL	
++0x47059a38	__fscache_acquire_cookie	vmlinux	EXPORT_SYMBOL	
++0xa5fcd850	filemap_fdatawait_range	vmlinux	EXPORT_SYMBOL	
++0x6929aa9d	rt_spin_lock_unlock	vmlinux	EXPORT_SYMBOL	
++0xef78ff11	ethtool_intersect_link_masks	vmlinux	EXPORT_SYMBOL	
++0x32446cdf	tc_setup_flow_action	vmlinux	EXPORT_SYMBOL	
++0x56d1ab73	skb_complete_tx_timestamp	vmlinux	EXPORT_SYMBOL_GPL	
++0xeb85ef67	usb_phy_generic_unregister	vmlinux	EXPORT_SYMBOL_GPL	
++0xd904e060	debugfs_create_file_unsafe	vmlinux	EXPORT_SYMBOL_GPL	
++0x69c13f19	inode_set_bytes	vmlinux	EXPORT_SYMBOL	
++0x57e13198	inode_sub_bytes	vmlinux	EXPORT_SYMBOL	
++0x348bdf4e	unpin_user_page	vmlinux	EXPORT_SYMBOL	
++0xbdb82707	svc_unreg_xprt_class	vmlinux	EXPORT_SYMBOL_GPL	
++0x0dd8075c	rpc_prepare_reply_pages	vmlinux	EXPORT_SYMBOL_GPL	
++0xa24a7e14	arp_xmit	vmlinux	EXPORT_SYMBOL	
++0x1ecc79ff	flow_rule_match_tcp	vmlinux	EXPORT_SYMBOL	
++0x780ab179	__dev_getfirstbyhwtype	vmlinux	EXPORT_SYMBOL	
++0xf084157f	__dev_get_by_index	vmlinux	EXPORT_SYMBOL	
++0x734f50b0	sock_inuse_get	vmlinux	EXPORT_SYMBOL_GPL	
++0x23c48143	bcm_phy_cable_test_get_status_rdb	vmlinux	EXPORT_SYMBOL_GPL	
++0x86028124	iscsi_alloc_conn	vmlinux	EXPORT_SYMBOL_GPL	
++0xcfdcc6a2	regulator_desc_list_voltage_linear_range	vmlinux	EXPORT_SYMBOL_GPL	
++0xf89cf2b3	clkdev_hw_create	vmlinux	EXPORT_SYMBOL_GPL	
++0x39a0482c	pci_release_selected_regions	vmlinux	EXPORT_SYMBOL	
++0x75f1063f	crypto_comp_decompress	vmlinux	EXPORT_SYMBOL_GPL	
++0xb5c56b85	debugfs_real_fops	vmlinux	EXPORT_SYMBOL_GPL	
++0xedcf6be4	qword_add	vmlinux	EXPORT_SYMBOL_GPL	
++0xd0b0a211	rpc_max_bc_payload	vmlinux	EXPORT_SYMBOL_GPL	
++0x38385a14	__inet6_lookup_established	vmlinux	EXPORT_SYMBOL	
++0x269b8cdd	ipv6_stub	vmlinux	EXPORT_SYMBOL_GPL	
++0xd6df178f	sdio_claim_host	vmlinux	EXPORT_SYMBOL_GPL	
++0x182deefb	clk_get	vmlinux	EXPORT_SYMBOL	
++0x22ed6c48	__nla_put_nohdr	vmlinux	EXPORT_SYMBOL	
++0x011a8279	blk_mq_end_request	vmlinux	EXPORT_SYMBOL	
++0x394135de	blk_register_queue	vmlinux	EXPORT_SYMBOL_GPL	
++0xe879955b	crypto_unregister_instance	vmlinux	EXPORT_SYMBOL_GPL	
++0xc5505f2b	xattr_supported_namespace	vmlinux	EXPORT_SYMBOL	
++0x6012b7c6	rt_read_unlock	vmlinux	EXPORT_SYMBOL	
++0x384e0e82	mr_mfc_find_parent	vmlinux	EXPORT_SYMBOL	
++0x40973662	sysctl_udp_mem	vmlinux	EXPORT_SYMBOL	
++0xa0ebd14c	sysctl_tcp_mem	vmlinux	EXPORT_SYMBOL	
++0xc7e30d91	sock_no_linger	vmlinux	EXPORT_SYMBOL	
++0xb7e3268f	usbnet_probe	vmlinux	EXPORT_SYMBOL_GPL	
++0xe4bc2c2f	hdmi_drm_infoframe_pack	vmlinux	EXPORT_SYMBOL	
++0xfb90236b	bio_chain	vmlinux	EXPORT_SYMBOL	
++0x08b2c467	__SCK__tp_func_ff_layout_commit_error	vmlinux	EXPORT_SYMBOL_GPL	
++0x6f3a05e1	get_user_pages_fast_only	vmlinux	EXPORT_SYMBOL_GPL	
++0x5e51cd74	swiotlb_nr_tbl	vmlinux	EXPORT_SYMBOL_GPL	
++0xb49f1e80	console_flush_on_panic	vmlinux	EXPORT_SYMBOL	
++0xd58a4d81	__cpuhp_remove_state_cpuslocked	vmlinux	EXPORT_SYMBOL	
++0xb05f9586	inet_csk_accept	vmlinux	EXPORT_SYMBOL	
++0x18e7420e	inet_hash_connect	vmlinux	EXPORT_SYMBOL_GPL	
++0x4b7636cb	nf_log_trace	vmlinux	EXPORT_SYMBOL	
++0x9a332598	reuseport_add_sock	vmlinux	EXPORT_SYMBOL	
++0x6a7df31b	sdio_retune_crc_disable	vmlinux	EXPORT_SYMBOL_GPL	
++0x6b81c38b	power_supply_unreg_notifier	vmlinux	EXPORT_SYMBOL_GPL	
++0x389cb57d	generic_mii_ioctl	vmlinux	EXPORT_SYMBOL	
++0x259a5d90	pci_add_resource	vmlinux	EXPORT_SYMBOL	
++0x0334da4e	scsi_command_size_tbl	vmlinux	EXPORT_SYMBOL	
++0xa186f1bb	skcipher_walk_async	vmlinux	EXPORT_SYMBOL_GPL	
++0x5c69a704	jbd2_fc_end_commit	vmlinux	EXPORT_SYMBOL	
++0x039db642	do_splice_direct	vmlinux	EXPORT_SYMBOL	
++0x419d6458	inode_congested	vmlinux	EXPORT_SYMBOL_GPL	
++0xa843805a	get_unused_fd_flags	vmlinux	EXPORT_SYMBOL	
++0x8a7094ba	vm_brk_flags	vmlinux	EXPORT_SYMBOL	
++0xb1e25684	__trace_bputs	vmlinux	EXPORT_SYMBOL_GPL	
++0x16e297c3	bit_wait	vmlinux	EXPORT_SYMBOL	
++0xcf44bcbb	xprt_wake_pending_tasks	vmlinux	EXPORT_SYMBOL_GPL	
++0x04e826e6	nf_hook_slow_list	vmlinux	EXPORT_SYMBOL	
++0x3952ab08	tcf_unregister_action	vmlinux	EXPORT_SYMBOL	
++0x2019f2e1	__traceiter_neigh_event_send_done	vmlinux	EXPORT_SYMBOL_GPL	
++0x939d4ad1	usb_of_get_device_node	vmlinux	EXPORT_SYMBOL_GPL	
++0xd3ebc502	usb_bulk_msg	vmlinux	EXPORT_SYMBOL_GPL	
++0x86e9722e	blk_delete_region	vmlinux	EXPORT_SYMBOL	
++0x4fe1111c	crypto_create_tfm_node	vmlinux	EXPORT_SYMBOL_GPL	
++0x7381287f	trace_handle_return	vmlinux	EXPORT_SYMBOL_GPL	
++0xfb87a6b9	svc_generic_rpcbind_set	vmlinux	EXPORT_SYMBOL_GPL	
++0xc677d529	xfrm_state_delete_tunnel	vmlinux	EXPORT_SYMBOL	
++0x64b61434	sock_edemux	vmlinux	EXPORT_SYMBOL	
++0x56a82704	dwc_cc_clear	vmlinux	EXPORT_SYMBOL	
++0x499d70d0	phy_attached_print	vmlinux	EXPORT_SYMBOL	
++0xe7aa2213	device_remove_properties	vmlinux	EXPORT_SYMBOL_GPL	
++0x827422da	platform_device_add_resources	vmlinux	EXPORT_SYMBOL_GPL	
++0x67ded270	of_pwm_xlate_with_flags	vmlinux	EXPORT_SYMBOL_GPL	
++0xeb948df3	blk_mq_hctx_set_fq_lock_class	vmlinux	EXPORT_SYMBOL_GPL	
++0x44cc3a41	__tracepoint_nfs_fsync_exit	vmlinux	EXPORT_SYMBOL_GPL	
++0x22d9409b	iomap_sort_ioends	vmlinux	EXPORT_SYMBOL_GPL	
++0x4688d7ec	pvclock_gtod_unregister_notifier	vmlinux	EXPORT_SYMBOL_GPL	
++0x1ee5e41b	irq_chip_eoi_parent	vmlinux	EXPORT_SYMBOL_GPL	
++0xcc1f4f55	in6_dev_finish_destroy	vmlinux	EXPORT_SYMBOL	
++0x6ac94566	eth_header	vmlinux	EXPORT_SYMBOL	
++0x0e681ae8	of_irq_parse_raw	vmlinux	EXPORT_SYMBOL_GPL	
++0x1a64fb5a	of_property_count_elems_of_size	vmlinux	EXPORT_SYMBOL_GPL	
++0x72cd1399	sdhci_enable_v4_mode	vmlinux	EXPORT_SYMBOL_GPL	
++0xe5198700	scsi_rescan_device	vmlinux	EXPORT_SYMBOL	
++0x9ed554b3	unregister_keyboard_notifier	vmlinux	EXPORT_SYMBOL_GPL	
++0xfd1a28e4	unregister_framebuffer	vmlinux	EXPORT_SYMBOL	
++0xf82ec573	rb_prev	vmlinux	EXPORT_SYMBOL	
++0xb3716208	jbd2_journal_init_dev	vmlinux	EXPORT_SYMBOL	
++0xe60332ee	fscache_add_cache	vmlinux	EXPORT_SYMBOL	
++0x86714d5c	forget_cached_acl	vmlinux	EXPORT_SYMBOL	
++0x5bc1b720	bd_unlink_disk_holder	vmlinux	EXPORT_SYMBOL_GPL	
++0xa9e18049	task_handoff_unregister	vmlinux	EXPORT_SYMBOL_GPL	
++0x36b6ebbf	down_killable	vmlinux	EXPORT_SYMBOL	
++0xa872ed9d	netdev_master_upper_dev_get_rcu	vmlinux	EXPORT_SYMBOL	
++0xedccf126	napi_gro_receive	vmlinux	EXPORT_SYMBOL	
++0x4415b6fd	usb_get_phy	vmlinux	EXPORT_SYMBOL_GPL	
++0xbfd00698	mctrl_gpio_free	vmlinux	EXPORT_SYMBOL_GPL	
++0x60091316	clk_notifier_register	vmlinux	EXPORT_SYMBOL_GPL	
++0x0e9a3540	pci_reset_function	vmlinux	EXPORT_SYMBOL_GPL	
++0xd5cc5160	rhashtable_walk_start_check	vmlinux	EXPORT_SYMBOL_GPL	
++0x4bc42540	debugfs_print_regs32	vmlinux	EXPORT_SYMBOL_GPL	
++0x9112ca33	buffer_check_dirty_writeback	vmlinux	EXPORT_SYMBOL	
++0x30e6f096	nf_unregister_queue_handler	vmlinux	EXPORT_SYMBOL	
++0x2f3516ab	vchiq_connect	vmlinux	EXPORT_SYMBOL	
++0x24eb7e32	leds_list	vmlinux	EXPORT_SYMBOL_GPL	
++0x6e466056	devm_phy_package_join	vmlinux	EXPORT_SYMBOL_GPL	
++0xeae3dfd6	__const_udelay	vmlinux	EXPORT_SYMBOL	
++0x29032d38	do_clone_file_range	vmlinux	EXPORT_SYMBOL	
++0x440fe9e7	dump_page	vmlinux	EXPORT_SYMBOL	
++0xb77d1a70	proc_douintvec_minmax	vmlinux	EXPORT_SYMBOL_GPL	
++0x8946ea72	fpsimd_context_busy	vmlinux	EXPORT_SYMBOL	
++0xf44a904a	net_ns_barrier	vmlinux	EXPORT_SYMBOL	
++0x7647726c	handle_sysrq	vmlinux	EXPORT_SYMBOL	
++0x0668b595	_kstrtoul	vmlinux	EXPORT_SYMBOL	
++0x25fb9e90	bioset_init_from_src	vmlinux	EXPORT_SYMBOL	
++0x44ee4afc	__block_write_begin	vmlinux	EXPORT_SYMBOL	
++0x857b2d7c	fs_param_is_enum	vmlinux	EXPORT_SYMBOL	
++0x3517383e	register_reboot_notifier	vmlinux	EXPORT_SYMBOL	
++0x6072ebe5	tcp_sockets_allocated	vmlinux	EXPORT_SYMBOL	
++0x1683e925	sk_free_unlock_clone	vmlinux	EXPORT_SYMBOL_GPL	
++0x1ce92b07	usb_fixup_endpoint	vmlinux	EXPORT_SYMBOL_GPL	
++0xb16439d7	vchan_find_desc	vmlinux	EXPORT_SYMBOL_GPL	
++0x5228d14b	inode_owner_or_capable	vmlinux	EXPORT_SYMBOL	
++0xec0235e3	get_super_thawed	vmlinux	EXPORT_SYMBOL	
++0x57352800	usb_gadget_vbus_connect	vmlinux	EXPORT_SYMBOL_GPL	
++0xa8cc73b5	usb_gadget_frame_number	vmlinux	EXPORT_SYMBOL_GPL	
++0x444534c1	DWC_READ_REG32	vmlinux	EXPORT_SYMBOL	
++0x8fe6248b	usbnet_tx_timeout	vmlinux	EXPORT_SYMBOL_GPL	
++0x8dfa9246	scsi_device_quiesce	vmlinux	EXPORT_SYMBOL	
++0x2e68d310	gssd_running	vmlinux	EXPORT_SYMBOL_GPL	
++0xede9acb4	inet6_protos	vmlinux	EXPORT_SYMBOL	
++0x388f0794	of_irq_find_parent	vmlinux	EXPORT_SYMBOL_GPL	
++0xe2e8d54a	DWC_SPINLOCK_FREE	vmlinux	EXPORT_SYMBOL	
++0x471ed810	devm_platform_get_irqs_affinity	vmlinux	EXPORT_SYMBOL_GPL	
++0x77430454	pci_select_bars	vmlinux	EXPORT_SYMBOL	
++0xf184d189	kernel_power_off	vmlinux	EXPORT_SYMBOL_GPL	
++0x4ee5cff5	svc_create_pooled	vmlinux	EXPORT_SYMBOL_GPL	
++0xa5480379	rpc_clnt_xprt_switch_put	vmlinux	EXPORT_SYMBOL_GPL	
++0xa5095693	xhci_dbg_trace	vmlinux	EXPORT_SYMBOL_GPL	
++0x70f47fe8	of_mdiobus_phy_device_register	vmlinux	EXPORT_SYMBOL	
++0x6b2db3a8	nvme_delete_ctrl	vmlinux	EXPORT_SYMBOL_GPL	
++0x7e3dd120	con_copy_unimap	vmlinux	EXPORT_SYMBOL	
++0x326a2a70	tty_ldisc_ref_wait	vmlinux	EXPORT_SYMBOL_GPL	
++0xdb2c9477	debugfs_create_u64	vmlinux	EXPORT_SYMBOL_GPL	
++0x8a8f7be5	dquot_quota_on_mount	vmlinux	EXPORT_SYMBOL	
++0x00f45b08	block_commit_write	vmlinux	EXPORT_SYMBOL	
++0x0d44c2f5	clone_private_mount	vmlinux	EXPORT_SYMBOL_GPL	
++0x8b9bab05	__netdev_alloc_skb	vmlinux	EXPORT_SYMBOL	
++0x1c8be028	pm_clk_resume	vmlinux	EXPORT_SYMBOL_GPL	
++0xc9605195	pcie_capability_read_word	vmlinux	EXPORT_SYMBOL	
++0x0871d898	perf_event_create_kernel_counter	vmlinux	EXPORT_SYMBOL_GPL	
++0x0bfa3a19	rcu_idle_exit	vmlinux	EXPORT_SYMBOL_GPL	
++0xc372f7a0	irq_chip_release_resources_parent	vmlinux	EXPORT_SYMBOL_GPL	
++0x22838b14	nvme_sync_queues	vmlinux	EXPORT_SYMBOL_GPL	
++0x6a74fb42	tty_kref_put	vmlinux	EXPORT_SYMBOL	
++0x6e24b77e	regulator_list_voltage_linear	vmlinux	EXPORT_SYMBOL_GPL	
++0x56310925	regulator_mode_to_status	vmlinux	EXPORT_SYMBOL_GPL	
++0xd261cd8c	fb_set_suspend	vmlinux	EXPORT_SYMBOL	
++0x506dff1a	__genradix_free	vmlinux	EXPORT_SYMBOL	
++0x5f5d3e35	locks_delete_block	vmlinux	EXPORT_SYMBOL	
++0x8cb851a6	dput	vmlinux	EXPORT_SYMBOL	
++0x0c6261c1	try_module_get	vmlinux	EXPORT_SYMBOL	
++0x33f88173	register_net_sysctl	vmlinux	EXPORT_SYMBOL_GPL	
++0xb3ba9c4b	rpc_proc_unregister	vmlinux	EXPORT_SYMBOL_GPL	
++0x037144f0	rpc_delay	vmlinux	EXPORT_SYMBOL_GPL	
++0x0b7d0344	dst_dev_put	vmlinux	EXPORT_SYMBOL	
++0xe0f73979	fill_inquiry_response	vmlinux	EXPORT_SYMBOL_GPL	USB_STORAGE
++0xe06296c6	usb_match_one_id	vmlinux	EXPORT_SYMBOL_GPL	
++0x802d067d	spi_delay_exec	vmlinux	EXPORT_SYMBOL_GPL	
++0xc99ce44f	dma_buf_move_notify	vmlinux	EXPORT_SYMBOL_GPL	
++0x3729e29e	screen_glyph	vmlinux	EXPORT_SYMBOL_GPL	
++0x665e92a0	clk_set_duty_cycle	vmlinux	EXPORT_SYMBOL_GPL	
++0x663e20eb	nfs_access_get_cached	vmlinux	EXPORT_SYMBOL_GPL	
++0x3bd5f5ed	srcu_notifier_call_chain	vmlinux	EXPORT_SYMBOL_GPL	
++0x7a2af7b4	cpu_number	vmlinux	EXPORT_SYMBOL	
++0x21f91254	vlan_vids_del_by_dev	vmlinux	EXPORT_SYMBOL	
++0x5fc33a6c	sk_free	vmlinux	EXPORT_SYMBOL	
++0x0dd4f74e	scsi_is_sdev_device	vmlinux	EXPORT_SYMBOL	
++0xb0f956ff	regmap_check_range_table	vmlinux	EXPORT_SYMBOL_GPL	
++0x03c96cb3	fwnode_graph_get_port_parent	vmlinux	EXPORT_SYMBOL_GPL	
++0x9eebdde7	mpi_point_new	vmlinux	EXPORT_SYMBOL_GPL	
++0x064e6011	apply_workqueue_attrs	vmlinux	EXPORT_SYMBOL_GPL	
++0x5ae19e36	skb_scrub_packet	vmlinux	EXPORT_SYMBOL_GPL	
++0x5df6a404	mm_vc_mem_size	vmlinux	EXPORT_SYMBOL	
++0xbe5d024d	regulator_list_voltage_table	vmlinux	EXPORT_SYMBOL_GPL	
++0x5e5ca635	pci_bus_max_busnr	vmlinux	EXPORT_SYMBOL_GPL	
++0xd3dbd559	kobject_init	vmlinux	EXPORT_SYMBOL	
++0xaa899cf4	blk_set_pm_only	vmlinux	EXPORT_SYMBOL_GPL	
++0x58adb05c	get_vaddr_frames	vmlinux	EXPORT_SYMBOL	
++0x785a93b4	si_mem_available	vmlinux	EXPORT_SYMBOL_GPL	
++0x42160169	flush_workqueue	vmlinux	EXPORT_SYMBOL	
++0x55b3828b	ping_close	vmlinux	EXPORT_SYMBOL_GPL	
++0xee1f5126	__tracepoint_neigh_timer_handler	vmlinux	EXPORT_SYMBOL_GPL	
++0x14aee9db	skb_flow_dissect_ct	vmlinux	EXPORT_SYMBOL	
++0x8f42a6a2	key_type_user	vmlinux	EXPORT_SYMBOL_GPL	
++0xacddf0d4	nosteal_pipe_buf_ops	vmlinux	EXPORT_SYMBOL	
++0x7f40e12e	simple_lookup	vmlinux	EXPORT_SYMBOL	
++0x27e6a707	get_user_pages_locked	vmlinux	EXPORT_SYMBOL	
++0x9593ef31	register_ftrace_export	vmlinux	EXPORT_SYMBOL_GPL	
++0x5e3240a0	__cpu_online_mask	vmlinux	EXPORT_SYMBOL	
++0xfa599bb2	netlink_register_notifier	vmlinux	EXPORT_SYMBOL	
++0x8557c349	__skb_get_hash	vmlinux	EXPORT_SYMBOL	
++0x50c2ae54	rpi_firmware_property	vmlinux	EXPORT_SYMBOL_GPL	
++0x21e093e1	usb_match_id	vmlinux	EXPORT_SYMBOL_GPL	
++0xa2510f32	__scsi_execute	vmlinux	EXPORT_SYMBOL	
++0x2d66659d	gpiochip_disable_irq	vmlinux	EXPORT_SYMBOL_GPL	
++0x5b979a9b	xfrm_policy_insert	vmlinux	EXPORT_SYMBOL	
++0x56ff5625	lwtunnel_input	vmlinux	EXPORT_SYMBOL_GPL	
++0xe0e74e5f	__netpoll_cleanup	vmlinux	EXPORT_SYMBOL_GPL	
++0x8a8587f8	skb_segment	vmlinux	EXPORT_SYMBOL_GPL	
++0x6e2af195	usb_add_hcd	vmlinux	EXPORT_SYMBOL_GPL	
++0x6268ee91	blk_queue_max_segments	vmlinux	EXPORT_SYMBOL	
++0xd8eb228f	unlock_rename	vmlinux	EXPORT_SYMBOL	
++0x0fa4d422	skb_push	vmlinux	EXPORT_SYMBOL	
++0xfeb8220a	sdio_f0_writeb	vmlinux	EXPORT_SYMBOL_GPL	
++0xee628622	iscsi_session_chkready	vmlinux	EXPORT_SYMBOL_GPL	
++0xaf5dc3db	device_create	vmlinux	EXPORT_SYMBOL_GPL	
++0xe4b064f9	pcie_link_speed	vmlinux	EXPORT_SYMBOL_GPL	
++0x0105b595	des_encrypt	vmlinux	EXPORT_SYMBOL_GPL	
++0x3606b9c6	simple_rmdir	vmlinux	EXPORT_SYMBOL	
++0x95eeafc2	pin_user_pages_remote	vmlinux	EXPORT_SYMBOL	
++0x419504e1	free_task	vmlinux	EXPORT_SYMBOL	
++0xb6e36ce2	psched_ratecfg_precompute	vmlinux	EXPORT_SYMBOL	
++0xe70fdd1d	i2c_del_adapter	vmlinux	EXPORT_SYMBOL	
++0x2b7a45e6	i2c_adapter_depth	vmlinux	EXPORT_SYMBOL_GPL	
++0x5838f6c9	rtc_valid_tm	vmlinux	EXPORT_SYMBOL	
++0xc90f9445	usb_register_driver	vmlinux	EXPORT_SYMBOL_GPL	
++0xfd832dfb	nvme_uninit_ctrl	vmlinux	EXPORT_SYMBOL_GPL	
++0x896f40ac	iscsi_find_flashnode_conn	vmlinux	EXPORT_SYMBOL_GPL	
++0xf45ecc12	scsi_block_requests	vmlinux	EXPORT_SYMBOL	
++0x773fa409	__kfifo_dma_in_finish_r	vmlinux	EXPORT_SYMBOL	
++0x7ad0a29a	blk_poll	vmlinux	EXPORT_SYMBOL_GPL	
++0x543ef284	seq_hlist_start	vmlinux	EXPORT_SYMBOL	
++0x26ab4755	put_old_itimerspec32	vmlinux	EXPORT_SYMBOL_GPL	
++0x44bae227	bit_wait_timeout	vmlinux	EXPORT_SYMBOL_GPL	
++0x99c95fa5	unregister_sound_special	vmlinux	EXPORT_SYMBOL	
++0x1068e157	led_blink_set_oneshot	vmlinux	EXPORT_SYMBOL_GPL	
++0xdffc19a4	mmc_release_host	vmlinux	EXPORT_SYMBOL	
++0x38fbe9fb	sdev_disable_disk_events	vmlinux	EXPORT_SYMBOL	
++0xb6705eac	tty_ldisc_release	vmlinux	EXPORT_SYMBOL_GPL	
++0x0d867800	fat_dir_empty	vmlinux	EXPORT_SYMBOL_GPL	
++0xecc9f147	cdev_alloc	vmlinux	EXPORT_SYMBOL	
++0xd1c3fa8c	rpc_put_task_async	vmlinux	EXPORT_SYMBOL_GPL	
++0xd9ee1767	extcon_dev_free	vmlinux	EXPORT_SYMBOL_GPL	
++0x119d27a9	sdhci_set_bus_width	vmlinux	EXPORT_SYMBOL_GPL	
++0x386f8fdf	DWC_MODIFY_REG32	vmlinux	EXPORT_SYMBOL	
++0x91b60f7d	usb_hcd_unlink_urb_from_ep	vmlinux	EXPORT_SYMBOL_GPL	
++0xdbf7cb70	mpi_get_nbits	vmlinux	EXPORT_SYMBOL_GPL	
++0xa67b08f7	security_path_mkdir	vmlinux	EXPORT_SYMBOL	
++0xe60ecdfe	param_ops_hexint	vmlinux	EXPORT_SYMBOL	
++0x1bf7f230	get_phy_device	vmlinux	EXPORT_SYMBOL	
++0x9f46ced8	__sw_hweight64	vmlinux	EXPORT_SYMBOL	
++0x57674fd7	__sw_hweight16	vmlinux	EXPORT_SYMBOL	
++0x74c134b9	__sw_hweight32	vmlinux	EXPORT_SYMBOL	
++0xce4e47b6	__kfifo_skip_r	vmlinux	EXPORT_SYMBOL	
++0x424753e5	fat_truncate_time	vmlinux	EXPORT_SYMBOL_GPL	
++0xaca9244e	posix_acl_default_xattr_handler	vmlinux	EXPORT_SYMBOL_GPL	
++0xaccf990e	svc_exit_thread	vmlinux	EXPORT_SYMBOL_GPL	
++0x39e61495	nf_logger_request_module	vmlinux	EXPORT_SYMBOL_GPL	
++0x91fd0b22	tcf_get_next_proto	vmlinux	EXPORT_SYMBOL	
++0x75dd4ebe	of_overlay_remove	vmlinux	EXPORT_SYMBOL_GPL	
++0x46d38e31	DWC_SNPRINTF	vmlinux	EXPORT_SYMBOL	
++0x31a43154	gpiod_direction_input	vmlinux	EXPORT_SYMBOL_GPL	
++0xf27b833b	nfs_lock	vmlinux	EXPORT_SYMBOL_GPL	
++0xdffb744b	frame_vector_to_pfns	vmlinux	EXPORT_SYMBOL	
++0xc3f8b772	rpc_clnt_show_stats	vmlinux	EXPORT_SYMBOL_GPL	
++0x1ef4a171	tcp_reno_cong_avoid	vmlinux	EXPORT_SYMBOL_GPL	
++0x6befaeaf	hid_dump_report	vmlinux	EXPORT_SYMBOL_GPL	
++0xf83efc83	led_trigger_blink	vmlinux	EXPORT_SYMBOL_GPL	
++0xca8637d0	DWC_WORKQ_ALLOC	vmlinux	EXPORT_SYMBOL	
++0x379cc75b	usb_reset_device	vmlinux	EXPORT_SYMBOL_GPL	
++0x8df92f66	memchr_inv	vmlinux	EXPORT_SYMBOL	
++0x769f6e64	errseq_check	vmlinux	EXPORT_SYMBOL	
++0x6a260aaa	kernfs_put	vmlinux	EXPORT_SYMBOL_GPL	
++0x4e839977	kernfs_get	vmlinux	EXPORT_SYMBOL_GPL	
++0x923ed21e	__dquot_free_space	vmlinux	EXPORT_SYMBOL	
++0x811b1797	locks_copy_lock	vmlinux	EXPORT_SYMBOL	
++0xc7ec0663	irq_domain_associate	vmlinux	EXPORT_SYMBOL_GPL	
++0x52c61793	__SCK__tp_func_signal_generate	vmlinux	EXPORT_SYMBOL	
++0x1e119a79	rpcauth_get_pseudoflavor	vmlinux	EXPORT_SYMBOL_GPL	
++0x4a5a4053	flow_block_cb_lookup	vmlinux	EXPORT_SYMBOL	
++0x94390cbe	gnet_stats_start_copy_compat	vmlinux	EXPORT_SYMBOL	
++0x9da158ba	rtc_alarm_irq_enable	vmlinux	EXPORT_SYMBOL_GPL	
++0x191fb6d5	gpiod_get_index	vmlinux	EXPORT_SYMBOL_GPL	
++0x4cc316f5	pcim_iounmap_regions	vmlinux	EXPORT_SYMBOL	
++0x86e06ba5	check_move_unevictable_pages	vmlinux	EXPORT_SYMBOL_GPL	
++0x7522f3ba	irq_modify_status	vmlinux	EXPORT_SYMBOL_GPL	
++0x7eb808d0	add_cpu	vmlinux	EXPORT_SYMBOL_GPL	
++0xa9e6d934	inet6_del_protocol	vmlinux	EXPORT_SYMBOL	
++0xe6479974	xfrm_input_resume	vmlinux	EXPORT_SYMBOL	
++0x1c637af2	udplite_prot	vmlinux	EXPORT_SYMBOL	
++0xfd6356fc	sock_create_kern	vmlinux	EXPORT_SYMBOL	
++0x1aa8839a	scsi_eh_restore_cmnd	vmlinux	EXPORT_SYMBOL	
++0xd5a6c6d3	transport_remove_device	vmlinux	EXPORT_SYMBOL_GPL	
++0x11e30762	chacha_block_generic	vmlinux	EXPORT_SYMBOL	
++0xd72f8d9a	cache_destroy_net	vmlinux	EXPORT_SYMBOL_GPL	
++0xac66228d	mr_dump	vmlinux	EXPORT_SYMBOL	
++0x31a58f4b	sk_clone_lock	vmlinux	EXPORT_SYMBOL_GPL	
++0x60ec7418	kernel_sock_ip_overhead	vmlinux	EXPORT_SYMBOL	
++0x4e01d44f	thermal_zone_get_zone_by_name	vmlinux	EXPORT_SYMBOL_GPL	
++0xaa4e5fe7	spi_slave_abort	vmlinux	EXPORT_SYMBOL_GPL	
++0x6ea3d936	dev_pm_genpd_remove_notifier	vmlinux	EXPORT_SYMBOL_GPL	
++0xe20320cb	regulator_count_voltages	vmlinux	EXPORT_SYMBOL_GPL	
++0xe3330b91	debugfs_file_put	vmlinux	EXPORT_SYMBOL_GPL	
++0x75f41367	debugfs_file_get	vmlinux	EXPORT_SYMBOL_GPL	
++0xaeb4e17d	d_find_any_alias	vmlinux	EXPORT_SYMBOL	
++0x4daab266	vlan_uses_dev	vmlinux	EXPORT_SYMBOL	
++0x91534e08	sk_detach_filter	vmlinux	EXPORT_SYMBOL_GPL	
++0x2976e690	sk_attach_filter	vmlinux	EXPORT_SYMBOL_GPL	
++0xece7316c	__DWC_WARN	vmlinux	EXPORT_SYMBOL	
++0x6548c8c1	fb_set_cmap	vmlinux	EXPORT_SYMBOL	
++0x7fa82287	pci_unregister_driver	vmlinux	EXPORT_SYMBOL	
++0x54994378	radix_tree_tagged	vmlinux	EXPORT_SYMBOL	
++0xc890c008	zlib_deflateEnd	vmlinux	EXPORT_SYMBOL	
++0x33736a1d	__genradix_ptr_alloc	vmlinux	EXPORT_SYMBOL	
++0xd47c117b	blk_mq_pci_map_queues	vmlinux	EXPORT_SYMBOL_GPL	
++0xdaaef798	unload_nls	vmlinux	EXPORT_SYMBOL	
++0xc7514b0a	seq_open_private	vmlinux	EXPORT_SYMBOL	
++0x953e1b9e	ktime_get_real_seconds	vmlinux	EXPORT_SYMBOL_GPL	
++0x2e66298c	__SCK__tp_func_sched_util_est_cfs_tp	vmlinux	EXPORT_SYMBOL_GPL	
++0xc96dd7a9	sunrpc_cache_update	vmlinux	EXPORT_SYMBOL_GPL	
++0x7583103b	tcp_conn_request	vmlinux	EXPORT_SYMBOL	
++0x5eb6329f	kernel_listen	vmlinux	EXPORT_SYMBOL	
++0x1ed9b649	sdhci_set_uhs_signaling	vmlinux	EXPORT_SYMBOL_GPL	
++0x3ca13e47	gen_pool_alloc_algo_owner	vmlinux	EXPORT_SYMBOL	
++0x3b644591	__bitmap_shift_left	vmlinux	EXPORT_SYMBOL	
++0x537252cf	__SCK__tp_func_rpm_return_int	vmlinux	EXPORT_SYMBOL_GPL	
++0x81b939ec	log_buf_addr_get	vmlinux	EXPORT_SYMBOL_GPL	
++0xcd88c2c0	gss_mech_get	vmlinux	EXPORT_SYMBOL	
++0x3154ca12	rc_repeat	vmlinux	EXPORT_SYMBOL_GPL	
++0xcef7cd65	__scsi_device_lookup	vmlinux	EXPORT_SYMBOL	
++0x4829a47e	memcpy	vmlinux	EXPORT_SYMBOL	
++0x689e17a9	crypto_chain	vmlinux	EXPORT_SYMBOL_GPL	
++0x7412ed5b	kvfree_sensitive	vmlinux	EXPORT_SYMBOL	
++0x6c2ddb19	perf_aux_output_begin	vmlinux	EXPORT_SYMBOL_GPL	
++0x8314c684	kthread_func	vmlinux	EXPORT_SYMBOL_GPL	
++0x6bbcd1c9	rpc_run_task	vmlinux	EXPORT_SYMBOL_GPL	
++0x7ea3930a	skb_flow_dissect_tunnel_info	vmlinux	EXPORT_SYMBOL	
++0x046f359e	of_overlay_notifier_register	vmlinux	EXPORT_SYMBOL_GPL	
++0x81b03377	efivar_entry_set_safe	vmlinux	EXPORT_SYMBOL_GPL	
++0x80ef49fe	cpufreq_dbs_governor_exit	vmlinux	EXPORT_SYMBOL_GPL	
++0x3f7d1979	cpufreq_dbs_governor_init	vmlinux	EXPORT_SYMBOL_GPL	
++0xd819a524	crc_itu_t_table	vmlinux	EXPORT_SYMBOL	
++0x1c80d27d	btree_geo128	vmlinux	EXPORT_SYMBOL_GPL	
++0x502b715d	bdevname	vmlinux	EXPORT_SYMBOL	
++0x79ec8f93	blk_start_plug	vmlinux	EXPORT_SYMBOL	
++0x691229a1	cdev_init	vmlinux	EXPORT_SYMBOL	
++0x816288a9	request_resource	vmlinux	EXPORT_SYMBOL	
++0x3c09c3bb	xprt_unpin_rqst	vmlinux	EXPORT_SYMBOL_GPL	
++0x4bca9ca6	inet_getname	vmlinux	EXPORT_SYMBOL	
++0xe9e8faeb	efi_tpm_final_log_size	vmlinux	EXPORT_SYMBOL	
++0x489686dc	__nvme_submit_sync_cmd	vmlinux	EXPORT_SYMBOL_GPL	
++0x71b768b0	__SCK__tp_func_iscsi_dbg_conn	vmlinux	EXPORT_SYMBOL_GPL	
++0xea593d3f	regcache_sync	vmlinux	EXPORT_SYMBOL_GPL	
++0x947848fc	devm_pinctrl_register	vmlinux	EXPORT_SYMBOL_GPL	
++0x1e199ab8	iov_iter_fault_in_readable	vmlinux	EXPORT_SYMBOL	
++0xd9fa4bc4	module_mutex	vmlinux	EXPORT_SYMBOL_GPL	
++0x414d119a	videomode_from_timings	vmlinux	EXPORT_SYMBOL_GPL	
++0xd6719701	timestamp_truncate	vmlinux	EXPORT_SYMBOL	
++0x114f056a	modify_user_hw_breakpoint	vmlinux	EXPORT_SYMBOL_GPL	
++0xbf9bcc8d	__cap_empty_set	vmlinux	EXPORT_SYMBOL	
++0x7968467d	xprt_register_transport	vmlinux	EXPORT_SYMBOL_GPL	
++0x70d01903	inet_rcv_saddr_equal	vmlinux	EXPORT_SYMBOL	
++0x8c6d624b	platform_get_resource	vmlinux	EXPORT_SYMBOL_GPL	
++0xb50a6647	gpiochip_irqchip_add_domain	vmlinux	EXPORT_SYMBOL_GPL	
++0x5bcaf10f	crypto_shoot_alg	vmlinux	EXPORT_SYMBOL_GPL	
++0x0003a1b4	nfs_show_path	vmlinux	EXPORT_SYMBOL_GPL	
++0x87a1632e	iput	vmlinux	EXPORT_SYMBOL	
++0x42c81dd9	xprt_complete_rqst	vmlinux	EXPORT_SYMBOL_GPL	
++0x0562989c	ethtool_virtdev_set_link_ksettings	vmlinux	EXPORT_SYMBOL	
++0x80f9de73	input_ff_upload	vmlinux	EXPORT_SYMBOL_GPL	
++0x8571f9a8	iscsi_alloc_session	vmlinux	EXPORT_SYMBOL_GPL	
++0xd93c367a	devm_regulator_bulk_register_supply_alias	vmlinux	EXPORT_SYMBOL_GPL	
++0x76464c44	open_related_ns	vmlinux	EXPORT_SYMBOL_GPL	
++0x03fd2571	vm_unmap_ram	vmlinux	EXPORT_SYMBOL	
++0x0aa309cf	synchronize_hardirq	vmlinux	EXPORT_SYMBOL	
++0xed2765be	proc_doulongvec_ms_jiffies_minmax	vmlinux	EXPORT_SYMBOL	
++0x3256ba29	xfrm_output	vmlinux	EXPORT_SYMBOL_GPL	
++0xaf62a319	devm_led_classdev_unregister	vmlinux	EXPORT_SYMBOL_GPL	
++0x495bfdc6	dev_pm_opp_find_freq_exact	vmlinux	EXPORT_SYMBOL_GPL	
++0xeae6bf43	of_phy_connect	vmlinux	EXPORT_SYMBOL	
++0x92d31cfb	fixed_phy_add	vmlinux	EXPORT_SYMBOL_GPL	
++0x70ed76b7	pci_enable_device_mem	vmlinux	EXPORT_SYMBOL	
++0xf474c21c	bitmap_print_to_pagebuf	vmlinux	EXPORT_SYMBOL	
++0x71a50dbc	register_blkdev	vmlinux	EXPORT_SYMBOL	
++0x706c5a65	preempt_count_sub	vmlinux	EXPORT_SYMBOL	
++0x32c4fd63	ipv6_select_ident	vmlinux	EXPORT_SYMBOL	
++0xe800d96a	inet_offloads	vmlinux	EXPORT_SYMBOL	
++0xa8ffe86c	neigh_event_ns	vmlinux	EXPORT_SYMBOL	
++0x150d8c2e	of_dma_configure_id	vmlinux	EXPORT_SYMBOL_GPL	
++0xb355d08d	sdhci_free_host	vmlinux	EXPORT_SYMBOL_GPL	
++0x0666c746	iscsi_flashnode_bus_match	vmlinux	EXPORT_SYMBOL_GPL	
++0x9d056bc5	fb_firmware_edid	vmlinux	EXPORT_SYMBOL	
++0xe5285bd6	jbd2_journal_blocks_per_page	vmlinux	EXPORT_SYMBOL	
++0x0fd902db	mb_cache_entry_create	vmlinux	EXPORT_SYMBOL	
++0xef4d4ff9	iterate_supers_type	vmlinux	EXPORT_SYMBOL	
++0xd0654aba	woken_wake_function	vmlinux	EXPORT_SYMBOL	
++0xa314bc7b	nf_queue_entry_get_refs	vmlinux	EXPORT_SYMBOL_GPL	
++0x253ee1bc	usb_kill_anchored_urbs	vmlinux	EXPORT_SYMBOL_GPL	
++0x49224181	nvme_reset_wq	vmlinux	EXPORT_SYMBOL_GPL	
++0xae30004c	request_firmware_nowait	vmlinux	EXPORT_SYMBOL	
++0xca6756f5	fscache_check_aux	vmlinux	EXPORT_SYMBOL	
++0xa7425900	kmem_cache_free_bulk	vmlinux	EXPORT_SYMBOL	
++0xd1794a3b	jump_label_rate_limit	vmlinux	EXPORT_SYMBOL_GPL	
++0x6ca2f10e	percpu_down_write	vmlinux	EXPORT_SYMBOL_GPL	
++0x1403ad09	cpufreq_add_update_util_hook	vmlinux	EXPORT_SYMBOL_GPL	
++0xec904baf	svc_xprt_do_enqueue	vmlinux	EXPORT_SYMBOL_GPL	
++0x17e01a0b	init_dummy_netdev	vmlinux	EXPORT_SYMBOL_GPL	
++0x1e628c46	netdev_change_features	vmlinux	EXPORT_SYMBOL	
++0x614e4588	__hid_request	vmlinux	EXPORT_SYMBOL_GPL	
++0x084f4da2	sdhci_set_power_noreg	vmlinux	EXPORT_SYMBOL_GPL	
++0xc633d82d	phy_unregister_fixup	vmlinux	EXPORT_SYMBOL	
++0xad16c5e8	pci_assign_unassigned_bus_resources	vmlinux	EXPORT_SYMBOL_GPL	
++0x433504d4	nfs4_put_deviceid_node	vmlinux	EXPORT_SYMBOL_GPL	
++0x18008c59	ring_buffer_resize	vmlinux	EXPORT_SYMBOL_GPL	
++0x99fd4315	ftrace_ops_set_global_filter	vmlinux	EXPORT_SYMBOL_GPL	
++0xa339e6e5	on_each_cpu_cond_mask	vmlinux	EXPORT_SYMBOL	
++0x53c54238	rcu_read_unlock_trace_special	vmlinux	EXPORT_SYMBOL_GPL	
++0xcc3a6d69	tcf_qevent_validate_change	vmlinux	EXPORT_SYMBOL	
++0x61b35029	__traceiter_neigh_update_done	vmlinux	EXPORT_SYMBOL_GPL	
++0xf15cc348	dst_destroy	vmlinux	EXPORT_SYMBOL	
++0xe95f7c68	usbnet_get_drvinfo	vmlinux	EXPORT_SYMBOL_GPL	
++0x39fa86cb	serdev_device_remove	vmlinux	EXPORT_SYMBOL_GPL	
++0x71075c34	pci_disable_msi	vmlinux	EXPORT_SYMBOL	
++0x66b00aca	pci_disable_rom	vmlinux	EXPORT_SYMBOL_GPL	
++0x66d2c274	of_phy_put	vmlinux	EXPORT_SYMBOL_GPL	
++0xd7dd0639	of_phy_get	vmlinux	EXPORT_SYMBOL_GPL	
++0xc7a9d954	__SCK__tp_func_nfs4_pnfs_read	vmlinux	EXPORT_SYMBOL_GPL	
++0xe5b43013	svc_wake_up	vmlinux	EXPORT_SYMBOL_GPL	
++0x0334a210	xprt_write_space	vmlinux	EXPORT_SYMBOL_GPL	
++0x3a91828f	devm_usb_get_phy	vmlinux	EXPORT_SYMBOL_GPL	
++0x1b12bc12	phy_do_ioctl_running	vmlinux	EXPORT_SYMBOL	
++0x9a04bb67	scsi_mode_sense	vmlinux	EXPORT_SYMBOL	
++0xd406d266	fb_mode_is_equal	vmlinux	EXPORT_SYMBOL	
++0x29b1f422	fs_param_is_blockdev	vmlinux	EXPORT_SYMBOL	
++0xf4af35c2	rcu_gp_is_normal	vmlinux	EXPORT_SYMBOL_GPL	
++0x46a50d4a	__init_waitqueue_head	vmlinux	EXPORT_SYMBOL	
++0xfe67c684	ns_capable_setid	vmlinux	EXPORT_SYMBOL	
++0x8f410b51	of_property_read_u64	vmlinux	EXPORT_SYMBOL_GPL	
++0xd10a5a25	dwc_cc_match_cdid	vmlinux	EXPORT_SYMBOL	
++0x710a1af1	dwc_cc_match_chid	vmlinux	EXPORT_SYMBOL	
++0x46c47494	iscsi_find_flashnode_sess	vmlinux	EXPORT_SYMBOL_GPL	
++0x7a329311	pwm_apply_state	vmlinux	EXPORT_SYMBOL_GPL	
++0xf26f0784	phy_remove_lookup	vmlinux	EXPORT_SYMBOL_GPL	
++0x35a09e16	blk_queue_virt_boundary	vmlinux	EXPORT_SYMBOL	
++0x5e86cd38	blk_insert_cloned_request	vmlinux	EXPORT_SYMBOL_GPL	
++0x3f952f0f	security_sb_set_mnt_opts	vmlinux	EXPORT_SYMBOL	
++0xf1c834f6	bdev_disk_changed	vmlinux	EXPORT_SYMBOL_GPL	
++0xc7f1bfb3	zpool_unregister_driver	vmlinux	EXPORT_SYMBOL	
++0x572004d9	irq_inject_interrupt	vmlinux	EXPORT_SYMBOL_GPL	
++0x6ba6904f	ir_raw_event_store_edge	vmlinux	EXPORT_SYMBOL_GPL	
++0xd8b3e931	regulator_enable	vmlinux	EXPORT_SYMBOL_GPL	
++0x139e3ffa	gpiochip_reqres_irq	vmlinux	EXPORT_SYMBOL_GPL	
++0x20eadeb6	ip_compute_csum	vmlinux	EXPORT_SYMBOL	
++0xbfc973d2	blk_mq_kick_requeue_list	vmlinux	EXPORT_SYMBOL	
++0x5f58a392	dst_alloc	vmlinux	EXPORT_SYMBOL	
++0x6214aef2	cpufreq_unregister_notifier	vmlinux	EXPORT_SYMBOL	
++0xe93e49c3	devres_free	vmlinux	EXPORT_SYMBOL_GPL	
++0x4ef5e9de	mipi_dsi_device_register_full	vmlinux	EXPORT_SYMBOL	
++0x3ffdacf3	timerqueue_iterate_next	vmlinux	EXPORT_SYMBOL_GPL	
++0x029ed7be	blk_put_queue	vmlinux	EXPORT_SYMBOL	
++0xa24376a9	proc_create_mount_point	vmlinux	EXPORT_SYMBOL	
++0xa428653b	single_release	vmlinux	EXPORT_SYMBOL	
++0x8d4e2299	get_user_pages	vmlinux	EXPORT_SYMBOL	
++0xd277239d	housekeeping_affine	vmlinux	EXPORT_SYMBOL_GPL	
++0xa108eb4d	sysctl_optmem_max	vmlinux	EXPORT_SYMBOL	
++0xdc49c198	reciprocal_value_adv	vmlinux	EXPORT_SYMBOL	
++0x5fb326a6	akcipher_register_instance	vmlinux	EXPORT_SYMBOL_GPL	
++0x0b5f531d	jbd2_journal_destroy	vmlinux	EXPORT_SYMBOL	
++0xb3dcaedd	jbd2_journal_restart	vmlinux	EXPORT_SYMBOL	
++0x789affb1	frontswap_tmem_exclusive_gets	vmlinux	EXPORT_SYMBOL	
++0xa5f7cf37	__cpu_possible_mask	vmlinux	EXPORT_SYMBOL	
++0x609bcd98	in6_pton	vmlinux	EXPORT_SYMBOL	
++0xac5fcec0	in4_pton	vmlinux	EXPORT_SYMBOL	
++0xe14fae1f	neigh_proc_dointvec_ms_jiffies	vmlinux	EXPORT_SYMBOL	
++0x1eaa412c	of_get_mac_address	vmlinux	EXPORT_SYMBOL	
++0x42c92509	of_get_pci_address	vmlinux	EXPORT_SYMBOL	
++0x11351b35	scsi_mode_select	vmlinux	EXPORT_SYMBOL_GPL	
++0x8b149c36	clk_is_match	vmlinux	EXPORT_SYMBOL_GPL	
++0x70042ae9	cfb_copyarea	vmlinux	EXPORT_SYMBOL	
++0xf6fc8791	__bitmap_xor	vmlinux	EXPORT_SYMBOL	
++0x78b66598	mnt_want_write	vmlinux	EXPORT_SYMBOL_GPL	
++0x8dd94f7d	__dev_remove_pack	vmlinux	EXPORT_SYMBOL	
++0x0209f3a7	secure_ipv6_port_ephemeral	vmlinux	EXPORT_SYMBOL	
++0xbdc07d13	pernet_ops_rwsem	vmlinux	EXPORT_SYMBOL_GPL	
++0xde9dcb11	pcie_relaxed_ordering_enabled	vmlinux	EXPORT_SYMBOL	
++0xf96f41b7	devm_gpiod_unhinge	vmlinux	EXPORT_SYMBOL_GPL	
++0x27a21578	iov_iter_init	vmlinux	EXPORT_SYMBOL	
++0x56852089	config_group_init	vmlinux	EXPORT_SYMBOL	
++0x134110b1	posix_acl_to_xattr	vmlinux	EXPORT_SYMBOL	
++0x007bd12c	path_is_mountpoint	vmlinux	EXPORT_SYMBOL	
++0xaadd1f1d	vfs_submount	vmlinux	EXPORT_SYMBOL_GPL	
++0xa924b4aa	__traceiter_kmem_cache_alloc_node	vmlinux	EXPORT_SYMBOL	
++0x07024bd6	devm_register_reboot_notifier	vmlinux	EXPORT_SYMBOL	
++0x8adbcbfe	tc_setup_cb_reoffload	vmlinux	EXPORT_SYMBOL	
++0x1393c5b3	__traceiter_fdb_delete	vmlinux	EXPORT_SYMBOL_GPL	
++0xcea7ebcb	__starget_for_each_device	vmlinux	EXPORT_SYMBOL	
++0x44ec2a42	pci_bus_put	vmlinux	EXPORT_SYMBOL	
++0x0b126369	pci_bus_get	vmlinux	EXPORT_SYMBOL	
++0x478fed1f	radix_tree_next_chunk	vmlinux	EXPORT_SYMBOL	
++0xa5ac3e33	ZSTD_DCtxWorkspaceBound	vmlinux	EXPORT_SYMBOL	
++0x951a2773	crypto_has_alg	vmlinux	EXPORT_SYMBOL_GPL	
++0x290b6b03	splice_to_pipe	vmlinux	EXPORT_SYMBOL_GPL	
++0x30a4f9cb	iget5_locked	vmlinux	EXPORT_SYMBOL	
++0x3dcb88a0	irq_set_handler_data	vmlinux	EXPORT_SYMBOL	
++0xe5d177ad	yield_to	vmlinux	EXPORT_SYMBOL_GPL	
++0xf0ab0bc6	udp_pre_connect	vmlinux	EXPORT_SYMBOL	
++0x94e50ad4	call_fib_notifier	vmlinux	EXPORT_SYMBOL	
++0x18bfd1cd	sk_page_frag_refill	vmlinux	EXPORT_SYMBOL	
++0x6d467b08	arm_smccc_1_1_get_conduit	vmlinux	EXPORT_SYMBOL_GPL	
++0x145bbbea	__phy_write_mmd	vmlinux	EXPORT_SYMBOL	
++0xb520bfb1	mii_check_media	vmlinux	EXPORT_SYMBOL	
++0x350cc9ff	user_revoke	vmlinux	EXPORT_SYMBOL	
++0x33addef2	debugfs_create_dir	vmlinux	EXPORT_SYMBOL_GPL	
++0x8853e917	dcache_dir_lseek	vmlinux	EXPORT_SYMBOL	
++0xddb77806	timer_reduce	vmlinux	EXPORT_SYMBOL	
++0x651a4139	test_taint	vmlinux	EXPORT_SYMBOL	
++0xab277661	vlan_filter_drop_vids	vmlinux	EXPORT_SYMBOL	
++0x28746913	ip_tunnel_parse_protocol	vmlinux	EXPORT_SYMBOL	
++0xd57f6cf2	netdev_printk	vmlinux	EXPORT_SYMBOL	
++0xcf8169f0	of_address_to_resource	vmlinux	EXPORT_SYMBOL_GPL	
++0x4372ef50	of_graph_get_remote_port	vmlinux	EXPORT_SYMBOL	
++0x9a362c1c	thermal_zone_device_register	vmlinux	EXPORT_SYMBOL_GPL	
++0xc949e94e	stmpe_enable	vmlinux	EXPORT_SYMBOL_GPL	
++0x62377a7b	blk_io_schedule	vmlinux	EXPORT_SYMBOL_GPL	
++0xf5a691cd	invalidate_bh_lrus	vmlinux	EXPORT_SYMBOL_GPL	
++0xf091f2f4	vfs_iter_read	vmlinux	EXPORT_SYMBOL	
++0x936ad0e4	unregister_trace_event	vmlinux	EXPORT_SYMBOL_GPL	
++0x33350f2a	__traceiter_neigh_timer_handler	vmlinux	EXPORT_SYMBOL_GPL	
++0x32c3cb4e	class_compat_register	vmlinux	EXPORT_SYMBOL_GPL	
++0xc1e0cff4	blk_mq_freeze_queue_wait	vmlinux	EXPORT_SYMBOL_GPL	
++0x30ace14f	put_fs_context	vmlinux	EXPORT_SYMBOL	
++0xed5e516e	add_to_pipe	vmlinux	EXPORT_SYMBOL	
++0xe87705b3	d_splice_alias	vmlinux	EXPORT_SYMBOL	
++0x327f4a38	mem_map	vmlinux	EXPORT_SYMBOL	
++0x09496ffc	alarm_expires_remaining	vmlinux	EXPORT_SYMBOL_GPL	
++0x0366307a	console_suspend_enabled	vmlinux	EXPORT_SYMBOL	
++0xe43e8293	svc_reg_xprt_class	vmlinux	EXPORT_SYMBOL_GPL	
++0xc1439c1d	tcf_qevent_dump	vmlinux	EXPORT_SYMBOL	
++0x2dae975c	devm_alloc_etherdev_mqs	vmlinux	EXPORT_SYMBOL	
++0x5259f39b	sdio_release_irq	vmlinux	EXPORT_SYMBOL_GPL	
++0xfe1e92f3	mmc_wait_for_cmd	vmlinux	EXPORT_SYMBOL	
++0x43f81957	clk_round_rate	vmlinux	EXPORT_SYMBOL_GPL	
++0xabf36871	gpiochip_generic_request	vmlinux	EXPORT_SYMBOL_GPL	
++0x9f5945cd	kobject_rename	vmlinux	EXPORT_SYMBOL_GPL	
++0x7589458d	param_ops_charp	vmlinux	EXPORT_SYMBOL	
++0x66777757	rpc_count_iostats_metrics	vmlinux	EXPORT_SYMBOL_GPL	
++0xad5737fc	efivar_init	vmlinux	EXPORT_SYMBOL_GPL	
++0xb6acaa13	phy_sfp_detach	vmlinux	EXPORT_SYMBOL	
++0x394a1e11	phy_sfp_attach	vmlinux	EXPORT_SYMBOL	
++0xb9b3d277	dma_resv_copy_fences	vmlinux	EXPORT_SYMBOL	
++0x4c085666	__inode_add_bytes	vmlinux	EXPORT_SYMBOL	
++0x81807edb	cad_pid	vmlinux	EXPORT_SYMBOL	
++0x905ae6d6	inet_twsk_deschedule_put	vmlinux	EXPORT_SYMBOL	
++0x90b3bb82	tc_setup_cb_replace	vmlinux	EXPORT_SYMBOL	
++0x9be3f6de	bcm_phy_get_stats	vmlinux	EXPORT_SYMBOL_GPL	
++0x4ec2080f	genphy_read_status_fixed	vmlinux	EXPORT_SYMBOL	
++0x47267eb5	phy_set_max_speed	vmlinux	EXPORT_SYMBOL	
++0xad128dc1	__tracepoint_dma_fence_enable_signal	vmlinux	EXPORT_SYMBOL	
++0x6a6e05bf	kstrtou8	vmlinux	EXPORT_SYMBOL	
++0x794b7271	orderly_reboot	vmlinux	EXPORT_SYMBOL_GPL	
++0x7273a77f	get_task_pid	vmlinux	EXPORT_SYMBOL_GPL	
++0x85aa9a86	of_nvmem_cell_get	vmlinux	EXPORT_SYMBOL_GPL	
++0x944f391c	touchscreen_report_pos	vmlinux	EXPORT_SYMBOL	
++0xd58b90f6	of_usb_host_tpl_support	vmlinux	EXPORT_SYMBOL_GPL	
++0x8d007428	device_get_child_node_count	vmlinux	EXPORT_SYMBOL_GPL	
++0xd23ba336	serial8250_rx_chars	vmlinux	EXPORT_SYMBOL_GPL	
++0xda72a7ec	ZSTD_nextInputType	vmlinux	EXPORT_SYMBOL	
++0x5a7bfe41	crypto_probing_notify	vmlinux	EXPORT_SYMBOL_GPL	
++0xf738d1be	register_blocking_lsm_notifier	vmlinux	EXPORT_SYMBOL	
++0x5bbc74d6	__inet_twsk_schedule	vmlinux	EXPORT_SYMBOL_GPL	
++0xef7e8838	netif_receive_skb	vmlinux	EXPORT_SYMBOL	
++0x6e98cdbb	spi_new_device	vmlinux	EXPORT_SYMBOL_GPL	
++0x36cec44a	pm_runtime_enable	vmlinux	EXPORT_SYMBOL_GPL	
++0xbc6e209c	of_regulator_match	vmlinux	EXPORT_SYMBOL_GPL	
++0x785c06ab	__SCK__tp_func_ff_layout_read_error	vmlinux	EXPORT_SYMBOL_GPL	
++0xd9e079af	jbd2_journal_inode_ranged_write	vmlinux	EXPORT_SYMBOL	
++0xdae8a497	pin_user_pages_fast	vmlinux	EXPORT_SYMBOL_GPL	
++0x346030b7	__wake_up_locked_key_bookmark	vmlinux	EXPORT_SYMBOL_GPL	
++0xfb6af58d	recalc_sigpending	vmlinux	EXPORT_SYMBOL	
++0x4538a721	input_match_device_id	vmlinux	EXPORT_SYMBOL	
++0x181fec0b	genphy_c45_read_pma	vmlinux	EXPORT_SYMBOL_GPL	
++0x1229cf3e	genphy_c45_read_lpa	vmlinux	EXPORT_SYMBOL_GPL	
++0xc3cb6bc3	pci_user_read_config_dword	vmlinux	EXPORT_SYMBOL_GPL	
++0xb3f548ad	kmemdup_nul	vmlinux	EXPORT_SYMBOL	
++0xe6e40502	rcu_get_gp_seq	vmlinux	EXPORT_SYMBOL_GPL	
++0xada38766	dst_cache_destroy	vmlinux	EXPORT_SYMBOL_GPL	
++0x3459e242	__traceiter_neigh_update	vmlinux	EXPORT_SYMBOL_GPL	
++0xf1f4e125	stmpe_block_read	vmlinux	EXPORT_SYMBOL_GPL	
++0x3987f6a9	anon_transport_class_register	vmlinux	EXPORT_SYMBOL_GPL	
++0x78e7f2d1	devm_krealloc	vmlinux	EXPORT_SYMBOL_GPL	
++0x8a89b761	devm_phy_create	vmlinux	EXPORT_SYMBOL_GPL	
++0xcbd4898c	fortify_panic	vmlinux	EXPORT_SYMBOL	
++0x258d2f76	net_dim_get_tx_moderation	vmlinux	EXPORT_SYMBOL	
++0x99d472b1	net_dim_get_rx_moderation	vmlinux	EXPORT_SYMBOL	
++0x64d56a62	disk_part_iter_exit	vmlinux	EXPORT_SYMBOL_GPL	
++0xa65f3c8c	__tracepoint_block_bio_complete	vmlinux	EXPORT_SYMBOL_GPL	
++0x34407691	crypto_has_ahash	vmlinux	EXPORT_SYMBOL_GPL	
++0xc217750a	sysfs_create_file_ns	vmlinux	EXPORT_SYMBOL_GPL	
++0xf0d12c21	follow_down_one	vmlinux	EXPORT_SYMBOL	
++0x7944e0fc	tracing_off	vmlinux	EXPORT_SYMBOL_GPL	
++0x07b73e7b	__rt_mutex_owner_current	vmlinux	EXPORT_SYMBOL	
++0x18f88193	rpcauth_init_credcache	vmlinux	EXPORT_SYMBOL_GPL	
++0xfab8943e	raw_seq_next	vmlinux	EXPORT_SYMBOL_GPL	
++0x09694fba	ip_getsockopt	vmlinux	EXPORT_SYMBOL	
++0x36544154	ip_setsockopt	vmlinux	EXPORT_SYMBOL	
++0xfd6fb7bc	tty_encode_baud_rate	vmlinux	EXPORT_SYMBOL_GPL	
++0x4e0be2ac	clk_hw_set_rate_range	vmlinux	EXPORT_SYMBOL_GPL	
++0x13b8c357	devm_phy_destroy	vmlinux	EXPORT_SYMBOL_GPL	
++0xeb41b308	page_endio	vmlinux	EXPORT_SYMBOL_GPL	
++0x103e12ba	xdr_shift_buf	vmlinux	EXPORT_SYMBOL_GPL	
++0x134e340b	ip_options_rcv_srr	vmlinux	EXPORT_SYMBOL	
++0xe9869b4b	mmc_put_card	vmlinux	EXPORT_SYMBOL	
++0x05054d88	mmc_cqe_recovery	vmlinux	EXPORT_SYMBOL	
++0xaee1679b	device_register	vmlinux	EXPORT_SYMBOL_GPL	
++0xc7c1107a	LZ4_decompress_safe	vmlinux	EXPORT_SYMBOL	
++0xcbf4fde2	gen_pool_add_owner	vmlinux	EXPORT_SYMBOL	
++0x89427387	pcim_iomap_regions_request_all	vmlinux	EXPORT_SYMBOL	
++0x61df199e	blk_mq_rq_cpu	vmlinux	EXPORT_SYMBOL	
++0xee1b1ae3	dentry_open	vmlinux	EXPORT_SYMBOL	
++0xcd9c5037	__SetPageMovable	vmlinux	EXPORT_SYMBOL	
++0x68b3d127	freq_qos_add_notifier	vmlinux	EXPORT_SYMBOL_GPL	
++0x2053958b	unregister_netdevice_queue	vmlinux	EXPORT_SYMBOL	
++0x5b3cff3c	skb_checksum_help	vmlinux	EXPORT_SYMBOL	
++0x8c89e3b8	usb_phy_roothub_power_off	vmlinux	EXPORT_SYMBOL_GPL	
++0x97bdfa60	scsi_dev_info_remove_list	vmlinux	EXPORT_SYMBOL	
++0x8c9a0e7f	regmap_write	vmlinux	EXPORT_SYMBOL_GPL	
++0xcdc39c9e	security_ismaclabel	vmlinux	EXPORT_SYMBOL	
++0x1d07e365	memdup_user_nul	vmlinux	EXPORT_SYMBOL	
++0x5f21c4fb	tasklet_init	vmlinux	EXPORT_SYMBOL	
++0xd9cdb055	rpc_sleep_on_priority	vmlinux	EXPORT_SYMBOL_GPL	
++0x8f996a30	ethtool_convert_legacy_u32_to_link_mode	vmlinux	EXPORT_SYMBOL	
++0x275847c1	led_trigger_set_default	vmlinux	EXPORT_SYMBOL_GPL	
++0xf553318d	cpuidle_pause_and_lock	vmlinux	EXPORT_SYMBOL_GPL	
++0x1d9475d8	thermal_zone_of_sensor_unregister	vmlinux	EXPORT_SYMBOL_GPL	
++0x36ba66d2	bcm_phy_downshift_set	vmlinux	EXPORT_SYMBOL_GPL	
++0x137beec0	bcm_phy_downshift_get	vmlinux	EXPORT_SYMBOL_GPL	
++0xfa9c0af2	amba_bustype	vmlinux	EXPORT_SYMBOL_GPL	
++0xfe6b6720	jbd2_journal_get_undo_access	vmlinux	EXPORT_SYMBOL	
++0xabd45848	stop_machine	vmlinux	EXPORT_SYMBOL_GPL	
++0xb6261484	register_die_notifier	vmlinux	EXPORT_SYMBOL_GPL	
++0xf3b6d213	ip6_find_1stfragopt	vmlinux	EXPORT_SYMBOL	
++0xefb1dbcb	sock_no_recvmsg	vmlinux	EXPORT_SYMBOL	
++0xe4ab89c1	sk_ns_capable	vmlinux	EXPORT_SYMBOL	
++0x449bba77	spi_controller_resume	vmlinux	EXPORT_SYMBOL_GPL	
++0x0a303dd1	devm_regulator_register_notifier	vmlinux	EXPORT_SYMBOL_GPL	
++0xae0ab5e3	devm_regulator_bulk_unregister_supply_alias	vmlinux	EXPORT_SYMBOL_GPL	
++0x4f91a4c0	bcm2711_dma40_memcpy	vmlinux	EXPORT_SYMBOL	
++0x1f1ea4cc	hrtimer_cancel	vmlinux	EXPORT_SYMBOL_GPL	
++0xab63baa5	unregister_inetaddr_validator_notifier	vmlinux	EXPORT_SYMBOL	
++0x0ff015f4	ip_frag_next	vmlinux	EXPORT_SYMBOL	
++0x68c90b74	netlink_net_capable	vmlinux	EXPORT_SYMBOL	
++0x918e5801	sdhci_calc_clk	vmlinux	EXPORT_SYMBOL_GPL	
++0x64f0214b	mdio_driver_unregister	vmlinux	EXPORT_SYMBOL	
++0xff8ca960	nvme_start_freeze	vmlinux	EXPORT_SYMBOL_GPL	
++0x318ae66e	component_unbind_all	vmlinux	EXPORT_SYMBOL_GPL	
++0x124bad4d	kstrtobool	vmlinux	EXPORT_SYMBOL	
++0x3a014837	security_inode_setattr	vmlinux	EXPORT_SYMBOL_GPL	
++0xaf53f020	dquot_file_open	vmlinux	EXPORT_SYMBOL	
++0x8f786bee	fs_umode_to_dtype	vmlinux	EXPORT_SYMBOL_GPL	
++0x84264ced	fs_umode_to_ftype	vmlinux	EXPORT_SYMBOL_GPL	
++0x605790dc	fiemap_fill_next_extent	vmlinux	EXPORT_SYMBOL	
++0x3feb1093	trace_event_ignore_this_pid	vmlinux	EXPORT_SYMBOL_GPL	
++0x35cfd775	qdisc_watchdog_cancel	vmlinux	EXPORT_SYMBOL	
++0x4aed2c8d	dev_queue_xmit_accel	vmlinux	EXPORT_SYMBOL	
++0x0dd95f28	devm_device_remove_groups	vmlinux	EXPORT_SYMBOL_GPL	
++0x1ce1b890	__xa_clear_mark	vmlinux	EXPORT_SYMBOL	
++0xa0806b1b	crypto_shash_digest	vmlinux	EXPORT_SYMBOL_GPL	
++0x765b86fb	crypto_ahash_digest	vmlinux	EXPORT_SYMBOL_GPL	
++0x3de9cae1	crypto_remove_final	vmlinux	EXPORT_SYMBOL_GPL	
++0xd1816f32	frontswap_writethrough	vmlinux	EXPORT_SYMBOL	
++0x6346f389	get_user_pages_unlocked	vmlinux	EXPORT_SYMBOL	
++0x358f9cd9	svc_authenticate	vmlinux	EXPORT_SYMBOL_GPL	
++0x282b5ece	rtnl_set_sk_err	vmlinux	EXPORT_SYMBOL	
++0x25498ee2	__sock_queue_rcv_skb	vmlinux	EXPORT_SYMBOL	
++0x02f9b2cf	kernel_sendpage_locked	vmlinux	EXPORT_SYMBOL	
++0xea7c5921	usb_hcd_pci_remove	vmlinux	EXPORT_SYMBOL_GPL	
++0xccb0db89	phy_device_remove	vmlinux	EXPORT_SYMBOL	
++0xfc5705db	class_remove_file_ns	vmlinux	EXPORT_SYMBOL_GPL	
++0x72e6ed1e	lockref_mark_dead	vmlinux	EXPORT_SYMBOL	
++0xb7ab1fb2	nfs_file_operations	vmlinux	EXPORT_SYMBOL_GPL	
++0x58e64158	__traceiter_mmap_lock_start_locking	vmlinux	EXPORT_SYMBOL	
++0x7d20f35e	irq_domain_free_fwnode	vmlinux	EXPORT_SYMBOL_GPL	
++0xe9c379d7	downgrade_write	vmlinux	EXPORT_SYMBOL	
++0xa6257a2f	complete	vmlinux	EXPORT_SYMBOL	
++0x2e58947f	ip_check_defrag	vmlinux	EXPORT_SYMBOL	
++0x67a57559	flow_get_u32_src	vmlinux	EXPORT_SYMBOL	
++0x7607a668	usb_pipe_type_check	vmlinux	EXPORT_SYMBOL_GPL	
++0x2850f79b	iscsi_block_session	vmlinux	EXPORT_SYMBOL_GPL	
++0x3f7618c5	mipi_dsi_dcs_read	vmlinux	EXPORT_SYMBOL	
++0x6e188cdd	rdev_get_dev	vmlinux	EXPORT_SYMBOL_GPL	
++0x6dba5856	iov_iter_single_seg_count	vmlinux	EXPORT_SYMBOL	
++0xe3bee3bc	config_item_init_type_name	vmlinux	EXPORT_SYMBOL	
++0xff8df791	adjust_managed_page_count	vmlinux	EXPORT_SYMBOL	
++0xc31db0ce	is_vmalloc_addr	vmlinux	EXPORT_SYMBOL	
++0x6cf0cd85	scsi_test_unit_ready	vmlinux	EXPORT_SYMBOL	
++0xd39c29ee	syscon_regmap_lookup_by_phandle_args	vmlinux	EXPORT_SYMBOL_GPL	
++0x86df64cb	stmpe_set_bits	vmlinux	EXPORT_SYMBOL_GPL	
++0x9d22f426	serial8250_read_char	vmlinux	EXPORT_SYMBOL_GPL	
++0x8a7d1c31	high_memory	vmlinux	EXPORT_SYMBOL	
++0x8d97b99c	perf_pmu_register	vmlinux	EXPORT_SYMBOL_GPL	
++0x94fc8d93	smp_call_function_many	vmlinux	EXPORT_SYMBOL	
++0x27b7eb15	irq_chip_retrigger_hierarchy	vmlinux	EXPORT_SYMBOL_GPL	
++0x77ec6a56	xprt_reconnect_backoff	vmlinux	EXPORT_SYMBOL_GPL	
++0xe0099ee0	of_reserved_mem_device_init_by_name	vmlinux	EXPORT_SYMBOL_GPL	
++0x16c6a7d5	spi_finalize_current_transfer	vmlinux	EXPORT_SYMBOL_GPL	
++0x7d1d7f9f	regmap_parse_val	vmlinux	EXPORT_SYMBOL_GPL	
++0xcb9dd2d1	clk_hw_get_rate	vmlinux	EXPORT_SYMBOL_GPL	
++0x973d5d59	__traceiter_block_bio_complete	vmlinux	EXPORT_SYMBOL_GPL	
++0x69b452fe	simple_link	vmlinux	EXPORT_SYMBOL	
++0xa5b2b19c	hidinput_find_field	vmlinux	EXPORT_SYMBOL_GPL	
++0x13cc491a	DWC_WORKQ_SCHEDULE_DELAYED	vmlinux	EXPORT_SYMBOL	
++0xe2099dc6	scsi_remove_target	vmlinux	EXPORT_SYMBOL	
++0xcfcce2f3	dma_buf_unpin	vmlinux	EXPORT_SYMBOL_GPL	
++0x44e2293b	regmap_noinc_read	vmlinux	EXPORT_SYMBOL_GPL	
++0xb14ab1ef	hdmi_audio_infoframe_init	vmlinux	EXPORT_SYMBOL	
++0x5b063edd	find_asymmetric_key	vmlinux	EXPORT_SYMBOL_GPL	
++0xe894f60b	fscrypt_zeroout_range	vmlinux	EXPORT_SYMBOL	
++0x8606844f	mempool_create	vmlinux	EXPORT_SYMBOL	
++0xf2967796	ring_buffer_record_on	vmlinux	EXPORT_SYMBOL_GPL	
++0x39552db2	tasklet_setup	vmlinux	EXPORT_SYMBOL	
++0x8e964c6d	tcf_get_next_chain	vmlinux	EXPORT_SYMBOL	
++0x756b0466	of_cpu_node_to_id	vmlinux	EXPORT_SYMBOL	
++0xd7399d2a	efivar_entry_iter_end	vmlinux	EXPORT_SYMBOL_GPL	
++0xfb7693a2	bcm_phy_r_rc_cal_reset	vmlinux	EXPORT_SYMBOL_GPL	
++0xd51ee9fc	phy_init_eee	vmlinux	EXPORT_SYMBOL	
++0x9bc82244	clkdev_drop	vmlinux	EXPORT_SYMBOL	
++0x452725c7	kblockd_schedule_work	vmlinux	EXPORT_SYMBOL	
++0xe5e7bf33	nfs4_init_ds_session	vmlinux	EXPORT_SYMBOL_GPL	
++0x220e55d0	mem_section	vmlinux	EXPORT_SYMBOL	
++0xb740acff	send_sig_info	vmlinux	EXPORT_SYMBOL	
++0xedc03953	iounmap	vmlinux	EXPORT_SYMBOL	
++0x6a182ca3	cache_seq_next_rcu	vmlinux	EXPORT_SYMBOL_GPL	
++0x6ce98fbe	xprt_release_xprt	vmlinux	EXPORT_SYMBOL_GPL	
++0xd58c4ff4	__neigh_event_send	vmlinux	EXPORT_SYMBOL	
++0x734d83a9	sk_stream_wait_close	vmlinux	EXPORT_SYMBOL	
++0x7ee22768	skb_mpls_dec_ttl	vmlinux	EXPORT_SYMBOL_GPL	
++0x2e80480d	sdhci_reset_tuning	vmlinux	EXPORT_SYMBOL_GPL	
++0xa349d6c0	i2c_parse_fw_timings	vmlinux	EXPORT_SYMBOL_GPL	
++0xefeefc09	__SCK__tp_func_dma_fence_emit	vmlinux	EXPORT_SYMBOL	
++0x5b146f0a	dev_pm_qos_hide_latency_tolerance	vmlinux	EXPORT_SYMBOL_GPL	
++0x01dd23c6	show_class_attr_string	vmlinux	EXPORT_SYMBOL_GPL	
++0xe8b31011	clk_hw_unregister_gate	vmlinux	EXPORT_SYMBOL_GPL	
++0xb6dfbaa6	nfs_file_mmap	vmlinux	EXPORT_SYMBOL_GPL	
++0x151f4898	schedule_timeout_uninterruptible	vmlinux	EXPORT_SYMBOL	
++0x5e299d1a	fqdir_exit	vmlinux	EXPORT_SYMBOL	
++0x424586a4	ndo_dflt_fdb_add	vmlinux	EXPORT_SYMBOL	
++0xf749b14b	pskb_extract	vmlinux	EXPORT_SYMBOL	
++0x18f15fda	ir_raw_event_set_idle	vmlinux	EXPORT_SYMBOL_GPL	
++0x88cd5876	platform_get_irq	vmlinux	EXPORT_SYMBOL_GPL	
++0xd3458b21	blk_mq_unquiesce_queue	vmlinux	EXPORT_SYMBOL_GPL	
++0x629eb646	crypto_register_rng	vmlinux	EXPORT_SYMBOL_GPL	
++0xfcf7d19a	kill_anon_super	vmlinux	EXPORT_SYMBOL	
++0xb88dbfce	irq_set_irqchip_state	vmlinux	EXPORT_SYMBOL_GPL	
++0x1d222ced	irq_get_irqchip_state	vmlinux	EXPORT_SYMBOL_GPL	
++0xaabc99f9	xfrm4_rcv	vmlinux	EXPORT_SYMBOL	
++0xb3dd29b9	of_pci_get_devfn	vmlinux	EXPORT_SYMBOL_GPL	
++0xf782fb07	percpu_ref_switch_to_atomic_sync	vmlinux	EXPORT_SYMBOL_GPL	
++0x4b6babdf	_copy_from_iter_full	vmlinux	EXPORT_SYMBOL	
++0xd3f6bc58	request_key_rcu	vmlinux	EXPORT_SYMBOL	
++0xa3874e1e	request_key_tag	vmlinux	EXPORT_SYMBOL	
++0x7ad49da7	kthread_mod_delayed_work	vmlinux	EXPORT_SYMBOL_GPL	
++0x6c2a3682	xdr_buf_subsegment	vmlinux	EXPORT_SYMBOL_GPL	
++0xeb856367	sync_file_get_fence	vmlinux	EXPORT_SYMBOL	
++0x42015580	nfs_unlink	vmlinux	EXPORT_SYMBOL_GPL	
++0xca693b56	fscache_init_cache	vmlinux	EXPORT_SYMBOL	
++0x0792c8ff	inet_dgram_connect	vmlinux	EXPORT_SYMBOL	
++0xaed26177	sock_set_keepalive	vmlinux	EXPORT_SYMBOL	
++0x88c2f5d3	usb_find_alt_setting	vmlinux	EXPORT_SYMBOL_GPL	
++0xd580b92b	phy_connect	vmlinux	EXPORT_SYMBOL	
++0xa7f13da6	dev_pm_disable_wake_irq	vmlinux	EXPORT_SYMBOL_GPL	
++0xeecfba26	driver_unregister	vmlinux	EXPORT_SYMBOL_GPL	
++0x22f75cd5	xa_load	vmlinux	EXPORT_SYMBOL	
++0x4336fcca	ucs2_as_utf8	vmlinux	EXPORT_SYMBOL	
++0x6bf5ba33	set_cached_acl	vmlinux	EXPORT_SYMBOL	
++0xa5e6ab7a	param_ops_ulong	vmlinux	EXPORT_SYMBOL	
++0x36fda2fe	phy_package_join	vmlinux	EXPORT_SYMBOL_GPL	
++0x50f3225c	iscsi_unblock_session	vmlinux	EXPORT_SYMBOL_GPL	
++0xf37b5b62	tty_buffer_set_limit	vmlinux	EXPORT_SYMBOL_GPL	
++0x17e432a2	fwnode_get_named_gpiod	vmlinux	EXPORT_SYMBOL_GPL	
++0x64bd70bc	kobject_put	vmlinux	EXPORT_SYMBOL	
++0x6a5bd0c3	kobject_get	vmlinux	EXPORT_SYMBOL	
++0xd5c1dcf8	nfs_kill_super	vmlinux	EXPORT_SYMBOL_GPL	
++0xb84bb3f3	begin_new_exec	vmlinux	EXPORT_SYMBOL	
++0xfdb5b2bb	relay_open	vmlinux	EXPORT_SYMBOL_GPL	
++0xdd2ba875	param_set_copystring	vmlinux	EXPORT_SYMBOL	
++0xc9634df9	in6addr_linklocal_allrouters	vmlinux	EXPORT_SYMBOL	
++0xb91cfe12	reuseport_select_sock	vmlinux	EXPORT_SYMBOL	
++0xfc8fee55	usb_scuttle_anchored_urbs	vmlinux	EXPORT_SYMBOL_GPL	
++0x2f0ddbf6	vchan_tx_submit	vmlinux	EXPORT_SYMBOL_GPL	
++0x58b73bc7	match_wildcard	vmlinux	EXPORT_SYMBOL	
++0x975519c1	asymmetric_key_id_same	vmlinux	EXPORT_SYMBOL_GPL	
++0x344cbd13	relay_close	vmlinux	EXPORT_SYMBOL_GPL	
++0xbfa3a9a2	net_ns_get_ownership	vmlinux	EXPORT_SYMBOL_GPL	
++0x696f2b63	of_changeset_init	vmlinux	EXPORT_SYMBOL_GPL	
++0x58bcf309	usb_reset_configuration	vmlinux	EXPORT_SYMBOL_GPL	
++0xa173364b	pwm_free	vmlinux	EXPORT_SYMBOL_GPL	
++0x50624917	sha1_init	vmlinux	EXPORT_SYMBOL	
++0xba53a1ef	__SCK__tp_func_pnfs_mds_fallback_pg_init_read	vmlinux	EXPORT_SYMBOL_GPL	
++0x7d507d01	sysfs_merge_group	vmlinux	EXPORT_SYMBOL_GPL	
++0x33b5de32	dq_data_lock	vmlinux	EXPORT_SYMBOL	
++0xc84a0a7e	seq_hlist_start_rcu	vmlinux	EXPORT_SYMBOL	
++0xfa99aa0e	__cleancache_put_page	vmlinux	EXPORT_SYMBOL	
++0x370b40be	__cleancache_get_page	vmlinux	EXPORT_SYMBOL	
++0xe9ffc063	down_trylock	vmlinux	EXPORT_SYMBOL	
++0x3228cd4f	rpc_clnt_setup_test_and_add_xprt	vmlinux	EXPORT_SYMBOL_GPL	
++0x643abe52	genl_register_family	vmlinux	EXPORT_SYMBOL	
++0xc37ce02e	of_phy_get_and_connect	vmlinux	EXPORT_SYMBOL	
++0x2b7a63ce	phy_suspend	vmlinux	EXPORT_SYMBOL	
++0x82226c53	pinctrl_unregister_mappings	vmlinux	EXPORT_SYMBOL_GPL	
++0xf3e6402e	__bitmap_equal	vmlinux	EXPORT_SYMBOL	
++0xa20f04d8	page_zero_new_buffers	vmlinux	EXPORT_SYMBOL	
++0x6d875bb2	mntget	vmlinux	EXPORT_SYMBOL	
++0x39932386	mntput	vmlinux	EXPORT_SYMBOL	
++0x08df9ad2	fasync_helper	vmlinux	EXPORT_SYMBOL	
++0xf3b451ca	kdb_poll_funcs	vmlinux	EXPORT_SYMBOL_GPL	
++0x9b9071cb	get_old_itimerspec32	vmlinux	EXPORT_SYMBOL_GPL	
++0xc98fa91b	log_buf_len_get	vmlinux	EXPORT_SYMBOL_GPL	
++0x224f51bf	nvmem_device_cell_read	vmlinux	EXPORT_SYMBOL_GPL	
++0xe208198f	phy_resolve_aneg_linkmode	vmlinux	EXPORT_SYMBOL_GPL	
++0x3a24fb2f	percpu_ref_resurrect	vmlinux	EXPORT_SYMBOL_GPL	
++0x8228a3b2	blk_mq_flush_busy_ctxs	vmlinux	EXPORT_SYMBOL_GPL	
++0x92fad363	pnfs_ld_write_done	vmlinux	EXPORT_SYMBOL_GPL	
++0x2f4113a2	dcookie_register	vmlinux	EXPORT_SYMBOL_GPL	
++0xf3e13099	locks_mandatory_area	vmlinux	EXPORT_SYMBOL	
++0x7babcbe2	tcf_exts_dump_stats	vmlinux	EXPORT_SYMBOL	
++0x2b9238d2	sock_alloc_send_pskb	vmlinux	EXPORT_SYMBOL	
++0x5e10b68c	xhci_resume	vmlinux	EXPORT_SYMBOL_GPL	
++0xaad0ae78	__bitmap_shift_right	vmlinux	EXPORT_SYMBOL	
++0xe84e6b92	exportfs_encode_inode_fh	vmlinux	EXPORT_SYMBOL_GPL	
++0x172d2ea3	nfs_request_add_commit_list_locked	vmlinux	EXPORT_SYMBOL_GPL	
++0xaaa918c9	ftrace_dump	vmlinux	EXPORT_SYMBOL_GPL	
++0x9c492370	alarm_init	vmlinux	EXPORT_SYMBOL_GPL	
++0xa24f23d8	__request_module	vmlinux	EXPORT_SYMBOL	
++0x2a47c8fc	fib_nexthop_info	vmlinux	EXPORT_SYMBOL_GPL	
++0x9e727959	ip_valid_fib_dump_req	vmlinux	EXPORT_SYMBOL_GPL	
++0x00ac4f18	inet_register_protosw	vmlinux	EXPORT_SYMBOL	
++0x7a865b51	__inet_inherit_port	vmlinux	EXPORT_SYMBOL_GPL	
++0x4eef20a2	dev_deactivate	vmlinux	EXPORT_SYMBOL	
++0x5fc294ef	usb_ep_clear_halt	vmlinux	EXPORT_SYMBOL_GPL	
++0x424d4ac1	usb_asmedia_modifyflowcontrol	vmlinux	EXPORT_SYMBOL_GPL	
++0xc1ca1d62	phy_find_first	vmlinux	EXPORT_SYMBOL	
++0xe0c9175e	pm_runtime_force_suspend	vmlinux	EXPORT_SYMBOL_GPL	
++0xd0aecd8e	uart_console_device	vmlinux	EXPORT_SYMBOL_GPL	
++0xa8e9abb0	idr_alloc_u32	vmlinux	EXPORT_SYMBOL_GPL	
++0x9559852a	submit_bio_wait	vmlinux	EXPORT_SYMBOL	
++0x23fd3028	vmalloc_node	vmlinux	EXPORT_SYMBOL	
++0xd6ff38fe	mempool_destroy	vmlinux	EXPORT_SYMBOL	
++0x054e550b	kernel_halt	vmlinux	EXPORT_SYMBOL_GPL	
++0xb51f00a2	netpoll_cleanup	vmlinux	EXPORT_SYMBOL	
++0x6d57befc	__traceiter_iscsi_dbg_session	vmlinux	EXPORT_SYMBOL_GPL	
++0x87037914	scsi_ioctl	vmlinux	EXPORT_SYMBOL	
++0xdd81d8f6	__SCK__tp_func_block_bio_complete	vmlinux	EXPORT_SYMBOL_GPL	
++0x386ea8ef	set_binfmt	vmlinux	EXPORT_SYMBOL	
++0xdf0bc36f	km_policy_expired	vmlinux	EXPORT_SYMBOL	
++0x54da4276	i2c_client_type	vmlinux	EXPORT_SYMBOL_GPL	
++0x69d91c03	usb_add_gadget_udc_release	vmlinux	EXPORT_SYMBOL_GPL	
++0xafe6ccbb	pci_user_write_config_word	vmlinux	EXPORT_SYMBOL_GPL	
++0xceab0311	strchrnul	vmlinux	EXPORT_SYMBOL	
++0xba4494e3	pci_iomap_wc	vmlinux	EXPORT_SYMBOL_GPL	
++0xfb0fc6af	elv_rb_find	vmlinux	EXPORT_SYMBOL	
++0x67e4de3c	crypto_shash_tfm_digest	vmlinux	EXPORT_SYMBOL_GPL	
++0xab941043	flow_rule_match_basic	vmlinux	EXPORT_SYMBOL	
++0xefa644e5	call_fib_notifiers	vmlinux	EXPORT_SYMBOL	
++0x263f8f82	DWC_CPU_TO_BE16	vmlinux	EXPORT_SYMBOL	
++0x8f74c17f	DWC_CPU_TO_BE32	vmlinux	EXPORT_SYMBOL	
++0x7f770504	devm_reset_controller_register	vmlinux	EXPORT_SYMBOL_GPL	
++0x6f05ffac	regulator_bulk_force_disable	vmlinux	EXPORT_SYMBOL_GPL	
++0x627197fe	kstrdup_quotable_cmdline	vmlinux	EXPORT_SYMBOL_GPL	
++0x9829fc11	__kfifo_out_peek_r	vmlinux	EXPORT_SYMBOL	
++0x198620d7	security_add_mnt_opt	vmlinux	EXPORT_SYMBOL	
++0xf77e0d9e	fscache_object_mark_killed	vmlinux	EXPORT_SYMBOL	
++0x96f33469	netlink_ns_capable	vmlinux	EXPORT_SYMBOL	
++0xc4212ab9	qdisc_class_hash_insert	vmlinux	EXPORT_SYMBOL	
++0x9b2b03bc	eth_commit_mac_addr_change	vmlinux	EXPORT_SYMBOL	
++0xe5867808	dlci_ioctl_set	vmlinux	EXPORT_SYMBOL	
++0x8255e34f	DWC_ATOI	vmlinux	EXPORT_SYMBOL	
++0xddb12f16	stmpe_set_altfunc	vmlinux	EXPORT_SYMBOL_GPL	
++0x39a7affc	driver_deferred_probe_timeout	vmlinux	EXPORT_SYMBOL_GPL	
++0x82cb01a6	pci_set_host_bridge_release	vmlinux	EXPORT_SYMBOL_GPL	
++0x96a2316a	refcount_dec_and_lock_irqsave	vmlinux	EXPORT_SYMBOL	
++0xde3d09e1	generic_perform_write	vmlinux	EXPORT_SYMBOL	
++0x6a433d30	__rpc_wait_for_completion_task	vmlinux	EXPORT_SYMBOL_GPL	
++0xc6473150	udp_set_csum	vmlinux	EXPORT_SYMBOL	
++0xe825822a	__traceiter_spi_transfer_stop	vmlinux	EXPORT_SYMBOL	
++0x10383495	scsi_print_sense	vmlinux	EXPORT_SYMBOL	
++0xaae73871	scsi_report_device_reset	vmlinux	EXPORT_SYMBOL	
++0x0904eb7d	devm_phy_optional_get	vmlinux	EXPORT_SYMBOL_GPL	
++0x054bef45	layoutstats_timer	vmlinux	EXPORT_SYMBOL_GPL	
++0x98602f2b	pnfs_read_resend_pnfs	vmlinux	EXPORT_SYMBOL_GPL	
++0x6e81f032	__SCK__tp_func_nfs_fsync_exit	vmlinux	EXPORT_SYMBOL_GPL	
++0x16d55ee9	config_item_get_unless_zero	vmlinux	EXPORT_SYMBOL	
++0xd582d993	opens_in_grace	vmlinux	EXPORT_SYMBOL_GPL	
++0x913ca9ca	locks_free_lock	vmlinux	EXPORT_SYMBOL	
++0x318e518d	fixed_size_llseek	vmlinux	EXPORT_SYMBOL	
++0xa8ed1a2d	inet6_add_offload	vmlinux	EXPORT_SYMBOL	
++0xd67624c1	register_sound_mixer	vmlinux	EXPORT_SYMBOL	
++0x83d2cf51	mmc_regulator_set_ocr	vmlinux	EXPORT_SYMBOL_GPL	
++0xe397b0f4	regmap_test_bits	vmlinux	EXPORT_SYMBOL_GPL	
++0x8bb9a25a	regulator_allow_bypass	vmlinux	EXPORT_SYMBOL_GPL	
++0x172ad4e8	regulator_get_optional	vmlinux	EXPORT_SYMBOL_GPL	
++0xc3b062c9	sg_miter_skip	vmlinux	EXPORT_SYMBOL	
++0xd21e97e5	simple_attr_release	vmlinux	EXPORT_SYMBOL_GPL	
++0x77a08179	perf_aux_output_flag	vmlinux	EXPORT_SYMBOL_GPL	
++0x0f052b51	reuseport_detach_prog	vmlinux	EXPORT_SYMBOL	
++0x2cc495c5	rpi_firmware_property_list	vmlinux	EXPORT_SYMBOL_GPL	
++0x3565180e	led_sysfs_disable	vmlinux	EXPORT_SYMBOL_GPL	
++0x4fb26f88	usb_submit_urb	vmlinux	EXPORT_SYMBOL_GPL	
++0x5f83e8c9	fwnode_get_next_available_child_node	vmlinux	EXPORT_SYMBOL_GPL	
++0xa93ccdd5	blk_queue_set_zoned	vmlinux	EXPORT_SYMBOL_GPL	
++0x0f35f985	fscrypt_fname_siphash	vmlinux	EXPORT_SYMBOL_GPL	
++0x5a67d502	rename_lock	vmlinux	EXPORT_SYMBOL	
++0xd3012ca1	page_symlink_inode_operations	vmlinux	EXPORT_SYMBOL	
++0x5d245604	file_path	vmlinux	EXPORT_SYMBOL	
++0xdae2cd90	xprt_put	vmlinux	EXPORT_SYMBOL_GPL	
++0x1fbd16da	ip_tos2prio	vmlinux	EXPORT_SYMBOL	
++0x6545268e	__tracepoint_neigh_cleanup_and_release	vmlinux	EXPORT_SYMBOL_GPL	
++0x11f97a4b	regmap_field_alloc	vmlinux	EXPORT_SYMBOL_GPL	
++0x5a3a30f1	pinctrl_register	vmlinux	EXPORT_SYMBOL_GPL	
++0x4399f1b3	gen_pool_set_algo	vmlinux	EXPORT_SYMBOL	
++0x4af6ddf0	kstrtou16	vmlinux	EXPORT_SYMBOL	
++0x5c3c7387	kstrtoull	vmlinux	EXPORT_SYMBOL	
++0xacd81eb3	jbd2_inode_cache	vmlinux	EXPORT_SYMBOL	
++0x94961283	vunmap	vmlinux	EXPORT_SYMBOL	
++0x452c2ea7	write_cache_pages	vmlinux	EXPORT_SYMBOL	
++0xdd24e065	xfrm_policy_alloc	vmlinux	EXPORT_SYMBOL	
++0xe9a6048e	sock_set_reuseport	vmlinux	EXPORT_SYMBOL	
++0x162e7d97	led_blink_set	vmlinux	EXPORT_SYMBOL_GPL	
++0xe7103c5e	devm_thermal_of_cooling_device_register	vmlinux	EXPORT_SYMBOL_GPL	
++0x5ecd15f5	mipi_dsi_dcs_enter_sleep_mode	vmlinux	EXPORT_SYMBOL	
++0xe5c78a99	do_blank_screen	vmlinux	EXPORT_SYMBOL	
++0x5a290250	hdmi_drm_infoframe_pack_only	vmlinux	EXPORT_SYMBOL	
++0x595c8918	pci_check_and_unmask_intx	vmlinux	EXPORT_SYMBOL_GPL	
++0x67da9f7c	sha512_zero_message_hash	vmlinux	EXPORT_SYMBOL_GPL	
++0x84252c87	fscrypt_get_symlink	vmlinux	EXPORT_SYMBOL_GPL	
++0x885d6f5a	finish_open	vmlinux	EXPORT_SYMBOL	
++0x8ae8fa4d	kmem_cache_create_usercopy	vmlinux	EXPORT_SYMBOL	
++0xb912560d	static_key_disable	vmlinux	EXPORT_SYMBOL_GPL	
++0xf6f16c56	rcu_barrier_tasks	vmlinux	EXPORT_SYMBOL_GPL	
++0x117093be	qdisc_class_hash_init	vmlinux	EXPORT_SYMBOL	
++0x94ed945b	of_mdiobus_child_is_phy	vmlinux	EXPORT_SYMBOL	
++0x11377ec9	fwnode_property_read_string	vmlinux	EXPORT_SYMBOL_GPL	
++0xfa873ad0	prandom_seed	vmlinux	EXPORT_SYMBOL	
++0xd96ba9c6	get_acl	vmlinux	EXPORT_SYMBOL	
++0x6cd3ac01	set_page_dirty_lock	vmlinux	EXPORT_SYMBOL	
++0xbd13d055	cache_unregister_net	vmlinux	EXPORT_SYMBOL_GPL	
++0xea5ce790	tcp_v4_conn_request	vmlinux	EXPORT_SYMBOL	
++0x51793353	tcp_sock_set_keepidle	vmlinux	EXPORT_SYMBOL	
++0x8a0d1eee	netdev_get_xmit_slave	vmlinux	EXPORT_SYMBOL	
++0xba0d612b	rtc_add_group	vmlinux	EXPORT_SYMBOL	
++0xd220e14f	usb_get_descriptor	vmlinux	EXPORT_SYMBOL_GPL	
++0x31fb9f11	genphy_c45_read_link	vmlinux	EXPORT_SYMBOL_GPL	
++0x25083e06	spi_async_locked	vmlinux	EXPORT_SYMBOL_GPL	
++0x643f3068	__tracepoint_spi_transfer_stop	vmlinux	EXPORT_SYMBOL	
++0xe9f9b48d	blk_rq_init	vmlinux	EXPORT_SYMBOL	
++0x025281aa	__wake_up_locked_sync_key	vmlinux	EXPORT_SYMBOL_GPL	
++0xb2ead97c	kimage_vaddr	vmlinux	EXPORT_SYMBOL	
++0x6d0b9eb9	icmp_ndo_send	vmlinux	EXPORT_SYMBOL	
++0x2dd182c2	tcp_v4_syn_recv_sock	vmlinux	EXPORT_SYMBOL	
++0xe74823e5	usb_put_dev	vmlinux	EXPORT_SYMBOL_GPL	
++0xdd742d72	__sg_free_table	vmlinux	EXPORT_SYMBOL	
++0x6c63337b	kmem_cache_shrink	vmlinux	EXPORT_SYMBOL	
++0x5d49aabc	init_wait_var_entry	vmlinux	EXPORT_SYMBOL	
++0x49045426	icmp_err_convert	vmlinux	EXPORT_SYMBOL	
++0xf9510c52	mdio_device_create	vmlinux	EXPORT_SYMBOL	
++0xcf07d8f8	mii_check_link	vmlinux	EXPORT_SYMBOL	
++0xddd810be	gpiod_get_optional	vmlinux	EXPORT_SYMBOL_GPL	
++0x28ab4fb9	pinctrl_gpio_free	vmlinux	EXPORT_SYMBOL_GPL	
++0xb7f990e9	rht_bucket_nested	vmlinux	EXPORT_SYMBOL_GPL	
++0xd011359b	blkcg_policy_register	vmlinux	EXPORT_SYMBOL_GPL	
++0xf66eed40	tcp_hashinfo	vmlinux	EXPORT_SYMBOL	
++0x2d140a58	genl_unlock	vmlinux	EXPORT_SYMBOL	
++0x788f56d4	of_changeset_action	vmlinux	EXPORT_SYMBOL_GPL	
++0x08b10bb2	of_n_size_cells	vmlinux	EXPORT_SYMBOL	
++0x06d7de4a	hid_report_raw_event	vmlinux	EXPORT_SYMBOL_GPL	
++0x3d766cc3	dma_buf_begin_cpu_access	vmlinux	EXPORT_SYMBOL_GPL	
++0xcd262181	blk_mq_requeue_request	vmlinux	EXPORT_SYMBOL	
++0x666c15b2	crypto_aead_setauthsize	vmlinux	EXPORT_SYMBOL_GPL	
++0x25c1626c	nlmclnt_init	vmlinux	EXPORT_SYMBOL_GPL	
++0xeae8522f	__tracepoint_nfs4_pnfs_commit_ds	vmlinux	EXPORT_SYMBOL_GPL	
++0xaac82d54	fd_install	vmlinux	EXPORT_SYMBOL	
++0xd5fb867b	inet6_unregister_icmp_sender	vmlinux	EXPORT_SYMBOL	
++0x291a8f35	__phy_resume	vmlinux	EXPORT_SYMBOL	
++0xbdcd7e67	spi_mem_get_name	vmlinux	EXPORT_SYMBOL_GPL	
++0xb51686cf	iscsi_get_conn	vmlinux	EXPORT_SYMBOL_GPL	
++0xe20c82b9	bio_devname	vmlinux	EXPORT_SYMBOL	
++0x93e0c16b	vfs_fsync_range	vmlinux	EXPORT_SYMBOL	
++0x0e0cc052	memory_cgrp_subsys	vmlinux	EXPORT_SYMBOL	
++0xd4935851	__SCK__tp_func_suspend_resume	vmlinux	EXPORT_SYMBOL_GPL	
++0x3ce4ca6f	disable_irq	vmlinux	EXPORT_SYMBOL	
++0x55eecff4	bit_wait_io_timeout	vmlinux	EXPORT_SYMBOL_GPL	
++0xdc9fa232	raw_notifier_chain_register	vmlinux	EXPORT_SYMBOL_GPL	
++0x8e4eb451	bpf_sk_storage_diag_free	vmlinux	EXPORT_SYMBOL_GPL	
++0xcc56587f	scsi_host_alloc	vmlinux	EXPORT_SYMBOL	
++0x9bc6f0db	bus_get_device_klist	vmlinux	EXPORT_SYMBOL_GPL	
++0xfbb8a761	strscpy_pad	vmlinux	EXPORT_SYMBOL	
++0xe8f3500e	nfs_create	vmlinux	EXPORT_SYMBOL_GPL	
++0x863b2a10	fscrypt_drop_inode	vmlinux	EXPORT_SYMBOL_GPL	
++0xdf645a1a	path_put	vmlinux	EXPORT_SYMBOL	
++0xc59b91ad	apply_to_page_range	vmlinux	EXPORT_SYMBOL_GPL	
++0x1984d421	out_of_line_wait_on_bit	vmlinux	EXPORT_SYMBOL	
++0xb0323d01	xfrm4_protocol_deregister	vmlinux	EXPORT_SYMBOL	
++0xf78f3e48	led_set_brightness_sync	vmlinux	EXPORT_SYMBOL_GPL	
++0xc7fcbabe	gen10g_config_aneg	vmlinux	EXPORT_SYMBOL_GPL	
++0x1d0d9b8b	pci_request_irq	vmlinux	EXPORT_SYMBOL	
++0x73c2554f	__iowrite64_copy	vmlinux	EXPORT_SYMBOL_GPL	
++0x22b0c97b	map_kernel_range	vmlinux	EXPORT_SYMBOL	
++0x2140ac20	handle_mm_fault	vmlinux	EXPORT_SYMBOL_GPL	
++0xd217e9e6	trace_set_clr_event	vmlinux	EXPORT_SYMBOL_GPL	
++0xdced0f90	blk_add_driver_data	vmlinux	EXPORT_SYMBOL_GPL	
++0x83306ce3	kmsg_dump_rewind	vmlinux	EXPORT_SYMBOL_GPL	
++0xfa9ca9d4	kick_process	vmlinux	EXPORT_SYMBOL_GPL	
++0x85c54b61	efivar_validate	vmlinux	EXPORT_SYMBOL_GPL	
++0x3decc99a	__devm_spi_alloc_controller	vmlinux	EXPORT_SYMBOL_GPL	
++0x09e0fd70	soc_device_register	vmlinux	EXPORT_SYMBOL_GPL	
++0xbfbc5434	pciserial_resume_ports	vmlinux	EXPORT_SYMBOL_GPL	
++0xe84f6e5c	pciserial_remove_ports	vmlinux	EXPORT_SYMBOL_GPL	
++0x6ec8f089	sg_miter_stop	vmlinux	EXPORT_SYMBOL	
++0x0da10ec3	security_sock_graft	vmlinux	EXPORT_SYMBOL	
++0x5a0c951c	key_reject_and_link	vmlinux	EXPORT_SYMBOL	
++0x5e347ded	jbd2_journal_init_jbd_inode	vmlinux	EXPORT_SYMBOL	
++0xe46021ca	_raw_spin_unlock_bh	vmlinux	EXPORT_SYMBOL	
++0x8954dc8e	__SCK__tp_func_br_fdb_external_learn_add	vmlinux	EXPORT_SYMBOL_GPL	
++0x4b0a3f52	gic_nonsecure_priorities	vmlinux	EXPORT_SYMBOL	
++0xaeac049a	generate_random_guid	vmlinux	EXPORT_SYMBOL	
++0x8d3ded5b	__sg_alloc_table_from_pages	vmlinux	EXPORT_SYMBOL	
++0xb1d3a15c	blk_finish_plug	vmlinux	EXPORT_SYMBOL	
++0x8ebeb2b5	fscache_put_operation	vmlinux	EXPORT_SYMBOL	
++0x0b1beb31	vmalloc_32_user	vmlinux	EXPORT_SYMBOL	
++0x9a0a83ab	ping_recvmsg	vmlinux	EXPORT_SYMBOL_GPL	
++0x3c09533e	dev_pm_opp_unregister_set_opp_helper	vmlinux	EXPORT_SYMBOL_GPL	
++0xfab30dc0	mdio_bus_exit	vmlinux	EXPORT_SYMBOL_GPL	
++0x49bbbf0f	pm_clk_add_clk	vmlinux	EXPORT_SYMBOL_GPL	
++0xec2aea44	pci_get_subsys	vmlinux	EXPORT_SYMBOL	
++0x2e028ae6	rcutorture_get_gp_data	vmlinux	EXPORT_SYMBOL_GPL	
++0x6c79e19e	ip_local_out	vmlinux	EXPORT_SYMBOL_GPL	
++0x5cb01526	dev_pm_opp_find_freq_floor	vmlinux	EXPORT_SYMBOL_GPL	
++0x4383765d	usb_hcd_check_unlink_urb	vmlinux	EXPORT_SYMBOL_GPL	
++0x1e9c590a	usb_find_common_endpoints_reverse	vmlinux	EXPORT_SYMBOL_GPL	
++0x3d346eb1	genphy_check_and_restart_aneg	vmlinux	EXPORT_SYMBOL	
++0xa7bfbcf4	phy_device_free	vmlinux	EXPORT_SYMBOL	
++0x3efdfc90	regcache_cache_bypass	vmlinux	EXPORT_SYMBOL_GPL	
++0x3c94a2fd	fwnode_graph_get_remote_endpoint	vmlinux	EXPORT_SYMBOL_GPL	
++0x81188c30	match_string	vmlinux	EXPORT_SYMBOL	
++0x3d9ee9f0	clear_page	vmlinux	EXPORT_SYMBOL	
++0x0ce19729	mb_cache_entry_touch	vmlinux	EXPORT_SYMBOL	
++0xd833a154	generic_permission	vmlinux	EXPORT_SYMBOL	
++0x585ae877	nmi_panic	vmlinux	EXPORT_SYMBOL	
++0x85540ebc	nvmem_cell_put	vmlinux	EXPORT_SYMBOL_GPL	
++0xe98f55f2	arm_smccc_get_version	vmlinux	EXPORT_SYMBOL_GPL	
++0x0a5cf872	usbnet_open	vmlinux	EXPORT_SYMBOL_GPL	
++0xb63dcf01	pci_msi_mask_irq	vmlinux	EXPORT_SYMBOL_GPL	
++0xa6af1e35	__SCK__tp_func_block_rq_remap	vmlinux	EXPORT_SYMBOL_GPL	
++0x70c2c7ea	pids_cgrp_subsys_on_dfl_key	vmlinux	EXPORT_SYMBOL_GPL	
++0x506ab3a9	usb_ep_queue	vmlinux	EXPORT_SYMBOL_GPL	
++0xd39e80f7	mdio_device_register	vmlinux	EXPORT_SYMBOL	
++0x1d2c4d25	regmap_async_complete	vmlinux	EXPORT_SYMBOL_GPL	
++0xd6d7a809	uart_get_baud_rate	vmlinux	EXPORT_SYMBOL	
++0x24f39c39	reset_control_reset	vmlinux	EXPORT_SYMBOL_GPL	
++0x4100a662	clk_get_scaled_duty_cycle	vmlinux	EXPORT_SYMBOL_GPL	
++0x327f6e67	pci_find_next_bus	vmlinux	EXPORT_SYMBOL	
++0x6e858888	gen_pool_fixed_alloc	vmlinux	EXPORT_SYMBOL	
++0x3391ad16	atomic_notifier_chain_unregister	vmlinux	EXPORT_SYMBOL_GPL	
++0x46b296c3	usbnet_disconnect	vmlinux	EXPORT_SYMBOL_GPL	
++0xdb3322bd	scsi_vpd_tpg_id	vmlinux	EXPORT_SYMBOL	
++0x6430a989	serdev_device_alloc	vmlinux	EXPORT_SYMBOL_GPL	
++0x508db635	clk_register_gate	vmlinux	EXPORT_SYMBOL_GPL	
++0xa4c4d150	__traceiter_pnfs_mds_fallback_read_pagelist	vmlinux	EXPORT_SYMBOL_GPL	
++0x097f8546	kgdb_register_io_module	vmlinux	EXPORT_SYMBOL_GPL	
++0x0fff5afc	time64_to_tm	vmlinux	EXPORT_SYMBOL	
++0x8b6abc43	set_user_nice	vmlinux	EXPORT_SYMBOL	
++0x31dab445	gss_pseudoflavor_to_service	vmlinux	EXPORT_SYMBOL	
++0x2f770745	netdev_notify_peers	vmlinux	EXPORT_SYMBOL	
++0xb4061db7	iscsi_create_flashnode_conn	vmlinux	EXPORT_SYMBOL_GPL	
++0xb035957b	devm_serdev_device_open	vmlinux	EXPORT_SYMBOL_GPL	
++0xf89b0eac	splice_direct_to_actor	vmlinux	EXPORT_SYMBOL	
++0x9e18ad72	rpc_release_client	vmlinux	EXPORT_SYMBOL_GPL	
++0x2b9da7a4	genl_lock	vmlinux	EXPORT_SYMBOL	
++0x53d35985	qdisc_class_hash_grow	vmlinux	EXPORT_SYMBOL	
++0xa8de1369	__dev_kfree_skb_any	vmlinux	EXPORT_SYMBOL	
++0xb793876b	__dev_kfree_skb_irq	vmlinux	EXPORT_SYMBOL	
++0x07fb6eb6	sock_setsockopt	vmlinux	EXPORT_SYMBOL	
++0x6538d9c6	usb_unlocked_enable_lpm	vmlinux	EXPORT_SYMBOL_GPL	
++0x35f17e21	tty_port_close_start	vmlinux	EXPORT_SYMBOL	
++0x656b55a3	dma_find_channel	vmlinux	EXPORT_SYMBOL	
++0x4c9365e0	fb_find_mode	vmlinux	EXPORT_SYMBOL	
++0x9df6e85a	blk_mq_init_queue_data	vmlinux	EXPORT_SYMBOL_GPL	
++0x5cf6c763	unlock_buffer	vmlinux	EXPORT_SYMBOL	
++0x012716e9	simple_transaction_release	vmlinux	EXPORT_SYMBOL	
++0xc41bc980	iwe_stream_add_value	vmlinux	EXPORT_SYMBOL	
++0xa61ced89	qdisc_put_rtab	vmlinux	EXPORT_SYMBOL	
++0x31613e36	extcon_find_edev_by_node	vmlinux	EXPORT_SYMBOL_GPL	
++0x21f6a36c	mmc_abort_tuning	vmlinux	EXPORT_SYMBOL_GPL	
++0xc1f16b6f	regmap_irq_get_domain	vmlinux	EXPORT_SYMBOL_GPL	
++0xdfc4afbe	subsys_find_device_by_id	vmlinux	EXPORT_SYMBOL_GPL	
++0x50d52a7d	vga_put	vmlinux	EXPORT_SYMBOL	
++0x09769037	dmt_modes	vmlinux	EXPORT_SYMBOL	
++0x40f8bd4e	klist_add_before	vmlinux	EXPORT_SYMBOL_GPL	
++0xa6db352c	crypto_register_rngs	vmlinux	EXPORT_SYMBOL_GPL	
++0xedbde752	key_invalidate	vmlinux	EXPORT_SYMBOL	
++0x37f3586b	nfs_commit_free	vmlinux	EXPORT_SYMBOL_GPL	
++0x6c7a0323	__tracepoint_kmem_cache_alloc	vmlinux	EXPORT_SYMBOL	
++0x3928efe9	__per_cpu_offset	vmlinux	EXPORT_SYMBOL	
++0xc1e4a4fe	freq_qos_update_request	vmlinux	EXPORT_SYMBOL_GPL	
++0x937b50e0	proto_register	vmlinux	EXPORT_SYMBOL	
++0x5b37236f	spi_replace_transfers	vmlinux	EXPORT_SYMBOL_GPL	
++0x24d34303	to_software_node	vmlinux	EXPORT_SYMBOL_GPL	
++0xb6e95518	_dev_crit	vmlinux	EXPORT_SYMBOL	
++0xebe4aff9	tty_wakeup	vmlinux	EXPORT_SYMBOL_GPL	
++0x9e3e9c4c	amba_ahb_device_add	vmlinux	EXPORT_SYMBOL_GPL	
++0x7990bac5	gen_pool_virt_to_phys	vmlinux	EXPORT_SYMBOL	
++0x8e470186	ip_sock_set_mtu_discover	vmlinux	EXPORT_SYMBOL	
++0x149b59d3	tcf_block_put	vmlinux	EXPORT_SYMBOL	
++0x80881dac	genphy_write_mmd_unsupported	vmlinux	EXPORT_SYMBOL	
++0xb9478d90	hdmi_drm_infoframe_unpack_only	vmlinux	EXPORT_SYMBOL	
++0x8654de52	__traceiter_pnfs_mds_fallback_write_pagelist	vmlinux	EXPORT_SYMBOL_GPL	
++0x0fb2f8a4	mktime64	vmlinux	EXPORT_SYMBOL	
++0x4863274b	down_read	vmlinux	EXPORT_SYMBOL	
++0xb35c0c9a	km_report	vmlinux	EXPORT_SYMBOL	
++0x3f512fd0	tcp_sock_set_nodelay	vmlinux	EXPORT_SYMBOL	
++0x5de928ea	skb_copy_expand	vmlinux	EXPORT_SYMBOL	
++0x7287914e	of_nvmem_device_get	vmlinux	EXPORT_SYMBOL_GPL	
++0xf3e1dd04	device_property_read_string_array	vmlinux	EXPORT_SYMBOL_GPL	
++0xf938c0c4	transport_setup_device	vmlinux	EXPORT_SYMBOL_GPL	
++0x950ee7d1	fb_find_logo	vmlinux	EXPORT_SYMBOL_GPL	
++0x9e9926cb	pci_release_resource	vmlinux	EXPORT_SYMBOL	
++0x5d486ad3	nfs_alloc_server	vmlinux	EXPORT_SYMBOL_GPL	
++0xc68bffd6	sysfs_groups_change_owner	vmlinux	EXPORT_SYMBOL_GPL	
++0xc1d8cfaf	__fdget	vmlinux	EXPORT_SYMBOL	
++0xcb505fdb	d_lookup	vmlinux	EXPORT_SYMBOL	
++0x5b8d2b7a	dmam_free_coherent	vmlinux	EXPORT_SYMBOL	
++0xe95e0941	vchiq_close_service	vmlinux	EXPORT_SYMBOL	
++0x478debf5	phy_10gbit_fec_features	vmlinux	EXPORT_SYMBOL_GPL	
++0x1867a203	phy_write_paged	vmlinux	EXPORT_SYMBOL	
++0x538d073d	phy_duplex_to_str	vmlinux	EXPORT_SYMBOL_GPL	
++0xf811e69d	scsi_eh_flush_done_q	vmlinux	EXPORT_SYMBOL	
++0xca15413f	ZSTD_resetDStream	vmlinux	EXPORT_SYMBOL	
++0x627ed908	pci_iomap	vmlinux	EXPORT_SYMBOL	
++0xd45cc6ca	bin2hex	vmlinux	EXPORT_SYMBOL	
++0x95730a2a	nfs_create_server	vmlinux	EXPORT_SYMBOL_GPL	
++0xda5152c1	path_is_under	vmlinux	EXPORT_SYMBOL	
++0xb350d140	unix_attach_fds	vmlinux	EXPORT_SYMBOL	
++0x634618ab	skb_morph	vmlinux	EXPORT_SYMBOL_GPL	
++0x7d5d392a	mmc_erase	vmlinux	EXPORT_SYMBOL	
++0x7c46233a	cpufreq_quick_get	vmlinux	EXPORT_SYMBOL	
++0xd8978b4e	percpu_counter_set	vmlinux	EXPORT_SYMBOL	
++0x173b49a8	rht_bucket_nested_insert	vmlinux	EXPORT_SYMBOL_GPL	
++0x584b8482	nfs_inc_attr_generation_counter	vmlinux	EXPORT_SYMBOL_GPL	
++0xb0747ed2	rcu_cpu_stall_suppress	vmlinux	EXPORT_SYMBOL_GPL	
++0xb1bcc51e	hwmon_device_register_with_info	vmlinux	EXPORT_SYMBOL_GPL	
++0x484e9ad6	scsi_remove_host	vmlinux	EXPORT_SYMBOL	
++0xb8dbccd7	of_clk_get	vmlinux	EXPORT_SYMBOL	
++0x8f743116	pci_request_selected_regions_exclusive	vmlinux	EXPORT_SYMBOL	
++0xc5f92bd4	pinctrl_register_and_init	vmlinux	EXPORT_SYMBOL_GPL	
++0xd4bd4460	radix_tree_gang_lookup_tag	vmlinux	EXPORT_SYMBOL	
++0xb972d96f	klist_add_head	vmlinux	EXPORT_SYMBOL_GPL	
++0x69e683de	uuid_gen	vmlinux	EXPORT_SYMBOL_GPL	
++0x7c0a6f0f	pnfs_ld_read_done	vmlinux	EXPORT_SYMBOL_GPL	
++0x626ce491	flush_dcache_page	vmlinux	EXPORT_SYMBOL	
++0xb9927f9e	nvme_find_get_ns	vmlinux	EXPORT_SYMBOL_GPL	NVME_TARGET_PASSTHRU
++0xe5d171fc	scsi_is_host_device	vmlinux	EXPORT_SYMBOL	
++0x719e17ff	clk_notifier_unregister	vmlinux	EXPORT_SYMBOL_GPL	
++0x83f90f5d	gpiochip_irqchip_irq_valid	vmlinux	EXPORT_SYMBOL_GPL	
++0x37320ebe	sync_dirty_buffer	vmlinux	EXPORT_SYMBOL	
++0xa1b79449	ip_tunnel_header_ops	vmlinux	EXPORT_SYMBOL	
++0xf5e209b6	tcp_reno_ssthresh	vmlinux	EXPORT_SYMBOL_GPL	
++0xb0ca0c7b	netlink_has_listeners	vmlinux	EXPORT_SYMBOL_GPL	
++0x58d9f941	__netif_napi_del	vmlinux	EXPORT_SYMBOL	
++0xc9831ad7	flow_keys_dissector	vmlinux	EXPORT_SYMBOL	
++0xbc002561	of_irq_to_resource_table	vmlinux	EXPORT_SYMBOL_GPL	
++0xcc13a0ae	of_detach_node	vmlinux	EXPORT_SYMBOL_GPL	
++0xc16be39d	iter_div_u64_rem	vmlinux	EXPORT_SYMBOL	
++0x5ec4aee6	put_sg_io_hdr	vmlinux	EXPORT_SYMBOL	
++0xb1216f81	dquot_get_next_id	vmlinux	EXPORT_SYMBOL	
++0x409032f8	dma_supported	vmlinux	EXPORT_SYMBOL	
++0x81e88f4e	tcf_exts_num_actions	vmlinux	EXPORT_SYMBOL	
++0x641465cb	usb_alloc_urb	vmlinux	EXPORT_SYMBOL_GPL	
++0x3c27e0a0	phy_driver_is_genphy	vmlinux	EXPORT_SYMBOL_GPL	
++0xd85561dc	spi_setup	vmlinux	EXPORT_SYMBOL_GPL	
++0xc447eb55	add_disk_randomness	vmlinux	EXPORT_SYMBOL_GPL	
++0xa7f44c94	serial8250_get_port	vmlinux	EXPORT_SYMBOL_GPL	
++0x25014ece	phy_optional_get	vmlinux	EXPORT_SYMBOL_GPL	
++0xb2a73d75	btree_update	vmlinux	EXPORT_SYMBOL_GPL	
++0x13f2c925	inode_init_once	vmlinux	EXPORT_SYMBOL	
++0x369fcd70	tracing_snapshot	vmlinux	EXPORT_SYMBOL_GPL	
++0xa4b07fe7	ring_buffer_change_overwrite	vmlinux	EXPORT_SYMBOL_GPL	
++0xbe687e88	wake_up_all_idle_cpus	vmlinux	EXPORT_SYMBOL_GPL	
++0x7ddacb7e	nf_ip6_checksum	vmlinux	EXPORT_SYMBOL	
++0x84e629d9	qdisc_watchdog_schedule_range_ns	vmlinux	EXPORT_SYMBOL	
++0x66f0c479	get_net_ns	vmlinux	EXPORT_SYMBOL_GPL	
++0x959d2cf0	of_get_required_opp_performance_state	vmlinux	EXPORT_SYMBOL_GPL	
++0x5cea594b	thermal_add_hwmon_sysfs	vmlinux	EXPORT_SYMBOL_GPL	
++0x398fe154	__DWC_DMA_FREE	vmlinux	EXPORT_SYMBOL	
++0x93859682	device_move	vmlinux	EXPORT_SYMBOL_GPL	
++0xd63ae1c3	bcm_dmaman_remove	vmlinux	EXPORT_SYMBOL	
++0x6257dda7	clk_rate_exclusive_get	vmlinux	EXPORT_SYMBOL_GPL	
++0x0d2b848c	gpiod_cansleep	vmlinux	EXPORT_SYMBOL_GPL	
++0xa29cbe0e	scsi_cmd_ioctl	vmlinux	EXPORT_SYMBOL	
++0x5892ca4b	page_cache_async_ra	vmlinux	EXPORT_SYMBOL_GPL	
++0xc3bbd9e1	arm64_mm_context_put	vmlinux	EXPORT_SYMBOL_GPL	
++0xd7b5c31d	arm64_mm_context_get	vmlinux	EXPORT_SYMBOL_GPL	
++0x4c077374	neigh_seq_stop	vmlinux	EXPORT_SYMBOL	
++0xb69878b1	usb_stor_clear_halt	vmlinux	EXPORT_SYMBOL_GPL	USB_STORAGE
++0x25051c37	mipi_dsi_detach	vmlinux	EXPORT_SYMBOL	
++0x0631e0a2	pci_user_write_config_dword	vmlinux	EXPORT_SYMBOL_GPL	
++0x92a25046	current_in_userns	vmlinux	EXPORT_SYMBOL	
++0xb51a3724	rpc_pipefs_notifier_unregister	vmlinux	EXPORT_SYMBOL_GPL	
++0x31d1701a	flow_rule_match_enc_control	vmlinux	EXPORT_SYMBOL	
++0x57c4d90b	dev_mc_del_global	vmlinux	EXPORT_SYMBOL	
++0x4570aed0	dev_mc_add_global	vmlinux	EXPORT_SYMBOL	
++0xead5c8e5	clk_bulk_prepare	vmlinux	EXPORT_SYMBOL_GPL	
++0x11793fe9	fb_prepare_logo	vmlinux	EXPORT_SYMBOL	
++0x489eda10	memset32	vmlinux	EXPORT_SYMBOL	
++0xd697e69a	trace_hardirqs_on	vmlinux	EXPORT_SYMBOL	
++0xaf3a44e9	__SCK__tp_func_sched_overutilized_tp	vmlinux	EXPORT_SYMBOL_GPL	
++0xc4ab3748	blocking_notifier_chain_unregister	vmlinux	EXPORT_SYMBOL_GPL	
++0x86e32369	fifo_create_dflt	vmlinux	EXPORT_SYMBOL	
++0xfb9753fe	neigh_table_init	vmlinux	EXPORT_SYMBOL	
++0x81e46332	mmc_register_driver	vmlinux	EXPORT_SYMBOL	
++0x96985073	cpuidle_register_device	vmlinux	EXPORT_SYMBOL_GPL	
++0x59b2adbf	input_ff_effect_from_user	vmlinux	EXPORT_SYMBOL_GPL	
++0xed477293	mfd_cell_enable	vmlinux	EXPORT_SYMBOL	
++0x416d0ef9	attribute_container_register	vmlinux	EXPORT_SYMBOL_GPL	
++0x436d817f	mpi_clear_bit	vmlinux	EXPORT_SYMBOL_GPL	
++0x93d3935a	blk_queue_segment_boundary	vmlinux	EXPORT_SYMBOL	
++0xc3f82a5d	acomp_request_alloc	vmlinux	EXPORT_SYMBOL_GPL	
++0x3884e83d	sysfs_create_link	vmlinux	EXPORT_SYMBOL_GPL	
++0x65aa0a0f	task_active_pid_ns	vmlinux	EXPORT_SYMBOL_GPL	
++0x01ccdb36	svc_set_client	vmlinux	EXPORT_SYMBOL_GPL	
++0x2f967081	tcp_fastopen_defer_connect	vmlinux	EXPORT_SYMBOL	
++0x16198740	inetpeer_invalidate_tree	vmlinux	EXPORT_SYMBOL	
++0x418d90ae	__neigh_create	vmlinux	EXPORT_SYMBOL	
++0x209cc3a3	cpufreq_freq_transition_end	vmlinux	EXPORT_SYMBOL_GPL	
++0xf357eb50	power_supply_powers	vmlinux	EXPORT_SYMBOL_GPL	
++0xec728dc0	DWC_ATOUI	vmlinux	EXPORT_SYMBOL	
++0x809712ff	hdmi_avi_infoframe_pack	vmlinux	EXPORT_SYMBOL	
++0x71ba66ab	pci_add_dynid	vmlinux	EXPORT_SYMBOL_GPL	
++0xfd72e3da	gpiod_set_debounce	vmlinux	EXPORT_SYMBOL_GPL	
++0x434aec4f	trace_array_destroy	vmlinux	EXPORT_SYMBOL_GPL	
++0x6d294e43	clock_t_to_jiffies	vmlinux	EXPORT_SYMBOL	
++0x6309611b	capable_wrt_inode_uidgid	vmlinux	EXPORT_SYMBOL	
++0xe97f4ce5	qword_get	vmlinux	EXPORT_SYMBOL_GPL	
++0x8cb25337	fanout_mutex	vmlinux	EXPORT_SYMBOL_GPL	
++0x05f84261	mr_vif_seq_next	vmlinux	EXPORT_SYMBOL	
++0xec7302ff	skb_mac_gso_segment	vmlinux	EXPORT_SYMBOL	
++0x713b5716	vchiq_shutdown	vmlinux	EXPORT_SYMBOL	
++0xe6562033	of_map_id	vmlinux	EXPORT_SYMBOL_GPL	
++0x4730168a	fixed_phy_register_with_gpiod	vmlinux	EXPORT_SYMBOL_GPL	
++0x74ef023e	dim_on_top	vmlinux	EXPORT_SYMBOL	
++0xf8bf8e22	ZSTD_DDictWorkspaceBound	vmlinux	EXPORT_SYMBOL	
++0x92c45fb3	pcim_iomap_table	vmlinux	EXPORT_SYMBOL	
++0x55f97111	crypto_larval_alloc	vmlinux	EXPORT_SYMBOL_GPL	
++0x96189e7e	debugfs_attr_write	vmlinux	EXPORT_SYMBOL_GPL	
++0x018574a1	mb_cache_entry_delete	vmlinux	EXPORT_SYMBOL	
++0xc0cf7239	seq_release	vmlinux	EXPORT_SYMBOL	
++0x08d4dd8e	insert_inode_locked	vmlinux	EXPORT_SYMBOL	
++0x9b6ec967	ring_buffer_size	vmlinux	EXPORT_SYMBOL_GPL	
++0xca9a1d5e	ring_buffer_free	vmlinux	EXPORT_SYMBOL_GPL	
++0x2d54a761	module_layout	vmlinux	EXPORT_SYMBOL	
++0x5c5a1b16	tick_broadcast_control	vmlinux	EXPORT_SYMBOL_GPL	
++0xdac842b2	xfrm_audit_state_notfound	vmlinux	EXPORT_SYMBOL_GPL	
++0x981a905d	lwtstate_free	vmlinux	EXPORT_SYMBOL_GPL	
++0xa01639b3	hidinput_disconnect	vmlinux	EXPORT_SYMBOL_GPL	
++0xdd73b088	pinctrl_utils_add_map_configs	vmlinux	EXPORT_SYMBOL_GPL	
++0xaf5c7282	__percpu_counter_compare	vmlinux	EXPORT_SYMBOL	
++0xfb08ed3b	blk_mq_tagset_wait_completed_request	vmlinux	EXPORT_SYMBOL	
++0xf8dea5c6	pm_clk_add	vmlinux	EXPORT_SYMBOL_GPL	
++0xe239cd5d	pinctrl_remove_gpio_range	vmlinux	EXPORT_SYMBOL_GPL	
++0x0a4c7368	elv_rb_latter_request	vmlinux	EXPORT_SYMBOL	
++0x32f186a8	sysfs_create_bin_file	vmlinux	EXPORT_SYMBOL_GPL	
++0x27fa66e1	nr_free_buffer_pages	vmlinux	EXPORT_SYMBOL_GPL	
++0x9ffb90c3	mod_delayed_work_on	vmlinux	EXPORT_SYMBOL_GPL	
++0xa79e94c0	xfrm_state_unregister_afinfo	vmlinux	EXPORT_SYMBOL	
++0x83a5708e	__traceiter_neigh_event_send_dead	vmlinux	EXPORT_SYMBOL_GPL	
++0x42d2ba6f	of_find_node_by_name	vmlinux	EXPORT_SYMBOL	
++0xa25a7ea1	_dev_emerg	vmlinux	EXPORT_SYMBOL	
++0xfb07bf40	serial8250_do_pm	vmlinux	EXPORT_SYMBOL	
++0x92fa8227	klist_init	vmlinux	EXPORT_SYMBOL_GPL	
++0x6b640864	nla_strlcpy	vmlinux	EXPORT_SYMBOL	
++0x3b6c41ea	kstrtouint	vmlinux	EXPORT_SYMBOL	
++0x368d6239	fs_context_for_submount	vmlinux	EXPORT_SYMBOL	
++0xb8b043f2	kfree_link	vmlinux	EXPORT_SYMBOL	
++0x7f00d041	up_write	vmlinux	EXPORT_SYMBOL	
++0xf6beee37	__SCK__tp_func_pelt_cfs_tp	vmlinux	EXPORT_SYMBOL_GPL	
++0x16e7e2cb	cpu_all_bits	vmlinux	EXPORT_SYMBOL	
++0xe6aed022	auth_domain_put	vmlinux	EXPORT_SYMBOL_GPL	
++0x7dbf4cc7	mmc_gpio_get_cd	vmlinux	EXPORT_SYMBOL	
++0x05389e0d	mmc_gpio_get_ro	vmlinux	EXPORT_SYMBOL	
++0xbffe29b0	cpufreq_cpu_put	vmlinux	EXPORT_SYMBOL_GPL	
++0x50e33707	cpufreq_cpu_get	vmlinux	EXPORT_SYMBOL_GPL	
++0x47abc88d	power_supply_external_power_changed	vmlinux	EXPORT_SYMBOL_GPL	
++0x0cc86ca4	scsi_target_block	vmlinux	EXPORT_SYMBOL_GPL	
++0xcb9f1dbb	free_buffer_head	vmlinux	EXPORT_SYMBOL	
++0x82fe876c	fget	vmlinux	EXPORT_SYMBOL	
++0xfe476039	ktime_get_resolution_ns	vmlinux	EXPORT_SYMBOL_GPL	
++0x5c26a53b	wait_for_completion_io_timeout	vmlinux	EXPORT_SYMBOL	
++0xe492f1f6	kthread_associate_blkcg	vmlinux	EXPORT_SYMBOL	
++0xecf3162d	firmware_request_nowarn	vmlinux	EXPORT_SYMBOL_GPL	
++0xfa1eb910	unregister_syscore_ops	vmlinux	EXPORT_SYMBOL_GPL	
++0xc77e8a2d	screen_pos	vmlinux	EXPORT_SYMBOL_GPL	
++0x2fbaf7d6	pci_reset_bus	vmlinux	EXPORT_SYMBOL_GPL	
++0x878469bd	ZSTD_decompressStream	vmlinux	EXPORT_SYMBOL	
++0x8decb47d	jbd2_log_start_commit	vmlinux	EXPORT_SYMBOL	
++0xdf42b184	remove_proc_subtree	vmlinux	EXPORT_SYMBOL	
++0x07b21f85	kdb_get_kbd_char	vmlinux	EXPORT_SYMBOL_GPL	
++0xce6db656	rcu_is_watching	vmlinux	EXPORT_SYMBOL_GPL	
++0xa4bad2d3	rtc_add_groups	vmlinux	EXPORT_SYMBOL	
++0xe376b791	DWC_SPINUNLOCK_IRQRESTORE	vmlinux	EXPORT_SYMBOL	
++0x29ee8ad4	mctrl_gpio_init	vmlinux	EXPORT_SYMBOL_GPL	
++0x29e1e204	hdmi_audio_infoframe_pack	vmlinux	EXPORT_SYMBOL	
++0x44e9a829	match_token	vmlinux	EXPORT_SYMBOL	
++0x75f297e8	jbd2_journal_abort	vmlinux	EXPORT_SYMBOL	
++0x42214614	__ftrace_vbprintk	vmlinux	EXPORT_SYMBOL_GPL	
++0xe65e39a2	down_write	vmlinux	EXPORT_SYMBOL	
++0x90e0a83c	ip_route_output_flow	vmlinux	EXPORT_SYMBOL_GPL	
++0xea3c8e4e	scsilun_to_int	vmlinux	EXPORT_SYMBOL	
++0x80fffcd4	key_type_logon	vmlinux	EXPORT_SYMBOL_GPL	
++0x677d3a9e	proc_create_seq_private	vmlinux	EXPORT_SYMBOL	
++0x081aae44	posix_test_lock	vmlinux	EXPORT_SYMBOL	
++0xa1277be4	kill_block_super	vmlinux	EXPORT_SYMBOL	
++0x49bd0e11	flush_signals	vmlinux	EXPORT_SYMBOL	
++0xe095897e	__inet_stream_connect	vmlinux	EXPORT_SYMBOL	
++0x8650ad02	neigh_lookup_nodev	vmlinux	EXPORT_SYMBOL	
++0x10b33a12	usb_stor_disconnect	vmlinux	EXPORT_SYMBOL_GPL	USB_STORAGE
++0xbaf93b56	scsi_change_queue_depth	vmlinux	EXPORT_SYMBOL	
++0x468d1334	fwnode_get_mac_address	vmlinux	EXPORT_SYMBOL	
++0xdeea0d6b	phy_pm_runtime_allow	vmlinux	EXPORT_SYMBOL_GPL	
++0x3224b2a9	mpi_read_raw_from_sgl	vmlinux	EXPORT_SYMBOL_GPL	
++0xf3797506	mpi_ec_deinit	vmlinux	EXPORT_SYMBOL_GPL	
++0xbd6841d4	crc16	vmlinux	EXPORT_SYMBOL	
++0x358690b1	dquot_operations	vmlinux	EXPORT_SYMBOL	
++0x514cf520	sched_show_task	vmlinux	EXPORT_SYMBOL_GPL	
++0xf82f3657	work_on_cpu	vmlinux	EXPORT_SYMBOL_GPL	
++0x51c10692	devm_nvmem_cell_put	vmlinux	EXPORT_SYMBOL	
++0xb153f0c8	nvme_start_ctrl	vmlinux	EXPORT_SYMBOL_GPL	
++0x640b41f8	dev_pm_qos_hide_latency_limit	vmlinux	EXPORT_SYMBOL_GPL	
++0xc4c83e13	gpiochip_unlock_as_irq	vmlinux	EXPORT_SYMBOL_GPL	
++0xa36a9506	rhltable_init	vmlinux	EXPORT_SYMBOL_GPL	
++0x1057a279	bsearch	vmlinux	EXPORT_SYMBOL	
++0x6287f688	blk_put_request	vmlinux	EXPORT_SYMBOL	
++0x8b76f940	__mmap_lock_do_trace_start_locking	vmlinux	EXPORT_SYMBOL	
++0x6ca4bf88	async_synchronize_full_domain	vmlinux	EXPORT_SYMBOL_GPL	
++0x27cff1a4	dst_blackhole_update_pmtu	vmlinux	EXPORT_SYMBOL_GPL	
++0x4bb99ed5	sock_zerocopy_put_abort	vmlinux	EXPORT_SYMBOL_GPL	
++0x346fb583	of_get_cpu_node	vmlinux	EXPORT_SYMBOL	
++0x53675182	input_get_timestamp	vmlinux	EXPORT_SYMBOL	
++0xba9b3c17	metadata_dst_alloc_percpu	vmlinux	EXPORT_SYMBOL_GPL	
++0xbc0f349f	sock_queue_rcv_skb	vmlinux	EXPORT_SYMBOL	
++0xc3a7c5e1	rc_map_register	vmlinux	EXPORT_SYMBOL_GPL	
++0x51c3da5e	dwc_remove_observer	vmlinux	EXPORT_SYMBOL	
++0x1d222416	usbnet_write_cmd_async	vmlinux	EXPORT_SYMBOL_GPL	
++0xbc5026b3	nvme_start_queues	vmlinux	EXPORT_SYMBOL_GPL	
++0x9fc9cac9	devm_of_pwm_get	vmlinux	EXPORT_SYMBOL_GPL	
++0x5009c71d	glob_match	vmlinux	EXPORT_SYMBOL	
++0x0d65c66f	rhashtable_init	vmlinux	EXPORT_SYMBOL_GPL	
++0xfaf9df9d	blk_limits_io_min	vmlinux	EXPORT_SYMBOL	
++0xfc92dfff	sysfs_remove_files	vmlinux	EXPORT_SYMBOL_GPL	
++0x8dec100b	__mmap_lock_do_trace_acquire_returned	vmlinux	EXPORT_SYMBOL	
++0x9d5429a1	percpu_up_write	vmlinux	EXPORT_SYMBOL_GPL	
++0x084341aa	rpc_setbufsize	vmlinux	EXPORT_SYMBOL_GPL	
++0xd7731ad0	rc_unregister_device	vmlinux	EXPORT_SYMBOL_GPL	
++0xd9c2e891	usbnet_purge_paused_rxq	vmlinux	EXPORT_SYMBOL_GPL	
++0x20200250	scsi_internal_device_unblock_nowait	vmlinux	EXPORT_SYMBOL_GPL	
++0x863a276a	color_table	vmlinux	EXPORT_SYMBOL	
++0x2a4b4fdf	devm_clk_hw_register	vmlinux	EXPORT_SYMBOL_GPL	
++0xd5519c6b	put_disk	vmlinux	EXPORT_SYMBOL	
++0xb7f6c668	add_timer	vmlinux	EXPORT_SYMBOL	
++0x6bb39347	lwtunnel_get_encap_size	vmlinux	EXPORT_SYMBOL_GPL	
++0x757b3939	hid_allocate_device	vmlinux	EXPORT_SYMBOL_GPL	
++0xcb838faf	spi_sync	vmlinux	EXPORT_SYMBOL_GPL	
++0xd47c27e4	dma_sync_wait	vmlinux	EXPORT_SYMBOL	
++0x7380dffa	argv_split	vmlinux	EXPORT_SYMBOL	
++0x44a6e90a	irq_cpu_rmap_add	vmlinux	EXPORT_SYMBOL	
++0x34f3484e	security_tun_dev_attach_queue	vmlinux	EXPORT_SYMBOL	
++0x78ce0df2	iomap_bmap	vmlinux	EXPORT_SYMBOL_GPL	
++0xfb0cc9f2	__cleancache_invalidate_inode	vmlinux	EXPORT_SYMBOL	
++0x8ab6ec6b	irq_chip_mask_ack_parent	vmlinux	EXPORT_SYMBOL_GPL	
++0x4b750f53	_raw_spin_unlock_irq	vmlinux	EXPORT_SYMBOL	
++0x47fc05fe	xprt_reconnect_delay	vmlinux	EXPORT_SYMBOL_GPL	
++0x091637a8	udp_abort	vmlinux	EXPORT_SYMBOL_GPL	
++0xc8fd2064	__gnet_stats_copy_basic	vmlinux	EXPORT_SYMBOL	
++0x04c7f210	sock_kzfree_s	vmlinux	EXPORT_SYMBOL	
++0xc289e46d	cpufreq_generic_frequency_table_verify	vmlinux	EXPORT_SYMBOL_GPL	
++0xa6f162f7	usb_alloc_dev	vmlinux	EXPORT_SYMBOL_GPL	
++0x0c1eb5fc	gen_pool_best_fit	vmlinux	EXPORT_SYMBOL	
++0xe0a89b31	blk_queue_max_hw_sectors	vmlinux	EXPORT_SYMBOL	
++0x7fead810	generic_pipe_buf_try_steal	vmlinux	EXPORT_SYMBOL	
++0xfe9e8bc9	handle_bad_irq	vmlinux	EXPORT_SYMBOL_GPL	
++0x31a89d59	rpc_debug	vmlinux	EXPORT_SYMBOL_GPL	
++0x2ed8b86a	svc_xprt_enqueue	vmlinux	EXPORT_SYMBOL_GPL	
++0x4b270cf9	of_device_request_module	vmlinux	EXPORT_SYMBOL_GPL	
++0xb8dec7db	devm_kvasprintf	vmlinux	EXPORT_SYMBOL	
++0xbf700930	bus_create_file	vmlinux	EXPORT_SYMBOL_GPL	
++0x66632e13	__serdev_device_driver_register	vmlinux	EXPORT_SYMBOL_GPL	
++0xa6aa9857	des_decrypt	vmlinux	EXPORT_SYMBOL_GPL	
++0x6ff6f97a	crypto_aes_set_key	vmlinux	EXPORT_SYMBOL_GPL	
++0x3bdb5d28	alg_test	vmlinux	EXPORT_SYMBOL_GPL	
++0x217e69da	jbd2__journal_restart	vmlinux	EXPORT_SYMBOL	
++0x7ce18c9f	from_kqid	vmlinux	EXPORT_SYMBOL	
++0x939fb78c	iomap_writepages	vmlinux	EXPORT_SYMBOL_GPL	
++0xbef43296	console_conditional_schedule	vmlinux	EXPORT_SYMBOL	
++0x29eba37f	current_is_async	vmlinux	EXPORT_SYMBOL_GPL	
++0xc1243988	svc_destroy	vmlinux	EXPORT_SYMBOL_GPL	
++0xdd720559	qdisc_offload_graft_helper	vmlinux	EXPORT_SYMBOL	
++0x043b485b	thermal_remove_hwmon_sysfs	vmlinux	EXPORT_SYMBOL_GPL	
++0x55eb28bd	blkdev_issue_discard	vmlinux	EXPORT_SYMBOL	
++0x25f1154c	crypto_unregister_scomp	vmlinux	EXPORT_SYMBOL_GPL	
++0x80e7de9c	crypto_unregister_acomp	vmlinux	EXPORT_SYMBOL_GPL	
++0xabeba7b2	debugfs_create_symlink	vmlinux	EXPORT_SYMBOL_GPL	
++0xa05ca625	nfs_fattr_init	vmlinux	EXPORT_SYMBOL_GPL	
++0xa3eea4e2	fat_detach	vmlinux	EXPORT_SYMBOL_GPL	
++0xed6e0fce	__fscache_update_cookie	vmlinux	EXPORT_SYMBOL	
++0xd9e24457	ring_buffer_peek	vmlinux	EXPORT_SYMBOL_GPL	
++0x34b416bf	handle_untracked_irq	vmlinux	EXPORT_SYMBOL_GPL	
++0xaa22b736	vlan_for_each	vmlinux	EXPORT_SYMBOL	
++0x0f60d979	__ip_options_compile	vmlinux	EXPORT_SYMBOL	
++0x18b44c75	fib_notifier_ops_unregister	vmlinux	EXPORT_SYMBOL	
++0x3055406f	sdhci_end_tuning	vmlinux	EXPORT_SYMBOL_GPL	
++0x9d53b40b	sdhci_enable_clk	vmlinux	EXPORT_SYMBOL_GPL	
++0x8bb13115	dev_pm_domain_set	vmlinux	EXPORT_SYMBOL_GPL	
++0x9b60cf59	device_match_devt	vmlinux	EXPORT_SYMBOL_GPL	
++0x6228c21f	smp_call_function_single	vmlinux	EXPORT_SYMBOL	
++0xfa544843	cookie_ecn_ok	vmlinux	EXPORT_SYMBOL	
++0x8160aa23	bcm_phy_get_sset_count	vmlinux	EXPORT_SYMBOL_GPL	
++0x3260f42c	bcm_phy_enable_apd	vmlinux	EXPORT_SYMBOL_GPL	
++0xda1e7c24	devm_pwm_put	vmlinux	EXPORT_SYMBOL_GPL	
++0x0978f4d0	devm_phy_get	vmlinux	EXPORT_SYMBOL_GPL	
++0x4d9b652b	rb_erase	vmlinux	EXPORT_SYMBOL	
++0xc0bca0f1	ZSTD_nextSrcSizeToDecompress	vmlinux	EXPORT_SYMBOL	
++0x77c169cd	fsnotify_alloc_group	vmlinux	EXPORT_SYMBOL_GPL	
++0x7113f338	__cpuhp_state_add_instance	vmlinux	EXPORT_SYMBOL_GPL	
++0x3f9a2b0b	rpcauth_get_gssinfo	vmlinux	EXPORT_SYMBOL_GPL	
++0xedaa932b	__netdev_watchdog_up	vmlinux	EXPORT_SYMBOL_GPL	
++0xfa355613	hid_quirks_init	vmlinux	EXPORT_SYMBOL_GPL	
++0x058b582a	vt_get_leds	vmlinux	EXPORT_SYMBOL_GPL	
++0xaafdc258	strcasecmp	vmlinux	EXPORT_SYMBOL	
++0xad85641a	blk_mq_start_hw_queue	vmlinux	EXPORT_SYMBOL	
++0xcfdd4090	security_cred_getsecid	vmlinux	EXPORT_SYMBOL	
++0xede41327	__tracepoint_nfs4_pnfs_read	vmlinux	EXPORT_SYMBOL_GPL	
++0x6c016d96	unregister_kretprobe	vmlinux	EXPORT_SYMBOL_GPL	
++0xf6282840	clockevents_register_device	vmlinux	EXPORT_SYMBOL_GPL	
++0x15ae6bd7	cache_check	vmlinux	EXPORT_SYMBOL_GPL	
++0xbe6f1e9f	tcf_idr_search	vmlinux	EXPORT_SYMBOL	
++0x0028c182	fib_rules_seq_read	vmlinux	EXPORT_SYMBOL_GPL	
++0x190a48a9	efi	vmlinux	EXPORT_SYMBOL	
++0x0a8c3b4b	usb_ep_set_halt	vmlinux	EXPORT_SYMBOL_GPL	
++0x5b30fc12	phy_modify_paged_changed	vmlinux	EXPORT_SYMBOL	
++0x03c50a48	phy_speed_down	vmlinux	EXPORT_SYMBOL_GPL	
++0x90af3090	nvme_stop_ctrl	vmlinux	EXPORT_SYMBOL_GPL	
++0x3fc898cc	tty_unthrottle	vmlinux	EXPORT_SYMBOL	
++0xb6243baa	gpiod_get_raw_value	vmlinux	EXPORT_SYMBOL_GPL	
++0x0310e699	gpiochip_add_data_with_key	vmlinux	EXPORT_SYMBOL_GPL	
++0xea161f3c	security_socket_getpeersec_dgram	vmlinux	EXPORT_SYMBOL	
++0x90326fca	set_blocksize	vmlinux	EXPORT_SYMBOL	
++0x9d7977a1	block_page_mkwrite	vmlinux	EXPORT_SYMBOL	
++0x036de383	perf_event_cgrp_subsys_enabled_key	vmlinux	EXPORT_SYMBOL_GPL	
++0xcc2dbfd8	irq_domain_check_msi_remap	vmlinux	EXPORT_SYMBOL_GPL	
++0xf8a2af93	dst_release_immediate	vmlinux	EXPORT_SYMBOL	
++0xecbb3181	class_compat_remove_link	vmlinux	EXPORT_SYMBOL_GPL	
++0x3dd99ec0	uart_unregister_driver	vmlinux	EXPORT_SYMBOL	
++0x0acf7679	dma_issue_pending_all	vmlinux	EXPORT_SYMBOL	
++0x4891eddb	gpiochip_irq_unmap	vmlinux	EXPORT_SYMBOL_GPL	
++0xb7a00d28	devm_pinctrl_unregister	vmlinux	EXPORT_SYMBOL_GPL	
++0x65cf8831	ZSTD_decompress_usingDict	vmlinux	EXPORT_SYMBOL	
++0x06717d79	bsg_job_get	vmlinux	EXPORT_SYMBOL_GPL	
++0x15927183	bsg_job_put	vmlinux	EXPORT_SYMBOL_GPL	
++0x85f3a0c6	crypto_spawn_tfm	vmlinux	EXPORT_SYMBOL_GPL	
++0x787cd8aa	security_inode_notifysecctx	vmlinux	EXPORT_SYMBOL	
++0x10495fec	generic_error_remove_page	vmlinux	EXPORT_SYMBOL	
++0x81a56efe	inet_unhash	vmlinux	EXPORT_SYMBOL_GPL	
++0x2d64ba18	ip_fraglist_prepare	vmlinux	EXPORT_SYMBOL	
++0x0b6bd9cf	dev_nit_active	vmlinux	EXPORT_SYMBOL_GPL	
++0xd4835ef8	dmi_check_system	vmlinux	EXPORT_SYMBOL	
++0x83e17074	mdio_bus_type	vmlinux	EXPORT_SYMBOL	
++0x25739556	blk_execute_rq	vmlinux	EXPORT_SYMBOL	
++0x808031d3	crypto_register_scomp	vmlinux	EXPORT_SYMBOL_GPL	
++0x25e9d4bd	resource_list_free	vmlinux	EXPORT_SYMBOL	
++0xea9ef1ed	rpc_call_sync	vmlinux	EXPORT_SYMBOL_GPL	
++0x58167502	tcf_exts_dump	vmlinux	EXPORT_SYMBOL	
++0x2fc29430	sk_stop_timer_sync	vmlinux	EXPORT_SYMBOL	
++0x06f470c6	dev_pm_qos_expose_flags	vmlinux	EXPORT_SYMBOL_GPL	
++0xf8f7fdb3	serdev_device_write_room	vmlinux	EXPORT_SYMBOL_GPL	
++0x564116a4	__xa_store	vmlinux	EXPORT_SYMBOL	
++0x59588850	vsscanf	vmlinux	EXPORT_SYMBOL	
++0x514c82cd	jbd2_journal_unlock_updates	vmlinux	EXPORT_SYMBOL	
++0x82d79b51	sysctl_vfs_cache_pressure	vmlinux	EXPORT_SYMBOL_GPL	
++0x347ae630	dma_sync_single_for_cpu	vmlinux	EXPORT_SYMBOL	
++0xf1e046cc	panic	vmlinux	EXPORT_SYMBOL	
++0xcdb4b60e	xprt_wake_up_backlog	vmlinux	EXPORT_SYMBOL_GPL	
++0xeddcb329	udp4_lib_lookup_skb	vmlinux	EXPORT_SYMBOL_GPL	
++0xdc7f92a9	led_trigger_remove	vmlinux	EXPORT_SYMBOL_GPL	
++0xa0fa1b3c	sdhci_set_clock	vmlinux	EXPORT_SYMBOL_GPL	
++0x7a790f10	fwnode_property_match_string	vmlinux	EXPORT_SYMBOL_GPL	
++0xb320cc0e	sg_init_one	vmlinux	EXPORT_SYMBOL	
++0x625f3e90	__traceiter_nfs_fsync_enter	vmlinux	EXPORT_SYMBOL_GPL	
++0xeb233a45	__kmalloc	vmlinux	EXPORT_SYMBOL	
++0xae04012c	__vmalloc	vmlinux	EXPORT_SYMBOL	
++0x9b647a6e	xdr_truncate_encode	vmlinux	EXPORT_SYMBOL	
++0xb97767cf	tcp_set_keepalive	vmlinux	EXPORT_SYMBOL_GPL	
++0x9f7525f2	dev_pm_opp_of_get_sharing_cpus	vmlinux	EXPORT_SYMBOL_GPL	
++0x2acddb11	usbnet_get_ethernet_addr	vmlinux	EXPORT_SYMBOL_GPL	
++0x514a5860	reset_controller_register	vmlinux	EXPORT_SYMBOL_GPL	
++0x94dbe65b	devm_pci_alloc_host_bridge	vmlinux	EXPORT_SYMBOL	
++0xf643d104	hsiphash_4u32	vmlinux	EXPORT_SYMBOL	
++0x9e0fa5ae	hsiphash_3u32	vmlinux	EXPORT_SYMBOL	
++0x30acfde9	hsiphash_2u32	vmlinux	EXPORT_SYMBOL	
++0x6481ffe0	hsiphash_1u32	vmlinux	EXPORT_SYMBOL	
++0xa011787a	kobject_init_and_add	vmlinux	EXPORT_SYMBOL_GPL	
++0x750fb156	__fscache_relinquish_cookie	vmlinux	EXPORT_SYMBOL	
++0xc609f9e9	rpc_wake_up_next	vmlinux	EXPORT_SYMBOL_GPL	
++0x4c4fd7bb	__ip_select_ident	vmlinux	EXPORT_SYMBOL	
++0x7ba08ec1	of_parse_phandle_with_args_map	vmlinux	EXPORT_SYMBOL	
++0x62212212	of_genpd_add_provider_simple	vmlinux	EXPORT_SYMBOL_GPL	
++0x313c264a	fwnode_count_parents	vmlinux	EXPORT_SYMBOL_GPL	
++0xb11d9000	tty_dev_name_to_number	vmlinux	EXPORT_SYMBOL_GPL	
++0x88faa568	pci_platform_power_transition	vmlinux	EXPORT_SYMBOL_GPL	
++0x0fd4c81c	pci_find_ht_capability	vmlinux	EXPORT_SYMBOL_GPL	
++0x2acbbf5c	pci_find_next_ht_capability	vmlinux	EXPORT_SYMBOL_GPL	
++0x18ac8840	iw_handler_get_spy	vmlinux	EXPORT_SYMBOL	
++0x07d12242	nf_nat_hook	vmlinux	EXPORT_SYMBOL_GPL	
++0xb070c849	__skb_warn_lro_forwarding	vmlinux	EXPORT_SYMBOL	
++0xfbe671bf	usb_control_msg_send	vmlinux	EXPORT_SYMBOL_GPL	
++0xefff517a	regmap_exit	vmlinux	EXPORT_SYMBOL_GPL	
++0x96c17136	fb_var_to_videomode	vmlinux	EXPORT_SYMBOL	
++0xbf43e54a	pinconf_generic_dump_config	vmlinux	EXPORT_SYMBOL_GPL	
++0x7892dfc8	devm_of_phy_get	vmlinux	EXPORT_SYMBOL_GPL	
++0x14e5eafa	idr_for_each	vmlinux	EXPORT_SYMBOL	
++0x449ad0a7	memcmp	vmlinux	EXPORT_SYMBOL	
++0xe12054e9	percpu_counter_sync	vmlinux	EXPORT_SYMBOL	
++0xd5b27867	bio_add_pc_page	vmlinux	EXPORT_SYMBOL	
++0xf1b0af50	query_asymmetric_key	vmlinux	EXPORT_SYMBOL_GPL	
++0x23a27d29	shash_ahash_digest	vmlinux	EXPORT_SYMBOL_GPL	
++0x68748bc2	locks_init_lock	vmlinux	EXPORT_SYMBOL	
++0xb43a5a27	split_page	vmlinux	EXPORT_SYMBOL_GPL	
++0x5f0cf4c5	inet6_del_offload	vmlinux	EXPORT_SYMBOL	
++0xda89ea3b	ip_idents_reserve	vmlinux	EXPORT_SYMBOL	
++0xb847f23d	netif_stacked_transfer_operstate	vmlinux	EXPORT_SYMBOL	
++0xc099078e	genphy_read_mmd_unsupported	vmlinux	EXPORT_SYMBOL	
++0xe33f80bf	ida_alloc_range	vmlinux	EXPORT_SYMBOL	
++0x8df9dd10	guid_null	vmlinux	EXPORT_SYMBOL	
++0xd0279c60	crypto_type_has_alg	vmlinux	EXPORT_SYMBOL_GPL	
++0xe66746e7	key_set_timeout	vmlinux	EXPORT_SYMBOL_GPL	
++0xb9558062	nfs4_label_alloc	vmlinux	EXPORT_SYMBOL_GPL	
++0x9887b3e3	d_alloc_name	vmlinux	EXPORT_SYMBOL	
++0x635caa83	dmam_alloc_attrs	vmlinux	EXPORT_SYMBOL	
++0x0e859e04	console_atomic_unlock	vmlinux	EXPORT_SYMBOL	
++0x4ae12193	of_translate_address	vmlinux	EXPORT_SYMBOL	
++0xc62995d6	power_supply_property_is_writeable	vmlinux	EXPORT_SYMBOL_GPL	
++0xea5cc990	bcm_phy_read_misc	vmlinux	EXPORT_SYMBOL_GPL	
++0x69c5391d	pinctrl_dev_get_drvdata	vmlinux	EXPORT_SYMBOL_GPL	
++0x446b0771	devm_ioport_unmap	vmlinux	EXPORT_SYMBOL	
++0x8d55bb8a	qid_eq	vmlinux	EXPORT_SYMBOL	
++0x7d176450	cont_write_begin	vmlinux	EXPORT_SYMBOL	
++0x08d3bf02	trace_vprintk	vmlinux	EXPORT_SYMBOL_GPL	
++0x98e508ef	ignore_console_lock_warning	vmlinux	EXPORT_SYMBOL	
++0xdbdcf5bc	pktgen_xfrm_outer_mode_output	vmlinux	EXPORT_SYMBOL_GPL	
++0x80c68137	nf_log_buf_close	vmlinux	EXPORT_SYMBOL_GPL	
++0x06095be2	dmaenginem_async_device_register	vmlinux	EXPORT_SYMBOL	
++0xa2b543be	pci_d3cold_disable	vmlinux	EXPORT_SYMBOL_GPL	
++0xd262dfcb	vscnprintf	vmlinux	EXPORT_SYMBOL	
++0x581f98da	zlib_inflate	vmlinux	EXPORT_SYMBOL	
++0xbfc62b17	simple_statfs	vmlinux	EXPORT_SYMBOL	
++0x365e7911	kstrdup_const	vmlinux	EXPORT_SYMBOL	
++0x785b2bf6	dma_map_page_attrs	vmlinux	EXPORT_SYMBOL	
++0x4846ae84	param_set_long	vmlinux	EXPORT_SYMBOL	
++0x958222c2	km_policy_notify	vmlinux	EXPORT_SYMBOL	
++0x9deab4fd	ip_mc_join_group	vmlinux	EXPORT_SYMBOL	
++0x2f90e577	usb_string	vmlinux	EXPORT_SYMBOL_GPL	
++0xb00c6a97	usb_hub_release_port	vmlinux	EXPORT_SYMBOL_GPL	
++0xdb760f52	__kfifo_free	vmlinux	EXPORT_SYMBOL	
++0x7ada04d1	configfs_undepend_item	vmlinux	EXPORT_SYMBOL	
++0xa263892b	fscrypt_fname_free_buffer	vmlinux	EXPORT_SYMBOL	
++0x09b6ed40	irq_domain_update_bus_token	vmlinux	EXPORT_SYMBOL_GPL	
++0x403e9c03	ip_icmp_error_rfc4884	vmlinux	EXPORT_SYMBOL_GPL	
++0x863eb9c5	inet_csk_reqsk_queue_hash_add	vmlinux	EXPORT_SYMBOL_GPL	
++0x2b7c691e	arizona_of_get_type	vmlinux	EXPORT_SYMBOL_GPL	
++0x1062dc4e	debugfs_remove	vmlinux	EXPORT_SYMBOL_GPL	
++0x86613d85	pnfs_generic_search_commit_reqs	vmlinux	EXPORT_SYMBOL_GPL	
++0xc765efff	lease_modify	vmlinux	EXPORT_SYMBOL	
++0xb2bae13d	drop_nlink	vmlinux	EXPORT_SYMBOL	
++0x90813b7f	vmf_insert_mixed_mkwrite	vmlinux	EXPORT_SYMBOL	
++0xcf543903	kthread_cancel_delayed_work_sync	vmlinux	EXPORT_SYMBOL_GPL	
++0xde970901	xfrm_dst_ifdown	vmlinux	EXPORT_SYMBOL	
++0x29c192d6	neigh_seq_start	vmlinux	EXPORT_SYMBOL	
++0x5ee375b9	pci_assign_unassigned_bridge_resources	vmlinux	EXPORT_SYMBOL_GPL	
++0x906ed993	gpiod_set_raw_array_value	vmlinux	EXPORT_SYMBOL_GPL	
++0x9cb3e611	__xa_cmpxchg	vmlinux	EXPORT_SYMBOL	
++0xd1ff3f7f	sysfs_group_change_owner	vmlinux	EXPORT_SYMBOL_GPL	
++0xc8621480	rpc_put_task	vmlinux	EXPORT_SYMBOL_GPL	
++0x5963cfe3	eth_header_cache_update	vmlinux	EXPORT_SYMBOL	
++0x3cbcbaf8	usb_get_dr_mode	vmlinux	EXPORT_SYMBOL_GPL	
++0x31839ad3	software_node_register_nodes	vmlinux	EXPORT_SYMBOL_GPL	
++0x8dc452c3	regulator_unregister_notifier	vmlinux	EXPORT_SYMBOL_GPL	
++0xdd64e639	strscpy	vmlinux	EXPORT_SYMBOL	
++0x5792f848	strlcpy	vmlinux	EXPORT_SYMBOL	
++0x9166fada	strncpy	vmlinux	EXPORT_SYMBOL	
++0x905695ab	sg_copy_from_buffer	vmlinux	EXPORT_SYMBOL	
++0x8abacc47	get_max_files	vmlinux	EXPORT_SYMBOL_GPL	
++0xec3d2e1b	trace_hardirqs_off	vmlinux	EXPORT_SYMBOL	
++0x4683ea45	tcf_em_tree_destroy	vmlinux	EXPORT_SYMBOL	
++0x4439bcd2	__SCK__tp_func_neigh_event_send_dead	vmlinux	EXPORT_SYMBOL_GPL	
++0x2555aafd	scsi_host_complete_all_commands	vmlinux	EXPORT_SYMBOL_GPL	
++0x40f0683e	reset_control_put	vmlinux	EXPORT_SYMBOL_GPL	
++0xf195c682	fb_invert_cmaps	vmlinux	EXPORT_SYMBOL	
++0x93017a4e	of_pci_parse_bus_range	vmlinux	EXPORT_SYMBOL_GPL	
++0x6bf181c1	__tracepoint_kmem_cache_free	vmlinux	EXPORT_SYMBOL	
++0xb049a294	__SCK__tp_func_pelt_irq_tp	vmlinux	EXPORT_SYMBOL_GPL	
++0x452de1be	tcp_register_ulp	vmlinux	EXPORT_SYMBOL_GPL	
++0x0971fe18	driver_create_file	vmlinux	EXPORT_SYMBOL_GPL	
++0xe8cbd554	serial8250_do_startup	vmlinux	EXPORT_SYMBOL_GPL	
++0x863b91b1	xdr_expand_hole	vmlinux	EXPORT_SYMBOL_GPL	
++0x3040b131	skb_get_hash_perturb	vmlinux	EXPORT_SYMBOL	
++0xf91cab95	__bcm_phy_modify_rdb	vmlinux	EXPORT_SYMBOL_GPL	
++0x3c087197	__bcm_phy_modify_exp	vmlinux	EXPORT_SYMBOL_GPL	
++0x098b71c6	fb_dealloc_cmap	vmlinux	EXPORT_SYMBOL	
++0x7e16dad4	blk_mq_run_hw_queue	vmlinux	EXPORT_SYMBOL	
++0x51492c0d	jbd2_journal_start_reserved	vmlinux	EXPORT_SYMBOL	
++0x22126b86	blkdev_write_iter	vmlinux	EXPORT_SYMBOL_GPL	
++0x5a4c5510	insert_inode_locked4	vmlinux	EXPORT_SYMBOL	
++0x41482d8b	strndup_user	vmlinux	EXPORT_SYMBOL	
++0x6fcef6ab	ring_buffer_reset	vmlinux	EXPORT_SYMBOL_GPL	
++0xbd3fe1e3	disable_hardirq	vmlinux	EXPORT_SYMBOL_GPL	
++0xc37f9c6e	cpufreq_update_policy	vmlinux	EXPORT_SYMBOL	
++0x54d55f40	pcie_get_width_cap	vmlinux	EXPORT_SYMBOL	
++0x64724495	pwmchip_remove	vmlinux	EXPORT_SYMBOL_GPL	
++0xfff72e8e	simple_nosetlease	vmlinux	EXPORT_SYMBOL	
++0x30229ea1	mount_nodev	vmlinux	EXPORT_SYMBOL	
++0x1181e918	xfrm_find_acq	vmlinux	EXPORT_SYMBOL	
++0x0d65bb5b	eth_mac_addr	vmlinux	EXPORT_SYMBOL	
++0x4ec21e1c	DWC_WAITQ_ABORT	vmlinux	EXPORT_SYMBOL	
++0xd0525d65	scsi_scan_host	vmlinux	EXPORT_SYMBOL	
++0xb911bb58	minmax_running_max	vmlinux	EXPORT_SYMBOL	
++0xc656a8f3	security_inode_listsecurity	vmlinux	EXPORT_SYMBOL	
++0xb02ef567	nfs_clear_inode	vmlinux	EXPORT_SYMBOL_GPL	
++0xa409f664	unregister_hw_breakpoint	vmlinux	EXPORT_SYMBOL_GPL	
++0x78ba6f0e	sched_trace_rq_cpu_capacity	vmlinux	EXPORT_SYMBOL_GPL	
++0xd9a86e7f	tcp_sendpage	vmlinux	EXPORT_SYMBOL	
++0x03683b5a	nvmem_cell_read_u8	vmlinux	EXPORT_SYMBOL_GPL	
++0xe5883bd9	class_compat_unregister	vmlinux	EXPORT_SYMBOL_GPL	
++0xb608fe4a	radix_tree_lookup_slot	vmlinux	EXPORT_SYMBOL	
++0x3d73bc10	allocate_resource	vmlinux	EXPORT_SYMBOL	
++0xc7856a3d	inet6addr_notifier_call_chain	vmlinux	EXPORT_SYMBOL	
++0x2a7f86c3	cpuidle_unregister	vmlinux	EXPORT_SYMBOL_GPL	
++0x3ce650fd	phy_10gbit_features	vmlinux	EXPORT_SYMBOL_GPL	
++0x7bae7aa0	iscsi_put_endpoint	vmlinux	EXPORT_SYMBOL_GPL	
++0x491c67a6	pm_schedule_suspend	vmlinux	EXPORT_SYMBOL_GPL	
++0x0f15d92d	serdev_device_open	vmlinux	EXPORT_SYMBOL_GPL	
++0x7171fc2e	clk_bulk_get_all	vmlinux	EXPORT_SYMBOL	
++0x8af502f1	of_get_display_timings	vmlinux	EXPORT_SYMBOL_GPL	
++0xe7e90e31	fscrypt_ioctl_remove_key_all_users	vmlinux	EXPORT_SYMBOL_GPL	
++0xc3de65ff	ring_buffer_bytes_cpu	vmlinux	EXPORT_SYMBOL_GPL	
++0xcbbf0a6f	audit_log_task_context	vmlinux	EXPORT_SYMBOL	
++0x2f09c591	tcf_block_netif_keep_dst	vmlinux	EXPORT_SYMBOL	
++0x7940b9f7	hid_alloc_report_buf	vmlinux	EXPORT_SYMBOL_GPL	
++0xebb8510c	dwc_cc_if_free	vmlinux	EXPORT_SYMBOL	
++0x51413529	phy_start_cable_test_tdr	vmlinux	EXPORT_SYMBOL	
++0x9367f62c	spi_write_then_read	vmlinux	EXPORT_SYMBOL_GPL	
++0x2421d818	nvme_stop_keep_alive	vmlinux	EXPORT_SYMBOL_GPL	
++0xbf77ff87	pinctrl_lookup_state	vmlinux	EXPORT_SYMBOL_GPL	
++0x58fe2805	jbd2_fc_end_commit_fallback	vmlinux	EXPORT_SYMBOL	
++0xf9a054b5	__round_jiffies	vmlinux	EXPORT_SYMBOL_GPL	
++0x11a8631a	kthread_create_worker	vmlinux	EXPORT_SYMBOL	
++0x7be18aa1	hardirqs_enabled	vmlinux	EXPORT_SYMBOL_GPL	
++0x01f48e22	regmap_get_max_register	vmlinux	EXPORT_SYMBOL_GPL	
++0xd21751a0	serial8250_em485_destroy	vmlinux	EXPORT_SYMBOL_GPL	
++0xeef8a8fb	devm_reset_control_array_get	vmlinux	EXPORT_SYMBOL_GPL	
++0x76108606	crypto_skcipher_setkey	vmlinux	EXPORT_SYMBOL_GPL	
++0x4fa80483	security_sb_clone_mnt_opts	vmlinux	EXPORT_SYMBOL	
++0x10768cdc	nfs_write_inode	vmlinux	EXPORT_SYMBOL_GPL	
++0x50aa96f7	vfs_rmdir	vmlinux	EXPORT_SYMBOL	
++0x92a87ed5	generic_shutdown_super	vmlinux	EXPORT_SYMBOL	
++0xeec1b1ad	unpin_user_pages	vmlinux	EXPORT_SYMBOL	
++0x3f0e8fe3	netdev_master_upper_dev_link	vmlinux	EXPORT_SYMBOL	
++0x1ddb46bd	scsi_track_queue_full	vmlinux	EXPORT_SYMBOL	
++0xaf9972ec	pinctrl_count_index_with_args	vmlinux	EXPORT_SYMBOL_GPL	
++0x146289b7	crc16_table	vmlinux	EXPORT_SYMBOL	
++0x937733e3	qid_valid	vmlinux	EXPORT_SYMBOL	
++0xde3d4c71	d_alloc_parallel	vmlinux	EXPORT_SYMBOL	
++0xf21e1f9b	disable_percpu_irq	vmlinux	EXPORT_SYMBOL_GPL	
++0x1cbd92b0	cpu_mitigations_off	vmlinux	EXPORT_SYMBOL_GPL	
++0xb265d85e	svc_fill_symlink_pathname	vmlinux	EXPORT_SYMBOL_GPL	
++0xac1f1bc9	skb_copy_and_hash_datagram_iter	vmlinux	EXPORT_SYMBOL	
++0x2bcb39ea	__sock_recv_ts_and_drops	vmlinux	EXPORT_SYMBOL_GPL	
++0x1846aca5	device_add_properties	vmlinux	EXPORT_SYMBOL_GPL	
++0x03d3b9a2	jbd2__journal_start	vmlinux	EXPORT_SYMBOL	
++0x8c00f571	noop_set_page_dirty	vmlinux	EXPORT_SYMBOL_GPL	
++0xd4ba2daa	vfs_copy_file_range	vmlinux	EXPORT_SYMBOL	
++0x0f09cc34	schedule_timeout_killable	vmlinux	EXPORT_SYMBOL	
++0x959ec5f5	call_rcu_tasks	vmlinux	EXPORT_SYMBOL_GPL	
++0xaf71fa93	rpcauth_create	vmlinux	EXPORT_SYMBOL_GPL	
++0xa566a94e	rtm_getroute_parse_ip_proto	vmlinux	EXPORT_SYMBOL_GPL	
++0x857a204e	skb_eth_pop	vmlinux	EXPORT_SYMBOL	
++0x985e83b4	sock_no_getname	vmlinux	EXPORT_SYMBOL	
++0xcaf0b1a3	of_device_is_big_endian	vmlinux	EXPORT_SYMBOL	
++0x672457bb	pci_msix_vec_count	vmlinux	EXPORT_SYMBOL	
++0xa5feaa19	gpiochip_relres_irq	vmlinux	EXPORT_SYMBOL_GPL	
++0x8b0088d1	LZ4_decompress_safe_usingDict	vmlinux	EXPORT_SYMBOL	
++0x8a4e8299	vfs_link	vmlinux	EXPORT_SYMBOL	
++0x48b1f459	from_kuid_munged	vmlinux	EXPORT_SYMBOL	
++0x365acda7	set_normalized_timespec64	vmlinux	EXPORT_SYMBOL	
++0x655e4879	__irq_alloc_descs	vmlinux	EXPORT_SYMBOL_GPL	
++0x39cb2f8c	call_usermodehelper_setup	vmlinux	EXPORT_SYMBOL	
++0x170d3bef	netlink_rcv_skb	vmlinux	EXPORT_SYMBOL	
++0xf58948be	phy_driver_unregister	vmlinux	EXPORT_SYMBOL	
++0xdf6bdbf4	of_clk_src_onecell_get	vmlinux	EXPORT_SYMBOL_GPL	
++0xf82abc1d	isa_dma_bridge_buggy	vmlinux	EXPORT_SYMBOL	
++0x69f86b6e	crypto_alloc_acomp	vmlinux	EXPORT_SYMBOL_GPL	
++0x023943b4	trace_event_reg	vmlinux	EXPORT_SYMBOL_GPL	
++0x1bc85e1c	irq_set_affinity	vmlinux	EXPORT_SYMBOL_GPL	
++0x39bcdf5a	panic_notifier_list	vmlinux	EXPORT_SYMBOL	
++0x0cf8a03f	__xfrm_state_delete	vmlinux	EXPORT_SYMBOL	
++0x06f36955	mbox_client_peek_data	vmlinux	EXPORT_SYMBOL_GPL	
++0xd768e985	regulator_has_full_constraints	vmlinux	EXPORT_SYMBOL_GPL	
++0x5827183e	gpiod_get_raw_array_value_cansleep	vmlinux	EXPORT_SYMBOL_GPL	
++0x3801776b	__ioread32_copy	vmlinux	EXPORT_SYMBOL_GPL	
++0x874d81ee	fs_param_is_bool	vmlinux	EXPORT_SYMBOL	
++0x7d7919e4	d_delete	vmlinux	EXPORT_SYMBOL	
++0xcc6f546b	mod_timer	vmlinux	EXPORT_SYMBOL	
++0x0d09ad2d	send_sig_mceerr	vmlinux	EXPORT_SYMBOL	
++0x9a7d8fed	vc_scrolldelta_helper	vmlinux	EXPORT_SYMBOL_GPL	
++0x685659f8	idr_remove	vmlinux	EXPORT_SYMBOL_GPL	
++0xb4f3f470	mnt_set_expiry	vmlinux	EXPORT_SYMBOL	
++0x2d41e6f5	__trace_puts	vmlinux	EXPORT_SYMBOL_GPL	
++0xdaf2ebb3	param_get_invbool	vmlinux	EXPORT_SYMBOL	
++0xbf9d1b96	nfsd_debug	vmlinux	EXPORT_SYMBOL_GPL	
++0xa8c1603a	genl_notify	vmlinux	EXPORT_SYMBOL	
++0xa0dad88e	netdev_adjacent_get_private	vmlinux	EXPORT_SYMBOL	
++0xa0c719b4	dev_pm_opp_put_clkname	vmlinux	EXPORT_SYMBOL_GPL	
++0x16631c01	devm_rtc_device_register	vmlinux	EXPORT_SYMBOL_GPL	
++0x953167e9	bcm_phy_write_misc	vmlinux	EXPORT_SYMBOL_GPL	
++0x3774f156	devres_destroy	vmlinux	EXPORT_SYMBOL_GPL	
++0xbc612be6	tty_hangup	vmlinux	EXPORT_SYMBOL	
++0x5ee47bef	pci_disable_device	vmlinux	EXPORT_SYMBOL	
++0x4079d81e	gpiod_get_array_value	vmlinux	EXPORT_SYMBOL_GPL	
++0x8ac3334b	net_dim_get_def_rx_moderation	vmlinux	EXPORT_SYMBOL	
++0x8b2cd8f9	add_page_wait_queue	vmlinux	EXPORT_SYMBOL_GPL	
++0x9504df26	irq_wake_thread	vmlinux	EXPORT_SYMBOL_GPL	
++0xd95ef990	prepare_to_swait_exclusive	vmlinux	EXPORT_SYMBOL	
++0xa99561a6	xfrm_lookup_route	vmlinux	EXPORT_SYMBOL	
++0xd2ed6d6b	mdiobus_read	vmlinux	EXPORT_SYMBOL	
++0xb7cad004	pm_runtime_forbid	vmlinux	EXPORT_SYMBOL_GPL	
++0x30e74134	tty_termios_copy_hw	vmlinux	EXPORT_SYMBOL	
++0xbbe8201b	regulator_disable_deferred	vmlinux	EXPORT_SYMBOL_GPL	
++0xc9e9e869	dma_release_channel	vmlinux	EXPORT_SYMBOL_GPL	
++0x8a83fb45	mpi_point_free_parts	vmlinux	EXPORT_SYMBOL_GPL	
++0x2724c308	badblocks_set	vmlinux	EXPORT_SYMBOL_GPL	
++0xcaf2330f	fscache_obtained_object	vmlinux	EXPORT_SYMBOL	
++0x595e2b5e	seq_put_decimal_ll	vmlinux	EXPORT_SYMBOL	
++0xa6354554	rpc_pton	vmlinux	EXPORT_SYMBOL_GPL	
++0x1f2a9970	rpc_ntop	vmlinux	EXPORT_SYMBOL_GPL	
++0x21eb6bfd	efivars_kobject	vmlinux	EXPORT_SYMBOL_GPL	
++0x0d67c82d	usb_get_maximum_speed	vmlinux	EXPORT_SYMBOL_GPL	
++0x45985f06	fwnode_graph_get_remote_node	vmlinux	EXPORT_SYMBOL_GPL	
++0x502dbc8a	devm_clk_get	vmlinux	EXPORT_SYMBOL	
++0x49922141	pcie_capability_clear_and_set_word	vmlinux	EXPORT_SYMBOL	
++0x63dae99d	__traceiter_ff_layout_read_error	vmlinux	EXPORT_SYMBOL_GPL	
++0x71a0a84f	nfs_clone_server	vmlinux	EXPORT_SYMBOL_GPL	
++0xb148783a	irq_domain_remove	vmlinux	EXPORT_SYMBOL_GPL	
++0x715cb553	ir_raw_event_store	vmlinux	EXPORT_SYMBOL_GPL	
++0xbc77d023	DWC_MUTEX_TRYLOCK	vmlinux	EXPORT_SYMBOL	
++0xf0d71c55	request_firmware_into_buf	vmlinux	EXPORT_SYMBOL	
++0x3c2d84c0	con_is_bound	vmlinux	EXPORT_SYMBOL	
++0xa00aca2a	dql_completed	vmlinux	EXPORT_SYMBOL	
++0x69b34073	__bio_try_merge_page	vmlinux	EXPORT_SYMBOL_GPL	
++0x6cb57f65	crypto_unregister_scomps	vmlinux	EXPORT_SYMBOL_GPL	
++0x6a77c3d2	crypto_unregister_acomps	vmlinux	EXPORT_SYMBOL_GPL	
++0xfb609b30	key_link	vmlinux	EXPORT_SYMBOL	
++0x93f52ccd	read_cache_page	vmlinux	EXPORT_SYMBOL	
++0xbfe5616d	tick_broadcast_oneshot_control	vmlinux	EXPORT_SYMBOL_GPL	
++0x5bdbac4e	rcu_unexpedite_gp	vmlinux	EXPORT_SYMBOL_GPL	
++0x2200061c	__tracepoint_pelt_irq_tp	vmlinux	EXPORT_SYMBOL_GPL	
++0xdc024bf1	__udp_gso_segment	vmlinux	EXPORT_SYMBOL_GPL	
++0xbe5e4737	dev_change_flags	vmlinux	EXPORT_SYMBOL	
++0xa23aa31e	__skb_gso_segment	vmlinux	EXPORT_SYMBOL	
++0x84a0ca4d	bitmap_zalloc_node	vmlinux	EXPORT_SYMBOL	
++0x1de4ccb2	get_sg_io_hdr	vmlinux	EXPORT_SYMBOL	
++0x10c22bcf	nfs4_find_get_deviceid	vmlinux	EXPORT_SYMBOL_GPL	
++0xb6bb0c5c	dquot_drop	vmlinux	EXPORT_SYMBOL	
++0x74a96fbb	xfrm_state_walk	vmlinux	EXPORT_SYMBOL	
++0x8b7c0d4b	inet_gso_segment	vmlinux	EXPORT_SYMBOL	
++0xdfde3bca	mbox_chan_txdone	vmlinux	EXPORT_SYMBOL_GPL	
++0xe13cd8a7	dmi_name_in_vendors	vmlinux	EXPORT_SYMBOL	
++0x882077d5	usb_ep_dequeue	vmlinux	EXPORT_SYMBOL_GPL	
++0x69e29d17	fwnode_get_parent	vmlinux	EXPORT_SYMBOL_GPL	
++0xa2068da5	sbitmap_queue_wake_all	vmlinux	EXPORT_SYMBOL_GPL	
++0x9a5e1d63	nla_put_nohdr	vmlinux	EXPORT_SYMBOL	
++0xa788700b	copy_to_user_nofault	vmlinux	EXPORT_SYMBOL_GPL	
++0x69431382	pid_nr_ns	vmlinux	EXPORT_SYMBOL_GPL	
++0x9be07adf	__tracepoint_signal_generate	vmlinux	EXPORT_SYMBOL	
++0x480de20f	napi_gro_flush	vmlinux	EXPORT_SYMBOL	
++0x2b6150fb	power_supply_temp2resist_simple	vmlinux	EXPORT_SYMBOL_GPL	
++0x43a991fc	scsi_set_medium_removal	vmlinux	EXPORT_SYMBOL	
++0x8b4b781a	pinctrl_pm_select_sleep_state	vmlinux	EXPORT_SYMBOL_GPL	
++0x181d6621	blk_stat_enable_accounting	vmlinux	EXPORT_SYMBOL_GPL	
++0x759d5784	keyring_clear	vmlinux	EXPORT_SYMBOL	
++0xb3a82019	profile_pc	vmlinux	EXPORT_SYMBOL	
++0xe6c7ba3d	devm_regulator_register_supply_alias	vmlinux	EXPORT_SYMBOL_GPL	
++0x8f5e7376	devm_clk_bulk_get_all	vmlinux	EXPORT_SYMBOL_GPL	
++0xd749c10c	jbd2_journal_wipe	vmlinux	EXPORT_SYMBOL	
++0x444f1735	cpu_pm_register_notifier	vmlinux	EXPORT_SYMBOL_GPL	
++0x7c2a1793	netdev_lower_get_next_private_rcu	vmlinux	EXPORT_SYMBOL	
++0x300c16b2	__skb_pad	vmlinux	EXPORT_SYMBOL	
++0x0152c3d8	usb_block_urb	vmlinux	EXPORT_SYMBOL_GPL	
++0x49a6e234	phy_ethtool_get_sset_count	vmlinux	EXPORT_SYMBOL	
++0x8c743fb6	reset_control_status	vmlinux	EXPORT_SYMBOL_GPL	
++0xeebf8302	dmaengine_desc_get_metadata_ptr	vmlinux	EXPORT_SYMBOL_GPL	
++0xfb8d0e3c	fb_set_var	vmlinux	EXPORT_SYMBOL	
++0xc310b981	strnstr	vmlinux	EXPORT_SYMBOL	
++0x43df96ba	__nla_put	vmlinux	EXPORT_SYMBOL	
++0x3411bcf6	__list_lru_init	vmlinux	EXPORT_SYMBOL_GPL	
++0xbd72a8b1	perf_pmu_migrate_context	vmlinux	EXPORT_SYMBOL_GPL	
++0x3b7fa9d4	get_state_synchronize_srcu	vmlinux	EXPORT_SYMBOL_GPL	
++0xfb77d40d	sdhci_pltfm_unregister	vmlinux	EXPORT_SYMBOL_GPL	
++0xbf3b9a27	bcm_phy_get_strings	vmlinux	EXPORT_SYMBOL_GPL	
++0x4a17ed66	sysrq_mask	vmlinux	EXPORT_SYMBOL_GPL	
++0x71de11b9	devm_pci_remap_cfg_resource	vmlinux	EXPORT_SYMBOL	
++0x169938c1	__sysfs_match_string	vmlinux	EXPORT_SYMBOL	
++0x01a97953	crypto_register_acomps	vmlinux	EXPORT_SYMBOL_GPL	
++0xab7a9b79	pnfs_generic_layout_insert_lseg	vmlinux	EXPORT_SYMBOL_GPL	
++0x5d5afaa6	blk_trace_startstop	vmlinux	EXPORT_SYMBOL_GPL	
++0x34db050b	_raw_spin_lock_irqsave	vmlinux	EXPORT_SYMBOL	
++0x702e000d	tcp_done	vmlinux	EXPORT_SYMBOL_GPL	
++0xd66c8184	add_device_randomness	vmlinux	EXPORT_SYMBOL	
++0x20d65e40	fb_find_nearest_mode	vmlinux	EXPORT_SYMBOL	
++0x5fd8d8fa	gpiod_get_array	vmlinux	EXPORT_SYMBOL_GPL	
++0x2796e19a	trace_put_event_file	vmlinux	EXPORT_SYMBOL_GPL	
++0x0a575945	xfrm_count_pfkey_auth_supported	vmlinux	EXPORT_SYMBOL_GPL	
++0x0c25ec48	secure_tcpv6_seq	vmlinux	EXPORT_SYMBOL	
++0x78ddb76b	dmi_match	vmlinux	EXPORT_SYMBOL_GPL	
++0x8b699dfb	usb_of_has_combined_node	vmlinux	EXPORT_SYMBOL_GPL	
++0xedf582e9	usb_init_urb	vmlinux	EXPORT_SYMBOL_GPL	
++0xa3b400ab	genphy_aneg_done	vmlinux	EXPORT_SYMBOL	
++0x994b3bba	iscsi_create_iface	vmlinux	EXPORT_SYMBOL_GPL	
++0xdb7a5380	add_bootloader_randomness	vmlinux	EXPORT_SYMBOL_GPL	
++0xc4095d5d	serial8250_rpm_get	vmlinux	EXPORT_SYMBOL_GPL	
++0xed8a2d95	memset64	vmlinux	EXPORT_SYMBOL	
++0xabd89b11	badblocks_clear	vmlinux	EXPORT_SYMBOL_GPL	
++0x2a15e1c0	crypto_alloc_kpp	vmlinux	EXPORT_SYMBOL_GPL	
++0xe43fab66	security_inode_getsecctx	vmlinux	EXPORT_SYMBOL	
++0x4ef77472	unregister_nfs_version	vmlinux	EXPORT_SYMBOL_GPL	
++0x0dd48778	fscrypt_enqueue_decrypt_work	vmlinux	EXPORT_SYMBOL	
++0x1fa532e8	wait_on_page_bit_killable	vmlinux	EXPORT_SYMBOL	
++0xd1bcbbab	irq_domain_free_irqs_common	vmlinux	EXPORT_SYMBOL_GPL	
++0x9607a699	__irq_domain_alloc_fwnode	vmlinux	EXPORT_SYMBOL_GPL	
++0x7b6fa396	udp_init_sock	vmlinux	EXPORT_SYMBOL_GPL	
++0x56eba17c	__traceiter_kfree_skb	vmlinux	EXPORT_SYMBOL_GPL	
++0xc32ac53e	usb_hcd_unmap_urb_setup_for_dma	vmlinux	EXPORT_SYMBOL_GPL	
++0x1ecfc267	scsi_device_put	vmlinux	EXPORT_SYMBOL	
++0x9f8327ac	scsi_device_get	vmlinux	EXPORT_SYMBOL	
++0x257b6f7d	of_pm_clk_add_clk	vmlinux	EXPORT_SYMBOL_GPL	
++0x4eeb4dba	__pm_runtime_set_status	vmlinux	EXPORT_SYMBOL_GPL	
++0x932136dc	serdev_controller_alloc	vmlinux	EXPORT_SYMBOL_GPL	
++0x0bd5d316	kmem_cache_alloc_bulk	vmlinux	EXPORT_SYMBOL	
++0xfd7449d7	unregister_shrinker	vmlinux	EXPORT_SYMBOL	
++0x7bae6f85	unregister_ftrace_function	vmlinux	EXPORT_SYMBOL_GPL	
++0x2e2360b1	ftrace_set_global_notrace	vmlinux	EXPORT_SYMBOL_GPL	
++0x09678caf	xfrm_policy_flush	vmlinux	EXPORT_SYMBOL	
++0x1f67a33a	skb_tx_error	vmlinux	EXPORT_SYMBOL	
++0x4b747b02	sock_efree	vmlinux	EXPORT_SYMBOL	
++0x4cddf5fa	mmc_set_blocklen	vmlinux	EXPORT_SYMBOL	
++0xa9f8d08f	napi_gro_frags	vmlinux	EXPORT_SYMBOL	
++0xfce42204	netdev_unbind_sb_channel	vmlinux	EXPORT_SYMBOL	
++0x46e1a265	skb_copy_datagram_from_iter	vmlinux	EXPORT_SYMBOL	
++0x8f58721f	cpufreq_cpu_get_raw	vmlinux	EXPORT_SYMBOL_GPL	
++0x0d16fa13	pci_load_saved_state	vmlinux	EXPORT_SYMBOL_GPL	
++0xf0abf896	key_task_permission	vmlinux	EXPORT_SYMBOL	
++0x5485ef43	page_cache_next_miss	vmlinux	EXPORT_SYMBOL	
++0x961286e0	ring_buffer_read_events_cpu	vmlinux	EXPORT_SYMBOL_GPL	
++0x0d4961de	nf_log_buf_open	vmlinux	EXPORT_SYMBOL_GPL	
++0x5307fa64	netdev_has_upper_dev_all_rcu	vmlinux	EXPORT_SYMBOL	
++0x3f709959	sock_sendmsg	vmlinux	EXPORT_SYMBOL	
++0x37729d04	iscsi_offload_mesg	vmlinux	EXPORT_SYMBOL_GPL	
++0x37d60749	import_iovec	vmlinux	EXPORT_SYMBOL	
++0x86d52ba5	lookup_constant	vmlinux	EXPORT_SYMBOL	
++0xc43e92b9	trace_seq_bprintf	vmlinux	EXPORT_SYMBOL_GPL	
++0xe4df13ad	skb_tunnel_check_pmtu	vmlinux	EXPORT_SYMBOL	
++0xa4d0b704	netlink_kernel_release	vmlinux	EXPORT_SYMBOL	
++0x31c73cdd	__sock_create	vmlinux	EXPORT_SYMBOL	
++0x73dd5677	regulator_suspend_disable	vmlinux	EXPORT_SYMBOL_GPL	
++0x5be848b5	pci_bus_resource_n	vmlinux	EXPORT_SYMBOL_GPL	
++0x36d1f179	pinctrl_select_default_state	vmlinux	EXPORT_SYMBOL_GPL	
++0xf5a20ed2	__genradix_prealloc	vmlinux	EXPORT_SYMBOL	
++0xc6871432	bio_free_pages	vmlinux	EXPORT_SYMBOL	
++0x69585523	__ksize	vmlinux	EXPORT_SYMBOL	
++0x6bd0e573	down_interruptible	vmlinux	EXPORT_SYMBOL	
++0x2f786008	tcp_abort	vmlinux	EXPORT_SYMBOL_GPL	
++0x5f064586	netif_carrier_off	vmlinux	EXPORT_SYMBOL	
++0xeaf34b99	mmc_request_done	vmlinux	EXPORT_SYMBOL	
++0x13ed8784	sdev_evt_alloc	vmlinux	EXPORT_SYMBOL_GPL	
++0xcdef4730	pinctrl_force_default	vmlinux	EXPORT_SYMBOL_GPL	
++0x376dcd4c	lease_get_mtime	vmlinux	EXPORT_SYMBOL	
++0x7ad2a9ee	sb_set_blocksize	vmlinux	EXPORT_SYMBOL	
++0x57768862	srcu_barrier	vmlinux	EXPORT_SYMBOL_GPL	
++0xd8693147	kthread_unpark	vmlinux	EXPORT_SYMBOL_GPL	
++0xcfeb2d9a	cache_seq_start_rcu	vmlinux	EXPORT_SYMBOL_GPL	
++0x9175c4c9	inet_csk_reqsk_queue_drop	vmlinux	EXPORT_SYMBOL	
++0xf2812ef2	nf_ct_hook	vmlinux	EXPORT_SYMBOL_GPL	
++0x4a2c2eff	flow_block_cb_incref	vmlinux	EXPORT_SYMBOL	
++0x0b0cd260	sdio_writew	vmlinux	EXPORT_SYMBOL_GPL	
++0xf358ea39	pinctrl_utils_free_map	vmlinux	EXPORT_SYMBOL_GPL	
++0x3744cf36	vmalloc_to_pfn	vmlinux	EXPORT_SYMBOL	
++0x83150a69	access_process_vm	vmlinux	EXPORT_SYMBOL_GPL	
++0x017cc464	__tracepoint_xdp_exception	vmlinux	EXPORT_SYMBOL_GPL	
++0x6d6f67f5	get_task_mm	vmlinux	EXPORT_SYMBOL_GPL	
++0xfeb5d0aa	verify_spi_info	vmlinux	EXPORT_SYMBOL	
++0x6b93cdca	udp_skb_destructor	vmlinux	EXPORT_SYMBOL	
++0x42e1ca26	inet_csk_prepare_forced_close	vmlinux	EXPORT_SYMBOL	
++0x551bd071	__rb_erase_color	vmlinux	EXPORT_SYMBOL	
++0x42f2c81f	nfs4_client_id_uniquifier	vmlinux	EXPORT_SYMBOL_GPL	
++0x7cb0a541	bd_set_nr_sectors	vmlinux	EXPORT_SYMBOL	
++0x8e16419b	trace_clock_local	vmlinux	EXPORT_SYMBOL_GPL	
++0x185dff6a	rpc_task_release_transport	vmlinux	EXPORT_SYMBOL_GPL	
++0xda510603	register_tcf_proto_ops	vmlinux	EXPORT_SYMBOL	
++0xebd1a176	input_get_poll_interval	vmlinux	EXPORT_SYMBOL	
++0xb9b9df41	usb_amd_dev_put	vmlinux	EXPORT_SYMBOL_GPL	
++0x41de6e46	phy_start_cable_test	vmlinux	EXPORT_SYMBOL	
++0xedf70426	nvme_command_effects	vmlinux	EXPORT_SYMBOL_GPL	NVME_TARGET_PASSTHRU
++0xdd6c0ac0	reset_simple_ops	vmlinux	EXPORT_SYMBOL_GPL	
++0x34c2c6f5	pci_ignore_hotplug	vmlinux	EXPORT_SYMBOL_GPL	
++0x95843030	mpi_ec_init	vmlinux	EXPORT_SYMBOL_GPL	
++0xa21af898	crypto_unregister_rng	vmlinux	EXPORT_SYMBOL_GPL	
++0xaf301623	crypto_unregister_alg	vmlinux	EXPORT_SYMBOL_GPL	
++0xd21c9646	sched_trace_rq_avg_rt	vmlinux	EXPORT_SYMBOL_GPL	
++0xaa0fd81b	nvmem_get_mac_address	vmlinux	EXPORT_SYMBOL	
++0xd1a9ca15	__SCK__tp_func_neigh_update	vmlinux	EXPORT_SYMBOL_GPL	
++0x7d6333a0	netdev_walk_all_lower_dev	vmlinux	EXPORT_SYMBOL_GPL	
++0xe1704022	__skb_vlan_pop	vmlinux	EXPORT_SYMBOL	
++0x63a3422f	hwmon_device_register_with_groups	vmlinux	EXPORT_SYMBOL_GPL	
++0x6a9ef2ae	__class_create	vmlinux	EXPORT_SYMBOL_GPL	
++0x310b475e	clk_register_mux_table	vmlinux	EXPORT_SYMBOL_GPL	
++0x4c416eb9	LZ4_decompress_fast	vmlinux	EXPORT_SYMBOL	
++0x3b20c05c	truncate_bdev_range	vmlinux	EXPORT_SYMBOL	
++0x3a61d8fa	filp_open	vmlinux	EXPORT_SYMBOL	
++0x8fb815ca	__vmalloc_node_range	vmlinux	EXPORT_SYMBOL_GPL	
++0x6ce10eb0	trace_clock_jiffies	vmlinux	EXPORT_SYMBOL_GPL	
++0xbc83749f	smpboot_register_percpu_thread	vmlinux	EXPORT_SYMBOL_GPL	
++0xaab23340	xfrm_calg_get_byname	vmlinux	EXPORT_SYMBOL_GPL	
++0xa22e9df3	vchiq_add_connected_callback	vmlinux	EXPORT_SYMBOL	
++0x2a0c0004	__bcm_phy_write_exp	vmlinux	EXPORT_SYMBOL_GPL	
++0x2ebe3135	cpu_is_hotpluggable	vmlinux	EXPORT_SYMBOL_GPL	
++0x543ac14c	pci_read_vpd	vmlinux	EXPORT_SYMBOL	
++0x3ba7aa74	gen_pool_dma_zalloc_align	vmlinux	EXPORT_SYMBOL	
++0x127e9880	crypto_sha256_finup	vmlinux	EXPORT_SYMBOL	
++0x6636c3c9	irq_set_vcpu_affinity	vmlinux	EXPORT_SYMBOL_GPL	
++0xb3ee2231	_mutex_unlock	vmlinux	EXPORT_SYMBOL	
++0xe7eee3d5	__cookie_v4_init_sequence	vmlinux	EXPORT_SYMBOL_GPL	
++0x54d6508d	of_property_match_string	vmlinux	EXPORT_SYMBOL_GPL	
++0x172ec730	DWC_WORKQ_PENDING	vmlinux	EXPORT_SYMBOL	
++0x9c14394c	DWC_TASK_FREE	vmlinux	EXPORT_SYMBOL	
++0x8e7ec2b6	__tracepoint_nvme_sq	vmlinux	EXPORT_SYMBOL_GPL	
++0x01e7d208	regulator_bulk_register_supply_alias	vmlinux	EXPORT_SYMBOL_GPL	
++0x9a44ab08	__clk_get_hw	vmlinux	EXPORT_SYMBOL_GPL	
++0xfbeeeec5	blk_pm_runtime_init	vmlinux	EXPORT_SYMBOL	
++0xb9d64667	bsg_setup_queue	vmlinux	EXPORT_SYMBOL_GPL	
++0xab2c2511	d_exact_alias	vmlinux	EXPORT_SYMBOL	
++0x862b1c8e	__free_pages	vmlinux	EXPORT_SYMBOL	
++0x95e102ab	tracepoint_probe_register	vmlinux	EXPORT_SYMBOL_GPL	
++0x7eda6c17	inet_bind	vmlinux	EXPORT_SYMBOL	
++0x5024f624	tc_setup_cb_call	vmlinux	EXPORT_SYMBOL	
++0x171b12a1	qdisc_watchdog_init	vmlinux	EXPORT_SYMBOL	
++0xad76a3f0	__SCK__tp_func_neigh_update_done	vmlinux	EXPORT_SYMBOL_GPL	
++0x590368ee	power_supply_class	vmlinux	EXPORT_SYMBOL_GPL	
++0x3016fecd	rtc_nvmem_register	vmlinux	EXPORT_SYMBOL_GPL	
++0x98381874	usb_gadget_probe_driver	vmlinux	EXPORT_SYMBOL_GPL	
++0xe3556a4c	usb_hcd_end_port_resume	vmlinux	EXPORT_SYMBOL_GPL	
++0x7073c04f	phy_10_100_features_array	vmlinux	EXPORT_SYMBOL_GPL	
++0x17f8c873	class_find_device	vmlinux	EXPORT_SYMBOL_GPL	
++0x96c16c14	msi_desc_to_pci_sysdata	vmlinux	EXPORT_SYMBOL_GPL	
++0x2ed53e98	pci_scan_child_bus	vmlinux	EXPORT_SYMBOL_GPL	
++0x7391bb1d	blk_mq_run_hw_queues	vmlinux	EXPORT_SYMBOL	
++0xdb8e7e21	__register_binfmt	vmlinux	EXPORT_SYMBOL	
++0x5ae1154b	__traceiter_kfree	vmlinux	EXPORT_SYMBOL	
++0x3adbd628	xfrm_init_state	vmlinux	EXPORT_SYMBOL	
++0x733d8cd2	rtnl_nla_parse_ifla	vmlinux	EXPORT_SYMBOL	
++0xabe6c66c	alloc_skb_with_frags	vmlinux	EXPORT_SYMBOL	
++0xc385cb58	perf_num_counters	vmlinux	EXPORT_SYMBOL_GPL	
++0xd88b6aaf	sb800_prefetch	vmlinux	EXPORT_SYMBOL_GPL	
++0x3fec1e59	pci_assign_resource	vmlinux	EXPORT_SYMBOL	
++0xb3f49446	kstrtos8_from_user	vmlinux	EXPORT_SYMBOL	
++0x0aa8a98d	crypto_unregister_aead	vmlinux	EXPORT_SYMBOL_GPL	
++0x01c6cb0c	cpu_cluster_pm_enter	vmlinux	EXPORT_SYMBOL_GPL	
++0xee98c5af	xfrm_user_policy	vmlinux	EXPORT_SYMBOL	
++0x40d2e520	tcp_sock_set_keepcnt	vmlinux	EXPORT_SYMBOL	
++0x60fbc7a7	netpoll_poll_disable	vmlinux	EXPORT_SYMBOL	
++0x6ca5e2c2	netif_napi_add	vmlinux	EXPORT_SYMBOL	
++0xf053b28a	skb_split	vmlinux	EXPORT_SYMBOL	
++0x2c70b6b5	input_grab_device	vmlinux	EXPORT_SYMBOL	
++0x755db8cf	xhci_init_driver	vmlinux	EXPORT_SYMBOL_GPL	
++0xec9f9182	phy_modify_paged	vmlinux	EXPORT_SYMBOL	
++0x05f29683	tty_port_block_til_ready	vmlinux	EXPORT_SYMBOL	
++0xc3e8f2d0	regulator_get_init_drvdata	vmlinux	EXPORT_SYMBOL_GPL	
++0x3353205c	regulator_get_current_limit	vmlinux	EXPORT_SYMBOL_GPL	
++0xa3b0a892	nfs_file_write	vmlinux	EXPORT_SYMBOL_GPL	
++0xa71e48aa	vif_device_init	vmlinux	EXPORT_SYMBOL	
++0x0ef36659	netlink_broadcast	vmlinux	EXPORT_SYMBOL	
++0xcf1d0198	__skb_get_hash_symmetric	vmlinux	EXPORT_SYMBOL_GPL	
++0x497ceef6	nvmem_cell_read_u64	vmlinux	EXPORT_SYMBOL_GPL	
++0xe51dda3f	nvmem_cell_read_u32	vmlinux	EXPORT_SYMBOL_GPL	
++0xf244388d	nvmem_cell_read_u16	vmlinux	EXPORT_SYMBOL_GPL	
++0x21348be9	sdhci_cqe_enable	vmlinux	EXPORT_SYMBOL_GPL	
++0xdeb03959	dev_pm_opp_get_max_clock_latency	vmlinux	EXPORT_SYMBOL_GPL	
++0x0343bdf1	__i2c_board_list	vmlinux	EXPORT_SYMBOL_GPL	
++0x7c159476	shmem_file_setup	vmlinux	EXPORT_SYMBOL_GPL	
++0x7a98f4b4	copy_from_user_nofault	vmlinux	EXPORT_SYMBOL_GPL	
++0xc631580a	console_unlock	vmlinux	EXPORT_SYMBOL	
++0x8b8059bd	in_group_p	vmlinux	EXPORT_SYMBOL	
++0x0375b73a	udp_sendmsg	vmlinux	EXPORT_SYMBOL	
++0x46269814	__tracepoint_neigh_event_send_dead	vmlinux	EXPORT_SYMBOL_GPL	
++0x3bdc0e0c	__tracepoint_neigh_event_send_done	vmlinux	EXPORT_SYMBOL_GPL	
++0x1e44dc32	ipv6_bpf_stub	vmlinux	EXPORT_SYMBOL_GPL	
++0xe4b818c3	phy_speed_to_str	vmlinux	EXPORT_SYMBOL_GPL	
++0xf29f8515	__kfifo_dma_out_prepare_r	vmlinux	EXPORT_SYMBOL	
++0x1b94bf53	blkg_prfill_rwstat	vmlinux	EXPORT_SYMBOL_GPL	
++0x30ee45a9	elv_rb_former_request	vmlinux	EXPORT_SYMBOL	
++0x433ae21c	user_preparse	vmlinux	EXPORT_SYMBOL_GPL	
++0x79bf9c3a	bpf_trace_run9	vmlinux	EXPORT_SYMBOL_GPL	
++0xf501a9fb	bpf_trace_run8	vmlinux	EXPORT_SYMBOL_GPL	
++0x6ab7a6b1	bpf_trace_run7	vmlinux	EXPORT_SYMBOL_GPL	
++0x64808c7c	bpf_trace_run6	vmlinux	EXPORT_SYMBOL_GPL	
++0xa8847092	bpf_trace_run5	vmlinux	EXPORT_SYMBOL_GPL	
++0x6d2471b0	bpf_trace_run4	vmlinux	EXPORT_SYMBOL_GPL	
++0xd969f657	bpf_trace_run3	vmlinux	EXPORT_SYMBOL_GPL	
++0x03fe9f79	bpf_trace_run2	vmlinux	EXPORT_SYMBOL_GPL	
++0x982cc33b	bpf_trace_run1	vmlinux	EXPORT_SYMBOL_GPL	
++0xf53d4c26	qdisc_class_hash_destroy	vmlinux	EXPORT_SYMBOL	
++0x7cfb33b2	sdio_register_driver	vmlinux	EXPORT_SYMBOL_GPL	
++0xa6b0f637	usb_kill_urb	vmlinux	EXPORT_SYMBOL_GPL	
++0xfecaff2c	usb_get_intf	vmlinux	EXPORT_SYMBOL_GPL	
++0x7bdd589b	iscsi_destroy_all_flashnode	vmlinux	EXPORT_SYMBOL_GPL	
++0x656c5042	dev_pm_genpd_set_performance_state	vmlinux	EXPORT_SYMBOL_GPL	
++0xae9c7e48	regulator_get_voltage_rdev	vmlinux	EXPORT_SYMBOL_GPL	
++0x28a6c0d0	devm_request_pci_bus_resources	vmlinux	EXPORT_SYMBOL_GPL	
++0x53104483	nfs4_test_deviceid_unavailable	vmlinux	EXPORT_SYMBOL_GPL	
++0xa6e1a69d	kick_all_cpus_sync	vmlinux	EXPORT_SYMBOL_GPL	
++0xb9f9f794	sbitmap_queue_clear	vmlinux	EXPORT_SYMBOL_GPL	
++0x976b9a58	key_type_asymmetric	vmlinux	EXPORT_SYMBOL_GPL	
++0x3f5256a4	proc_get_parent_data	vmlinux	EXPORT_SYMBOL_GPL	
++0x288b8f8a	find_inode_rcu	vmlinux	EXPORT_SYMBOL	
++0x419ac667	audit_log	vmlinux	EXPORT_SYMBOL	
++0x617ec936	_mutex_lock_io_nested	vmlinux	EXPORT_SYMBOL_GPL	
++0x79f5152e	set_security_override_from_ctx	vmlinux	EXPORT_SYMBOL	
++0xb864ba0f	xdr_process_buf	vmlinux	EXPORT_SYMBOL_GPL	
++0x3306242c	sk_wait_data	vmlinux	EXPORT_SYMBOL	
++0xb331f819	usb_autopm_put_interface_no_suspend	vmlinux	EXPORT_SYMBOL_GPL	
++0xb2c392a5	spi_mem_dirmap_write	vmlinux	EXPORT_SYMBOL_GPL	
++0x6ab5e455	pci_enable_wake	vmlinux	EXPORT_SYMBOL	
++0xeff76508	__blk_mq_end_request	vmlinux	EXPORT_SYMBOL	
++0xeab524e1	skcipher_walk_complete	vmlinux	EXPORT_SYMBOL_GPL	
++0x92195875	crypto_remove_spawns	vmlinux	EXPORT_SYMBOL_GPL	
++0x412bc681	ring_buffer_empty_cpu	vmlinux	EXPORT_SYMBOL_GPL	
++0xf0adbdd9	ip6tun_encaps	vmlinux	EXPORT_SYMBOL	
++0xb1a49ff2	lwtunnel_state_alloc	vmlinux	EXPORT_SYMBOL_GPL	
++0xc024be25	__netpoll_setup	vmlinux	EXPORT_SYMBOL_GPL	
++0x9bfdc372	put_cmsg_scm_timestamping	vmlinux	EXPORT_SYMBOL	
++0xbc9da3c5	pci_free_host_bridge	vmlinux	EXPORT_SYMBOL	
++0x93d992ee	__percpu_counter_init	vmlinux	EXPORT_SYMBOL	
++0x920cc389	visitorl	vmlinux	EXPORT_SYMBOL_GPL	
++0xf668b946	get_user_pages_remote	vmlinux	EXPORT_SYMBOL	
++0x9e6c9888	irq_get_domain_generic_chip	vmlinux	EXPORT_SYMBOL_GPL	
++0x1d03366a	irq_set_affinity_notifier	vmlinux	EXPORT_SYMBOL_GPL	
++0x029305d8	inet_hashinfo_init	vmlinux	EXPORT_SYMBOL_GPL	
++0xd20986d7	ipv4_sk_redirect	vmlinux	EXPORT_SYMBOL_GPL	
++0xad7e64e6	input_mt_report_pointer_emulation	vmlinux	EXPORT_SYMBOL	
++0x30f61e16	usb_stor_bulk_transfer_sg	vmlinux	EXPORT_SYMBOL_GPL	USB_STORAGE
++0xac74ba0b	tty_ldisc_receive_buf	vmlinux	EXPORT_SYMBOL_GPL	
++0x73ec3f8b	pci_ioremap_bar	vmlinux	EXPORT_SYMBOL_GPL	
++0xcb05ebb4	pwm_request	vmlinux	EXPORT_SYMBOL_GPL	
++0xca8ad245	xas_find_marked	vmlinux	EXPORT_SYMBOL_GPL	
++0x4616f38e	pnfs_generic_prepare_to_resend_writes	vmlinux	EXPORT_SYMBOL_GPL	
++0x4bffb4b1	end_buffer_read_sync	vmlinux	EXPORT_SYMBOL	
++0x8147886d	d_add	vmlinux	EXPORT_SYMBOL	
++0xbf5c0d11	set_cpus_allowed_ptr	vmlinux	EXPORT_SYMBOL_GPL	
++0xe6f8af6e	tcf_em_tree_dump	vmlinux	EXPORT_SYMBOL	
++0xd3422289	neigh_for_each	vmlinux	EXPORT_SYMBOL	
++0xbc42e909	rtc_initialize_alarm	vmlinux	EXPORT_SYMBOL_GPL	
++0x6971447a	rtc_month_days	vmlinux	EXPORT_SYMBOL	
++0x7e64181d	usb_calc_bus_time	vmlinux	EXPORT_SYMBOL_GPL	
++0x49c431bd	regulator_is_enabled_regmap	vmlinux	EXPORT_SYMBOL_GPL	
++0x765c0b59	devm_pinctrl_register_and_init	vmlinux	EXPORT_SYMBOL_GPL	
++0x77e9eb37	aes_encrypt	vmlinux	EXPORT_SYMBOL	
++0x19d16507	sg_miter_next	vmlinux	EXPORT_SYMBOL	
++0x85efc7e0	zero_pfn	vmlinux	EXPORT_SYMBOL	
++0xaa21e61a	param_get_ushort	vmlinux	EXPORT_SYMBOL	
++0xbc0b7e78	svc_sock_update_bufs	vmlinux	EXPORT_SYMBOL_GPL	
++0x870aa261	tcp_sock_set_cork	vmlinux	EXPORT_SYMBOL	
++0x79e18758	skb_pull	vmlinux	EXPORT_SYMBOL	
++0xe5b54e2e	usb_find_interface	vmlinux	EXPORT_SYMBOL_GPL	
++0x89baf055	bcm_phy_write_rdb	vmlinux	EXPORT_SYMBOL_GPL	
++0x813cf212	nvme_io_timeout	vmlinux	EXPORT_SYMBOL_GPL	
++0x2cc24b9c	device_get_match_data	vmlinux	EXPORT_SYMBOL_GPL	
++0x31be4e1d	clk_register	vmlinux	EXPORT_SYMBOL_GPL	
++0xcf884925	amba_find_device	vmlinux	EXPORT_SYMBOL	
++0xc0bcd119	pci_add_new_bus	vmlinux	EXPORT_SYMBOL	
++0x9ba2bb2b	gpio_request_array	vmlinux	EXPORT_SYMBOL_GPL	
++0x55bfe58f	font_vga_8x16	vmlinux	EXPORT_SYMBOL	
++0x2688ec10	bitmap_zalloc	vmlinux	EXPORT_SYMBOL	
++0x59d1e349	blkcg_policy_unregister	vmlinux	EXPORT_SYMBOL_GPL	
++0x21f87cab	sysfs_remove_file_ns	vmlinux	EXPORT_SYMBOL_GPL	
++0x4e8f6ca7	sunrpc_net_id	vmlinux	EXPORT_SYMBOL_GPL	
++0x613b35dc	neigh_app_ns	vmlinux	EXPORT_SYMBOL	
++0xb708e155	netdev_lower_get_first_private_rcu	vmlinux	EXPORT_SYMBOL	
++0x596e90c8	iscsi_block_scsi_eh	vmlinux	EXPORT_SYMBOL_GPL	
++0xe7ff70f0	scsi_get_vpd_page	vmlinux	EXPORT_SYMBOL_GPL	
++0x2e32ff08	pm_clk_runtime_suspend	vmlinux	EXPORT_SYMBOL_GPL	
++0x90ad66b1	software_node_unregister_nodes	vmlinux	EXPORT_SYMBOL_GPL	
++0xb0d1656c	gpio_free_array	vmlinux	EXPORT_SYMBOL_GPL	
++0x47c5317c	iomap_finish_ioends	vmlinux	EXPORT_SYMBOL_GPL	
++0x9aba2d16	irq_remove_generic_chip	vmlinux	EXPORT_SYMBOL_GPL	
++0x0f7bcb33	xfrm_state_check_expire	vmlinux	EXPORT_SYMBOL	
++0x50146fd4	xfrm4_protocol_register	vmlinux	EXPORT_SYMBOL	
++0x5db69d57	sock_diag_unregister_inet_compat	vmlinux	EXPORT_SYMBOL_GPL	
++0xa9ecd911	netdev_boot_setup_check	vmlinux	EXPORT_SYMBOL	
++0x31cb14cd	sock_i_ino	vmlinux	EXPORT_SYMBOL	
++0x08dde397	sock_i_uid	vmlinux	EXPORT_SYMBOL	
++0x8ac27056	phy_attached_info	vmlinux	EXPORT_SYMBOL	
++0x52ce4bcd	regulator_set_voltage_time	vmlinux	EXPORT_SYMBOL_GPL	
++0x430a3e24	__traceiter_nfs4_pnfs_write	vmlinux	EXPORT_SYMBOL_GPL	
++0x118d0375	xprt_get	vmlinux	EXPORT_SYMBOL_GPL	
++0x526a4a11	ip_build_and_send_pkt	vmlinux	EXPORT_SYMBOL_GPL	
++0x367498ae	register_gifconf	vmlinux	EXPORT_SYMBOL	
++0x09e6b9c7	mmc_wait_for_req_done	vmlinux	EXPORT_SYMBOL	
++0x46b03548	cpufreq_unregister_driver	vmlinux	EXPORT_SYMBOL_GPL	
++0xe88c0be2	dev_pm_opp_of_add_table_indexed	vmlinux	EXPORT_SYMBOL_GPL	
++0xa3e475f1	regulator_get_voltage_sel_regmap	vmlinux	EXPORT_SYMBOL_GPL	
++0x843c6015	clk_gate_is_enabled	vmlinux	EXPORT_SYMBOL_GPL	
++0xdd55e6c5	__clk_mux_determine_rate_closest	vmlinux	EXPORT_SYMBOL_GPL	
++0xec4d9e3a	clk_get_sys	vmlinux	EXPORT_SYMBOL	
++0x1331247e	pcie_print_link_status	vmlinux	EXPORT_SYMBOL	
++0x3204da89	gpiochip_find	vmlinux	EXPORT_SYMBOL_GPL	
++0x6531a37f	mpi_add	vmlinux	EXPORT_SYMBOL_GPL	
++0x33fcf44a	__kfifo_out_r	vmlinux	EXPORT_SYMBOL	
++0xf0a24129	crypto_req_done	vmlinux	EXPORT_SYMBOL_GPL	
++0x457594fa	crypto_alg_list	vmlinux	EXPORT_SYMBOL_GPL	
++0x551f5ab6	sync_inode_metadata	vmlinux	EXPORT_SYMBOL	
++0x7d2251be	vm_map_pages	vmlinux	EXPORT_SYMBOL	
++0x318a8428	mempool_alloc	vmlinux	EXPORT_SYMBOL	
++0xfabecec7	unregister_wide_hw_breakpoint	vmlinux	EXPORT_SYMBOL_GPL	
++0xa2dd811f	free_cgroup_ns	vmlinux	EXPORT_SYMBOL	
++0x86f6b99d	synchronize_rcu_expedited	vmlinux	EXPORT_SYMBOL_GPL	
++0xc0f0458a	ip_tunnel_unneed_metadata	vmlinux	EXPORT_SYMBOL_GPL	
++0x2578f666	hid_setup_resolution_multiplier	vmlinux	EXPORT_SYMBOL_GPL	
++0x3cc18acc	__srcu_read_lock	vmlinux	EXPORT_SYMBOL_GPL	
++0xba835748	irq_domain_alloc_irqs_parent	vmlinux	EXPORT_SYMBOL_GPL	
++0x892592e0	__rt_spin_unlock	vmlinux	EXPORT_SYMBOL	
++0x6e5e13c6	ip_sock_set_pktinfo	vmlinux	EXPORT_SYMBOL	
++0xe42a4657	flow_rule_match_ct	vmlinux	EXPORT_SYMBOL	
++0xe3840e18	secure_ipv4_port_ephemeral	vmlinux	EXPORT_SYMBOL_GPL	
++0x545025e5	nvmem_add_cell_table	vmlinux	EXPORT_SYMBOL_GPL	
++0xbc3b57cf	dma_fence_init	vmlinux	EXPORT_SYMBOL	
++0x979148b1	serdev_device_set_flow_control	vmlinux	EXPORT_SYMBOL_GPL	
++0xa6b5ee5b	__SCK__tp_func_block_split	vmlinux	EXPORT_SYMBOL_GPL	
++0x6081b89c	nfs_submount	vmlinux	EXPORT_SYMBOL_GPL	
++0xe5e5df13	iomap_seek_data	vmlinux	EXPORT_SYMBOL_GPL	
++0x042f8a95	pagecache_get_page	vmlinux	EXPORT_SYMBOL	
++0xfa6f79a2	rt_spin_lock	vmlinux	EXPORT_SYMBOL	
++0xb900e71c	proc_dointvec_minmax	vmlinux	EXPORT_SYMBOL	
++0xf8fdd0ca	mr_vif_seq_idx	vmlinux	EXPORT_SYMBOL	
++0x3c7a0bf3	dev_mc_add_excl	vmlinux	EXPORT_SYMBOL	
++0x1f58cc07	dev_uc_add_excl	vmlinux	EXPORT_SYMBOL	
++0x4d587bde	i2c_bus_type	vmlinux	EXPORT_SYMBOL_GPL	
++0x64d2f0f6	spi_mem_adjust_op_size	vmlinux	EXPORT_SYMBOL_GPL	
++0xbe933024	dma_fence_array_ops	vmlinux	EXPORT_SYMBOL	
++0x4fa4ea8b	pci_msi_create_irq_domain	vmlinux	EXPORT_SYMBOL_GPL	
++0x4db5da49	pci_unmap_iospace	vmlinux	EXPORT_SYMBOL	
++0xbf374ff5	blkcg_print_blkgs	vmlinux	EXPORT_SYMBOL_GPL	
++0x58980f82	blk_mq_alloc_request_hctx	vmlinux	EXPORT_SYMBOL_GPL	
++0x849dac16	kmalloc_caches	vmlinux	EXPORT_SYMBOL	
++0x4b6c679c	rpc_malloc	vmlinux	EXPORT_SYMBOL_GPL	
++0x469e0659	rt_dst_alloc	vmlinux	EXPORT_SYMBOL	
++0x0a2f25d8	usbnet_pause_rx	vmlinux	EXPORT_SYMBOL_GPL	
++0xd115b578	do_take_over_console	vmlinux	EXPORT_SYMBOL_GPL	
++0xe962916b	regulator_set_current_limit	vmlinux	EXPORT_SYMBOL_GPL	
++0xe97dbd9d	of_mm_gpiochip_add_data	vmlinux	EXPORT_SYMBOL_GPL	
++0x5e038960	sysfs_add_link_to_group	vmlinux	EXPORT_SYMBOL_GPL	
++0x25e65ad1	truncate_pagecache_range	vmlinux	EXPORT_SYMBOL	
++0x79f017ff	__traceiter_xdp_exception	vmlinux	EXPORT_SYMBOL_GPL	
++0x6f9e763b	timecounter_read	vmlinux	EXPORT_SYMBOL_GPL	
++0x16ec4e34	param_ops_ullong	vmlinux	EXPORT_SYMBOL	
++0x601eba30	led_classdev_resume	vmlinux	EXPORT_SYMBOL_GPL	
++0xc4c2a71b	input_reset_device	vmlinux	EXPORT_SYMBOL	
++0x16f96e33	fwnode_graph_get_remote_port_parent	vmlinux	EXPORT_SYMBOL_GPL	
++0xdcc85af4	tty_ldisc_deref	vmlinux	EXPORT_SYMBOL_GPL	
++0x2ee4c2b1	hdmi_avi_infoframe_pack_only	vmlinux	EXPORT_SYMBOL	
++0x76fb53c3	security_inode_setsecctx	vmlinux	EXPORT_SYMBOL	
++0xf689313b	dquot_scan_active	vmlinux	EXPORT_SYMBOL	
++0x5b93d2de	vfs_getattr	vmlinux	EXPORT_SYMBOL	
++0xc872fd85	in6addr_interfacelocal_allnodes	vmlinux	EXPORT_SYMBOL	
++0xddc0aff5	inet_del_protocol	vmlinux	EXPORT_SYMBOL	
++0x670b77ad	neigh_update	vmlinux	EXPORT_SYMBOL	
++0xd7bf4268	DWC_WAITQ_FREE	vmlinux	EXPORT_SYMBOL	
++0x130ef684	phy_stop	vmlinux	EXPORT_SYMBOL	
++0xfb0a66ec	tty_kclose	vmlinux	EXPORT_SYMBOL_GPL	
++0x902f5199	cpumask_next_wrap	vmlinux	EXPORT_SYMBOL	
++0xd4fa5a87	__kfifo_dma_out_prepare	vmlinux	EXPORT_SYMBOL	
++0x22d0a8a0	blk_queue_io_min	vmlinux	EXPORT_SYMBOL	
++0x587e87eb	nfs_writeback_update_inode	vmlinux	EXPORT_SYMBOL_GPL	
++0x190478b0	dquot_load_quota_inode	vmlinux	EXPORT_SYMBOL	
++0xd501a819	nobh_truncate_page	vmlinux	EXPORT_SYMBOL	
++0xbf5a31b0	xprt_lock_connect	vmlinux	EXPORT_SYMBOL_GPL	
++0x87bb810a	regulator_set_voltage_rdev	vmlinux	EXPORT_SYMBOL_GPL	
++0xeb8fcc84	__xas_prev	vmlinux	EXPORT_SYMBOL_GPL	
++0x6aeef23e	securityfs_create_symlink	vmlinux	EXPORT_SYMBOL_GPL	
++0x68b0bff3	nfs_pgio_header_alloc	vmlinux	EXPORT_SYMBOL_GPL	
++0x6c431de9	__vfs_getxattr	vmlinux	EXPORT_SYMBOL	
++0xeeeefa34	__put_page	vmlinux	EXPORT_SYMBOL	
++0xcf2a6966	up	vmlinux	EXPORT_SYMBOL	
++0x03a122f5	rpc_call_start	vmlinux	EXPORT_SYMBOL_GPL	
++0x2182a16a	of_pci_range_parser_one	vmlinux	EXPORT_SYMBOL_GPL	
++0x55d41b90	mmc_run_bkops	vmlinux	EXPORT_SYMBOL	
++0x4ad811aa	devm_spi_register_controller	vmlinux	EXPORT_SYMBOL_GPL	
++0x7cf7acd9	iscsi_lookup_endpoint	vmlinux	EXPORT_SYMBOL_GPL	
++0x2713e820	iov_iter_copy_from_user_atomic	vmlinux	EXPORT_SYMBOL	
++0xd4a68fea	nfs4_set_ds_client	vmlinux	EXPORT_SYMBOL_GPL	
++0xeb275cd6	nfs3_set_ds_client	vmlinux	EXPORT_SYMBOL_GPL	
++0x732564f1	path_get	vmlinux	EXPORT_SYMBOL	
++0x5af707d2	__inode_sub_bytes	vmlinux	EXPORT_SYMBOL	
++0xed362a1d	xfrm_state_update	vmlinux	EXPORT_SYMBOL	
++0x41fe0936	usb_deregister_dev	vmlinux	EXPORT_SYMBOL_GPL	
++0x42e9b528	usb_hcd_is_primary_hcd	vmlinux	EXPORT_SYMBOL_GPL	
++0xe92cb6bb	pci_bridge_secondary_bus_reset	vmlinux	EXPORT_SYMBOL_GPL	
++0x13ce87e8	asn1_ber_decoder	vmlinux	EXPORT_SYMBOL_GPL	
++0x5953acce	crypto_grab_aead	vmlinux	EXPORT_SYMBOL_GPL	
++0x933abfe3	no_seek_end_llseek_size	vmlinux	EXPORT_SYMBOL	
++0x1b30a1a3	__traceiter_rpm_return_int	vmlinux	EXPORT_SYMBOL_GPL	
++0x23864ce7	cpuset_mem_spread_node	vmlinux	EXPORT_SYMBOL_GPL	
++0xf09feb86	poll_state_synchronize_srcu	vmlinux	EXPORT_SYMBOL_GPL	
++0xd31f54bc	kthread_unuse_mm	vmlinux	EXPORT_SYMBOL_GPL	
++0xc558399c	get_pid_task	vmlinux	EXPORT_SYMBOL_GPL	
++0x47884890	system_power_efficient_wq	vmlinux	EXPORT_SYMBOL_GPL	
++0x6cb7a6d9	dev_open	vmlinux	EXPORT_SYMBOL	
++0xbd484093	__skb_free_datagram_locked	vmlinux	EXPORT_SYMBOL	
++0x1d746b4f	lock_sock_fast	vmlinux	EXPORT_SYMBOL	
++0x902108c4	sdhci_resume_host	vmlinux	EXPORT_SYMBOL_GPL	
++0xebe768fe	stmpe_block_write	vmlinux	EXPORT_SYMBOL_GPL	
++0x8342ff26	ilookup	vmlinux	EXPORT_SYMBOL	
++0x4302d0eb	free_pages	vmlinux	EXPORT_SYMBOL	
++0xaf579e9d	irq_create_of_mapping	vmlinux	EXPORT_SYMBOL_GPL	
++0x81e6b37f	dmi_get_system_info	vmlinux	EXPORT_SYMBOL	
++0x245a0424	thermal_of_cooling_device_register	vmlinux	EXPORT_SYMBOL_GPL	
++0xbf452caf	mdiobus_free	vmlinux	EXPORT_SYMBOL	
++0x2b4e36d5	of_pm_clk_add_clks	vmlinux	EXPORT_SYMBOL_GPL	
++0xbdaf9823	of_dma_request_slave_channel	vmlinux	EXPORT_SYMBOL_GPL	
++0x03592ea0	security_unix_stream_connect	vmlinux	EXPORT_SYMBOL	
++0x40739385	nfs_wait_bit_killable	vmlinux	EXPORT_SYMBOL_GPL	
++0x1d14179c	generic_file_fsync	vmlinux	EXPORT_SYMBOL	
++0x6d5863df	unlock_new_inode	vmlinux	EXPORT_SYMBOL	
++0x7901ddb2	__f_setown	vmlinux	EXPORT_SYMBOL	
++0xccef08c1	irq_create_direct_mapping	vmlinux	EXPORT_SYMBOL_GPL	
++0xd65a0fb8	execute_in_process_context	vmlinux	EXPORT_SYMBOL_GPL	
++0xa8f6c843	ip_frag_ecn_table	vmlinux	EXPORT_SYMBOL	
++0x242de579	ethnl_cable_test_finished	vmlinux	EXPORT_SYMBOL_GPL	
++0x62737e1d	sock_unregister	vmlinux	EXPORT_SYMBOL	
++0x2fd50bf0	i2c_new_client_device	vmlinux	EXPORT_SYMBOL_GPL	
++0xb9f18dd3	DWC_STRDUP	vmlinux	EXPORT_SYMBOL	
++0xcf27e530	DWC_STRCPY	vmlinux	EXPORT_SYMBOL	
++0x06872817	DWC_STRLEN	vmlinux	EXPORT_SYMBOL	
++0x0841b588	DWC_STRCMP	vmlinux	EXPORT_SYMBOL	
++0x311e9911	devm_regmap_field_free	vmlinux	EXPORT_SYMBOL_GPL	
++0xf93fd09c	fb_find_mode_cvt	vmlinux	EXPORT_SYMBOL	
++0x0a169620	devm_gpiod_get_index_optional	vmlinux	EXPORT_SYMBOL_GPL	
++0x954f099c	idr_preload	vmlinux	EXPORT_SYMBOL	
++0x50cbab5f	kset_register	vmlinux	EXPORT_SYMBOL	
++0xed8c5a3e	fput	vmlinux	EXPORT_SYMBOL	
++0x167b1b8f	of_pci_range_parser_init	vmlinux	EXPORT_SYMBOL_GPL	
++0x02d55a6e	efivars_register	vmlinux	EXPORT_SYMBOL_GPL	
++0x71f7131d	platform_device_alloc	vmlinux	EXPORT_SYMBOL_GPL	
++0x2fdcf54c	dev_printk_emit	vmlinux	EXPORT_SYMBOL	
++0xa361f438	clkdev_add	vmlinux	EXPORT_SYMBOL	
++0x361b382a	iov_iter_get_pages_alloc	vmlinux	EXPORT_SYMBOL	
++0x99078b39	trace_print_flags_seq	vmlinux	EXPORT_SYMBOL	
++0xd2ac000c	ir_raw_handler_unregister	vmlinux	EXPORT_SYMBOL	
++0xde17799e	component_add_typed	vmlinux	EXPORT_SYMBOL_GPL	
++0xd7d5a835	serial8250_em485_config	vmlinux	EXPORT_SYMBOL_GPL	
++0x429f64b5	dma_get_slave_caps	vmlinux	EXPORT_SYMBOL_GPL	
++0xad59fbd0	clk_hw_unregister_mux	vmlinux	EXPORT_SYMBOL_GPL	
++0x91b774a1	mpi_scanval	vmlinux	EXPORT_SYMBOL_GPL	
++0xc8d0c578	__fsnotify_parent	vmlinux	EXPORT_SYMBOL_GPL	
++0x2d2c902f	perf_trace_buf_alloc	vmlinux	EXPORT_SYMBOL_GPL	
++0x944a564d	is_console_locked	vmlinux	EXPORT_SYMBOL	
++0xf98f33ec	param_ops_bool	vmlinux	EXPORT_SYMBOL	
++0xa32d402c	DWC_BE16_TO_CPU	vmlinux	EXPORT_SYMBOL	
++0xddf6cb61	DWC_LE16_TO_CPU	vmlinux	EXPORT_SYMBOL	
++0x732778da	usb_ep0_reinit	vmlinux	EXPORT_SYMBOL_GPL	
++0x06e2d6f8	regulator_get_drvdata	vmlinux	EXPORT_SYMBOL_GPL	
++0x579126b8	__SCK__tp_func_pnfs_mds_fallback_read_pagelist	vmlinux	EXPORT_SYMBOL_GPL	
++0x3df70e8d	sysfs_change_owner	vmlinux	EXPORT_SYMBOL_GPL	
++0x7f7cbc64	ip_tunnel_need_metadata	vmlinux	EXPORT_SYMBOL_GPL	
++0x248325e5	inet_shutdown	vmlinux	EXPORT_SYMBOL	
++0xf1135fef	power_supply_set_property	vmlinux	EXPORT_SYMBOL_GPL	
++0xbac7ad41	power_supply_get_property	vmlinux	EXPORT_SYMBOL_GPL	
++0x37341193	syscon_node_to_regmap	vmlinux	EXPORT_SYMBOL_GPL	
++0x38374815	clear_selection	vmlinux	EXPORT_SYMBOL_GPL	
++0x0f4bc7e4	regulator_set_voltage_sel_regmap	vmlinux	EXPORT_SYMBOL_GPL	
++0xae64f1dd	__tracepoint_block_bio_remap	vmlinux	EXPORT_SYMBOL_GPL	
++0xa10f5415	flow_rule_match_cvlan	vmlinux	EXPORT_SYMBOL	
++0xc6804f82	uart_remove_one_port	vmlinux	EXPORT_SYMBOL	
++0x706f940b	pnfs_generic_sync	vmlinux	EXPORT_SYMBOL_GPL	
++0x6167e72c	vmalloc_no_huge	vmlinux	EXPORT_SYMBOL	
++0x4bcadb5c	vmalloc_to_page	vmlinux	EXPORT_SYMBOL	
++0xb2b8b4b5	__cgroup_bpf_run_filter_sock_addr	vmlinux	EXPORT_SYMBOL	
++0x74c878b1	xfrm_trans_queue	vmlinux	EXPORT_SYMBOL	
++0xa6c71ce0	mmc_can_gpio_ro	vmlinux	EXPORT_SYMBOL	
++0x6a1777f0	mmc_can_gpio_cd	vmlinux	EXPORT_SYMBOL	
++0x1c5541bd	cpufreq_boost_enabled	vmlinux	EXPORT_SYMBOL_GPL	
++0x5c430f05	usb_get_hcd	vmlinux	EXPORT_SYMBOL_GPL	
++0x67d37141	fbcon_set_bitops	vmlinux	EXPORT_SYMBOL	
++0xf17a2783	blk_update_request	vmlinux	EXPORT_SYMBOL_GPL	
++0x02649054	security_sock_rcv_skb	vmlinux	EXPORT_SYMBOL	
++0x84ab12ac	jbd2_journal_put_journal_head	vmlinux	EXPORT_SYMBOL	
++0x602db839	__wake_up_bit	vmlinux	EXPORT_SYMBOL	
++0x5b7b6dcd	get_task_cred	vmlinux	EXPORT_SYMBOL	
++0x642ccf49	xdr_encode_array2	vmlinux	EXPORT_SYMBOL_GPL	
++0x8d6585c9	sock_release	vmlinux	EXPORT_SYMBOL	
++0x92180be2	power_supply_get_by_phandle	vmlinux	EXPORT_SYMBOL_GPL	
++0x56058d0e	usb_hcd_giveback_urb	vmlinux	EXPORT_SYMBOL_GPL	
++0x63255a4f	iscsi_is_session_dev	vmlinux	EXPORT_SYMBOL_GPL	
++0x16ecbefc	tty_port_tty_wakeup	vmlinux	EXPORT_SYMBOL_GPL	
++0x1a1c10b3	regulator_map_voltage_ascend	vmlinux	EXPORT_SYMBOL_GPL	
++0x5bdb362a	gpiochip_lock_as_irq	vmlinux	EXPORT_SYMBOL_GPL	
++0x37bf7be3	percpu_ref_exit	vmlinux	EXPORT_SYMBOL_GPL	
++0x3691224a	add_wait_queue_exclusive	vmlinux	EXPORT_SYMBOL	
++0xc4479a8b	led_trigger_rename_static	vmlinux	EXPORT_SYMBOL_GPL	
++0xe5a7d691	mipi_dsi_dcs_soft_reset	vmlinux	EXPORT_SYMBOL	
++0x857f163b	tty_register_device_attr	vmlinux	EXPORT_SYMBOL_GPL	
++0x9746eb89	ZSTD_decompressBegin_usingDict	vmlinux	EXPORT_SYMBOL	
++0xa24676a1	rhashtable_walk_stop	vmlinux	EXPORT_SYMBOL_GPL	
++0xb75b45ad	nlmclnt_proc	vmlinux	EXPORT_SYMBOL_GPL	
++0x5dd1d46b	pnfs_generic_write_commit_done	vmlinux	EXPORT_SYMBOL_GPL	
++0xb66a5d89	d_add_ci	vmlinux	EXPORT_SYMBOL	
++0x9b70c6ff	tracepoint_probe_register_prio	vmlinux	EXPORT_SYMBOL_GPL	
++0xfe98046a	phys_mem_access_prot	vmlinux	EXPORT_SYMBOL	
++0xad0b9e57	__skb_checksum_complete_head	vmlinux	EXPORT_SYMBOL	
++0xd8ba6acf	skb_send_sock_locked	vmlinux	EXPORT_SYMBOL_GPL	
++0xfc2cacb0	usb_gadget_unmap_request_by_dev	vmlinux	EXPORT_SYMBOL_GPL	
++0xcbeb37c5	dwc_register_notifier	vmlinux	EXPORT_SYMBOL	
++0xc4cea612	dwc_free_notification_manager	vmlinux	EXPORT_SYMBOL	
++0xf0c442f3	xhci_shutdown	vmlinux	EXPORT_SYMBOL_GPL	
++0x9927cdaa	phy_ethtool_get_wol	vmlinux	EXPORT_SYMBOL	
++0xee60e155	phy_ethtool_set_wol	vmlinux	EXPORT_SYMBOL	
++0x7d83fe99	__percpu_counter_sum	vmlinux	EXPORT_SYMBOL	
++0x39ee6a5c	mpage_readpage	vmlinux	EXPORT_SYMBOL	
++0xd6ee688f	vmalloc	vmlinux	EXPORT_SYMBOL	
++0xc378ca1e	perf_pmu_unregister	vmlinux	EXPORT_SYMBOL_GPL	
++0xf31b3fd1	workqueue_set_max_active	vmlinux	EXPORT_SYMBOL_GPL	
++0x5df4975c	flow_rule_match_enc_ports	vmlinux	EXPORT_SYMBOL	
++0x202d4ed6	nvmem_cell_write	vmlinux	EXPORT_SYMBOL_GPL	
++0x16f9ed16	of_get_compatible_child	vmlinux	EXPORT_SYMBOL	
++0x47be6e26	bcm_phy_modify_rdb	vmlinux	EXPORT_SYMBOL_GPL	
++0x622b2b89	tty_port_raise_dtr_rts	vmlinux	EXPORT_SYMBOL	
++0xda75c8de	pci_request_region	vmlinux	EXPORT_SYMBOL	
++0x9623dca2	blk_queue_io_opt	vmlinux	EXPORT_SYMBOL	
++0x528ba632	nfs_set_verifier	vmlinux	EXPORT_SYMBOL_GPL	
++0x542564be	bdgrab	vmlinux	EXPORT_SYMBOL	
++0xd4c14632	system_unbound_wq	vmlinux	EXPORT_SYMBOL_GPL	
++0x95338d39	flow_block_cb_alloc	vmlinux	EXPORT_SYMBOL	
++0xb7c6db70	sysctl_max_skb_frags	vmlinux	EXPORT_SYMBOL	
++0xf5744c6b	dma_resv_test_signaled_rcu	vmlinux	EXPORT_SYMBOL_GPL	
++0x6005be21	clk_hw_unregister_fixed_rate	vmlinux	EXPORT_SYMBOL_GPL	
++0xef94107f	devm_get_clk_from_child	vmlinux	EXPORT_SYMBOL	
++0xba084fea	gpiod_direction_output	vmlinux	EXPORT_SYMBOL_GPL	
++0x9f50b770	keyring_restrict	vmlinux	EXPORT_SYMBOL	
++0x0b1edc8a	nfs_fscache_open_file	vmlinux	EXPORT_SYMBOL_GPL	
++0x903b627c	list_lru_isolate_move	vmlinux	EXPORT_SYMBOL_GPL	
++0x43da8be0	xprt_wait_for_reply_request_def	vmlinux	EXPORT_SYMBOL_GPL	
++0x4990a51f	rpc_clnt_test_and_add_xprt	vmlinux	EXPORT_SYMBOL_GPL	
++0x171b3b6e	sock_set_rcvbuf	vmlinux	EXPORT_SYMBOL	
++0xad1fdc5c	component_match_add_typed	vmlinux	EXPORT_SYMBOL	
++0x3a4f9d28	rng_is_initialized	vmlinux	EXPORT_SYMBOL	
++0x7618af39	hdmi_infoframe_check	vmlinux	EXPORT_SYMBOL	
++0x422b641d	iov_iter_revert	vmlinux	EXPORT_SYMBOL	
++0x376b2c76	rsa_parse_priv_key_raw	vmlinux	EXPORT_SYMBOL_GPL	
++0x45d91d0b	crypto_unregister_aeads	vmlinux	EXPORT_SYMBOL_GPL	
++0x23ee13fd	mb_cache_entry_find_first	vmlinux	EXPORT_SYMBOL	
++0xf8d393dc	__bread_gfp	vmlinux	EXPORT_SYMBOL	
++0xb6ed57e2	__mutex_do_init	vmlinux	EXPORT_SYMBOL	
++0x02556cb0	tcp_unregister_congestion_control	vmlinux	EXPORT_SYMBOL_GPL	
++0xe913638d	nf_checksum_partial	vmlinux	EXPORT_SYMBOL_GPL	
++0x0274dc2b	netif_get_num_default_rss_queues	vmlinux	EXPORT_SYMBOL	
++0x1d94a218	dmi_memdev_handle	vmlinux	EXPORT_SYMBOL_GPL	
++0x0acfe2e7	usb_ep_set_wedge	vmlinux	EXPORT_SYMBOL_GPL	
++0x61f67c92	phy_gbit_features_array	vmlinux	EXPORT_SYMBOL_GPL	
++0xade8f340	__phy_modify	vmlinux	EXPORT_SYMBOL_GPL	
++0x16837e8f	__traceiter_iscsi_dbg_conn	vmlinux	EXPORT_SYMBOL_GPL	
++0xaa6e88c6	clk_gate_restore_context	vmlinux	EXPORT_SYMBOL_GPL	
++0xa1a99004	gpiochip_line_is_open_drain	vmlinux	EXPORT_SYMBOL_GPL	
++0x514ab02a	bio_split	vmlinux	EXPORT_SYMBOL	
++0x344a2c84	iomap_dio_complete	vmlinux	EXPORT_SYMBOL_GPL	
++0xdaa7f526	lock_rename	vmlinux	EXPORT_SYMBOL	
++0x810c5fd0	netlink_remove_tap	vmlinux	EXPORT_SYMBOL_GPL	
++0xf39357ff	cpuidle_poll_state_init	vmlinux	EXPORT_SYMBOL_GPL	
++0x693f92d3	class_destroy	vmlinux	EXPORT_SYMBOL_GPL	
++0x1680e946	pci_pme_active	vmlinux	EXPORT_SYMBOL	
++0xa7361043	gpiochip_remove	vmlinux	EXPORT_SYMBOL_GPL	
++0x6d0ae550	pinctrl_gpio_request	vmlinux	EXPORT_SYMBOL_GPL	
++0x474ab48d	__xa_set_mark	vmlinux	EXPORT_SYMBOL	
++0xa53b597c	proc_create_net_single	vmlinux	EXPORT_SYMBOL_GPL	
++0xdcdadb07	proc_create_net_data_write	vmlinux	EXPORT_SYMBOL_GPL	
++0x775b4327	fs_param_is_string	vmlinux	EXPORT_SYMBOL	
++0x3d93c7c2	__arm_smccc_sve_check	vmlinux	EXPORT_SYMBOL	
++0xe01c1a07	xdr_inline_decode	vmlinux	EXPORT_SYMBOL_GPL	
++0xec36f42b	tcp_check_req	vmlinux	EXPORT_SYMBOL	
++0x4c8721e5	tcp_init_sock	vmlinux	EXPORT_SYMBOL	
++0xa80abdf4	netlink_unicast	vmlinux	EXPORT_SYMBOL	
++0x9d319f88	neigh_sysctl_register	vmlinux	EXPORT_SYMBOL	
++0x7a9299bc	tty_port_tty_hangup	vmlinux	EXPORT_SYMBOL_GPL	
++0x52b1e3c7	pci_flags	vmlinux	EXPORT_SYMBOL_GPL	
++0xcfd884a8	__hsiphash_unaligned	vmlinux	EXPORT_SYMBOL	
++0x18a35896	__bio_add_page	vmlinux	EXPORT_SYMBOL_GPL	
++0xb18fa524	__fscache_check_page_write	vmlinux	EXPORT_SYMBOL	
++0xfd6699ec	bpf_trace_run12	vmlinux	EXPORT_SYMBOL_GPL	
++0xb877633c	bpf_trace_run11	vmlinux	EXPORT_SYMBOL_GPL	
++0xb482c2b2	bpf_trace_run10	vmlinux	EXPORT_SYMBOL_GPL	
++0x8761c87b	rps_needed	vmlinux	EXPORT_SYMBOL	
++0x83676332	skb_flow_get_icmp_tci	vmlinux	EXPORT_SYMBOL	
++0x601cc734	spi_mem_dirmap_read	vmlinux	EXPORT_SYMBOL_GPL	
++0x895f1e7a	serdev_controller_add	vmlinux	EXPORT_SYMBOL_GPL	
++0x0296695f	refcount_warn_saturate	vmlinux	EXPORT_SYMBOL	
++0xf1ba8e06	import_single_range	vmlinux	EXPORT_SYMBOL	
++0xbc794b62	security_sctp_bind_connect	vmlinux	EXPORT_SYMBOL	
++0x284adcc9	set_nlink	vmlinux	EXPORT_SYMBOL	
++0xaf348da7	cpu_pm_exit	vmlinux	EXPORT_SYMBOL_GPL	
++0xeb7ad866	kill_pgrp	vmlinux	EXPORT_SYMBOL	
++0x870b2f7a	fat_build_inode	vmlinux	EXPORT_SYMBOL_GPL	
++0xb3ab4140	seq_read	vmlinux	EXPORT_SYMBOL	
++0xb5aacefd	is_bad_inode	vmlinux	EXPORT_SYMBOL	
++0x8889ad3e	lru_cache_add	vmlinux	EXPORT_SYMBOL	
++0xeff64ef0	param_get_int	vmlinux	EXPORT_SYMBOL	
++0x34f033b6	skb_ext_add	vmlinux	EXPORT_SYMBOL	
++0x221c9354	dma_buf_dynamic_attach	vmlinux	EXPORT_SYMBOL_GPL	
++0x1f9486bd	start_tty	vmlinux	EXPORT_SYMBOL	
++0x6513a3fa	fb_get_color_depth	vmlinux	EXPORT_SYMBOL	
++0xc43a04a7	crypto_unregister_kpp	vmlinux	EXPORT_SYMBOL_GPL	
++0xe8b15d02	shash_ahash_finup	vmlinux	EXPORT_SYMBOL_GPL	
++0x4f507a36	user_update	vmlinux	EXPORT_SYMBOL_GPL	
++0x46e260f9	configfs_unregister_group	vmlinux	EXPORT_SYMBOL	
++0xc4f0da12	ktime_get_with_offset	vmlinux	EXPORT_SYMBOL_GPL	
++0x53a8c6ca	kernel_sock_shutdown	vmlinux	EXPORT_SYMBOL	
++0x59d3045f	of_find_i2c_adapter_by_node	vmlinux	EXPORT_SYMBOL	
++0x11d643fc	regulator_set_drvdata	vmlinux	EXPORT_SYMBOL_GPL	
++0x54215db5	visitor64	vmlinux	EXPORT_SYMBOL_GPL	
++0xc9641b48	visitor32	vmlinux	EXPORT_SYMBOL_GPL	
++0xfda9581f	prandom_u32	vmlinux	EXPORT_SYMBOL	
++0xdbecc41c	posix_acl_chmod	vmlinux	EXPORT_SYMBOL	
++0xef752367	notify_change	vmlinux	EXPORT_SYMBOL	
++0x66941825	follow_up	vmlinux	EXPORT_SYMBOL	
++0xba537d4f	param_get_short	vmlinux	EXPORT_SYMBOL	
++0xce56fe5a	inet_sk_set_state	vmlinux	EXPORT_SYMBOL	
++0x6422558d	nf_log_bind_pf	vmlinux	EXPORT_SYMBOL	
++0x30285b44	dev_pick_tx_zero	vmlinux	EXPORT_SYMBOL	
++0x8ba81e79	sock_no_ioctl	vmlinux	EXPORT_SYMBOL	
++0x0664a5de	of_reconfig_get_state_change	vmlinux	EXPORT_SYMBOL_GPL	
++0x5ee6b58e	sdhci_set_power_and_bus_voltage	vmlinux	EXPORT_SYMBOL_GPL	
++0x9fe899b7	get_cpu_idle_time	vmlinux	EXPORT_SYMBOL_GPL	
++0xaa976bb3	__tracepoint_iscsi_dbg_tcp	vmlinux	EXPORT_SYMBOL_GPL	
++0x6a600f3e	wm5102_i2c_regmap	vmlinux	EXPORT_SYMBOL_GPL	
++0x2958ce72	wm5102_spi_regmap	vmlinux	EXPORT_SYMBOL_GPL	
++0xc3b3fb17	mipi_dsi_dcs_set_tear_off	vmlinux	EXPORT_SYMBOL	
++0x275f3d49	hdmi_vendor_infoframe_check	vmlinux	EXPORT_SYMBOL	
++0x59482b26	get_user_pages_fast	vmlinux	EXPORT_SYMBOL_GPL	
++0xc40a5708	kernel_param_lock	vmlinux	EXPORT_SYMBOL	
++0xad103511	scsi_remove_device	vmlinux	EXPORT_SYMBOL	
++0x52bf31d1	simple_empty	vmlinux	EXPORT_SYMBOL	
++0xc306c3a8	page_frag_alloc	vmlinux	EXPORT_SYMBOL	
++0x5db81976	find_extend_vma	vmlinux	EXPORT_SYMBOL_GPL	
++0xcc8c94d8	vm_mmap	vmlinux	EXPORT_SYMBOL	
++0x6afc70c8	shmem_read_mapping_page_gfp	vmlinux	EXPORT_SYMBOL_GPL	
++0xad781581	dma_alloc_attrs	vmlinux	EXPORT_SYMBOL	
++0x080c6be7	__sk_mem_schedule	vmlinux	EXPORT_SYMBOL	
++0xa7bb850b	__hid_register_driver	vmlinux	EXPORT_SYMBOL_GPL	
++0x7b773861	hid_disconnect	vmlinux	EXPORT_SYMBOL_GPL	
++0x70cf032f	usb_hcd_irq	vmlinux	EXPORT_SYMBOL_GPL	
++0x8b5104b6	__spi_register_driver	vmlinux	EXPORT_SYMBOL_GPL	
++0x5aec7c6b	__pci_register_driver	vmlinux	EXPORT_SYMBOL	
++0x8538081f	radix_tree_gang_lookup_tag_slot	vmlinux	EXPORT_SYMBOL	
++0x9c7daea8	mnt_want_write_file	vmlinux	EXPORT_SYMBOL_GPL	
++0x54446c63	ip_ct_attach	vmlinux	EXPORT_SYMBOL	
++0xbffc09e5	dev_set_mtu	vmlinux	EXPORT_SYMBOL	
++0xa7420db5	fwnode_handle_get	vmlinux	EXPORT_SYMBOL_GPL	
++0x86389c82	bcm_dma_chan_free	vmlinux	EXPORT_SYMBOL_GPL	
++0x0087b11f	crypto_unregister_template	vmlinux	EXPORT_SYMBOL_GPL	
++0xd669a3fd	security_sk_classify_flow	vmlinux	EXPORT_SYMBOL	
++0xbbfe76fe	nfs_file_set_open_context	vmlinux	EXPORT_SYMBOL_GPL	
++0x0428658b	nfs_free_server	vmlinux	EXPORT_SYMBOL_GPL	
++0xd36b6444	bd_link_disk_holder	vmlinux	EXPORT_SYMBOL_GPL	
++0x2919b156	xdr_decode_string_inplace	vmlinux	EXPORT_SYMBOL_GPL	
++0x66ba3078	of_fwnode_ops	vmlinux	EXPORT_SYMBOL_GPL	
++0x05b0b203	dev_pm_opp_get_opp_count	vmlinux	EXPORT_SYMBOL_GPL	
++0x04bf36f9	regulator_set_soft_start_regmap	vmlinux	EXPORT_SYMBOL_GPL	
++0x9cd94ff8	regulator_get_error_flags	vmlinux	EXPORT_SYMBOL_GPL	
++0xc4944d7e	fscache_cache_cleared_wq	vmlinux	EXPORT_SYMBOL	
++0x2f4880df	static_key_slow_dec	vmlinux	EXPORT_SYMBOL_GPL	
++0x335c570f	enable_percpu_irq	vmlinux	EXPORT_SYMBOL_GPL	
++0xf2ec60b4	svc_seq_show	vmlinux	EXPORT_SYMBOL_GPL	
++0x053d738a	__SCK__tp_func_br_fdb_update	vmlinux	EXPORT_SYMBOL_GPL	
++0x0626da5f	od_unregister_powersave_bias_handler	vmlinux	EXPORT_SYMBOL_GPL	
++0xd87fc0a0	usb_amd_prefetch_quirk	vmlinux	EXPORT_SYMBOL_GPL	
++0x7b332210	scsi_free_host_dev	vmlinux	EXPORT_SYMBOL	
++0xb3599124	driver_register	vmlinux	EXPORT_SYMBOL_GPL	
++0xb6410433	mpi_addm	vmlinux	EXPORT_SYMBOL_GPL	
++0x7d8f7e5d	should_remove_suid	vmlinux	EXPORT_SYMBOL	
++0xe666aa25	input_ff_create	vmlinux	EXPORT_SYMBOL_GPL	
++0x6b57ab82	regmap_add_irq_chip_fwnode	vmlinux	EXPORT_SYMBOL_GPL	
++0xca4e9b72	device_destroy	vmlinux	EXPORT_SYMBOL_GPL	
++0x04967344	divider_ro_round_rate_parent	vmlinux	EXPORT_SYMBOL_GPL	
++0x03d9fb5f	srcu_notifier_chain_unregister	vmlinux	EXPORT_SYMBOL_GPL	
++0xb5083fab	xfrm_if_register_cb	vmlinux	EXPORT_SYMBOL	
++0x586dd798	unregister_pernet_device	vmlinux	EXPORT_SYMBOL_GPL	
++0xe1c2319f	of_dma_is_coherent	vmlinux	EXPORT_SYMBOL_GPL	
++0xd07ff8d8	input_ff_destroy	vmlinux	EXPORT_SYMBOL_GPL	
++0xab695e41	mfd_cell_disable	vmlinux	EXPORT_SYMBOL	
++0xa5b02aba	platform_get_irq_byname	vmlinux	EXPORT_SYMBOL_GPL	
++0xb83129db	ZSTD_decompressContinue	vmlinux	EXPORT_SYMBOL	
++0xb4292416	seq_dentry	vmlinux	EXPORT_SYMBOL	
++0xc32a287f	remove_wait_queue	vmlinux	EXPORT_SYMBOL	
++0x087a36dc	param_array_ops	vmlinux	EXPORT_SYMBOL	
++0xe508f7aa	napi_get_frags	vmlinux	EXPORT_SYMBOL	
++0x5715db01	efivar_entry_remove	vmlinux	EXPORT_SYMBOL_GPL	
++0x33a70b30	dev_pm_domain_detach	vmlinux	EXPORT_SYMBOL_GPL	
++0xd24cf626	clk_hw_get_parent_index	vmlinux	EXPORT_SYMBOL_GPL	
++0xb2bd9703	devm_gpiochip_add_data_with_key	vmlinux	EXPORT_SYMBOL_GPL	
++0xdd10471b	xas_clear_mark	vmlinux	EXPORT_SYMBOL_GPL	
++0xfbce6e30	kset_find_obj	vmlinux	EXPORT_SYMBOL_GPL	
++0x8bd6302a	scsi_verify_blk_ioctl	vmlinux	EXPORT_SYMBOL	
++0x03d33563	pnfs_generic_clear_request_commit	vmlinux	EXPORT_SYMBOL_GPL	
++0x686969ea	configfs_register_group	vmlinux	EXPORT_SYMBOL	
++0x2d1cb2e9	pagecache_isize_extended	vmlinux	EXPORT_SYMBOL	
++0x849c9086	disable_kprobe	vmlinux	EXPORT_SYMBOL_GPL	
++0x56470118	__warn_printk	vmlinux	EXPORT_SYMBOL	
++0x53e64370	mmc_gpiod_request_ro	vmlinux	EXPORT_SYMBOL	
++0x60067230	mmc_gpiod_request_cd	vmlinux	EXPORT_SYMBOL	
++0x1d47d1af	phy_register_fixup_for_id	vmlinux	EXPORT_SYMBOL	
++0x9d733677	cgroup_attach_task_all	vmlinux	EXPORT_SYMBOL_GPL	
++0x8d88a271	delayed_work_timer_fn	vmlinux	EXPORT_SYMBOL	
++0xf5ddf633	vchan_dma_desc_free_list	vmlinux	EXPORT_SYMBOL_GPL	
++0x9548f993	dim_park_tired	vmlinux	EXPORT_SYMBOL	
++0x4b22418d	configfs_remove_default_groups	vmlinux	EXPORT_SYMBOL	
++0x32052fa1	zap_vma_ptes	vmlinux	EXPORT_SYMBOL_GPL	
++0x0bf32478	__SCK__tp_func_pelt_rt_tp	vmlinux	EXPORT_SYMBOL_GPL	
++0x377bca27	rpc_init_priority_wait_queue	vmlinux	EXPORT_SYMBOL_GPL	
++0x6ac6cd14	xfrm_policy_bysel_ctx	vmlinux	EXPORT_SYMBOL	
++0xd8ef2533	tcp_sendmsg	vmlinux	EXPORT_SYMBOL	
++0x0760f40f	dev_pm_opp_is_turbo	vmlinux	EXPORT_SYMBOL_GPL	
++0xdf63d641	i2c_smbus_write_word_data	vmlinux	EXPORT_SYMBOL	
++0x2b952517	clk_has_parent	vmlinux	EXPORT_SYMBOL_GPL	
++0x45fd6c77	dim_park_on_top	vmlinux	EXPORT_SYMBOL	
++0x693c197a	elv_rb_del	vmlinux	EXPORT_SYMBOL	
++0x76c9c4ca	elv_rb_add	vmlinux	EXPORT_SYMBOL	
++0x1e8c78f6	init_user_ns	vmlinux	EXPORT_SYMBOL_GPL	
++0xb6a45e7b	rpc_init_pipe_dir_object	vmlinux	EXPORT_SYMBOL_GPL	
++0xe1c6c8eb	ip_mc_leave_group	vmlinux	EXPORT_SYMBOL	
++0xd378ed7f	lwtunnel_cmp_encap	vmlinux	EXPORT_SYMBOL_GPL	
++0x1205857f	netif_skb_features	vmlinux	EXPORT_SYMBOL	
++0xcdcbfa06	pm_runtime_set_memalloc_noio	vmlinux	EXPORT_SYMBOL_GPL	
++0x8da5295d	devm_gpiod_get_array	vmlinux	EXPORT_SYMBOL_GPL	
++0xe2ec0e2c	shash_free_singlespawn_instance	vmlinux	EXPORT_SYMBOL_GPL	
++0x6dbaafd3	put_old_timespec32	vmlinux	EXPORT_SYMBOL_GPL	
++0x423d70cf	work_busy	vmlinux	EXPORT_SYMBOL_GPL	
++0xb785a6a0	__sk_mem_reclaim	vmlinux	EXPORT_SYMBOL	
++0x39efb0d7	tty_set_ldisc	vmlinux	EXPORT_SYMBOL_GPL	
++0x04863e28	hdmi_audio_infoframe_pack_only	vmlinux	EXPORT_SYMBOL	
++0x8c7602d0	pcim_pin_device	vmlinux	EXPORT_SYMBOL	
++0x1aa24177	pci_cfg_access_lock	vmlinux	EXPORT_SYMBOL_GPL	
++0xebc80292	crypto_register_skcipher	vmlinux	EXPORT_SYMBOL_GPL	
++0xd195478c	d_prune_aliases	vmlinux	EXPORT_SYMBOL	
++0xc4e846dc	kmsg_dump_get_line	vmlinux	EXPORT_SYMBOL_GPL	
++0xfb2cb6ad	fib_nh_common_init	vmlinux	EXPORT_SYMBOL_GPL	
++0x35c4d95f	tcp_mss_to_mtu	vmlinux	EXPORT_SYMBOL	
++0xd14839a2	gro_cells_receive	vmlinux	EXPORT_SYMBOL	
++0x1cea7f92	dev_pm_opp_find_level_exact	vmlinux	EXPORT_SYMBOL_GPL	
++0xdba0d56e	pci_common_swizzle	vmlinux	EXPORT_SYMBOL_GPL	
++0xdaceeda3	blk_mq_init_sq_queue	vmlinux	EXPORT_SYMBOL	
++0x1658e96c	__pagevec_release	vmlinux	EXPORT_SYMBOL	
++0x43751ba4	cache_register_net	vmlinux	EXPORT_SYMBOL_GPL	
++0x4eac90e3	metadata_dst_free_percpu	vmlinux	EXPORT_SYMBOL_GPL	
++0x8ae80de4	hid_unregister_driver	vmlinux	EXPORT_SYMBOL_GPL	
++0x95ef1ccc	dmi_memdev_size	vmlinux	EXPORT_SYMBOL_GPL	
++0x1988a8d0	usb_autopm_put_interface	vmlinux	EXPORT_SYMBOL_GPL	
++0x71517e66	spi_take_timestamp_pre	vmlinux	EXPORT_SYMBOL_GPL	
++0x3f8422d6	arizona_pm_ops	vmlinux	EXPORT_SYMBOL_GPL	
++0x7350c2ee	pcie_set_readrq	vmlinux	EXPORT_SYMBOL	
++0xb6dcd57e	pcie_bus_configure_settings	vmlinux	EXPORT_SYMBOL_GPL	
++0x0a2eafc0	nla_reserve_nohdr	vmlinux	EXPORT_SYMBOL	
++0x4230a8d7	sg_nents_for_len	vmlinux	EXPORT_SYMBOL	
++0x4cde46aa	device_add_disk	vmlinux	EXPORT_SYMBOL	
++0x086b3993	x509_free_certificate	vmlinux	EXPORT_SYMBOL_GPL	
++0x3a7f5658	securityfs_create_file	vmlinux	EXPORT_SYMBOL_GPL	
++0x2a66e926	exportfs_encode_fh	vmlinux	EXPORT_SYMBOL_GPL	
++0x04f3a4b5	iomap_invalidatepage	vmlinux	EXPORT_SYMBOL_GPL	
++0xe78f13c1	ilookup5	vmlinux	EXPORT_SYMBOL	
++0x22fd08ba	cpuacct_cgrp_subsys_on_dfl_key	vmlinux	EXPORT_SYMBOL_GPL	
++0x5e515be6	ktime_get_ts64	vmlinux	EXPORT_SYMBOL_GPL	
++0xc0a96e14	rcu_gp_is_expedited	vmlinux	EXPORT_SYMBOL_GPL	
++0x8427cc7b	_raw_spin_lock_irq	vmlinux	EXPORT_SYMBOL	
++0x79a4df66	prepare_creds	vmlinux	EXPORT_SYMBOL	
++0xe45e7b59	dev_addr_flush	vmlinux	EXPORT_SYMBOL	
++0x3866e217	nvmem_device_write	vmlinux	EXPORT_SYMBOL_GPL	
++0xe19fdea4	thermal_notify_framework	vmlinux	EXPORT_SYMBOL_GPL	
++0x4cb9e001	recover_lost_locks	vmlinux	EXPORT_SYMBOL_GPL	
++0x668fb5a3	register_nfs_version	vmlinux	EXPORT_SYMBOL_GPL	
++0x535a66d7	dquot_quota_sync	vmlinux	EXPORT_SYMBOL	
++0xdd9f1910	irq_domain_create_sim	vmlinux	EXPORT_SYMBOL_GPL	
++0x2550f0ee	sunrpc_cache_pipe_upcall	vmlinux	EXPORT_SYMBOL_GPL	
++0x3c6dd173	nl_table_lock	vmlinux	EXPORT_SYMBOL_GPL	
++0x5bdae35b	usb_phy_roothub_set_mode	vmlinux	EXPORT_SYMBOL_GPL	
++0x86e34111	of_find_spi_device_by_node	vmlinux	EXPORT_SYMBOL_GPL	
++0x7100193f	blkdev_get_by_dev	vmlinux	EXPORT_SYMBOL	
++0xcc2e4b93	get_tree_keyed	vmlinux	EXPORT_SYMBOL	
++0xd89da37f	movable_zone	vmlinux	EXPORT_SYMBOL	
++0x42e9d0da	ring_buffer_unlock_commit	vmlinux	EXPORT_SYMBOL_GPL	
++0x41237f71	cpu_have_feature	vmlinux	EXPORT_SYMBOL_GPL	
++0xad436f80	ping_queue_rcv_skb	vmlinux	EXPORT_SYMBOL_GPL	
++0x6b55acd0	rtnl_lock_killable	vmlinux	EXPORT_SYMBOL	
++0x0f7bafd9	rc_allocate_device	vmlinux	EXPORT_SYMBOL_GPL	
++0x4096dc6a	pkcs7_get_content_data	vmlinux	EXPORT_SYMBOL_GPL	
++0xf2248922	nfs_scan_commit_list	vmlinux	EXPORT_SYMBOL_GPL	
++0x75339308	nfs4_dentry_operations	vmlinux	EXPORT_SYMBOL_GPL	
++0xe12fb8ef	simple_fill_super	vmlinux	EXPORT_SYMBOL	
++0x99ee33f5	event_triggers_call	vmlinux	EXPORT_SYMBOL_GPL	
++0x07cc4a5d	printk_timed_ratelimit	vmlinux	EXPORT_SYMBOL	
++0x42ae60de	l3mdev_table_lookup_register	vmlinux	EXPORT_SYMBOL_GPL	
++0x39e24242	sock_queue_err_skb	vmlinux	EXPORT_SYMBOL	
++0x96ba8f3a	phy_create_lookup	vmlinux	EXPORT_SYMBOL_GPL	
++0x61e272c9	sha256_final	vmlinux	EXPORT_SYMBOL	
++0xfe1d2e94	key_create_or_update	vmlinux	EXPORT_SYMBOL	
++0x49905f0d	pnfs_register_layoutdriver	vmlinux	EXPORT_SYMBOL_GPL	
++0x2a62cb3a	ring_buffer_overrun_cpu	vmlinux	EXPORT_SYMBOL_GPL	
++0xda6d4930	__tasklet_schedule	vmlinux	EXPORT_SYMBOL	
++0x69a50ece	xprt_adjust_cwnd	vmlinux	EXPORT_SYMBOL_GPL	
++0x96095a0e	dev_load	vmlinux	EXPORT_SYMBOL	
++0xf4f14de6	rtnl_trylock	vmlinux	EXPORT_SYMBOL	
++0x6eb1df15	skb_flow_dissect_meta	vmlinux	EXPORT_SYMBOL	
++0xba2b7f64	cpufreq_generic_get	vmlinux	EXPORT_SYMBOL_GPL	
++0xe87e1fd6	rc_keydown	vmlinux	EXPORT_SYMBOL_GPL	
++0x818416e1	scsi_set_sense_information	vmlinux	EXPORT_SYMBOL	
++0xee00fd23	bio_add_page	vmlinux	EXPORT_SYMBOL	
++0xf7f92f2a	debugfs_create_u16	vmlinux	EXPORT_SYMBOL_GPL	
++0x53237d82	__d_lookup_done	vmlinux	EXPORT_SYMBOL	
++0x138d06cc	init_on_alloc	vmlinux	EXPORT_SYMBOL	
++0x75b6b737	init_pid_ns	vmlinux	EXPORT_SYMBOL_GPL	
++0x8f49bc3d	proc_douintvec	vmlinux	EXPORT_SYMBOL	
++0x4a065839	gro_find_receive_by_type	vmlinux	EXPORT_SYMBOL	
++0xbc9fa8e0	__sk_mem_raise_allocated	vmlinux	EXPORT_SYMBOL	
++0x7f6aa48f	usb_unlink_anchored_urbs	vmlinux	EXPORT_SYMBOL_GPL	
++0x40a616d5	usbnet_write_cmd	vmlinux	EXPORT_SYMBOL_GPL	
++0xf658b699	fb_bl_default_curve	vmlinux	EXPORT_SYMBOL_GPL	
++0xf1e24f1e	xas_nomem	vmlinux	EXPORT_SYMBOL_GPL	
++0x107e5878	zlib_inflateEnd	vmlinux	EXPORT_SYMBOL	
++0x862bb17b	linear_range_values_in_range_array	vmlinux	EXPORT_SYMBOL_GPL	
++0x84cd7118	__blkdev_issue_discard	vmlinux	EXPORT_SYMBOL	
++0xde61b705	contig_page_data	vmlinux	EXPORT_SYMBOL	
++0xdbf7b3ba	rpc_num_bc_slots	vmlinux	EXPORT_SYMBOL_GPL	
++0xa35be542	ethnl_cable_test_result	vmlinux	EXPORT_SYMBOL_GPL	
++0x09adde9a	extcon_register_notifier_all	vmlinux	EXPORT_SYMBOL_GPL	
++0xb423dba1	console_blanked	vmlinux	EXPORT_SYMBOL	
++0xee7aba01	pci_bus_add_device	vmlinux	EXPORT_SYMBOL_GPL	
++0xd3e21e25	ack_all_badblocks	vmlinux	EXPORT_SYMBOL_GPL	
++0xc40fcf36	handle_fasteoi_nmi	vmlinux	EXPORT_SYMBOL_GPL	
++0xf0462cc8	sdhci_pltfm_clk_get_max_clock	vmlinux	EXPORT_SYMBOL_GPL	
++0x9cf37c44	__iowrite32_copy	vmlinux	EXPORT_SYMBOL_GPL	
++0xcf12a43e	config_group_init_type_name	vmlinux	EXPORT_SYMBOL	
++0xeb4221e4	trace_clock	vmlinux	EXPORT_SYMBOL_GPL	
++0x0c184153	from_kgid	vmlinux	EXPORT_SYMBOL	
++0x6c828548	prepare_to_wait_event	vmlinux	EXPORT_SYMBOL	
++0x48c93627	copy_user_highpage	vmlinux	EXPORT_SYMBOL_GPL	
++0x38993114	xdr_enter_page	vmlinux	EXPORT_SYMBOL_GPL	
++0xecce0efe	fib_rules_register	vmlinux	EXPORT_SYMBOL_GPL	
++0x1e564acf	cpufreq_generic_suspend	vmlinux	EXPORT_SYMBOL	
++0x8edb0410	dev_pm_opp_get_level	vmlinux	EXPORT_SYMBOL_GPL	
++0x7c30e0ad	iscsi_create_conn	vmlinux	EXPORT_SYMBOL_GPL	
++0x15f0c8af	part_end_io_acct	vmlinux	EXPORT_SYMBOL_GPL	
++0xd7d8e5ad	simple_transaction_read	vmlinux	EXPORT_SYMBOL	
++0x3bc74860	cleancache_register_ops	vmlinux	EXPORT_SYMBOL	
++0x8a99a016	mempool_free_slab	vmlinux	EXPORT_SYMBOL	
++0x18b48e28	__memset_io	vmlinux	EXPORT_SYMBOL	
++0x77ae495d	usb_speed_string	vmlinux	EXPORT_SYMBOL_GPL	
++0x5ca09bb9	mii_ethtool_set_link_ksettings	vmlinux	EXPORT_SYMBOL	
++0xd15ace48	mii_ethtool_get_link_ksettings	vmlinux	EXPORT_SYMBOL	
++0x33280b02	pci_scan_slot	vmlinux	EXPORT_SYMBOL	
++0xc9495861	net_dim	vmlinux	EXPORT_SYMBOL	
++0x7e00718d	gss_mech_register	vmlinux	EXPORT_SYMBOL_GPL	
++0xf4a2b3b7	__ip_mc_dec_group	vmlinux	EXPORT_SYMBOL	
++0x9dde5f65	__ip_mc_inc_group	vmlinux	EXPORT_SYMBOL	
++0x4baf02e9	usbnet_start_xmit	vmlinux	EXPORT_SYMBOL_GPL	
++0xbfa7e9e4	spi_unregister_controller	vmlinux	EXPORT_SYMBOL_GPL	
++0x3445b2bb	__pm_runtime_resume	vmlinux	EXPORT_SYMBOL_GPL	
++0x2b8efb6c	devm_kstrdup_const	vmlinux	EXPORT_SYMBOL_GPL	
++0x3047bf4d	of_reset_control_array_get	vmlinux	EXPORT_SYMBOL_GPL	
++0x541403ab	jbd2_journal_set_features	vmlinux	EXPORT_SYMBOL	
++0xe7d6d2d4	filter_match_preds	vmlinux	EXPORT_SYMBOL_GPL	
++0x54f3d3ac	sdhci_cleanup_host	vmlinux	EXPORT_SYMBOL_GPL	
++0x6238bbeb	regmap_raw_read	vmlinux	EXPORT_SYMBOL_GPL	
++0x9c1edc68	device_get_phy_mode	vmlinux	EXPORT_SYMBOL_GPL	
++0xabe21568	pci_request_regions	vmlinux	EXPORT_SYMBOL	
++0xd6b5b989	blk_mq_unique_tag	vmlinux	EXPORT_SYMBOL	
++0x82409884	__tracepoint_pnfs_mds_fallback_read_done	vmlinux	EXPORT_SYMBOL_GPL	
++0xc14b414a	__wait_on_buffer	vmlinux	EXPORT_SYMBOL	
++0x9f32c595	find_inode_by_ino_rcu	vmlinux	EXPORT_SYMBOL	
++0xa0d3456d	nr_swap_pages	vmlinux	EXPORT_SYMBOL_GPL	
++0x61b037c4	cancel_delayed_work_sync	vmlinux	EXPORT_SYMBOL	
++0x18774431	xdr_align_data	vmlinux	EXPORT_SYMBOL_GPL	
++0xf177a2fb	lwtunnel_encap_add_ops	vmlinux	EXPORT_SYMBOL_GPL	
++0x86814588	sock_create	vmlinux	EXPORT_SYMBOL	
++0x51f6189a	devm_watchdog_register_device	vmlinux	EXPORT_SYMBOL_GPL	
++0xf0b876e1	spi_controller_dma_map_mem_op_data	vmlinux	EXPORT_SYMBOL_GPL	
++0x9daaf67e	class_dev_iter_next	vmlinux	EXPORT_SYMBOL_GPL	
++0xddf7111b	clk_add_alias	vmlinux	EXPORT_SYMBOL	
++0x394cb539	skcipher_walk_atomise	vmlinux	EXPORT_SYMBOL_GPL	
++0x494019d4	debugfs_create_x32	vmlinux	EXPORT_SYMBOL_GPL	
++0x23fd94a2	bprm_change_interp	vmlinux	EXPORT_SYMBOL	
++0xbd217582	kill_litter_super	vmlinux	EXPORT_SYMBOL	
++0xa2df19b4	resource_list_create_entry	vmlinux	EXPORT_SYMBOL	
++0xa58e3ddc	xfrm_dev_offload_ok	vmlinux	EXPORT_SYMBOL_GPL	
++0x254ec316	inet_proto_csum_replace4	vmlinux	EXPORT_SYMBOL	
++0xf5aa5a5b	neigh_direct_output	vmlinux	EXPORT_SYMBOL	
++0xa84d5eb1	usb_free_urb	vmlinux	EXPORT_SYMBOL_GPL	
++0x67f9708f	tty_prepare_flip_string	vmlinux	EXPORT_SYMBOL_GPL	
++0x38c94fde	pci_add_resource_offset	vmlinux	EXPORT_SYMBOL	
++0xd9b774ef	__fscache_read_or_alloc_page	vmlinux	EXPORT_SYMBOL	
++0xbb902f0c	__breadahead_gfp	vmlinux	EXPORT_SYMBOL	
++0x75bda77a	seq_hlist_next	vmlinux	EXPORT_SYMBOL	
++0x28812245	__lock_page_killable	vmlinux	EXPORT_SYMBOL_GPL	
++0xd6b1001f	fib_rules_unregister	vmlinux	EXPORT_SYMBOL_GPL	
++0xe8e2808d	skb_copy_bits	vmlinux	EXPORT_SYMBOL	
++0x64e558a2	sock_no_sendpage_locked	vmlinux	EXPORT_SYMBOL	
++0x2eea912c	get_random_bytes_arch	vmlinux	EXPORT_SYMBOL	
++0x2d729645	clk_hw_register_fractional_divider	vmlinux	EXPORT_SYMBOL_GPL	
++0x612b90c5	pci_irq_get_affinity	vmlinux	EXPORT_SYMBOL	
++0xe412d540	pcim_iomap	vmlinux	EXPORT_SYMBOL	
++0xa6d32ce2	crypto_register_ahash	vmlinux	EXPORT_SYMBOL_GPL	
++0xe59a9f05	sysfs_remove_link	vmlinux	EXPORT_SYMBOL_GPL	
++0xa3714369	kernfs_notify	vmlinux	EXPORT_SYMBOL_GPL	
++0x2b306f05	noop_direct_IO	vmlinux	EXPORT_SYMBOL_GPL	
++0x4a74e149	shmem_file_setup_with_mnt	vmlinux	EXPORT_SYMBOL_GPL	
++0x8924eb1e	rcu_force_quiescent_state	vmlinux	EXPORT_SYMBOL_GPL	
++0x41062ac4	irq_domain_push_irq	vmlinux	EXPORT_SYMBOL_GPL	
++0x22390e6d	tcp_make_synack	vmlinux	EXPORT_SYMBOL	
++0xf79185db	__skb_checksum	vmlinux	EXPORT_SYMBOL	
++0x7359b103	hid_hw_stop	vmlinux	EXPORT_SYMBOL_GPL	
++0x653b6d4d	mii_check_gmii_support	vmlinux	EXPORT_SYMBOL	
++0x9d8ffe9a	bcm_dma_abort	vmlinux	EXPORT_SYMBOL_GPL	
++0xb52ce896	dma_async_device_register	vmlinux	EXPORT_SYMBOL	
++0x3b4c240a	display_timings_release	vmlinux	EXPORT_SYMBOL_GPL	
++0x3158d4e1	pci_resize_resource	vmlinux	EXPORT_SYMBOL	
++0x2f2bbcdf	hrtimer_forward	vmlinux	EXPORT_SYMBOL_GPL	
++0x7d59dd46	pm_wq	vmlinux	EXPORT_SYMBOL_GPL	
++0x53b4e8f2	bit_waitqueue	vmlinux	EXPORT_SYMBOL	
++0xef1f161b	sock_common_recvmsg	vmlinux	EXPORT_SYMBOL	
++0xd45434ee	admin_timeout	vmlinux	EXPORT_SYMBOL_GPL	
++0xc905b5b2	dma_request_chan	vmlinux	EXPORT_SYMBOL_GPL	
++0x495231ea	mul_u64_u64_div_u64	vmlinux	EXPORT_SYMBOL	
++0x5a1d134a	rcu_momentary_dyntick_idle	vmlinux	EXPORT_SYMBOL_GPL	
++0xb2de0c30	inet_csk_addr2sockaddr	vmlinux	EXPORT_SYMBOL_GPL	
++0x2f223996	inet_ehash_locks_alloc	vmlinux	EXPORT_SYMBOL_GPL	
++0xa28cfcc0	gen_estimator_active	vmlinux	EXPORT_SYMBOL	
++0x14d01690	clk_mux_index_to_val	vmlinux	EXPORT_SYMBOL_GPL	
++0x8339df73	klist_add_behind	vmlinux	EXPORT_SYMBOL_GPL	
++0x574c2e74	bitmap_release_region	vmlinux	EXPORT_SYMBOL	
++0xa445d8b8	__blk_mq_debugfs_rq_show	vmlinux	EXPORT_SYMBOL_GPL	
++0x3f28ab09	jbd2_transaction_committed	vmlinux	EXPORT_SYMBOL	
++0xb58aeaab	kernel_cpustat	vmlinux	EXPORT_SYMBOL	
++0xf6eca0b5	ip_mc_inc_group	vmlinux	EXPORT_SYMBOL	
++0x478e81f8	tcp_orphan_count	vmlinux	EXPORT_SYMBOL_GPL	
++0x875582b7	nvmem_del_cell_table	vmlinux	EXPORT_SYMBOL_GPL	
++0x2250848f	input_setup_polling	vmlinux	EXPORT_SYMBOL	
++0x11e96ecf	usb_enable_intel_xhci_ports	vmlinux	EXPORT_SYMBOL_GPL	
++0xbbb94342	request_key_with_auxdata	vmlinux	EXPORT_SYMBOL	
++0xc31c416b	fat_attach	vmlinux	EXPORT_SYMBOL_GPL	
++0xef95e0fb	sysfs_remove_bin_file	vmlinux	EXPORT_SYMBOL_GPL	
++0x1e2df54a	inode_nohighmem	vmlinux	EXPORT_SYMBOL	
++0x696f8882	file_write_and_wait_range	vmlinux	EXPORT_SYMBOL	
++0xc77e24f1	register_wide_hw_breakpoint	vmlinux	EXPORT_SYMBOL_GPL	
++0x6c806057	tcf_exts_validate	vmlinux	EXPORT_SYMBOL	
++0x9d486ba9	hid_dump_device	vmlinux	EXPORT_SYMBOL_GPL	
++0x88ebeed4	phy_attached_info_irq	vmlinux	EXPORT_SYMBOL	
++0x2c50f276	fwnode_graph_get_endpoint_by_id	vmlinux	EXPORT_SYMBOL_GPL	
++0x656e4a6e	snprintf	vmlinux	EXPORT_SYMBOL	
++0x8ce2d446	__tracepoint_block_rq_remap	vmlinux	EXPORT_SYMBOL_GPL	
++0xa76f94e6	proc_mkdir_mode	vmlinux	EXPORT_SYMBOL	
++0xee12cb7f	tag_pages_for_writeback	vmlinux	EXPORT_SYMBOL	
++0x247390a4	rpcauth_destroy_credcache	vmlinux	EXPORT_SYMBOL_GPL	
++0xec589de8	flow_indr_dev_register	vmlinux	EXPORT_SYMBOL	
++0x6efd67ff	nvmem_register	vmlinux	EXPORT_SYMBOL_GPL	
++0xa175b7f4	spi_take_timestamp_post	vmlinux	EXPORT_SYMBOL_GPL	
++0xbfadfcb3	tty_port_link_device	vmlinux	EXPORT_SYMBOL_GPL	
++0x453447af	pinctrl_find_and_add_gpio_range	vmlinux	EXPORT_SYMBOL_GPL	
++0x9315365c	sbitmap_get	vmlinux	EXPORT_SYMBOL_GPL	
++0x75133f6e	visitor128	vmlinux	EXPORT_SYMBOL_GPL	
++0x11c23240	crypto_attr_u32	vmlinux	EXPORT_SYMBOL_GPL	
++0x5c946b2c	PDE_DATA	vmlinux	EXPORT_SYMBOL	
++0x3fe358b5	fscrypt_free_bounce_page	vmlinux	EXPORT_SYMBOL	
++0x2f522ad7	follow_pfn	vmlinux	EXPORT_SYMBOL	
++0xa8b180bf	follow_pte	vmlinux	EXPORT_SYMBOL_GPL	
++0xe05ec088	make_kuid	vmlinux	EXPORT_SYMBOL	
++0xaf7eca7e	hrtimer_init	vmlinux	EXPORT_SYMBOL_GPL	
++0x85c885ee	__napi_alloc_skb	vmlinux	EXPORT_SYMBOL	
++0x04e1e6d2	usb_disable_xhci_ports	vmlinux	EXPORT_SYMBOL_GPL	
++0xc5905738	scsi_report_opcode	vmlinux	EXPORT_SYMBOL	
++0x6887a0bf	pm_clk_create	vmlinux	EXPORT_SYMBOL_GPL	
++0x9305bf68	find_next_and_bit	vmlinux	EXPORT_SYMBOL	
++0xdebac316	blk_mq_freeze_queue_wait_timeout	vmlinux	EXPORT_SYMBOL_GPL	
++0xa8615dcf	file_remove_privs	vmlinux	EXPORT_SYMBOL	
++0x69637b2c	__traceiter_powernv_throttle	vmlinux	EXPORT_SYMBOL_GPL	
++0x74f9f3c6	udp_seq_ops	vmlinux	EXPORT_SYMBOL	
++0x1b6314fd	in_aton	vmlinux	EXPORT_SYMBOL	
++0xc3915398	neigh_resolve_output	vmlinux	EXPORT_SYMBOL	
++0x6a5ac346	flow_get_u32_dst	vmlinux	EXPORT_SYMBOL	
++0x180d78d5	cfb_imageblit	vmlinux	EXPORT_SYMBOL	
++0x380b137a	__traceiter_nfs_xdr_status	vmlinux	EXPORT_SYMBOL_GPL	
++0x19d2e0c5	nfs_pageio_init_read	vmlinux	EXPORT_SYMBOL_GPL	
++0xceb70c2b	sysfs_unbreak_active_protection	vmlinux	EXPORT_SYMBOL_GPL	
++0x28cebc35	__mnt_is_readonly	vmlinux	EXPORT_SYMBOL_GPL	
++0x774f16ef	__tracepoint_cpu_idle	vmlinux	EXPORT_SYMBOL_GPL	
++0xf2be0062	tcp_close	vmlinux	EXPORT_SYMBOL	
++0x1bbdcac9	inet_add_offload	vmlinux	EXPORT_SYMBOL	
++0x6ba86bf0	__scm_send	vmlinux	EXPORT_SYMBOL	
++0x780fe405	skb_try_coalesce	vmlinux	EXPORT_SYMBOL	
++0x699a86e2	get_thermal_instance	vmlinux	EXPORT_SYMBOL	
++0xbea27115	usb_register_dev	vmlinux	EXPORT_SYMBOL_GPL	
++0x54a02fb2	scsi_dma_map	vmlinux	EXPORT_SYMBOL	
++0xf955e9c5	bprintf	vmlinux	EXPORT_SYMBOL_GPL	
++0x52d717da	xz_dec_init	vmlinux	EXPORT_SYMBOL	
++0xb1879a7d	blk_mq_delay_run_hw_queues	vmlinux	EXPORT_SYMBOL	
++0x7711f5df	try_to_free_buffers	vmlinux	EXPORT_SYMBOL	
++0xd612aff0	xattr_full_name	vmlinux	EXPORT_SYMBOL	
++0x1d2d6d15	wait_iff_congested	vmlinux	EXPORT_SYMBOL	
++0x4531ab62	copy_from_kernel_nofault	vmlinux	EXPORT_SYMBOL_GPL	
++0xc8c2d0ca	blk_trace_setup	vmlinux	EXPORT_SYMBOL_GPL	
++0x4f6a07fe	show_rcu_gp_kthreads	vmlinux	EXPORT_SYMBOL_GPL	
++0xf819c78a	__put_cred	vmlinux	EXPORT_SYMBOL	
++0x8ffbfb38	ping_getfrag	vmlinux	EXPORT_SYMBOL_GPL	
++0x09682273	skb_csum_hwoffload_help	vmlinux	EXPORT_SYMBOL	
++0xe02eb61b	of_root	vmlinux	EXPORT_SYMBOL	
++0x653ee1f8	serial8250_clear_and_reinit_fifos	vmlinux	EXPORT_SYMBOL_GPL	
++0x20bb2de6	register_framebuffer	vmlinux	EXPORT_SYMBOL	
++0x7858111c	crypto_unregister_templates	vmlinux	EXPORT_SYMBOL_GPL	
++0x7f2042bf	dquot_free_inode	vmlinux	EXPORT_SYMBOL	
++0xd0da78dc	migrate_page_states	vmlinux	EXPORT_SYMBOL	
++0x4fca8379	__traceiter_pelt_irq_tp	vmlinux	EXPORT_SYMBOL_GPL	
++0x537d40a2	__traceiter_pelt_cfs_tp	vmlinux	EXPORT_SYMBOL_GPL	
++0x930443a9	bpf_sk_storage_diag_put	vmlinux	EXPORT_SYMBOL_GPL	
++0xa5fe717e	mmc_of_parse	vmlinux	EXPORT_SYMBOL	
++0xe10fb15d	power_supply_notifier	vmlinux	EXPORT_SYMBOL_GPL	
++0x8e9a21cd	mfd_remove_devices	vmlinux	EXPORT_SYMBOL	
++0x3cd06035	add_input_randomness	vmlinux	EXPORT_SYMBOL_GPL	
++0xa4333afa	regulator_enable_regmap	vmlinux	EXPORT_SYMBOL_GPL	
++0x4d554a1d	clk_gate_ops	vmlinux	EXPORT_SYMBOL_GPL	
++0x477a8557	gpiod_set_config	vmlinux	EXPORT_SYMBOL_GPL	
++0x8280ee31	pinctrl_force_sleep	vmlinux	EXPORT_SYMBOL_GPL	
++0xad046f2a	iov_iter_advance	vmlinux	EXPORT_SYMBOL	
++0x4bef1c67	empty_name	vmlinux	EXPORT_SYMBOL	
++0x59e676ab	xdr_set_scratch_buffer	vmlinux	EXPORT_SYMBOL_GPL	
++0x136c4153	dev_pm_opp_get_of_node	vmlinux	EXPORT_SYMBOL_GPL	
++0x427f30d1	scsi_unblock_requests	vmlinux	EXPORT_SYMBOL	
++0xd9291dba	device_remove_bin_file	vmlinux	EXPORT_SYMBOL_GPL	
++0x365a9c6e	mipi_dsi_generic_read	vmlinux	EXPORT_SYMBOL	
++0x5fd0b8de	tty_port_free_xmit_buf	vmlinux	EXPORT_SYMBOL	
++0x803c0e1b	alarm_try_to_cancel	vmlinux	EXPORT_SYMBOL_GPL	
++0xaf5bf6ef	nfs_debug	vmlinux	EXPORT_SYMBOL_GPL	
++0xa434ed62	xfrm_replay_seqhi	vmlinux	EXPORT_SYMBOL	
++0xcac2b4e4	tcp_enter_cwr	vmlinux	EXPORT_SYMBOL	
++0xf04c867c	hidraw_report_event	vmlinux	EXPORT_SYMBOL_GPL	
++0x49d9f030	usb_ep_fifo_status	vmlinux	EXPORT_SYMBOL_GPL	
++0x864a6145	nvme_put_ns	vmlinux	EXPORT_SYMBOL_GPL	NVME_TARGET_PASSTHRU
++0xff8fdd71	sbitmap_del_wait_queue	vmlinux	EXPORT_SYMBOL_GPL	
++0x9e9fdd9d	memunmap	vmlinux	EXPORT_SYMBOL	
++0x4d924f20	memremap	vmlinux	EXPORT_SYMBOL	
++0x28aa6a67	call_rcu	vmlinux	EXPORT_SYMBOL_GPL	
++0x8146dac5	devm_request_any_context_irq	vmlinux	EXPORT_SYMBOL	
++0x2fc798c2	dev_pm_opp_put_prop_name	vmlinux	EXPORT_SYMBOL_GPL	
++0x8bc99f86	spi_mem_driver_unregister	vmlinux	EXPORT_SYMBOL_GPL	
++0xcaf30402	nvme_alloc_request	vmlinux	EXPORT_SYMBOL_GPL	
++0xd57fbd31	hwrng_unregister	vmlinux	EXPORT_SYMBOL_GPL	
++0xd478d843	pci_try_reset_function	vmlinux	EXPORT_SYMBOL_GPL	
++0x5f5d3e4d	nfs42_ssc_register	vmlinux	EXPORT_SYMBOL_GPL	
++0xa25a338f	fscrypt_d_revalidate	vmlinux	EXPORT_SYMBOL_GPL	
++0xaf56600a	arm64_use_ng_mappings	vmlinux	EXPORT_SYMBOL	
++0x8affe06a	tcf_exts_change	vmlinux	EXPORT_SYMBOL	
++0x92b2feb4	vchiq_bulk_transmit	vmlinux	EXPORT_SYMBOL	
++0x4a41c8d5	of_device_modalias	vmlinux	EXPORT_SYMBOL_GPL	
++0xca4bbe19	dwc_unregister_notifier	vmlinux	EXPORT_SYMBOL	
++0x7d6db775	iscsi_put_conn	vmlinux	EXPORT_SYMBOL_GPL	
++0xa7466ea0	disk_stack_limits	vmlinux	EXPORT_SYMBOL	
++0x9879932b	crypto_register_notifier	vmlinux	EXPORT_SYMBOL_GPL	
++0x6a384cb5	fib_table_lookup	vmlinux	EXPORT_SYMBOL_GPL	
++0x9e409cc7	skb_mpls_update_lse	vmlinux	EXPORT_SYMBOL_GPL	
++0x350b74cc	pskb_put	vmlinux	EXPORT_SYMBOL_GPL	
++0xc40c1149	__efivar_entry_iter	vmlinux	EXPORT_SYMBOL_GPL	
++0x816a41ca	cpufreq_update_limits	vmlinux	EXPORT_SYMBOL_GPL	
++0xb0ebae05	nvme_submit_sync_cmd	vmlinux	EXPORT_SYMBOL_GPL	
++0x1708363d	device_reprobe	vmlinux	EXPORT_SYMBOL_GPL	
++0x479c3c86	find_next_zero_bit	vmlinux	EXPORT_SYMBOL	
++0x085a6da1	inc_nlink	vmlinux	EXPORT_SYMBOL	
++0xf914183a	smpboot_unregister_percpu_thread	vmlinux	EXPORT_SYMBOL_GPL	
++0x180bda6e	__netlink_dump_start	vmlinux	EXPORT_SYMBOL	
++0xcddf1368	phy_write_mmd	vmlinux	EXPORT_SYMBOL	
++0xe791d486	security_task_getsecid	vmlinux	EXPORT_SYMBOL	
++0x4d16d9c8	seq_open	vmlinux	EXPORT_SYMBOL	
++0x19c8e4ad	mnt_drop_write	vmlinux	EXPORT_SYMBOL_GPL	
++0x200c3224	vmf_insert_pfn_prot	vmlinux	EXPORT_SYMBOL	
++0xaf793668	__alloc_percpu_gfp	vmlinux	EXPORT_SYMBOL_GPL	
++0x85e30c0d	rpc_uaddr2sockaddr	vmlinux	EXPORT_SYMBOL_GPL	
++0xc97fb08c	cpufreq_freq_transition_begin	vmlinux	EXPORT_SYMBOL_GPL	
++0x14f089e1	scsi_host_unblock	vmlinux	EXPORT_SYMBOL_GPL	
++0xbcf73a53	dma_fence_enable_sw_signaling	vmlinux	EXPORT_SYMBOL	
++0xa66fc257	pci_bus_type	vmlinux	EXPORT_SYMBOL	
++0xea97540b	fscache_mark_page_cached	vmlinux	EXPORT_SYMBOL	
++0x73d33bf8	simple_readpage	vmlinux	EXPORT_SYMBOL	
++0xe649d5a5	__page_frag_cache_drain	vmlinux	EXPORT_SYMBOL	
++0x9d58290d	__lock_page	vmlinux	EXPORT_SYMBOL	
++0xe3d4cab0	perf_event_pause	vmlinux	EXPORT_SYMBOL_GPL	
++0xb02ea3c4	synchronize_srcu_expedited	vmlinux	EXPORT_SYMBOL_GPL	
++0x775d46ab	tcp_cong_avoid_ai	vmlinux	EXPORT_SYMBOL_GPL	
++0xcabe04de	cpuidle_resume_and_unlock	vmlinux	EXPORT_SYMBOL_GPL	
++0x17558900	usb_altnum_to_altsetting	vmlinux	EXPORT_SYMBOL_GPL	
++0x5f60b873	pm_clk_runtime_resume	vmlinux	EXPORT_SYMBOL_GPL	
++0xb0ab23be	dev_pm_qos_update_user_latency_tolerance	vmlinux	EXPORT_SYMBOL_GPL	
++0xced1d9d7	pci_create_slot	vmlinux	EXPORT_SYMBOL_GPL	
++0xd774957d	mpi_write_to_sgl	vmlinux	EXPORT_SYMBOL_GPL	
++0xf44d53da	security_secid_to_secctx	vmlinux	EXPORT_SYMBOL	
++0xc239bcaf	nfs_close_context	vmlinux	EXPORT_SYMBOL_GPL	
++0x65922d47	follow_down	vmlinux	EXPORT_SYMBOL	
++0xc8863dbb	filemap_write_and_wait_range	vmlinux	EXPORT_SYMBOL	
++0xc82b3a88	__SCK__tp_func_rpm_resume	vmlinux	EXPORT_SYMBOL_GPL	
++0xa3718722	__traceiter_rpm_idle	vmlinux	EXPORT_SYMBOL_GPL	
++0x53d7c01e	__traceiter_cpu_idle	vmlinux	EXPORT_SYMBOL_GPL	
++0x7246617c	rpcauth_lookupcred	vmlinux	EXPORT_SYMBOL_GPL	
++0x067a6230	eth_get_headlen	vmlinux	EXPORT_SYMBOL	
++0x72d64704	__regmap_init	vmlinux	EXPORT_SYMBOL_GPL	
++0xfab53ed9	pinctrl_gpio_can_use_line	vmlinux	EXPORT_SYMBOL_GPL	
++0xc917e655	debug_smp_processor_id	vmlinux	EXPORT_SYMBOL	
++0x15539d5f	nfs42_ssc_unregister	vmlinux	EXPORT_SYMBOL_GPL	
++0x360b1afe	probe_irq_mask	vmlinux	EXPORT_SYMBOL	
++0x3a4e7433	usb_gadget_vbus_draw	vmlinux	EXPORT_SYMBOL_GPL	
++0x04e8d2f7	genphy_read_status	vmlinux	EXPORT_SYMBOL	
++0xcb456ff3	redraw_screen	vmlinux	EXPORT_SYMBOL	
++0xb52e0d54	tty_unregister_driver	vmlinux	EXPORT_SYMBOL	
++0x1934e405	pci_reenable_device	vmlinux	EXPORT_SYMBOL	
++0x8ba5bc0d	d_instantiate_new	vmlinux	EXPORT_SYMBOL	
++0x9963531d	invalidate_mapping_pages	vmlinux	EXPORT_SYMBOL	
++0x8fa77a1b	devm_release_resource	vmlinux	EXPORT_SYMBOL	
++0xaf7ea58b	napi_disable	vmlinux	EXPORT_SYMBOL	
++0xd93a5cb1	efivar_variable_is_removable	vmlinux	EXPORT_SYMBOL_GPL	
++0xe23f7882	pci_enable_rom	vmlinux	EXPORT_SYMBOL_GPL	
++0x6185b8af	pinctrl_find_gpio_range_from_pin	vmlinux	EXPORT_SYMBOL_GPL	
++0x7c173634	__bitmap_complement	vmlinux	EXPORT_SYMBOL	
++0x9291cd3b	memdup_user	vmlinux	EXPORT_SYMBOL	
++0x0f9e1197	ping_get_port	vmlinux	EXPORT_SYMBOL_GPL	
++0x8b50cb90	raw_abort	vmlinux	EXPORT_SYMBOL_GPL	
++0x4599f1da	thermal_cooling_device_unregister	vmlinux	EXPORT_SYMBOL_GPL	
++0x906b671d	__clk_mux_determine_rate	vmlinux	EXPORT_SYMBOL_GPL	
++0x743ebae0	blk_mq_free_request	vmlinux	EXPORT_SYMBOL_GPL	
++0xb48d4d22	security_sb_eat_lsm_opts	vmlinux	EXPORT_SYMBOL	
++0xc280fb46	kdb_register	vmlinux	EXPORT_SYMBOL_GPL	
++0x981e027e	del_timer	vmlinux	EXPORT_SYMBOL	
++0x97aa5c60	dma_get_required_mask	vmlinux	EXPORT_SYMBOL_GPL	
++0xb7a387fc	synchronize_rcu_tasks_rude	vmlinux	EXPORT_SYMBOL_GPL	
++0xec3d434d	nf_log_unbind_pf	vmlinux	EXPORT_SYMBOL	
++0x0876aca9	lwtunnel_valid_encap_type	vmlinux	EXPORT_SYMBOL_GPL	
++0xa5824d74	usb_get_current_frame_number	vmlinux	EXPORT_SYMBOL_GPL	
++0x80ac9e94	phy_resolve_aneg_pause	vmlinux	EXPORT_SYMBOL_GPL	
++0xb83f7701	pcie_update_link_speed	vmlinux	EXPORT_SYMBOL_GPL	
++0xfb4e4188	blk_mq_start_request	vmlinux	EXPORT_SYMBOL	
++0x50020b52	nfs_init_cinfo	vmlinux	EXPORT_SYMBOL_GPL	
++0x5bcae5af	tcp_v4_send_check	vmlinux	EXPORT_SYMBOL	
++0x5b971947	dev_close	vmlinux	EXPORT_SYMBOL	
++0xab4674c8	__SCK__tp_func_iscsi_dbg_sw_tcp	vmlinux	EXPORT_SYMBOL_GPL	
++0xf831d52d	dma_buf_put	vmlinux	EXPORT_SYMBOL_GPL	
++0x2abc7470	dma_buf_get	vmlinux	EXPORT_SYMBOL_GPL	
++0x54d7323f	of_genpd_remove_last	vmlinux	EXPORT_SYMBOL_GPL	
++0x168c9877	pci_hp_add_bridge	vmlinux	EXPORT_SYMBOL_GPL	
++0x173db125	pnfs_nfs_generic_sync	vmlinux	EXPORT_SYMBOL_GPL	
++0x4ac2efec	__mark_inode_dirty	vmlinux	EXPORT_SYMBOL	
++0xdafcdc3a	ktime_get_snapshot	vmlinux	EXPORT_SYMBOL_GPL	
++0x188ea314	jiffies_to_timespec64	vmlinux	EXPORT_SYMBOL	
++0xc2f7f6a3	tcp_set_rcvlowat	vmlinux	EXPORT_SYMBOL	
++0xbeb27a59	noop_qdisc	vmlinux	EXPORT_SYMBOL	
++0x1e56adaa	sock_alloc_send_skb	vmlinux	EXPORT_SYMBOL	
++0xdc995f27	firmware_request_cache	vmlinux	EXPORT_SYMBOL_GPL	
++0x9b490d3f	devm_of_phy_get_by_index	vmlinux	EXPORT_SYMBOL_GPL	
++0xa916b694	strnlen	vmlinux	EXPORT_SYMBOL	
++0x7b5b8f31	sha256_update	vmlinux	EXPORT_SYMBOL	
++0x009dd511	blk_mq_init_allocated_queue	vmlinux	EXPORT_SYMBOL	
++0x4022c058	blk_mq_quiesce_queue_nowait	vmlinux	EXPORT_SYMBOL_GPL	
++0xecd3dc8b	unregister_filesystem	vmlinux	EXPORT_SYMBOL	
++0x0ba0b938	vm_brk	vmlinux	EXPORT_SYMBOL	
++0x98004f03	irq_domain_add_simple	vmlinux	EXPORT_SYMBOL_GPL	
++0xeb767bee	adjust_resource	vmlinux	EXPORT_SYMBOL	
++0xbcd7c75a	xfrm_state_insert	vmlinux	EXPORT_SYMBOL	
++0x3b582fad	metadata_dst_alloc	vmlinux	EXPORT_SYMBOL_GPL	
++0x27dccb24	devm_rc_allocate_device	vmlinux	EXPORT_SYMBOL_GPL	
++0x60eeae28	__of_reset_control_get	vmlinux	EXPORT_SYMBOL_GPL	
++0x7a5a4b20	configfs_unregister_default_group	vmlinux	EXPORT_SYMBOL	
++0x9ab9cc9b	kmsg_dump_register	vmlinux	EXPORT_SYMBOL_GPL	
++0x86b92718	xprt_setup_backchannel	vmlinux	EXPORT_SYMBOL_GPL	
++0xc02d2b4a	rpc_peeraddr2str	vmlinux	EXPORT_SYMBOL_GPL	
++0x6d94713e	of_node_put	vmlinux	EXPORT_SYMBOL	
++0x22e17060	of_node_get	vmlinux	EXPORT_SYMBOL	
++0x9bd3301d	dev_pm_opp_set_clkname	vmlinux	EXPORT_SYMBOL_GPL	
++0x97ed2212	__tracepoint_spi_transfer_start	vmlinux	EXPORT_SYMBOL	
++0x74f2cdfd	of_genpd_remove_subdomain	vmlinux	EXPORT_SYMBOL_GPL	
++0xa1168cb9	platform_irq_count	vmlinux	EXPORT_SYMBOL_GPL	
++0xe9925100	__destroy_inode	vmlinux	EXPORT_SYMBOL	
++0xabfa0367	ethnl_cable_test_fault_length	vmlinux	EXPORT_SYMBOL_GPL	
++0x99ec44fc	usb_mon_register	vmlinux	EXPORT_SYMBOL_GPL	
++0x7e584555	bcm_phy_config_intr	vmlinux	EXPORT_SYMBOL_GPL	
++0x36f2662b	mdio_device_remove	vmlinux	EXPORT_SYMBOL	
++0xfeffe6ee	dma_resv_add_excl_fence	vmlinux	EXPORT_SYMBOL	
++0x5c80627a	dma_fence_chain_ops	vmlinux	EXPORT_SYMBOL	
++0xe6236b4e	device_property_present	vmlinux	EXPORT_SYMBOL_GPL	
++0x65191501	pci_bus_add_devices	vmlinux	EXPORT_SYMBOL	
++0x481f9b7d	mpi_mulm	vmlinux	EXPORT_SYMBOL_GPL	
++0xea018bbb	mpi_test_bit	vmlinux	EXPORT_SYMBOL_GPL	
++0xf73227de	blk_rq_unmap_user	vmlinux	EXPORT_SYMBOL	
++0x135adc24	crypto_mod_get	vmlinux	EXPORT_SYMBOL_GPL	
++0x0bc477a2	irq_set_irq_type	vmlinux	EXPORT_SYMBOL	
++0xce2840e7	irq_set_irq_wake	vmlinux	EXPORT_SYMBOL	
++0x4b140e9f	cpu_hwcap_keys	vmlinux	EXPORT_SYMBOL	
++0xb6bb204c	extcon_sync	vmlinux	EXPORT_SYMBOL_GPL	
++0x7b712226	of_platform_device_destroy	vmlinux	EXPORT_SYMBOL_GPL	
++0xc7f71603	phy_do_ioctl	vmlinux	EXPORT_SYMBOL	
++0xfd56d678	spi_res_add	vmlinux	EXPORT_SYMBOL_GPL	
++0xbe7a85f0	pwmchip_add_with_polarity	vmlinux	EXPORT_SYMBOL_GPL	
++0x340a8894	inode_io_list_del	vmlinux	EXPORT_SYMBOL	
++0xdb98c6fb	__remove_inode_hash	vmlinux	EXPORT_SYMBOL	
++0x2d53bb4b	device_match_acpi_dev	vmlinux	EXPORT_SYMBOL	
++0x3a46f438	__pci_reset_function_locked	vmlinux	EXPORT_SYMBOL_GPL	
++0x6128b5fc	__printk_ratelimit	vmlinux	EXPORT_SYMBOL	
++0xd40cb030	xdr_read_pages	vmlinux	EXPORT_SYMBOL_GPL	
++0x42d9ed5e	tcf_chain_put_by_act	vmlinux	EXPORT_SYMBOL	
++0xd04c1a64	sysctl_devconf_inherit_init_net	vmlinux	EXPORT_SYMBOL	
++0xad9a06cd	mmc_regulator_set_vqmmc	vmlinux	EXPORT_SYMBOL_GPL	
++0x28e4e147	nvme_execute_passthru_rq	vmlinux	EXPORT_SYMBOL_GPL	NVME_TARGET_PASSTHRU
++0xe279871b	iscsi_dbg_trace	vmlinux	EXPORT_SYMBOL_GPL	
++0x40414ce5	__traceiter_iscsi_dbg_sw_tcp	vmlinux	EXPORT_SYMBOL_GPL	
++0x1f3d5f89	clk_hw_get_parent_by_index	vmlinux	EXPORT_SYMBOL_GPL	
++0xb78debe3	LZ4_decompress_fast_usingDict	vmlinux	EXPORT_SYMBOL	
++0x94bf03ca	utf8_to_utf32	vmlinux	EXPORT_SYMBOL	
++0x9d09e8ae	ring_buffer_event_data	vmlinux	EXPORT_SYMBOL_GPL	
++0x313ea5fd	ipi_send_single	vmlinux	EXPORT_SYMBOL_GPL	
++0x1346e02d	skb_vlan_pop	vmlinux	EXPORT_SYMBOL	
++0x23b5335f	phy_sfp_probe	vmlinux	EXPORT_SYMBOL	
++0x6016bfd2	iscsi_create_session	vmlinux	EXPORT_SYMBOL_GPL	
++0xab3c53d3	__pm_runtime_disable	vmlinux	EXPORT_SYMBOL_GPL	
++0x547b6af3	paste_selection	vmlinux	EXPORT_SYMBOL_GPL	
++0x58e6dd9a	phy_pm_runtime_get_sync	vmlinux	EXPORT_SYMBOL_GPL	
++0x2acc1033	crypto_sha1_update	vmlinux	EXPORT_SYMBOL	
++0x1d5cedae	__tracepoint_kfree	vmlinux	EXPORT_SYMBOL	
++0x75dfc660	perf_aux_output_end	vmlinux	EXPORT_SYMBOL_GPL	
++0xebc73ec0	bpf_prog_select_runtime	vmlinux	EXPORT_SYMBOL_GPL	
++0x1a53e676	kmsg_dump_unregister	vmlinux	EXPORT_SYMBOL_GPL	
++0x0e85213d	cpu_latency_qos_add_request	vmlinux	EXPORT_SYMBOL_GPL	
++0xa2b8d3a8	override_creds	vmlinux	EXPORT_SYMBOL	
++0x131db64a	system_long_wq	vmlinux	EXPORT_SYMBOL_GPL	
++0x473f4c5e	__ip_queue_xmit	vmlinux	EXPORT_SYMBOL	
++0x7e757450	input_register_handle	vmlinux	EXPORT_SYMBOL	
++0x485dbe4e	clk_mux_ops	vmlinux	EXPORT_SYMBOL_GPL	
++0x6259d291	clk_restore_context	vmlinux	EXPORT_SYMBOL_GPL	
++0xb772a84b	radix_tree_iter_resume	vmlinux	EXPORT_SYMBOL	
++0xd58e70dd	net_rand_noise	vmlinux	EXPORT_SYMBOL	
++0x63a1e8f7	blkdev_issue_zeroout	vmlinux	EXPORT_SYMBOL	
++0xcdc90099	blk_bio_list_merge	vmlinux	EXPORT_SYMBOL_GPL	
++0x8d6f4454	__traceiter_block_split	vmlinux	EXPORT_SYMBOL_GPL	
++0xc19c6f53	get_tree_bdev	vmlinux	EXPORT_SYMBOL	
++0xf577bbf3	handle_level_irq	vmlinux	EXPORT_SYMBOL_GPL	
++0x3503dac9	unix_table_locks	vmlinux	EXPORT_SYMBOL_GPL	
++0xd31ccb06	of_machine_is_compatible	vmlinux	EXPORT_SYMBOL	
++0x7e079b3e	sdio_writesb	vmlinux	EXPORT_SYMBOL_GPL	
++0x05111002	phy_mac_interrupt	vmlinux	EXPORT_SYMBOL	
++0x04df8fbc	lzo1x_decompress_safe	vmlinux	EXPORT_SYMBOL_GPL	
++0x1564cd16	blkcg_deactivate_policy	vmlinux	EXPORT_SYMBOL_GPL	
++0xa39cdf4a	__bio_clone_fast	vmlinux	EXPORT_SYMBOL	
++0x2cd00836	nfs4_init_deviceid_node	vmlinux	EXPORT_SYMBOL_GPL	
++0xb9826596	__fscache_register_netfs	vmlinux	EXPORT_SYMBOL	
++0xe17f86aa	kern_unmount	vmlinux	EXPORT_SYMBOL	
++0x94f82081	total_swapcache_pages	vmlinux	EXPORT_SYMBOL_GPL	
++0x73b14177	__traceiter_br_fdb_external_learn_add	vmlinux	EXPORT_SYMBOL_GPL	
++0xc3394bd8	usb_control_msg	vmlinux	EXPORT_SYMBOL_GPL	
++0x8adf67c9	nla_append	vmlinux	EXPORT_SYMBOL	
++0x7f165621	pcim_iomap_regions	vmlinux	EXPORT_SYMBOL	
++0xd547c66e	jbd2_journal_lock_updates	vmlinux	EXPORT_SYMBOL	
++0xc5863d9d	__fscache_read_or_alloc_pages	vmlinux	EXPORT_SYMBOL	
++0xa35908b2	vfs_ioc_setflags_prepare	vmlinux	EXPORT_SYMBOL	
++0xac298e8e	vfs_llseek	vmlinux	EXPORT_SYMBOL	
++0xd9c4cada	__page_file_index	vmlinux	EXPORT_SYMBOL_GPL	
++0x6e4ae6e5	__irq_set_handler	vmlinux	EXPORT_SYMBOL_GPL	
++0x9e5c8aaf	of_platform_depopulate	vmlinux	EXPORT_SYMBOL_GPL	
++0x993cbf39	devm_regulator_get_optional	vmlinux	EXPORT_SYMBOL_GPL	
++0xab8eff35	iterate_fd	vmlinux	EXPORT_SYMBOL	
++0x7ceaf0d5	generic_handle_irq	vmlinux	EXPORT_SYMBOL_GPL	
++0x1d3c5503	_mutex_lock_killable	vmlinux	EXPORT_SYMBOL	
++0x8b2ffd83	__cpu_present_mask	vmlinux	EXPORT_SYMBOL	
++0x5c2bcd37	bpf_warn_invalid_xdp_action	vmlinux	EXPORT_SYMBOL_GPL	
++0x060d4610	of_find_node_opts_by_path	vmlinux	EXPORT_SYMBOL	
++0x1613bd43	mmc_pwrseq_unregister	vmlinux	EXPORT_SYMBOL_GPL	
++0x24543e0a	iscsi_add_session	vmlinux	EXPORT_SYMBOL_GPL	
++0x3b7687ab	device_property_read_u8_array	vmlinux	EXPORT_SYMBOL_GPL	
++0xb2210d64	reset_control_deassert	vmlinux	EXPORT_SYMBOL_GPL	
++0xd32862e8	nfs4_schedule_lease_recovery	vmlinux	EXPORT_SYMBOL_GPL	
++0xc824090d	dquot_resume	vmlinux	EXPORT_SYMBOL	
++0xf4bdbeb9	__frontswap_invalidate_area	vmlinux	EXPORT_SYMBOL	
++0x7ce58981	kvrealloc	vmlinux	EXPORT_SYMBOL	
++0xb8d1da28	__xfrm_state_destroy	vmlinux	EXPORT_SYMBOL	
++0xddd0a1c3	bfifo_qdisc_ops	vmlinux	EXPORT_SYMBOL	
++0xf4960dbe	of_prop_next_u32	vmlinux	EXPORT_SYMBOL_GPL	
++0x4386cd24	usb_unpoison_urb	vmlinux	EXPORT_SYMBOL_GPL	
++0xd15abc39	pm_genpd_remove_subdomain	vmlinux	EXPORT_SYMBOL_GPL	
++0x7bc9fb7f	tty_port_init	vmlinux	EXPORT_SYMBOL	
++0x161ba5c8	complete_request_key	vmlinux	EXPORT_SYMBOL	
++0x4f48e4e4	__traceiter_sched_util_est_cfs_tp	vmlinux	EXPORT_SYMBOL_GPL	
++0x1f8544b8	panic_timeout	vmlinux	EXPORT_SYMBOL_GPL	
++0x3556605e	nf_queue	vmlinux	EXPORT_SYMBOL_GPL	
++0x0ef1fd64	__sock_recv_timestamp	vmlinux	EXPORT_SYMBOL_GPL	
++0xfb92a46c	extcon_dev_unregister	vmlinux	EXPORT_SYMBOL_GPL	
++0x817cf354	extcon_set_state_sync	vmlinux	EXPORT_SYMBOL_GPL	
++0x838e1bde	usb_hcd_resume_root_hub	vmlinux	EXPORT_SYMBOL_GPL	
++0x37746fde	ZSTD_initDStream	vmlinux	EXPORT_SYMBOL	
++0x0ec761fc	aead_init_geniv	vmlinux	EXPORT_SYMBOL_GPL	
++0x20564197	securityfs_remove	vmlinux	EXPORT_SYMBOL_GPL	
++0x9e06313c	jbd2_journal_grab_journal_head	vmlinux	EXPORT_SYMBOL	
++0x98666233	noop_fsync	vmlinux	EXPORT_SYMBOL	
++0x1008c98d	list_lru_destroy	vmlinux	EXPORT_SYMBOL_GPL	
++0xfe4dd3a2	cpu_latency_qos_update_request	vmlinux	EXPORT_SYMBOL_GPL	
++0x0b666572	rpc_count_iostats	vmlinux	EXPORT_SYMBOL_GPL	
++0xab5d7ddf	rpc_destroy_pipe_data	vmlinux	EXPORT_SYMBOL_GPL	
++0xdf0000b8	fib_rule_matchall	vmlinux	EXPORT_SYMBOL_GPL	
++0x5ac767c7	scsi_add_host_with_dma	vmlinux	EXPORT_SYMBOL	
++0x092d0926	devres_remove_group	vmlinux	EXPORT_SYMBOL_GPL	
++0x6aa11aa6	sgl_free_n_order	vmlinux	EXPORT_SYMBOL	
++0xd1c63b4f	blkdev_issue_write_same	vmlinux	EXPORT_SYMBOL	
++0xe6fab2fc	crypto_hash_walk_first	vmlinux	EXPORT_SYMBOL_GPL	
++0x24937628	pnfs_generic_pg_cleanup	vmlinux	EXPORT_SYMBOL_GPL	
++0xb2d7df66	nfs4_proc_getdeviceinfo	vmlinux	EXPORT_SYMBOL_GPL	
++0xa4230811	alloc_anon_inode	vmlinux	EXPORT_SYMBOL	
++0x6b0d1620	vfs_mkobj	vmlinux	EXPORT_SYMBOL	
++0x87a41b2b	__ClearPageMovable	vmlinux	EXPORT_SYMBOL	
++0xf0a9a295	inet_sendpage	vmlinux	EXPORT_SYMBOL	
++0xb28ef84a	dev_set_allmulti	vmlinux	EXPORT_SYMBOL	
++0xc38eb7fc	dev_get_by_index_rcu	vmlinux	EXPORT_SYMBOL	
++0xee5e31f6	mmc_can_erase	vmlinux	EXPORT_SYMBOL	
++0xa529d923	i2c_add_adapter	vmlinux	EXPORT_SYMBOL	
++0x55c4f797	input_mt_report_finger_count	vmlinux	EXPORT_SYMBOL	
++0x1663668a	gen_pool_dma_zalloc	vmlinux	EXPORT_SYMBOL	
++0xe32ab4d8	xxh64_digest	vmlinux	EXPORT_SYMBOL	
++0x4a96a8eb	xxh32_digest	vmlinux	EXPORT_SYMBOL	
++0xbb35675b	__bitmap_intersects	vmlinux	EXPORT_SYMBOL	
++0xeabb5bd6	pnfs_report_layoutstat	vmlinux	EXPORT_SYMBOL_GPL	
++0x04ea5d10	ksize	vmlinux	EXPORT_SYMBOL	
++0x38869d88	kstat	vmlinux	EXPORT_SYMBOL	
++0xd6dd170a	kobject_set_name	vmlinux	EXPORT_SYMBOL	
++0x3bb531fc	__get_vm_area_caller	vmlinux	EXPORT_SYMBOL	
++0x2dc3963e	shmem_truncate_range	vmlinux	EXPORT_SYMBOL_GPL	
++0x5b21ceff	ring_buffer_iter_peek	vmlinux	EXPORT_SYMBOL_GPL	
++0x6f12560a	get_old_timespec32	vmlinux	EXPORT_SYMBOL_GPL	
++0xa5efbf4c	async_synchronize_full	vmlinux	EXPORT_SYMBOL_GPL	
++0xc407cff0	vchiq_msg_queue_push	vmlinux	EXPORT_SYMBOL	
++0x723289b2	DWC_WAITQ_WAIT_TIMEOUT	vmlinux	EXPORT_SYMBOL	
++0x13432fdc	phy_modify_mmd_changed	vmlinux	EXPORT_SYMBOL_GPL	
++0x759ebe4b	of_clk_src_simple_get	vmlinux	EXPORT_SYMBOL_GPL	
++0xfb8900c7	_atomic_dec_and_lock_irqsave	vmlinux	EXPORT_SYMBOL	
++0x704fe822	set_device_ro	vmlinux	EXPORT_SYMBOL	
++0x74eaa7d4	__traceiter_block_rq_remap	vmlinux	EXPORT_SYMBOL_GPL	
++0x16ce2524	nfs4_schedule_migration_recovery	vmlinux	EXPORT_SYMBOL_GPL	
++0xaa230f88	perf_unregister_guest_info_callbacks	vmlinux	EXPORT_SYMBOL_GPL	
++0x3d510a7b	rcu_jiffies_till_stall_check	vmlinux	EXPORT_SYMBOL_GPL	
++0x608741b5	__init_swait_queue_head	vmlinux	EXPORT_SYMBOL	
++0xec7524f4	ethtool_rx_flow_rule_destroy	vmlinux	EXPORT_SYMBOL	
++0xe5c7d11c	usb_anchor_urb	vmlinux	EXPORT_SYMBOL_GPL	
++0x7fbab160	pci_clear_mwi	vmlinux	EXPORT_SYMBOL	
++0x0ddb1cd7	llist_reverse_order	vmlinux	EXPORT_SYMBOL_GPL	
++0x2d54f24e	blk_rq_append_bio	vmlinux	EXPORT_SYMBOL	
++0x2fe239b9	migrate_page_move_mapping	vmlinux	EXPORT_SYMBOL	
++0x63eb9355	panic_blink	vmlinux	EXPORT_SYMBOL	
++0x19eb414a	DWC_THREAD_RUN	vmlinux	EXPORT_SYMBOL	
++0x74dd91f6	pci_cfg_access_trylock	vmlinux	EXPORT_SYMBOL_GPL	
++0x1053a013	gpiochip_get_desc	vmlinux	EXPORT_SYMBOL_GPL	
++0x247863d7	__blk_rq_map_sg	vmlinux	EXPORT_SYMBOL	
++0x5aa9a2ff	__sync_dirty_buffer	vmlinux	EXPORT_SYMBOL	
++0xcc40265e	d_mark_dontcache	vmlinux	EXPORT_SYMBOL	
++0x6198dfea	__ring_buffer_alloc	vmlinux	EXPORT_SYMBOL_GPL	
++0x9783dd76	__var_waitqueue	vmlinux	EXPORT_SYMBOL	
++0x0c56b6cf	tasklet_kill	vmlinux	EXPORT_SYMBOL	
++0x72ebdf7c	nf_ip_route	vmlinux	EXPORT_SYMBOL_GPL	
++0x6bd0b900	bcm_phy_cable_test_start_rdb	vmlinux	EXPORT_SYMBOL_GPL	
++0xeee0d017	scsi_print_command	vmlinux	EXPORT_SYMBOL	
++0xff1ff121	set_secondary_fwnode	vmlinux	EXPORT_SYMBOL_GPL	
++0xeb100698	amba_driver_register	vmlinux	EXPORT_SYMBOL	
++0x2435d6d7	pci_try_set_mwi	vmlinux	EXPORT_SYMBOL	
++0x240adca9	phy_configure	vmlinux	EXPORT_SYMBOL_GPL	
++0xf0698c10	ida_free	vmlinux	EXPORT_SYMBOL	
++0xc6f3b3fc	refcount_dec_if_one	vmlinux	EXPORT_SYMBOL	
++0x26e1efd0	blk_post_runtime_resume	vmlinux	EXPORT_SYMBOL	
++0x313d6467	bio_endio	vmlinux	EXPORT_SYMBOL	
++0x43d3212d	nfs_client_for_each_server	vmlinux	EXPORT_SYMBOL_GPL	
++0xb7c69a63	unregister_vmap_purge_notifier	vmlinux	EXPORT_SYMBOL_GPL	
++0x9c0fb8e7	account_page_redirty	vmlinux	EXPORT_SYMBOL	
++0x88b4ae92	ring_buffer_normalize_time_stamp	vmlinux	EXPORT_SYMBOL_GPL	
++0x97e7d10a	l3mdev_fib_table_rcu	vmlinux	EXPORT_SYMBOL_GPL	
++0xf2d32336	eth_prepare_mac_addr_change	vmlinux	EXPORT_SYMBOL	
++0xf407ae32	sk_stop_timer	vmlinux	EXPORT_SYMBOL	
++0x3346dfd0	of_platform_bus_probe	vmlinux	EXPORT_SYMBOL	
++0x7f5b4fe4	sg_free_table	vmlinux	EXPORT_SYMBOL	
++0x79f0a48e	locks_remove_posix	vmlinux	EXPORT_SYMBOL	
++0xb0b85f47	ring_buffer_iter_reset	vmlinux	EXPORT_SYMBOL_GPL	
++0xd8fbb14d	net_cls_cgrp_subsys_on_dfl_key	vmlinux	EXPORT_SYMBOL_GPL	
++0x43b0c9c3	preempt_schedule	vmlinux	EXPORT_SYMBOL	
++0x692907aa	__skb_recv_udp	vmlinux	EXPORT_SYMBOL	
++0x1de8fee8	__phy_read_mmd	vmlinux	EXPORT_SYMBOL	
++0x22632754	iscsi_unregister_transport	vmlinux	EXPORT_SYMBOL_GPL	
++0xcd74639d	radix_tree_delete	vmlinux	EXPORT_SYMBOL	
++0xb67fec0e	uuid_parse	vmlinux	EXPORT_SYMBOL	
++0xf08d38e7	sched_trace_rq_cpu	vmlinux	EXPORT_SYMBOL_GPL	
++0x156d94fa	tcp_slow_start	vmlinux	EXPORT_SYMBOL_GPL	
++0x7dd35c40	dev_activate	vmlinux	EXPORT_SYMBOL	
++0x1541429c	__pneigh_lookup	vmlinux	EXPORT_SYMBOL_GPL	
++0x3102613d	device_get_named_child_node	vmlinux	EXPORT_SYMBOL_GPL	
++0x25dcdbd9	fwnode_get_next_child_node	vmlinux	EXPORT_SYMBOL_GPL	
++0xb22ee863	mipi_dsi_dcs_set_tear_scanline	vmlinux	EXPORT_SYMBOL	
++0xe12b3331	devm_iounmap	vmlinux	EXPORT_SYMBOL	
++0xf336b701	devm_ioremap	vmlinux	EXPORT_SYMBOL	
++0x894b5a4a	mempool_init_node	vmlinux	EXPORT_SYMBOL	
++0xd29a358d	dma_set_mask	vmlinux	EXPORT_SYMBOL	
++0x2aac9dc7	skb_zerocopy	vmlinux	EXPORT_SYMBOL_GPL	
++0xc469009c	sdhci_request_atomic	vmlinux	EXPORT_SYMBOL_GPL	
++0xd9703704	cpu_topology	vmlinux	EXPORT_SYMBOL_GPL	
++0xa8dc83c2	bcm_sg_suitable_for_dma	vmlinux	EXPORT_SYMBOL_GPL	
++0x2e295199	nla_reserve	vmlinux	EXPORT_SYMBOL	
++0xd2582f8f	__SCK__tp_func_mmap_lock_acquire_returned	vmlinux	EXPORT_SYMBOL	
++0x11457027	bpf_offload_dev_match	vmlinux	EXPORT_SYMBOL_GPL	
++0x91cf3c63	tracepoint_srcu	vmlinux	EXPORT_SYMBOL_GPL	
++0x18774c4c	rtnl_put_cacheinfo	vmlinux	EXPORT_SYMBOL_GPL	
++0x8e0316a0	__cpufreq_driver_target	vmlinux	EXPORT_SYMBOL_GPL	
++0xf05fbf09	pci_pio_to_address	vmlinux	EXPORT_SYMBOL_GPL	
++0x16316a10	ZSTD_getFrameContentSize	vmlinux	EXPORT_SYMBOL	
++0xea124bd1	gcd	vmlinux	EXPORT_SYMBOL_GPL	
++0x6b9a4998	crypto_hash_alg_has_setkey	vmlinux	EXPORT_SYMBOL_GPL	
++0x736fc386	ihold	vmlinux	EXPORT_SYMBOL	
++0x3096be16	names_cachep	vmlinux	EXPORT_SYMBOL	
++0xeab49afd	invalidate_inode_pages2_range	vmlinux	EXPORT_SYMBOL_GPL	
++0xa45c7b90	stack_trace_print	vmlinux	EXPORT_SYMBOL_GPL	
++0x2f2b5351	irq_domain_get_irq_data	vmlinux	EXPORT_SYMBOL_GPL	
++0x48c32847	__SCK__tp_func_sched_util_est_se_tp	vmlinux	EXPORT_SYMBOL_GPL	
++0x1e82e306	cancel_delayed_work	vmlinux	EXPORT_SYMBOL	
++0xc8e96dea	qword_addhex	vmlinux	EXPORT_SYMBOL_GPL	
++0xb39687fc	xfrm_policy_register_afinfo	vmlinux	EXPORT_SYMBOL	
++0x45a39227	dev_pm_opp_of_find_icc_paths	vmlinux	EXPORT_SYMBOL_GPL	
++0x4dae16e4	i2c_put_dma_safe_msg_buf	vmlinux	EXPORT_SYMBOL_GPL	
++0xdfb515c0	pci_unmap_rom	vmlinux	EXPORT_SYMBOL	
++0x4337a752	sbitmap_queue_show	vmlinux	EXPORT_SYMBOL_GPL	
++0xf9e4a189	iov_iter_alignment	vmlinux	EXPORT_SYMBOL	
++0xdfa4547e	crypto_unregister_shashes	vmlinux	EXPORT_SYMBOL_GPL	
++0xc2fb63ec	crypto_unregister_ahashes	vmlinux	EXPORT_SYMBOL_GPL	
++0x8d9d58c7	key_instantiate_and_link	vmlinux	EXPORT_SYMBOL	
++0x3f2690f2	nfs_check_flags	vmlinux	EXPORT_SYMBOL_GPL	
++0x5a6bf0cf	dentry_path_raw	vmlinux	EXPORT_SYMBOL	
++0x7afcb7db	__kprobe_event_add_fields	vmlinux	EXPORT_SYMBOL_GPL	
++0xd6216f71	xfrm_sad_getinfo	vmlinux	EXPORT_SYMBOL	
++0xd1f2eee2	nf_logger_find_get	vmlinux	EXPORT_SYMBOL_GPL	
++0xe233762a	input_event_from_user	vmlinux	EXPORT_SYMBOL_GPL	
++0x4484a5a4	wait_for_device_probe	vmlinux	EXPORT_SYMBOL_GPL	
++0x67455ba3	tty_port_put	vmlinux	EXPORT_SYMBOL	
++0xec57bc87	clk_register_fixed_factor	vmlinux	EXPORT_SYMBOL_GPL	
++0xee58e970	fb_add_videomode	vmlinux	EXPORT_SYMBOL	
++0x2c0b48ed	crypto_register_alg	vmlinux	EXPORT_SYMBOL_GPL	
++0x2d98cda1	debugfs_rename	vmlinux	EXPORT_SYMBOL_GPL	
++0xb06f4729	simple_open	vmlinux	EXPORT_SYMBOL	
++0x19590c48	single_open	vmlinux	EXPORT_SYMBOL	
++0x8055bcfa	__page_file_mapping	vmlinux	EXPORT_SYMBOL_GPL	
++0xb58f4a8e	trace_hardirqs_on_prepare	vmlinux	EXPORT_SYMBOL	
++0x08f868f2	of_graph_get_port_parent	vmlinux	EXPORT_SYMBOL	
++0xbc091ed1	of_get_next_parent	vmlinux	EXPORT_SYMBOL	
++0x7757b51a	clk_unregister	vmlinux	EXPORT_SYMBOL_GPL	
++0x49b2e26a	__fscache_wait_on_invalidate	vmlinux	EXPORT_SYMBOL	
++0xfbbd41ca	no_action	vmlinux	EXPORT_SYMBOL_GPL	
++0xb84386ed	kthread_stop	vmlinux	EXPORT_SYMBOL	
++0xe1595da4	tcp_sendmsg_locked	vmlinux	EXPORT_SYMBOL_GPL	
++0x69ee2220	linear_range_get_selector_high	vmlinux	EXPORT_SYMBOL_GPL	
++0x78a16f48	aes_decrypt	vmlinux	EXPORT_SYMBOL	
++0x3d629358	security_inode_create	vmlinux	EXPORT_SYMBOL_GPL	
++0x0023094f	lockd_down	vmlinux	EXPORT_SYMBOL_GPL	
++0xb380e985	generic_file_buffered_read	vmlinux	EXPORT_SYMBOL_GPL	
++0xebc8520a	_mutex_lock	vmlinux	EXPORT_SYMBOL	
++0x912630a5	xprt_reserve_xprt	vmlinux	EXPORT_SYMBOL_GPL	
++0x5858099b	hid_register_report	vmlinux	EXPORT_SYMBOL_GPL	
++0x5354e678	rtc_set_alarm	vmlinux	EXPORT_SYMBOL_GPL	
++0xbffb243e	__bcm_phy_read_rdb	vmlinux	EXPORT_SYMBOL_GPL	
++0x536c8fa1	screen_glyph_unicode	vmlinux	EXPORT_SYMBOL_GPL	
++0x50cf7585	hex2bin	vmlinux	EXPORT_SYMBOL	
++0xf13bf74a	crypto_default_rng	vmlinux	EXPORT_SYMBOL_GPL	
++0x4c675104	__traceiter_nfs4_pnfs_commit_ds	vmlinux	EXPORT_SYMBOL_GPL	
++0x0f21edb0	locks_copy_conflock	vmlinux	EXPORT_SYMBOL	
++0xf4aa542a	d_make_root	vmlinux	EXPORT_SYMBOL	
++0x2516ad83	vfs_get_super	vmlinux	EXPORT_SYMBOL	
++0xc5e5573a	frame_vector_to_pages	vmlinux	EXPORT_SYMBOL	
++0xf229424a	preempt_count_add	vmlinux	EXPORT_SYMBOL	
++0x5fbf8439	xprt_add_backlog	vmlinux	EXPORT_SYMBOL_GPL	
++0xaaeaac5c	inet_csk_listen_start	vmlinux	EXPORT_SYMBOL_GPL	
++0x162a4ad6	dmaengine_desc_set_metadata_len	vmlinux	EXPORT_SYMBOL_GPL	
++0x2875a315	utf32_to_utf8	vmlinux	EXPORT_SYMBOL	
++0xccdb1fe5	blk_trace_remove	vmlinux	EXPORT_SYMBOL_GPL	
++0x4665f77d	cleanup_srcu_struct	vmlinux	EXPORT_SYMBOL_GPL	
++0x643d9ba1	groups_free	vmlinux	EXPORT_SYMBOL	
++0xac1a55be	unregister_reboot_notifier	vmlinux	EXPORT_SYMBOL	
++0xcee88e7a	of_overlay_fdt_apply	vmlinux	EXPORT_SYMBOL_GPL	
++0x7105ce66	__efivar_entry_get	vmlinux	EXPORT_SYMBOL_GPL	
++0x0f6fa0e1	regmap_register_patch	vmlinux	EXPORT_SYMBOL_GPL	
++0x90f9068d	device_add_groups	vmlinux	EXPORT_SYMBOL_GPL	
++0xbc1c59dc	tty_perform_flush	vmlinux	EXPORT_SYMBOL_GPL	
++0x85354236	gpiod_set_transitory	vmlinux	EXPORT_SYMBOL_GPL	
++0x7410aba2	strreplace	vmlinux	EXPORT_SYMBOL	
++0xd4bb4a82	inet6addr_validator_notifier_call_chain	vmlinux	EXPORT_SYMBOL	
++0xa31ce84a	ip_sock_set_recverr	vmlinux	EXPORT_SYMBOL	
++0xe0b51353	DWC_WORKQ_FREE	vmlinux	EXPORT_SYMBOL	
++0x33ac234c	__fscache_readpages_cancel	vmlinux	EXPORT_SYMBOL	
++0x387393de	neigh_parms_alloc	vmlinux	EXPORT_SYMBOL	
++0xf2cea379	cpuidle_unregister_device	vmlinux	EXPORT_SYMBOL_GPL	
++0x19a304ba	usb_disabled	vmlinux	EXPORT_SYMBOL_GPL	
++0xacd764a3	nvme_set_features	vmlinux	EXPORT_SYMBOL_GPL	
++0x61a0726a	clk_hw_is_prepared	vmlinux	EXPORT_SYMBOL_GPL	
++0x4d0cc44c	nfs_rmdir	vmlinux	EXPORT_SYMBOL_GPL	
++0xcccc3281	mount_single	vmlinux	EXPORT_SYMBOL	
++0x4061ee7f	of_css	vmlinux	EXPORT_SYMBOL_GPL	
++0x8aa7bbd3	netif_receive_skb_core	vmlinux	EXPORT_SYMBOL	
++0x5e490201	phy_restart_aneg	vmlinux	EXPORT_SYMBOL_GPL	
++0xb9c425de	register_syscore_ops	vmlinux	EXPORT_SYMBOL_GPL	
++0x3a9be019	asymmetric_key_id_partial	vmlinux	EXPORT_SYMBOL_GPL	
++0x73e623f4	bpf_prog_inc	vmlinux	EXPORT_SYMBOL_GPL	
++0x93a6e0b2	io_schedule	vmlinux	EXPORT_SYMBOL	
++0xfe01b0da	cfb_fillrect	vmlinux	EXPORT_SYMBOL	
++0xf4dc35da	pci_remap_iospace	vmlinux	EXPORT_SYMBOL	
++0xdd8794da	disk_part_iter_next	vmlinux	EXPORT_SYMBOL_GPL	
++0xee408bca	block_write_end	vmlinux	EXPORT_SYMBOL	
++0x890f4f97	__kprobe_event_gen_cmd_start	vmlinux	EXPORT_SYMBOL_GPL	
++0xbb61429b	pid_vnr	vmlinux	EXPORT_SYMBOL_GPL	
++0xffe36911	__xfrm_decode_session	vmlinux	EXPORT_SYMBOL	
++0x9748ab3e	sdhci_runtime_resume_host	vmlinux	EXPORT_SYMBOL_GPL	
++0x1744ef62	devm_regmap_del_irq_chip	vmlinux	EXPORT_SYMBOL_GPL	
++0x97bddcb6	devm_regmap_add_irq_chip	vmlinux	EXPORT_SYMBOL_GPL	
++0xb98b79fb	tty_port_lower_dtr_rts	vmlinux	EXPORT_SYMBOL	
++0x6d7c7dcc	bitmap_cut	vmlinux	EXPORT_SYMBOL	
++0xcd24e146	hash_digest_size	vmlinux	EXPORT_SYMBOL_GPL	
++0xef3aade3	nfs_link	vmlinux	EXPORT_SYMBOL_GPL	
++0x51dc25c6	__fput_sync	vmlinux	EXPORT_SYMBOL	
++0xd410df31	netlink_set_err	vmlinux	EXPORT_SYMBOL	
++0x81977177	alloc_netdev_mqs	vmlinux	EXPORT_SYMBOL	
++0x5df1c051	DWC_TIMER_ALLOC	vmlinux	EXPORT_SYMBOL	
++0x01e709d6	regmap_field_bulk_alloc	vmlinux	EXPORT_SYMBOL_GPL	
++0x28c01151	bus_register_notifier	vmlinux	EXPORT_SYMBOL_GPL	
++0x47488791	register_kprobe	vmlinux	EXPORT_SYMBOL_GPL	
++0x59f51494	make_kprojid	vmlinux	EXPORT_SYMBOL	
++0xe3b04b43	wireless_spy_update	vmlinux	EXPORT_SYMBOL	
++0x99ce20ae	inet_listen	vmlinux	EXPORT_SYMBOL	
++0xa5ae70f5	__dst_destroy_metrics_generic	vmlinux	EXPORT_SYMBOL	
++0x4be99355	skb_queue_purge	vmlinux	EXPORT_SYMBOL	
++0x6644cf9e	bcm_phy_ack_intr	vmlinux	EXPORT_SYMBOL_GPL	
++0x5d35bce2	dma_fence_chain_walk	vmlinux	EXPORT_SYMBOL	
++0xbf041102	register_vt_notifier	vmlinux	EXPORT_SYMBOL_GPL	
++0x263c3152	bcmp	vmlinux	EXPORT_SYMBOL	
++0x04139b6f	badblocks_show	vmlinux	EXPORT_SYMBOL_GPL	
++0xfff1d4d4	inode_update_time	vmlinux	EXPORT_SYMBOL	
++0x6fa4894a	get_unmapped_area	vmlinux	EXPORT_SYMBOL	
++0x800ce754	add_to_page_cache_lru	vmlinux	EXPORT_SYMBOL_GPL	
++0xb9e8e2cc	in6addr_sitelocal_allrouters	vmlinux	EXPORT_SYMBOL	
++0x19f009ac	flow_rule_match_ports	vmlinux	EXPORT_SYMBOL	
++0x07b52e38	rtnl_unregister	vmlinux	EXPORT_SYMBOL_GPL	
++0xd1691c15	genphy_config_eee_advert	vmlinux	EXPORT_SYMBOL	
++0xbc129440	platform_bus_type	vmlinux	EXPORT_SYMBOL_GPL	
++0x47de0dc7	clk_unregister_mux	vmlinux	EXPORT_SYMBOL_GPL	
++0x6bcdedc0	mpi_point_init	vmlinux	EXPORT_SYMBOL_GPL	
++0x6a1d89db	blk_rq_map_user	vmlinux	EXPORT_SYMBOL	
++0xdeab37ba	crypto_sha512_update	vmlinux	EXPORT_SYMBOL	
++0xe32a70d6	jbd2_journal_clear_features	vmlinux	EXPORT_SYMBOL	
++0xbe658da6	generic_pipe_buf_release	vmlinux	EXPORT_SYMBOL	
++0xbb201bb8	blocking_notifier_call_chain_robust	vmlinux	EXPORT_SYMBOL_GPL	
++0x91b50082	kthread_queue_delayed_work	vmlinux	EXPORT_SYMBOL_GPL	
++0xe5161346	sdhci_pltfm_pmops	vmlinux	EXPORT_SYMBOL_GPL	
++0x74ed88b5	DWC_WORKQ_SCHEDULE	vmlinux	EXPORT_SYMBOL	
++0x51892d61	nfs_callback_set_tcpport	vmlinux	EXPORT_SYMBOL_GPL	
++0x1a102099	d_find_alias	vmlinux	EXPORT_SYMBOL	
++0x1b5f4377	trace_seq_putc	vmlinux	EXPORT_SYMBOL_GPL	
++0x1741ddee	trace_seq_puts	vmlinux	EXPORT_SYMBOL_GPL	
++0x760a0f4f	yield	vmlinux	EXPORT_SYMBOL	
++0x12537dae	__tracepoint_napi_poll	vmlinux	EXPORT_SYMBOL_GPL	
++0x72edf918	__tracepoint_kfree_skb	vmlinux	EXPORT_SYMBOL_GPL	
++0xc865bc47	netdev_upper_dev_unlink	vmlinux	EXPORT_SYMBOL	
++0x5408e506	extcon_get_edev_by_phandle	vmlinux	EXPORT_SYMBOL_GPL	
++0xc802bdc4	sdio_claim_irq	vmlinux	EXPORT_SYMBOL_GPL	
++0x77bb9e98	devm_power_supply_get_by_phandle	vmlinux	EXPORT_SYMBOL_GPL	
++0xfe7c2a58	regmap_get_raw_read_max	vmlinux	EXPORT_SYMBOL_GPL	
++0xc07b0863	fb_destroy_modedb	vmlinux	EXPORT_SYMBOL	
++0xccd4c999	__sg_page_iter_start	vmlinux	EXPORT_SYMBOL	
++0x0d38db58	fsstack_copy_attr_all	vmlinux	EXPORT_SYMBOL_GPL	
++0x51a94389	xfrm_init_replay	vmlinux	EXPORT_SYMBOL	
++0xa4eae1ba	udp4_lib_lookup	vmlinux	EXPORT_SYMBOL_GPL	
++0x78b877f4	sock_zerocopy_put	vmlinux	EXPORT_SYMBOL_GPL	
++0xb6db11b5	sdio_signal_irq	vmlinux	EXPORT_SYMBOL_GPL	
++0x9194552b	dev_pm_opp_get_opp_table	vmlinux	EXPORT_SYMBOL_GPL	
++0xdd8226fa	scsi_command_normalize_sense	vmlinux	EXPORT_SYMBOL	
++0xbeefd247	devm_kmalloc	vmlinux	EXPORT_SYMBOL_GPL	
++0x4d0d163d	copy_page	vmlinux	EXPORT_SYMBOL	
++0x1046f7c7	lockref_put_not_zero	vmlinux	EXPORT_SYMBOL	
++0xd1b8f0c1	lockref_get_not_zero	vmlinux	EXPORT_SYMBOL	
++0x89fb6a26	inode_sb_list_add	vmlinux	EXPORT_SYMBOL_GPL	
++0x161a695b	inode_init_always	vmlinux	EXPORT_SYMBOL	
++0x326c431a	d_invalidate	vmlinux	EXPORT_SYMBOL	
++0xa0b04675	vmalloc_32	vmlinux	EXPORT_SYMBOL	
++0x6c506248	pid_task	vmlinux	EXPORT_SYMBOL	
++0xb334170d	tcp_time_wait	vmlinux	EXPORT_SYMBOL	
++0x438a08fc	of_get_i2c_adapter_by_node	vmlinux	EXPORT_SYMBOL	
++0xecbb4087	input_register_handler	vmlinux	EXPORT_SYMBOL	
++0x2c7f57ac	phy_check_downshift	vmlinux	EXPORT_SYMBOL_GPL	
++0x8617a452	textsearch_unregister	vmlinux	EXPORT_SYMBOL	
++0xe11ca997	ZSTD_getDictID_fromDict	vmlinux	EXPORT_SYMBOL	
++0xd0fe8d51	sg_pcopy_from_buffer	vmlinux	EXPORT_SYMBOL	
++0x2a39fea2	pnfs_generic_pg_check_range	vmlinux	EXPORT_SYMBOL_GPL	
++0x2f7754a8	dma_pool_free	vmlinux	EXPORT_SYMBOL	
++0x5e0fbbff	__SCK__tp_func_xdp_exception	vmlinux	EXPORT_SYMBOL_GPL	
++0x846f55ae	netif_carrier_on	vmlinux	EXPORT_SYMBOL	
++0x47c42b28	fib_rules_lookup	vmlinux	EXPORT_SYMBOL_GPL	
++0x80d7c68a	DWC_MUTEX_LOCK	vmlinux	EXPORT_SYMBOL	
++0xce8ebaec	spi_res_alloc	vmlinux	EXPORT_SYMBOL_GPL	
++0x08d03ddf	nvme_kill_queues	vmlinux	EXPORT_SYMBOL_GPL	
++0xae7c231d	mpi_cmp	vmlinux	EXPORT_SYMBOL_GPL	
++0x167c5967	print_hex_dump	vmlinux	EXPORT_SYMBOL	
++0x88f6a304	__DWC_FREE	vmlinux	EXPORT_SYMBOL	
++0x27756bc8	scsi_sanitize_inquiry_string	vmlinux	EXPORT_SYMBOL	
++0x0e5cba55	dev_pm_qos_add_notifier	vmlinux	EXPORT_SYMBOL_GPL	
++0xffc518fb	tty_find_polling_driver	vmlinux	EXPORT_SYMBOL_GPL	
++0x4047c82d	sbitmap_resize	vmlinux	EXPORT_SYMBOL_GPL	
++0x4b6efbe5	public_key_free	vmlinux	EXPORT_SYMBOL_GPL	
++0x12aa99db	inode_newsize_ok	vmlinux	EXPORT_SYMBOL	
++0xd55ce7a3	inet_csk_destroy_sock	vmlinux	EXPORT_SYMBOL	
++0xc0c29e78	inet_peer_base_init	vmlinux	EXPORT_SYMBOL_GPL	
++0xc817607a	devm_extcon_dev_register	vmlinux	EXPORT_SYMBOL_GPL	
++0xd2c71eb2	devm_extcon_dev_allocate	vmlinux	EXPORT_SYMBOL_GPL	
++0x018a9977	iscsi_post_host_event	vmlinux	EXPORT_SYMBOL_GPL	
++0xf44c3442	__pm_runtime_idle	vmlinux	EXPORT_SYMBOL_GPL	
++0x2e1ca751	clk_put	vmlinux	EXPORT_SYMBOL	
++0x78df6bd7	no_pci_devices	vmlinux	EXPORT_SYMBOL	
++0x5a921311	strncmp	vmlinux	EXPORT_SYMBOL	
++0xb38a49ce	crypto_register_shashes	vmlinux	EXPORT_SYMBOL_GPL	
++0xc657b858	nfs_pageio_reset_read_mds	vmlinux	EXPORT_SYMBOL_GPL	
++0x0d07f543	get_anon_bdev	vmlinux	EXPORT_SYMBOL	
++0xb4eda0da	ring_buffer_event_length	vmlinux	EXPORT_SYMBOL_GPL	
++0xb294ce9f	sock_kfree_s	vmlinux	EXPORT_SYMBOL	
++0x077531a3	devm_extcon_dev_unregister	vmlinux	EXPORT_SYMBOL_GPL	
++0x7cb8ada0	usb_stor_access_xfer_buf	vmlinux	EXPORT_SYMBOL_GPL	USB_STORAGE
++0x48a3d20b	mctrl_gpio_get	vmlinux	EXPORT_SYMBOL_GPL	
++0x69dd3b5b	crc32_le	vmlinux	EXPORT_SYMBOL	
++0xf54bd49b	lcm	vmlinux	EXPORT_SYMBOL_GPL	
++0x845dbf3b	scatterwalk_map_and_copy	vmlinux	EXPORT_SYMBOL_GPL	
++0x2f34f98d	nfs_add_or_obtain	vmlinux	EXPORT_SYMBOL_GPL	
++0x5e63bad8	iomap_file_unshare	vmlinux	EXPORT_SYMBOL_GPL	
++0xb586e082	empty_aops	vmlinux	EXPORT_SYMBOL	
++0x4ffb59bf	__SCK__tp_func_kfree	vmlinux	EXPORT_SYMBOL	
++0x484f6edf	ktime_get_coarse_real_ts64	vmlinux	EXPORT_SYMBOL	
++0xfac8b72b	irq_domain_pop_irq	vmlinux	EXPORT_SYMBOL_GPL	
++0x0219b05d	rt_read_trylock	vmlinux	EXPORT_SYMBOL	
++0xc7d14cbb	__task_pid_nr_ns	vmlinux	EXPORT_SYMBOL	
++0xf30d819c	ethtool_op_get_link	vmlinux	EXPORT_SYMBOL	
++0xf7455c16	input_event_to_user	vmlinux	EXPORT_SYMBOL_GPL	
++0x55af0423	input_unregister_device	vmlinux	EXPORT_SYMBOL	
++0xcaf2c603	scsi_sd_pm_domain	vmlinux	EXPORT_SYMBOL	
++0x4a26b39e	tty_buffer_space_avail	vmlinux	EXPORT_SYMBOL_GPL	
++0xc992bfb6	regulator_disable_regmap	vmlinux	EXPORT_SYMBOL_GPL	
++0xb8ec80eb	clk_hw_set_parent	vmlinux	EXPORT_SYMBOL_GPL	
++0x4c76665a	clk_hw_get_parent	vmlinux	EXPORT_SYMBOL_GPL	
++0x30d3523f	clk_bulk_get_optional	vmlinux	EXPORT_SYMBOL_GPL	
++0x015fe59c	read_cache_pages	vmlinux	EXPORT_SYMBOL	
++0xfe8cdb84	ring_buffer_alloc_read_page	vmlinux	EXPORT_SYMBOL_GPL	
++0x330010b6	cpuset_cgrp_subsys_enabled_key	vmlinux	EXPORT_SYMBOL_GPL	
++0xa8a8110c	kernel_neon_end	vmlinux	EXPORT_SYMBOL	
++0x53445f68	nlm_debug	vmlinux	EXPORT_SYMBOL_GPL	
++0x37b7ead3	ip_generic_getfrag	vmlinux	EXPORT_SYMBOL	
++0xa7492027	call_netdevice_notifiers	vmlinux	EXPORT_SYMBOL	
++0xdc825d6c	usb_amd_quirk_pll_disable	vmlinux	EXPORT_SYMBOL_GPL	
++0xa689e42f	usb_for_each_dev	vmlinux	EXPORT_SYMBOL_GPL	
++0xcf851d0c	mii_nway_restart	vmlinux	EXPORT_SYMBOL	
++0xadf9699b	pci_write_msi_msg	vmlinux	EXPORT_SYMBOL_GPL	
++0x3f545cad	cpumask_any_and_distribute	vmlinux	EXPORT_SYMBOL	
++0x2718376c	crypto_dequeue_request	vmlinux	EXPORT_SYMBOL_GPL	
++0x771d7046	crypto_enqueue_request	vmlinux	EXPORT_SYMBOL_GPL	
++0x32bb6e05	__tracepoint_ff_layout_write_error	vmlinux	EXPORT_SYMBOL_GPL	
++0xf9494ebe	fat_add_entries	vmlinux	EXPORT_SYMBOL_GPL	
++0x099f629b	thaw_bdev	vmlinux	EXPORT_SYMBOL	
++0x67bd3213	vfs_fallocate	vmlinux	EXPORT_SYMBOL_GPL	
++0xc010c4d9	kmem_cache_alloc_trace	vmlinux	EXPORT_SYMBOL	
++0xa3ece414	freezer_cgrp_subsys_enabled_key	vmlinux	EXPORT_SYMBOL_GPL	
++0x9a4f37ca	netdev_rx_csum_fault	vmlinux	EXPORT_SYMBOL	
++0x2da4ea18	of_pci_address_to_resource	vmlinux	EXPORT_SYMBOL_GPL	
++0xa38948ff	usb_phy_roothub_suspend	vmlinux	EXPORT_SYMBOL_GPL	
++0xbe608f8b	devres_release_group	vmlinux	EXPORT_SYMBOL_GPL	
++0xaaf5995b	serdev_device_add	vmlinux	EXPORT_SYMBOL_GPL	
++0x3244e921	btree_init_mempool	vmlinux	EXPORT_SYMBOL_GPL	
++0xb97220ff	bitmap_parse	vmlinux	EXPORT_SYMBOL	
++0xf42788c1	nfs_lookup	vmlinux	EXPORT_SYMBOL_GPL	
++0x1b455a86	nfs_force_lookup_revalidate	vmlinux	EXPORT_SYMBOL_GPL	
++0x9e61bb05	set_freezable	vmlinux	EXPORT_SYMBOL	
++0xab49565a	xdr_decode_array2	vmlinux	EXPORT_SYMBOL_GPL	
++0xa7f1c457	neigh_sysctl_unregister	vmlinux	EXPORT_SYMBOL	
++0xfd5f1ba9	neigh_proc_dointvec	vmlinux	EXPORT_SYMBOL	
++0xe8487d60	extcon_register_notifier	vmlinux	EXPORT_SYMBOL_GPL	
++0xa9e74462	usb_ep_alloc_request	vmlinux	EXPORT_SYMBOL_GPL	
++0xc1f71866	dwc_cc_change	vmlinux	EXPORT_SYMBOL	
++0xe4e48b12	swphy_validate_state	vmlinux	EXPORT_SYMBOL_GPL	
++0xf0ad68ee	dev_pm_clear_wake_irq	vmlinux	EXPORT_SYMBOL_GPL	
++0xc9561772	fb_destroy_modelist	vmlinux	EXPORT_SYMBOL_GPL	
++0x3dbb9233	blk_abort_request	vmlinux	EXPORT_SYMBOL_GPL	
++0xc26ed76e	blk_set_queue_depth	vmlinux	EXPORT_SYMBOL	
++0x4a81efc3	nfs_fhget	vmlinux	EXPORT_SYMBOL_GPL	
++0x5986d190	kdb_printf	vmlinux	EXPORT_SYMBOL_GPL	
++0x4d4310f6	__scm_destroy	vmlinux	EXPORT_SYMBOL	
++0x5eee770a	sdio_writeb_readb	vmlinux	EXPORT_SYMBOL_GPL	
++0x519415c8	DWC_TASK_ALLOC	vmlinux	EXPORT_SYMBOL	
++0x82483b59	usb_put_phy	vmlinux	EXPORT_SYMBOL_GPL	
++0xe9bdc15d	mdiobus_get_phy	vmlinux	EXPORT_SYMBOL	
++0xeeda822c	tty_port_register_device_serdev	vmlinux	EXPORT_SYMBOL_GPL	
++0xd01fd4b7	amba_ahb_device_add_res	vmlinux	EXPORT_SYMBOL_GPL	
++0x8511998d	phy_pm_runtime_put	vmlinux	EXPORT_SYMBOL_GPL	
++0xde4d4ace	dim_calc_stats	vmlinux	EXPORT_SYMBOL	
++0xeb9e913d	sgl_alloc_order	vmlinux	EXPORT_SYMBOL	
++0xfa726cfe	aead_exit_geniv	vmlinux	EXPORT_SYMBOL_GPL	
++0x0b573291	d_move	vmlinux	EXPORT_SYMBOL	
++0x5091b823	ring_buffer_read_start	vmlinux	EXPORT_SYMBOL_GPL	
++0x4d06f504	rpc_wake_up_first	vmlinux	EXPORT_SYMBOL_GPL	
++0x6b5bbb92	ping_common_sendmsg	vmlinux	EXPORT_SYMBOL_GPL	
++0x7d5d8801	tcf_block_get	vmlinux	EXPORT_SYMBOL	
++0x4268afd6	touch_atime	vmlinux	EXPORT_SYMBOL	
++0x2d1d76f0	evict_inodes	vmlinux	EXPORT_SYMBOL_GPL	
++0x4eaf0d7e	__frontswap_load	vmlinux	EXPORT_SYMBOL	
++0x7b9793a2	get_cpu_idle_time_us	vmlinux	EXPORT_SYMBOL_GPL	
++0xef55908e	kernel_sendmsg_locked	vmlinux	EXPORT_SYMBOL	
++0x4ff382a8	device_dma_supported	vmlinux	EXPORT_SYMBOL_GPL	
++0xcd1f8413	mod_timer_pending	vmlinux	EXPORT_SYMBOL	
++0x21cd16c3	unregister_nexthop_notifier	vmlinux	EXPORT_SYMBOL	
++0xf88a3289	qdisc_tree_reduce_backlog	vmlinux	EXPORT_SYMBOL	
++0xb110cab4	rtnl_configure_link	vmlinux	EXPORT_SYMBOL	
++0x351f9eaa	sock_wmalloc	vmlinux	EXPORT_SYMBOL	
++0x1945f043	of_msi_configure	vmlinux	EXPORT_SYMBOL_GPL	
++0x4de17ab3	usb_state_string	vmlinux	EXPORT_SYMBOL_GPL	
++0x1e6d26a8	strstr	vmlinux	EXPORT_SYMBOL	
++0x349cba85	strchr	vmlinux	EXPORT_SYMBOL	
++0x19e81304	btree_alloc	vmlinux	EXPORT_SYMBOL_GPL	
++0xbd7cf04d	security_kernel_post_read_file	vmlinux	EXPORT_SYMBOL_GPL	
++0x68df39f8	task_user_regset_view	vmlinux	EXPORT_SYMBOL_GPL	
++0x2fd1131c	netif_tx_stop_all_queues	vmlinux	EXPORT_SYMBOL	
++0x0caef520	perf_event_disable	vmlinux	EXPORT_SYMBOL_GPL	
++0xd6d37bc8	rpcauth_stringify_acceptor	vmlinux	EXPORT_SYMBOL_GPL	
++0xfebd643f	inet_csk_listen_stop	vmlinux	EXPORT_SYMBOL_GPL	
++0xfb2d6a6a	i2c_handle_smbus_host_notify	vmlinux	EXPORT_SYMBOL_GPL	
++0x737e48bf	usb_wait_anchor_empty_timeout	vmlinux	EXPORT_SYMBOL_GPL	
++0x4f72a987	uart_parse_options	vmlinux	EXPORT_SYMBOL_GPL	
++0x3a20f22b	kobject_create_and_add	vmlinux	EXPORT_SYMBOL_GPL	
++0x54840024	pci_iomap_range	vmlinux	EXPORT_SYMBOL	
++0xf41f6f5b	put_disk_and_module	vmlinux	EXPORT_SYMBOL	
++0x8b386bb3	setup_new_exec	vmlinux	EXPORT_SYMBOL	
++0xc8359635	__traceiter_pelt_se_tp	vmlinux	EXPORT_SYMBOL_GPL	
++0xfdebbd24	__traceiter_pelt_dl_tp	vmlinux	EXPORT_SYMBOL_GPL	
++0x54fc7f50	__traceiter_pelt_rt_tp	vmlinux	EXPORT_SYMBOL_GPL	
++0xdb8a1b3f	usermodehelper_read_trylock	vmlinux	EXPORT_SYMBOL_GPL	
++0x82a873bd	xfrm_state_lookup_byaddr	vmlinux	EXPORT_SYMBOL	
++0x34dc0275	pskb_expand_head	vmlinux	EXPORT_SYMBOL	
++0xa3038775	__sdhci_set_timeout	vmlinux	EXPORT_SYMBOL_GPL	
++0xbbcc5dc1	blkg_conf_prep	vmlinux	EXPORT_SYMBOL_GPL	
++0x618f6690	keyring_alloc	vmlinux	EXPORT_SYMBOL	
++0xaba81805	xps_rxqs_needed	vmlinux	EXPORT_SYMBOL	
++0xaf08a044	DWC_WAITQ_TRIGGER	vmlinux	EXPORT_SYMBOL	
++0x25379e73	clk_set_min_rate	vmlinux	EXPORT_SYMBOL_GPL	
++0xa9470129	skcipher_walk_virt	vmlinux	EXPORT_SYMBOL_GPL	
++0x604722fd	devices_cgrp_subsys_enabled_key	vmlinux	EXPORT_SYMBOL_GPL	
++0x7bb045a7	__request_percpu_irq	vmlinux	EXPORT_SYMBOL_GPL	
++0x6233bcc5	rtnl_link_register	vmlinux	EXPORT_SYMBOL_GPL	
++0x672fe29a	make_flow_keys_digest	vmlinux	EXPORT_SYMBOL	
++0x9bb12bdf	sk_set_memalloc	vmlinux	EXPORT_SYMBOL_GPL	
++0x18092d99	gov_update_cpu_data	vmlinux	EXPORT_SYMBOL_GPL	
++0x059145c9	thermal_zone_device_enable	vmlinux	EXPORT_SYMBOL_GPL	
++0x5c10f142	usb_gadget_activate	vmlinux	EXPORT_SYMBOL_GPL	
++0x32d26088	dma_buf_export	vmlinux	EXPORT_SYMBOL_GPL	
++0x707d28db	serdev_device_close	vmlinux	EXPORT_SYMBOL_GPL	
++0x8506baa8	clk_unregister_gate	vmlinux	EXPORT_SYMBOL_GPL	
++0x42124e5d	platform_irqchip_probe	vmlinux	EXPORT_SYMBOL_GPL	
++0x6f20235c	bh_submit_read	vmlinux	EXPORT_SYMBOL	
++0xd3acfac0	vfs_dedupe_file_range_one	vmlinux	EXPORT_SYMBOL	
++0xb9641696	rpc_localaddr	vmlinux	EXPORT_SYMBOL_GPL	
++0xcfb65a0c	ip_mc_check_igmp	vmlinux	EXPORT_SYMBOL	
++0xf6f2aa57	eth_header_parse	vmlinux	EXPORT_SYMBOL	
++0x71b6cf94	dst_cache_reset_now	vmlinux	EXPORT_SYMBOL_GPL	
++0x0eaa3d56	of_dma_router_register	vmlinux	EXPORT_SYMBOL_GPL	
++0x9aa72940	__clk_hw_register_gate	vmlinux	EXPORT_SYMBOL_GPL	
++0x06bd88b5	ucs2_strnlen	vmlinux	EXPORT_SYMBOL	
++0x89013ee0	discard_new_inode	vmlinux	EXPORT_SYMBOL	
++0xb172c706	kmsg_dump_get_buffer	vmlinux	EXPORT_SYMBOL_GPL	
++0xd76ed60d	sock_wake_async	vmlinux	EXPORT_SYMBOL	
++0x5b18ad17	usb_gadget_set_selfpowered	vmlinux	EXPORT_SYMBOL_GPL	
++0x020ca29e	bcm_phy_read_exp	vmlinux	EXPORT_SYMBOL_GPL	
++0x6077ae12	blk_set_runtime_active	vmlinux	EXPORT_SYMBOL	
++0x7929269e	bpf_offload_dev_netdev_register	vmlinux	EXPORT_SYMBOL_GPL	
++0xbfed2cd9	__wait_rcu_gp	vmlinux	EXPORT_SYMBOL_GPL	
++0x438e20e9	of_platform_device_create	vmlinux	EXPORT_SYMBOL	
++0xa8d99f3b	usb_gadget_connect	vmlinux	EXPORT_SYMBOL_GPL	
++0x3468938d	nvme_cancel_request	vmlinux	EXPORT_SYMBOL_GPL	
++0x2b4b8d02	xa_clear_mark	vmlinux	EXPORT_SYMBOL	
++0x73e3e435	rhashtable_walk_enter	vmlinux	EXPORT_SYMBOL_GPL	
++0xf93ba6ce	crypto_register_aead	vmlinux	EXPORT_SYMBOL_GPL	
++0xd08f83f6	crypto_register_algs	vmlinux	EXPORT_SYMBOL_GPL	
++0xc5c08ebf	fat_free_clusters	vmlinux	EXPORT_SYMBOL_GPL	
++0x3644214b	jbd2_complete_transaction	vmlinux	EXPORT_SYMBOL	
++0xe3a8c48b	__set_page_dirty_buffers	vmlinux	EXPORT_SYMBOL	
++0xfb379b4f	unlock_two_nondirectories	vmlinux	EXPORT_SYMBOL	
++0x73380f31	__wake_up_locked	vmlinux	EXPORT_SYMBOL_GPL	
++0x5bc6e360	tc_cleanup_flow_action	vmlinux	EXPORT_SYMBOL	
++0x180964b0	dev_pre_changeaddr_notify	vmlinux	EXPORT_SYMBOL	
++0x7f477a08	dev_queue_xmit_nit	vmlinux	EXPORT_SYMBOL_GPL	
++0x0812bb68	sock_prot_inuse_add	vmlinux	EXPORT_SYMBOL_GPL	
++0xdd5c83c6	dev_pm_opp_get_max_transition_latency	vmlinux	EXPORT_SYMBOL_GPL	
++0x78188e10	usb_gadget_clear_selfpowered	vmlinux	EXPORT_SYMBOL_GPL	
++0x5891686e	usb_hcd_platform_shutdown	vmlinux	EXPORT_SYMBOL_GPL	
++0x7f7d93f7	serdev_device_write_buf	vmlinux	EXPORT_SYMBOL_GPL	
++0x96848186	scnprintf	vmlinux	EXPORT_SYMBOL	
++0x2fdf62a4	put_nfs_open_context	vmlinux	EXPORT_SYMBOL_GPL	
++0xa6a088b7	fscrypt_match_name	vmlinux	EXPORT_SYMBOL_GPL	
++0x3cb343aa	mod_zone_page_state	vmlinux	EXPORT_SYMBOL	
++0xa6e42086	perf_event_refresh	vmlinux	EXPORT_SYMBOL_GPL	
++0x8ef3af0b	tcf_register_action	vmlinux	EXPORT_SYMBOL	
++0x71ceb36f	mini_qdisc_pair_swap	vmlinux	EXPORT_SYMBOL	
++0x9eb23d1a	netdev_reset_tc	vmlinux	EXPORT_SYMBOL	
++0xaecb22f7	of_property_read_string_helper	vmlinux	EXPORT_SYMBOL_GPL	
++0x79bbf373	usb_anchor_resume_wakeups	vmlinux	EXPORT_SYMBOL_GPL	
++0xcf859dae	dev_pm_set_wake_irq	vmlinux	EXPORT_SYMBOL_GPL	
++0x3b46fce4	pm_runtime_autosuspend_expiration	vmlinux	EXPORT_SYMBOL_GPL	
++0xd7f2009d	rtnl_link_unregister	vmlinux	EXPORT_SYMBOL_GPL	
++0x8b99dd92	d_alloc_anon	vmlinux	EXPORT_SYMBOL	
++0xf9b32b67	generic_copy_file_range	vmlinux	EXPORT_SYMBOL	
++0x4766f83f	__wait_on_bit	vmlinux	EXPORT_SYMBOL	
++0x0cba3507	vlan_filter_push_vids	vmlinux	EXPORT_SYMBOL	
++0x9122096a	extcon_set_state	vmlinux	EXPORT_SYMBOL_GPL	
++0x42c2f916	extcon_get_state	vmlinux	EXPORT_SYMBOL_GPL	
++0x7cd5182c	led_trigger_register_simple	vmlinux	EXPORT_SYMBOL_GPL	
++0x690f585e	phy_basic_ports_array	vmlinux	EXPORT_SYMBOL_GPL	
++0x92062beb	iscsi_recv_pdu	vmlinux	EXPORT_SYMBOL_GPL	
++0x78515c7d	__platform_register_drivers	vmlinux	EXPORT_SYMBOL_GPL	
++0x1fdf09e5	rdev_get_id	vmlinux	EXPORT_SYMBOL_GPL	
++0x4056e7c0	rhashtable_free_and_destroy	vmlinux	EXPORT_SYMBOL_GPL	
++0xcdd36592	device_add_disk_no_queue_reg	vmlinux	EXPORT_SYMBOL	
++0x2e39d307	thread_group_exited	vmlinux	EXPORT_SYMBOL	
++0x5cdc308e	tcp_enter_memory_pressure	vmlinux	EXPORT_SYMBOL_GPL	
++0x38364282	dst_init	vmlinux	EXPORT_SYMBOL	
++0x34fd04d2	skb_add_rx_frag	vmlinux	EXPORT_SYMBOL	
++0xab5a4487	usb_hcd_amd_remote_wakeup_quirk	vmlinux	EXPORT_SYMBOL_GPL	
++0x811dc334	usb_unregister_notify	vmlinux	EXPORT_SYMBOL_GPL	
++0x82aab424	bcm_phy_modify_exp	vmlinux	EXPORT_SYMBOL_GPL	
++0x28e0c634	genphy_c45_an_disable_aneg	vmlinux	EXPORT_SYMBOL_GPL	
++0x2211a4c0	blk_op_str	vmlinux	EXPORT_SYMBOL_GPL	
++0x29d488ec	cookie_tcp_reqsk_alloc	vmlinux	EXPORT_SYMBOL_GPL	
++0x8731424a	arp_create	vmlinux	EXPORT_SYMBOL	
++0x99d82612	of_modalias_node	vmlinux	EXPORT_SYMBOL_GPL	
++0xaaf15ef5	lirc_scancode_event	vmlinux	EXPORT_SYMBOL_GPL	
++0xdf11a209	genphy_c45_an_config_aneg	vmlinux	EXPORT_SYMBOL_GPL	
++0x4d8ae0c0	tty_port_alloc_xmit_buf	vmlinux	EXPORT_SYMBOL	
++0xccef37e4	ZSTD_DStreamOutSize	vmlinux	EXPORT_SYMBOL	
++0x88822d38	unregister_blocking_lsm_notifier	vmlinux	EXPORT_SYMBOL	
++0x0ff289f3	__SCK__tp_func_pnfs_mds_fallback_pg_init_write	vmlinux	EXPORT_SYMBOL_GPL	
++0x4ddbeb44	jbd2_journal_get_create_access	vmlinux	EXPORT_SYMBOL	
++0xd41972a0	no_llseek	vmlinux	EXPORT_SYMBOL	
++0x87fa98bd	__traceiter_spi_transfer_start	vmlinux	EXPORT_SYMBOL	
++0x53644558	of_find_mipi_dsi_device_by_node	vmlinux	EXPORT_SYMBOL	
++0x50a4698c	fb_videomode_to_modelist	vmlinux	EXPORT_SYMBOL	
++0x5fbd01d9	pci_generic_config_write	vmlinux	EXPORT_SYMBOL_GPL	
++0xb14fc46a	find_next_clump8	vmlinux	EXPORT_SYMBOL	
++0xc90933d5	iov_iter_for_each_range	vmlinux	EXPORT_SYMBOL	
++0xf9be270f	mb_cache_entry_wait_unused	vmlinux	EXPORT_SYMBOL	
++0x2db593f3	vfs_truncate	vmlinux	EXPORT_SYMBOL_GPL	
++0x3dec417a	__cgroup_bpf_run_filter_sock_ops	vmlinux	EXPORT_SYMBOL	
++0xde2552bc	__hrtimer_get_remaining	vmlinux	EXPORT_SYMBOL_GPL	
++0xe42e5f28	efivar_entry_add	vmlinux	EXPORT_SYMBOL_GPL	
++0x9c803020	usb_phy_roothub_power_on	vmlinux	EXPORT_SYMBOL_GPL	
++0x04c7de91	mdio_device_free	vmlinux	EXPORT_SYMBOL	
++0x1680e5ec	device_match_name	vmlinux	EXPORT_SYMBOL_GPL	
++0x2d192c70	sg_zero_buffer	vmlinux	EXPORT_SYMBOL	
++0x375c827e	register_sysctl_paths	vmlinux	EXPORT_SYMBOL	
++0xd099e8d2	iomap_migrate_page	vmlinux	EXPORT_SYMBOL_GPL	
++0x3d3fb86f	pagecache_write_begin	vmlinux	EXPORT_SYMBOL	
++0xe01f4cb0	irq_force_affinity	vmlinux	EXPORT_SYMBOL_GPL	
++0x0d459213	work_on_cpu_safe	vmlinux	EXPORT_SYMBOL_GPL	
++0xd5e1bf2d	rpc_clnt_xprt_switch_add_xprt	vmlinux	EXPORT_SYMBOL_GPL	
++0x92d928a5	flow_indr_dev_setup_offload	vmlinux	EXPORT_SYMBOL	
++0x3fc0a9db	spi_finalize_current_message	vmlinux	EXPORT_SYMBOL_GPL	
++0x6bb8cc9f	scmd_printk	vmlinux	EXPORT_SYMBOL	
++0x08e87122	dev_pm_qos_add_request	vmlinux	EXPORT_SYMBOL_GPL	
++0x21e9a597	bio_associate_blkg_from_css	vmlinux	EXPORT_SYMBOL_GPL	
++0xc6cbbc89	capable	vmlinux	EXPORT_SYMBOL	
++0x0e75562a	gro_cells_init	vmlinux	EXPORT_SYMBOL	
++0x4891033c	of_irq_get	vmlinux	EXPORT_SYMBOL_GPL	
++0x3f9b235c	hid_debug_event	vmlinux	EXPORT_SYMBOL_GPL	
++0x346d9ed4	mmc_can_trim	vmlinux	EXPORT_SYMBOL	
++0x62612bf8	input_set_capability	vmlinux	EXPORT_SYMBOL	
++0x2ec2e962	phy_queue_state_machine	vmlinux	EXPORT_SYMBOL	
++0x7d219da0	xa_find_after	vmlinux	EXPORT_SYMBOL	
++0xe7b690d8	crypto_register_templates	vmlinux	EXPORT_SYMBOL_GPL	
++0x0e6b79af	static_key_disable_cpuslocked	vmlinux	EXPORT_SYMBOL_GPL	
++0x4ef5bcf4	perf_swevent_get_recursion_context	vmlinux	EXPORT_SYMBOL_GPL	
++0x6db5ecb8	irq_find_mapping	vmlinux	EXPORT_SYMBOL_GPL	
++0xad73041f	autoremove_wake_function	vmlinux	EXPORT_SYMBOL	
++0xa153f5e6	__wake_up_sync	vmlinux	EXPORT_SYMBOL_GPL	
++0xd6d1c844	sched_trace_cfs_rq_cpu	vmlinux	EXPORT_SYMBOL_GPL	
++0xa01b39c9	vlan_vid_del	vmlinux	EXPORT_SYMBOL	
++0xfc76e6f4	skb_mpls_push	vmlinux	EXPORT_SYMBOL_GPL	
++0x70651e5e	give_up_console	vmlinux	EXPORT_SYMBOL	
++0x8724d38b	gpiod_put_array	vmlinux	EXPORT_SYMBOL_GPL	
++0x52dcb85b	__traceiter_kmalloc	vmlinux	EXPORT_SYMBOL	
++0xe7ffe877	pcpu_base_addr	vmlinux	EXPORT_SYMBOL_GPL	
++0xfb898b40	regulator_get_current_limit_regmap	vmlinux	EXPORT_SYMBOL_GPL	
++0xc74635e8	skcipher_walk_done	vmlinux	EXPORT_SYMBOL_GPL	
++0x9a11a0fc	crypto_attr_alg_name	vmlinux	EXPORT_SYMBOL_GPL	
++0x196dde10	debugfs_create_regset32	vmlinux	EXPORT_SYMBOL_GPL	
++0x2768b322	__test_set_page_writeback	vmlinux	EXPORT_SYMBOL	
++0xcb40baeb	irq_chip_set_wake_parent	vmlinux	EXPORT_SYMBOL_GPL	
++0x72395dc1	xfrm_calg_get_byid	vmlinux	EXPORT_SYMBOL_GPL	
++0x016b1d44	mmc_is_req_done	vmlinux	EXPORT_SYMBOL	
++0xe3841e6b	ir_raw_handler_register	vmlinux	EXPORT_SYMBOL	
++0x43395237	uhci_check_and_reset_hc	vmlinux	EXPORT_SYMBOL_GPL	
++0x282a5383	usb_hc_died	vmlinux	EXPORT_SYMBOL_GPL	
++0x527bfa4c	bcm_dmaman_probe	vmlinux	EXPORT_SYMBOL	
++0x2d4bdd5c	pci_free_irq	vmlinux	EXPORT_SYMBOL	
++0x1b1f50ae	pinctrl_dev_get_name	vmlinux	EXPORT_SYMBOL_GPL	
++0xc1514a3b	free_irq	vmlinux	EXPORT_SYMBOL	
++0x6b4b2933	__ioremap	vmlinux	EXPORT_SYMBOL	
++0xbd3aacc2	devm_of_led_get	vmlinux	EXPORT_SYMBOL_GPL	
++0xe397caf5	seq_buf_printf	vmlinux	EXPORT_SYMBOL_GPL	
++0x0da7b4a0	jbd2_journal_init_inode	vmlinux	EXPORT_SYMBOL	
++0x464a1608	take_dentry_name_snapshot	vmlinux	EXPORT_SYMBOL	
++0xc7f5d2d5	deactivate_locked_super	vmlinux	EXPORT_SYMBOL	
++0x4a1433a7	ftrace_set_filter	vmlinux	EXPORT_SYMBOL_GPL	
++0x6b9d17f6	sunrpc_cache_unhash	vmlinux	EXPORT_SYMBOL_GPL	
++0xc43f3b54	rpcauth_register	vmlinux	EXPORT_SYMBOL_GPL	
++0x69780ac2	xfrm_audit_policy_delete	vmlinux	EXPORT_SYMBOL_GPL	
++0x544f946a	inet_twsk_hashdance	vmlinux	EXPORT_SYMBOL_GPL	
++0x3d4314d9	sock_zerocopy_realloc	vmlinux	EXPORT_SYMBOL_GPL	
++0xfe39dea2	arizona_request_irq	vmlinux	EXPORT_SYMBOL_GPL	
++0xf9060035	clkdev_create	vmlinux	EXPORT_SYMBOL_GPL	
++0x95bc9078	btree_free	vmlinux	EXPORT_SYMBOL_GPL	
++0xf2a28957	devm_bitmap_zalloc	vmlinux	EXPORT_SYMBOL_GPL	
++0x696dbaa4	vprintk_emit	vmlinux	EXPORT_SYMBOL	
++0x09d44df9	in_lock_functions	vmlinux	EXPORT_SYMBOL	
++0xaeb2c0f4	rpc_wake_up	vmlinux	EXPORT_SYMBOL_GPL	
++0xaf0f80bd	netpoll_parse_options	vmlinux	EXPORT_SYMBOL	
++0xbfec042b	netdev_rx_handler_unregister	vmlinux	EXPORT_SYMBOL_GPL	
++0x54e62132	kernel_getpeername	vmlinux	EXPORT_SYMBOL	
++0xf15282b1	mdiobus_modify	vmlinux	EXPORT_SYMBOL_GPL	
++0x3821e324	serial8250_do_set_termios	vmlinux	EXPORT_SYMBOL	
++0x1634f9a9	__devm_of_phy_provider_register	vmlinux	EXPORT_SYMBOL_GPL	
++0xb292f715	sysfs_chmod_file	vmlinux	EXPORT_SYMBOL_GPL	
++0xd2c99738	__kmalloc_track_caller	vmlinux	EXPORT_SYMBOL	
++0xce66cb81	find_module	vmlinux	EXPORT_SYMBOL_GPL	
++0xc0229ef3	rt_mutex_lock	vmlinux	EXPORT_SYMBOL_GPL	
++0xad25602f	__tracepoint_sched_overutilized_tp	vmlinux	EXPORT_SYMBOL_GPL	
++0x6ed7b360	l3mdev_link_scope_lookup	vmlinux	EXPORT_SYMBOL_GPL	
++0x6284f7c0	skb_complete_wifi_ack	vmlinux	EXPORT_SYMBOL_GPL	
++0x39f59a3a	input_event	vmlinux	EXPORT_SYMBOL	
++0xd1452887	dev_get_regmap	vmlinux	EXPORT_SYMBOL_GPL	
++0xab599807	pm_runtime_suspended_time	vmlinux	EXPORT_SYMBOL_GPL	
++0x7c04b1fe	mipi_dsi_device_unregister	vmlinux	EXPORT_SYMBOL	
++0x98f3c522	of_clk_hw_onecell_get	vmlinux	EXPORT_SYMBOL_GPL	
++0xd80fd063	devm_pinctrl_put	vmlinux	EXPORT_SYMBOL_GPL	
++0xa07076ce	devm_pinctrl_get	vmlinux	EXPORT_SYMBOL_GPL	
++0x11f7ed4c	hex_to_bin	vmlinux	EXPORT_SYMBOL	
++0xc8827b75	sysctl_vals	vmlinux	EXPORT_SYMBOL	
++0x76777ef2	simple_pin_fs	vmlinux	EXPORT_SYMBOL	
++0x5635a60a	vmalloc_user	vmlinux	EXPORT_SYMBOL	
++0xad939a7b	posix_clock_unregister	vmlinux	EXPORT_SYMBOL_GPL	
++0x78b11281	kthread_create_worker_on_cpu	vmlinux	EXPORT_SYMBOL	
++0xe7d13b2b	xprt_pin_rqst	vmlinux	EXPORT_SYMBOL_GPL	
++0x272a8933	udp_memory_allocated	vmlinux	EXPORT_SYMBOL	
++0x0a9fff36	bpf_prog_create_from_user	vmlinux	EXPORT_SYMBOL_GPL	
++0x6921035b	sock_no_sendpage	vmlinux	EXPORT_SYMBOL	
++0x5615c12c	led_put	vmlinux	EXPORT_SYMBOL_GPL	
++0xe4329092	__ctzdi2	vmlinux	EXPORT_SYMBOL	
++0x6fd9c35a	__clzdi2	vmlinux	EXPORT_SYMBOL	
++0x3621d5d8	blk_pre_runtime_suspend	vmlinux	EXPORT_SYMBOL	
++0xe4bbc1dd	kimage_voffset	vmlinux	EXPORT_SYMBOL	
++0x5178e4c6	get_current_tty	vmlinux	EXPORT_SYMBOL_GPL	
++0xd472aa0d	proc_create_data	vmlinux	EXPORT_SYMBOL	
++0x526ecde6	filemap_fdatawait_range_keep_errors	vmlinux	EXPORT_SYMBOL	
++0x3fff9e6d	filemap_range_has_page	vmlinux	EXPORT_SYMBOL	
++0x60028dc7	param_ops_string	vmlinux	EXPORT_SYMBOL	
++0xfe95805d	sunrpc_cache_register_pipefs	vmlinux	EXPORT_SYMBOL_GPL	
++0xf852d746	__tracepoint_tcp_send_reset	vmlinux	EXPORT_SYMBOL_GPL	
++0x733f3fc2	kernel_getsockname	vmlinux	EXPORT_SYMBOL	
++0x62d77b93	kernel_sendmsg	vmlinux	EXPORT_SYMBOL	
++0xef8ab899	uart_register_driver	vmlinux	EXPORT_SYMBOL	
++0xc1c3ba75	divider_round_rate_parent	vmlinux	EXPORT_SYMBOL_GPL	
++0x39b52d19	__bitmap_and	vmlinux	EXPORT_SYMBOL	
++0x9b8635b0	nfs_getattr	vmlinux	EXPORT_SYMBOL_GPL	
++0x4c4fdea3	nfs_setattr	vmlinux	EXPORT_SYMBOL_GPL	
++0x98be671a	__traceiter_fs_file_read	vmlinux	EXPORT_SYMBOL_GPL	
++0x44c3d422	l3mdev_ifindex_lookup_by_table_id	vmlinux	EXPORT_SYMBOL_GPL	
++0x369cd1a4	xfrm_alloc_spi	vmlinux	EXPORT_SYMBOL	
++0x8349a895	nvmem_device_put	vmlinux	EXPORT_SYMBOL_GPL	
++0x96792232	nvmem_device_get	vmlinux	EXPORT_SYMBOL_GPL	
++0xd0caf4e2	led_trigger_read	vmlinux	EXPORT_SYMBOL_GPL	
++0xde2792b8	spi_mem_dirmap_create	vmlinux	EXPORT_SYMBOL_GPL	
++0x05ba376b	fwnode_remove_software_node	vmlinux	EXPORT_SYMBOL_GPL	
++0xc354edf8	blk_rq_err_bytes	vmlinux	EXPORT_SYMBOL_GPL	
++0xba225f4e	crypto_alloc_sync_skcipher	vmlinux	EXPORT_SYMBOL_GPL	
++0x27190726	nf_log_packet	vmlinux	EXPORT_SYMBOL	
++0xe2003119	dev_remove_pack	vmlinux	EXPORT_SYMBOL	
++0x8958c6ee	of_get_next_cpu_node	vmlinux	EXPORT_SYMBOL	
++0x0f7ca236	dmi_memdev_name	vmlinux	EXPORT_SYMBOL_GPL	
++0x70191eab	led_set_brightness_nopm	vmlinux	EXPORT_SYMBOL_GPL	
++0x2c256e1f	input_scancode_to_scalar	vmlinux	EXPORT_SYMBOL	
++0xa46f27eb	spi_get_next_queued_message	vmlinux	EXPORT_SYMBOL_GPL	
++0xbbcf8054	__devm_regmap_init	vmlinux	EXPORT_SYMBOL_GPL	
++0x7b46291e	btree_destroy	vmlinux	EXPORT_SYMBOL_GPL	
++0x1b79698c	rq_flush_dcache_pages	vmlinux	EXPORT_SYMBOL_GPL	
++0x373031c4	posix_lock_file	vmlinux	EXPORT_SYMBOL	
++0x71a672ef	dmam_pool_destroy	vmlinux	EXPORT_SYMBOL	
++0xa60c0717	unpin_user_pages_dirty_lock	vmlinux	EXPORT_SYMBOL	
++0xff7c5549	set_page_dirty	vmlinux	EXPORT_SYMBOL	
++0x4d7272e4	migrate_enable	vmlinux	EXPORT_SYMBOL_GPL	
++0x1ac2bb78	kthread_destroy_worker	vmlinux	EXPORT_SYMBOL	
++0x7cf52901	ir_raw_gen_manchester	vmlinux	EXPORT_SYMBOL	
++0x43962c68	udp_disconnect	vmlinux	EXPORT_SYMBOL	
++0x475ec0f4	ethnl_cable_test_pulse	vmlinux	EXPORT_SYMBOL_GPL	
++0x32de9110	dev_mc_unsync	vmlinux	EXPORT_SYMBOL	
++0x14362f2f	dev_uc_unsync	vmlinux	EXPORT_SYMBOL	
++0x424eb29d	unregister_netdevice_notifier_net	vmlinux	EXPORT_SYMBOL	
++0x65736924	devm_nvmem_cell_get	vmlinux	EXPORT_SYMBOL_GPL	
++0xefa78cb6	usb_choose_configuration	vmlinux	EXPORT_SYMBOL_GPL	
++0xc09e8f02	usb_free_streams	vmlinux	EXPORT_SYMBOL_GPL	
++0x69fa1efe	regcache_cache_only	vmlinux	EXPORT_SYMBOL_GPL	
++0x9b92d16e	pinctrl_gpio_set_config	vmlinux	EXPORT_SYMBOL_GPL	
++0x77d61fac	sbitmap_queue_min_shallow_depth	vmlinux	EXPORT_SYMBOL_GPL	
++0x6be00a33	input_set_timestamp	vmlinux	EXPORT_SYMBOL	
++0x92265f33	phy_set_asym_pause	vmlinux	EXPORT_SYMBOL	
++0x3c2dbb47	fwnode_graph_get_remote_port	vmlinux	EXPORT_SYMBOL_GPL	
++0x4d7b4627	bus_get_kset	vmlinux	EXPORT_SYMBOL_GPL	
++0xec59a706	regulator_set_active_discharge_regmap	vmlinux	EXPORT_SYMBOL_GPL	
++0x79b58be4	of_get_fb_videomode	vmlinux	EXPORT_SYMBOL_GPL	
++0xc4fc063b	fb_pan_display	vmlinux	EXPORT_SYMBOL	
++0x3073060b	fb_show_logo	vmlinux	EXPORT_SYMBOL	
++0x7fa0bbb3	__register_chrdev	vmlinux	EXPORT_SYMBOL	
++0xd39e9848	put_itimerspec64	vmlinux	EXPORT_SYMBOL_GPL	
++0xe5919cb1	xdr_encode_opaque	vmlinux	EXPORT_SYMBOL_GPL	
++0x18a2cf00	dst_blackhole_mtu	vmlinux	EXPORT_SYMBOL_GPL	
++0xd0051153	sdhci_abort_tuning	vmlinux	EXPORT_SYMBOL_GPL	
++0x81429ab9	rtc_class_close	vmlinux	EXPORT_SYMBOL_GPL	
++0x033832c7	usb_amd_hang_symptom_quirk	vmlinux	EXPORT_SYMBOL_GPL	
++0xc58d5a90	kstrtoll_from_user	vmlinux	EXPORT_SYMBOL	
++0x7e226908	trace_array_get_by_name	vmlinux	EXPORT_SYMBOL_GPL	
++0xf1969a8e	__usecs_to_jiffies	vmlinux	EXPORT_SYMBOL	
++0x7f02188f	__msecs_to_jiffies	vmlinux	EXPORT_SYMBOL	
++0xcd90f1d3	sched_trace_rq_avg_irq	vmlinux	EXPORT_SYMBOL_GPL	
++0x6cca9fa1	vlan_vids_add_by_dev	vmlinux	EXPORT_SYMBOL	
++0xa807e22d	svc_max_payload	vmlinux	EXPORT_SYMBOL_GPL	
++0xf2aa6623	devm_of_platform_populate	vmlinux	EXPORT_SYMBOL_GPL	
++0xdc14eda7	pci_pci_problems	vmlinux	EXPORT_SYMBOL	
++0xbf05e459	pcie_capability_read_dword	vmlinux	EXPORT_SYMBOL	
++0xb5f88571	drop_super_exclusive	vmlinux	EXPORT_SYMBOL	
++0x99b26a7f	free_vm_area	vmlinux	EXPORT_SYMBOL_GPL	
++0xcd7c1b45	tracing_snapshot_cond_disable	vmlinux	EXPORT_SYMBOL_GPL	
++0x56d28038	udp_lib_getsockopt	vmlinux	EXPORT_SYMBOL	
++0x91759279	udp_lib_setsockopt	vmlinux	EXPORT_SYMBOL	
++0x81533963	sysfs_format_mac	vmlinux	EXPORT_SYMBOL	
++0x0c689c8d	get_net_ns_by_fd	vmlinux	EXPORT_SYMBOL_GPL	
++0x1156e1db	sk_send_sigurg	vmlinux	EXPORT_SYMBOL	
++0xfc5cf8d6	mdiobus_alloc_size	vmlinux	EXPORT_SYMBOL	
++0xdf1b61aa	spi_bus_lock	vmlinux	EXPORT_SYMBOL_GPL	
++0xb24357dd	regulator_set_current_limit_regmap	vmlinux	EXPORT_SYMBOL_GPL	
++0xa75af567	xas_find_conflict	vmlinux	EXPORT_SYMBOL_GPL	
++0x78328444	nfs41_sequence_done	vmlinux	EXPORT_SYMBOL_GPL	
++0x092cf98e	fscache_object_sleep_till_congested	vmlinux	EXPORT_SYMBOL_GPL	
++0x7a2289e8	proc_set_size	vmlinux	EXPORT_SYMBOL	
++0xcd2da9e5	dma_alloc_pages	vmlinux	EXPORT_SYMBOL_GPL	
++0x90aa5af3	netif_rx_any_context	vmlinux	EXPORT_SYMBOL	
++0xceb17996	drop_super	vmlinux	EXPORT_SYMBOL	
++0xc5850110	printk	vmlinux	EXPORT_SYMBOL	
++0xe37a0123	flow_hash_from_keys	vmlinux	EXPORT_SYMBOL	
++0x63a9b6df	net_rwsem	vmlinux	EXPORT_SYMBOL_GPL	
++0x6760f2fe	sk_alloc	vmlinux	EXPORT_SYMBOL	
++0xcfcadce5	sock_enable_timestamps	vmlinux	EXPORT_SYMBOL	
++0x35d00e3f	bus_unregister_notifier	vmlinux	EXPORT_SYMBOL_GPL	
++0x2e06a33c	regulator_disable	vmlinux	EXPORT_SYMBOL_GPL	
++0x39e05ac3	nfs_idmap_cache_timeout	vmlinux	EXPORT_SYMBOL_GPL	
++0x76bb3b08	try_to_release_page	vmlinux	EXPORT_SYMBOL	
++0x92a83da3	synchronize_srcu	vmlinux	EXPORT_SYMBOL_GPL	
++0x78204a83	rt_write_lock	vmlinux	EXPORT_SYMBOL	
++0x3c94d699	rpcauth_lookup_credcache	vmlinux	EXPORT_SYMBOL_GPL	
++0x76fd669e	usb_gadget_disconnect	vmlinux	EXPORT_SYMBOL_GPL	
++0xc820e5b7	phy_restore_page	vmlinux	EXPORT_SYMBOL_GPL	
++0x9abca5e0	dma_buf_vmap	vmlinux	EXPORT_SYMBOL_GPL	
++0x35170477	dma_buf_mmap	vmlinux	EXPORT_SYMBOL_GPL	
++0x7395989f	__platform_driver_register	vmlinux	EXPORT_SYMBOL_GPL	
++0xb5340ce3	mipi_dsi_attach	vmlinux	EXPORT_SYMBOL	
++0x7038d5d4	pci_disable_msix	vmlinux	EXPORT_SYMBOL	
++0xbc0d8477	devm_of_phy_provider_unregister	vmlinux	EXPORT_SYMBOL_GPL	
++0xc6225a2c	kobject_add	vmlinux	EXPORT_SYMBOL	
++0xe7a970fe	klist_iter_init	vmlinux	EXPORT_SYMBOL_GPL	
++0x498e9128	ZSTD_findDecompressedSize	vmlinux	EXPORT_SYMBOL	
++0x92d8fefa	bio_list_copy_data	vmlinux	EXPORT_SYMBOL	
++0xcb89fcc6	nfs_commitdata_release	vmlinux	EXPORT_SYMBOL_GPL	
++0x10138352	tracing_on	vmlinux	EXPORT_SYMBOL_GPL	
++0x0b3c5dc6	xfrm_audit_policy_add	vmlinux	EXPORT_SYMBOL_GPL	
++0x455cd9de	sock_gen_put	vmlinux	EXPORT_SYMBOL_GPL	
++0x8250ae4c	thermal_zone_get_temp	vmlinux	EXPORT_SYMBOL_GPL	
++0x34e7dab9	dwc_cc_remove	vmlinux	EXPORT_SYMBOL	
++0x3b5bd5fa	platform_driver_unregister	vmlinux	EXPORT_SYMBOL_GPL	
++0x6bbf26ba	iw_handler_get_thrspy	vmlinux	EXPORT_SYMBOL	
++0x344e38dd	xfrm_state_mtu	vmlinux	EXPORT_SYMBOL_GPL	
++0x12779875	gnet_stats_copy_queue	vmlinux	EXPORT_SYMBOL	
++0x2fb2b0e6	of_match_device	vmlinux	EXPORT_SYMBOL	
++0xdc5ff75e	of_node_name_eq	vmlinux	EXPORT_SYMBOL	
++0x37e19840	hid_ignore	vmlinux	EXPORT_SYMBOL_GPL	
++0x13af20f1	dev_pm_opp_put	vmlinux	EXPORT_SYMBOL_GPL	
++0x7f0fa15a	xhci_gen_setup	vmlinux	EXPORT_SYMBOL_GPL	
++0x5b0f1bc5	usb_get_urb	vmlinux	EXPORT_SYMBOL_GPL	
++0xf5525641	pci_scan_single_device	vmlinux	EXPORT_SYMBOL	
++0x2505bf18	kstrtol_from_user	vmlinux	EXPORT_SYMBOL	
++0x8051b0db	__traceiter_pnfs_mds_fallback_pg_init_write	vmlinux	EXPORT_SYMBOL_GPL	
++0x54423d77	nfs_file_release	vmlinux	EXPORT_SYMBOL_GPL	
++0xe1287edd	simple_dir_operations	vmlinux	EXPORT_SYMBOL	
++0x162893fd	hashlen_string	vmlinux	EXPORT_SYMBOL	
++0x1ad9e0da	list_lru_del	vmlinux	EXPORT_SYMBOL_GPL	
++0xdbf448d3	inet_frag_reasm_finish	vmlinux	EXPORT_SYMBOL	
++0xc2a814db	tcp_memory_pressure	vmlinux	EXPORT_SYMBOL_GPL	
++0x840342c6	sgl_free	vmlinux	EXPORT_SYMBOL	
++0x78cc1d62	blk_queue_update_readahead	vmlinux	EXPORT_SYMBOL_GPL	
++0x20156014	dqget	vmlinux	EXPORT_SYMBOL	
++0x2a82cd28	dqput	vmlinux	EXPORT_SYMBOL	
++0xdc908540	always_delete_dentry	vmlinux	EXPORT_SYMBOL	
++0xfa2d665f	setattr_copy	vmlinux	EXPORT_SYMBOL	
++0xb4ea7cf7	kgdb_connected	vmlinux	EXPORT_SYMBOL_GPL	
++0xb89719df	icmpv6_ndo_send	vmlinux	EXPORT_SYMBOL	
++0x42153c9b	inet_frags_fini	vmlinux	EXPORT_SYMBOL	
++0x65d9e877	cpufreq_register_notifier	vmlinux	EXPORT_SYMBOL	
++0x1f97d279	scsi_queue_work	vmlinux	EXPORT_SYMBOL_GPL	
++0x0c3ce9a0	pm_genpd_remove_device	vmlinux	EXPORT_SYMBOL_GPL	
++0x9c224975	gpiod_set_raw_value	vmlinux	EXPORT_SYMBOL_GPL	
++0x9be7bde4	security_tun_dev_attach	vmlinux	EXPORT_SYMBOL	
++0xf346231f	seq_list_start_head	vmlinux	EXPORT_SYMBOL	
++0x68c91629	dns_query	vmlinux	EXPORT_SYMBOL	
++0xe2fc7ff4	netdev_set_default_ethtool_ops	vmlinux	EXPORT_SYMBOL_GPL	
++0x0df70392	netif_device_attach	vmlinux	EXPORT_SYMBOL	
++0x1f51b67b	netif_device_detach	vmlinux	EXPORT_SYMBOL	
++0xb9b28146	sdhci_pltfm_init	vmlinux	EXPORT_SYMBOL_GPL	
++0x31690af1	device_rename	vmlinux	EXPORT_SYMBOL_GPL	
++0x7a6c3f94	mipi_dsi_dcs_set_display_on	vmlinux	EXPORT_SYMBOL	
++0x73c43635	fbcon_rotate_ud	vmlinux	EXPORT_SYMBOL	
++0x5f44704f	fbcon_rotate_cw	vmlinux	EXPORT_SYMBOL	
++0xa8d7ec62	nfs4_setup_sequence	vmlinux	EXPORT_SYMBOL_GPL	
++0x7dcf35dd	simple_attr_read	vmlinux	EXPORT_SYMBOL_GPL	
++0x2c270222	relay_flush	vmlinux	EXPORT_SYMBOL_GPL	
++0xc12435e3	rpc_calc_rto	vmlinux	EXPORT_SYMBOL_GPL	
++0x1c0b3901	kernel_bind	vmlinux	EXPORT_SYMBOL	
++0xcc248d26	serial8250_suspend_port	vmlinux	EXPORT_SYMBOL	
++0x4e6e8ea7	fg_console	vmlinux	EXPORT_SYMBOL	
++0xcd279169	nla_find	vmlinux	EXPORT_SYMBOL	
++0xf45e93d1	kernel_read	vmlinux	EXPORT_SYMBOL	
++0x3c681dc4	ring_buffer_record_disable	vmlinux	EXPORT_SYMBOL_GPL	
++0xffae8e8b	nsecs_to_jiffies	vmlinux	EXPORT_SYMBOL_GPL	
++0x0e9fe006	dma_get_merge_boundary	vmlinux	EXPORT_SYMBOL_GPL	
++0xf8f60bae	dma_free_noncoherent	vmlinux	EXPORT_SYMBOL_GPL	
++0x807fdcc4	call_rcu_tasks_rude	vmlinux	EXPORT_SYMBOL_GPL	
++0xb25c09f5	__devm_release_region	vmlinux	EXPORT_SYMBOL	
++0x95cd6f15	sock_set_reuseaddr	vmlinux	EXPORT_SYMBOL	
++0xd380c4c5	device_link_del	vmlinux	EXPORT_SYMBOL_GPL	
++0xa78369f2	device_link_add	vmlinux	EXPORT_SYMBOL_GPL	
++0xf7d961d8	clk_hw_unregister_composite	vmlinux	EXPORT_SYMBOL_GPL	
++0x4914ed3a	pci_bus_find_capability	vmlinux	EXPORT_SYMBOL	
++0x578a408b	ZSTD_initDCtx	vmlinux	EXPORT_SYMBOL	
++0x9d605763	vlan_dev_vlan_id	vmlinux	EXPORT_SYMBOL	
++0xf407697d	__skb_try_recv_datagram	vmlinux	EXPORT_SYMBOL	
++0x8ff6c2b1	vchiq_get_peer_version	vmlinux	EXPORT_SYMBOL	
++0x91f2acd4	input_set_max_poll_interval	vmlinux	EXPORT_SYMBOL	
++0x52321647	input_set_min_poll_interval	vmlinux	EXPORT_SYMBOL	
++0x34bcfdc8	DWC_SPINLOCK_ALLOC	vmlinux	EXPORT_SYMBOL	
++0x9b9854cf	serial8250_em485_start_tx	vmlinux	EXPORT_SYMBOL_GPL	
++0xfaf68668	pinconf_generic_dt_free_map	vmlinux	EXPORT_SYMBOL_GPL	
++0xe691ac7f	ZSTD_decompressBegin	vmlinux	EXPORT_SYMBOL	
++0x6c9a3ef7	nfs4_delete_deviceid	vmlinux	EXPORT_SYMBOL_GPL	
++0x315a12da	frontswap_register_ops	vmlinux	EXPORT_SYMBOL	
++0xdf7f3a38	pagevec_lookup_range_tag	vmlinux	EXPORT_SYMBOL	
++0x78430027	sunrpc_cache_unregister_pipefs	vmlinux	EXPORT_SYMBOL_GPL	
++0x2c2c6468	dst_cache_get_ip4	vmlinux	EXPORT_SYMBOL_GPL	
++0xbf1be795	usbnet_resume_rx	vmlinux	EXPORT_SYMBOL_GPL	
++0xf9bb3d4b	__class_register	vmlinux	EXPORT_SYMBOL_GPL	
++0x998256c5	gpiochip_populate_parent_fwspec_twocell	vmlinux	EXPORT_SYMBOL_GPL	
++0xf5a3ba99	linear_range_values_in_range	vmlinux	EXPORT_SYMBOL_GPL	
++0x5fdbbae5	pnfs_generic_scan_commit_lists	vmlinux	EXPORT_SYMBOL_GPL	
++0x6a5cb5ee	__get_free_pages	vmlinux	EXPORT_SYMBOL	
++0x1435c5ce	__SCK__tp_func_kmalloc_node	vmlinux	EXPORT_SYMBOL	
++0x2f2182b0	nf_unregister_net_hook	vmlinux	EXPORT_SYMBOL	
++0x16a2209f	DWC_SPINLOCK	vmlinux	EXPORT_SYMBOL	
++0x20c8b014	usb_free_coherent	vmlinux	EXPORT_SYMBOL_GPL	
++0xadbeed61	mipi_dsi_packet_format_is_long	vmlinux	EXPORT_SYMBOL	
++0xd8a721e3	pciserial_init_ports	vmlinux	EXPORT_SYMBOL_GPL	
++0x74fc1bf2	pcie_has_flr	vmlinux	EXPORT_SYMBOL_GPL	
++0x97adb487	utf8s_to_utf16s	vmlinux	EXPORT_SYMBOL	
++0xb4b97c90	pvclock_gtod_register_notifier	vmlinux	EXPORT_SYMBOL_GPL	
++0xd6e3a9f9	ns_capable	vmlinux	EXPORT_SYMBOL	
++0x59059bdc	ip_route_output_key_hash	vmlinux	EXPORT_SYMBOL_GPL	
++0xdeb120d4	is_skb_forwardable	vmlinux	EXPORT_SYMBOL_GPL	
++0x08f7e829	nvmem_device_find	vmlinux	EXPORT_SYMBOL_GPL	
++0x899d02e1	usb_control_msg_recv	vmlinux	EXPORT_SYMBOL_GPL	
++0x694fdfe1	clk_hw_register_clkdev	vmlinux	EXPORT_SYMBOL	
++0xab8cab65	fb_deferred_io_init	vmlinux	EXPORT_SYMBOL_GPL	
++0xf6d1d20b	debugfs_attr_read	vmlinux	EXPORT_SYMBOL_GPL	
++0x7ab7bcc6	__tracepoint_ff_layout_commit_error	vmlinux	EXPORT_SYMBOL_GPL	
++0x92b9b180	slash_name	vmlinux	EXPORT_SYMBOL	
++0xbcc15e75	ktime_get_coarse_with_offset	vmlinux	EXPORT_SYMBOL_GPL	
++0xd88ee4c2	sched_trace_cfs_rq_avg	vmlinux	EXPORT_SYMBOL_GPL	
++0x6df1aaf1	kernel_sigaction	vmlinux	EXPORT_SYMBOL	
++0xd75f7d05	ipv4_specific	vmlinux	EXPORT_SYMBOL	
++0x9c6bd566	proto_unregister	vmlinux	EXPORT_SYMBOL	
++0x09fd5759	blackhole_netdev	vmlinux	EXPORT_SYMBOL	
++0x953cd8ff	spi_controller_dma_unmap_mem_op_data	vmlinux	EXPORT_SYMBOL_GPL	
++0xec33c668	__SCK__tp_func_spi_transfer_start	vmlinux	EXPORT_SYMBOL	
++0x1d74235b	devm_mfd_add_devices	vmlinux	EXPORT_SYMBOL	
++0x9fb7ac12	regulator_sync_voltage	vmlinux	EXPORT_SYMBOL_GPL	
++0x235bf594	csum_and_copy_from_iter	vmlinux	EXPORT_SYMBOL	
++0xa855bba1	__fsnotify_inode_delete	vmlinux	EXPORT_SYMBOL_GPL	
++0xd0b74dfc	DWC_UTF8_TO_UTF16LE	vmlinux	EXPORT_SYMBOL	
++0x016ee14d	device_node_to_regmap	vmlinux	EXPORT_SYMBOL_GPL	
++0xce64a238	fwnode_get_name	vmlinux	EXPORT_SYMBOL_GPL	
++0x84749812	bsg_scsi_register_queue	vmlinux	EXPORT_SYMBOL_GPL	
++0x91327742	blk_mq_free_tag_set	vmlinux	EXPORT_SYMBOL	
++0x9c623475	crypto_cipher_encrypt_one	vmlinux	EXPORT_SYMBOL_GPL	
++0x5f1eb4b7	fscrypt_show_test_dummy_encryption	vmlinux	EXPORT_SYMBOL_GPL	
++0xcd152515	list_lru_count_node	vmlinux	EXPORT_SYMBOL_GPL	
++0x14715449	from_kprojid_munged	vmlinux	EXPORT_SYMBOL	
++0xcc20c909	rpc_find_or_alloc_pipe_dir_object	vmlinux	EXPORT_SYMBOL_GPL	
++0x8e4bd5ef	rpcauth_unwrap_resp_decode	vmlinux	EXPORT_SYMBOL_GPL	
++0xfaedd456	flow_block_cb_setup_simple	vmlinux	EXPORT_SYMBOL	
++0x67263e84	flow_rule_match_enc_ip	vmlinux	EXPORT_SYMBOL	
++0x8c96b18d	rtnl_af_register	vmlinux	EXPORT_SYMBOL_GPL	
++0x1f77a356	mdio_device_reset	vmlinux	EXPORT_SYMBOL	
++0x27fc0923	spi_statistics_add_transfer_stats	vmlinux	EXPORT_SYMBOL_GPL	
++0x448f2548	cpu_latency_qos_remove_request	vmlinux	EXPORT_SYMBOL_GPL	
++0xa4893e71	param_ops_long	vmlinux	EXPORT_SYMBOL	
++0xb11c713d	rpc_add_pipe_dir_object	vmlinux	EXPORT_SYMBOL_GPL	
++0x34ae18cf	inet_csk_update_pmtu	vmlinux	EXPORT_SYMBOL_GPL	
++0xca84b151	radix_tree_lookup	vmlinux	EXPORT_SYMBOL	
++0x3e7080cb	mpi_read_from_buffer	vmlinux	EXPORT_SYMBOL_GPL	
++0x4aea463f	crc32_le_shift	vmlinux	EXPORT_SYMBOL	
++0xacf4d843	match_strdup	vmlinux	EXPORT_SYMBOL	
++0xc3805cd1	fs_ftype_to_dtype	vmlinux	EXPORT_SYMBOL_GPL	
++0x0f180070	ring_buffer_free_read_page	vmlinux	EXPORT_SYMBOL_GPL	
++0xc5d9cafa	rt_mutex_unlock	vmlinux	EXPORT_SYMBOL_GPL	
++0x12d3ad15	neigh_seq_next	vmlinux	EXPORT_SYMBOL	
++0x07a154ab	badblocks_init	vmlinux	EXPORT_SYMBOL_GPL	
++0x634b9d42	__SCK__tp_func_block_unplug	vmlinux	EXPORT_SYMBOL_GPL	
++0x8996428e	vfs_rename	vmlinux	EXPORT_SYMBOL	
++0x5fab9a5a	generic_ro_fops	vmlinux	EXPORT_SYMBOL	
++0xdbe8d8a0	__SCK__tp_func_cpu_frequency	vmlinux	EXPORT_SYMBOL_GPL	
++0xa947b2cb	nexthop_select_path	vmlinux	EXPORT_SYMBOL_GPL	
++0xcedd56c8	gnet_stats_copy_basic_hw	vmlinux	EXPORT_SYMBOL	
++0xbb612227	dev_pm_opp_free_cpufreq_table	vmlinux	EXPORT_SYMBOL_GPL	
++0x0732f77e	dev_pm_opp_enable	vmlinux	EXPORT_SYMBOL_GPL	
++0x6b7b40a3	phy_save_page	vmlinux	EXPORT_SYMBOL_GPL	
++0x2e82e2df	iscsi_free_session	vmlinux	EXPORT_SYMBOL_GPL	
++0x32b9def5	pm_runtime_force_resume	vmlinux	EXPORT_SYMBOL_GPL	
++0x8f531e69	devm_pci_remap_cfgspace	vmlinux	EXPORT_SYMBOL	
++0xc2f69367	devm_fwnode_pwm_get	vmlinux	EXPORT_SYMBOL_GPL	
++0x19e04593	phy_calibrate	vmlinux	EXPORT_SYMBOL_GPL	
++0xfbad9115	iomap_page_mkwrite	vmlinux	EXPORT_SYMBOL_GPL	
++0x01ffc4e9	user_path_create	vmlinux	EXPORT_SYMBOL	
++0x3d4a06e5	kthread_bind	vmlinux	EXPORT_SYMBOL	
++0x8cc5e391	xprt_disconnect_done	vmlinux	EXPORT_SYMBOL_GPL	
++0x7cebac54	phy_modify_mmd	vmlinux	EXPORT_SYMBOL_GPL	
++0x4aa499ff	nvme_enable_ctrl	vmlinux	EXPORT_SYMBOL_GPL	
++0xcc4c785e	blk_queue_flag_test_and_set	vmlinux	EXPORT_SYMBOL_GPL	
++0xf177da7c	forget_all_cached_acls	vmlinux	EXPORT_SYMBOL	
++0x6e2ef34b	inet_frag_find	vmlinux	EXPORT_SYMBOL	
++0xa45ae255	inetdev_by_index	vmlinux	EXPORT_SYMBOL	
++0x943ba333	__sk_backlog_rcv	vmlinux	EXPORT_SYMBOL	
++0x2a089c8b	usb_poison_anchored_urbs	vmlinux	EXPORT_SYMBOL_GPL	
++0x0e6ca8c1	con_is_visible	vmlinux	EXPORT_SYMBOL	
++0xd73f0982	devm_of_clk_add_hw_provider	vmlinux	EXPORT_SYMBOL_GPL	
++0xdf0f75c6	eventfd_signal	vmlinux	EXPORT_SYMBOL_GPL	
++0x950bb736	zpool_register_driver	vmlinux	EXPORT_SYMBOL	
++0x05a4a7bd	clocksource_unregister	vmlinux	EXPORT_SYMBOL	
++0xe7ca7da7	fifo_set_limit	vmlinux	EXPORT_SYMBOL	
++0x58b4645c	dev_close_many	vmlinux	EXPORT_SYMBOL	
++0x28b030d2	of_overlay_notifier_unregister	vmlinux	EXPORT_SYMBOL_GPL	
++0x51d9b2cc	dev_pm_opp_set_prop_name	vmlinux	EXPORT_SYMBOL_GPL	
++0x18dde6d7	phy_drivers_unregister	vmlinux	EXPORT_SYMBOL	
++0x5a63567c	genphy_c45_check_and_restart_aneg	vmlinux	EXPORT_SYMBOL_GPL	
++0xa0371e94	con_debug_enter	vmlinux	EXPORT_SYMBOL_GPL	
++0xa70f9e36	pci_write_config_dword	vmlinux	EXPORT_SYMBOL	
++0x599fb41c	kvmalloc_node	vmlinux	EXPORT_SYMBOL	
++0x4e1815b2	filemap_fdatawrite	vmlinux	EXPORT_SYMBOL	
++0xc6457b56	rpc_clone_client_set_auth	vmlinux	EXPORT_SYMBOL_GPL	
++0x2a6c7e0e	dev_fill_metadata_dst	vmlinux	EXPORT_SYMBOL_GPL	
++0x37b2dbb4	dev_add_offload	vmlinux	EXPORT_SYMBOL	
++0xb10a28b0	dev_base_lock	vmlinux	EXPORT_SYMBOL	
++0x5f931115	usb_del_gadget_udc	vmlinux	EXPORT_SYMBOL_GPL	
++0x0a2d4bcb	mdiobus_is_registered_device	vmlinux	EXPORT_SYMBOL	
++0x7e7212ed	__devm_regmap_init_mmio_clk	vmlinux	EXPORT_SYMBOL_GPL	
++0xd25d4f74	console_blank_hook	vmlinux	EXPORT_SYMBOL	
++0x61d9f64f	devm_clk_register	vmlinux	EXPORT_SYMBOL_GPL	
++0xd21374ee	iov_iter_discard	vmlinux	EXPORT_SYMBOL	
++0x247ef831	kdb_unregister	vmlinux	EXPORT_SYMBOL_GPL	
++0x3afb8ddc	cgroup_get_from_fd	vmlinux	EXPORT_SYMBOL_GPL	
++0xf204f85a	tcf_action_set_ctrlact	vmlinux	EXPORT_SYMBOL	
++0xca3dd94a	devm_extcon_unregister_notifier	vmlinux	EXPORT_SYMBOL	
++0x9b943a06	__sdhci_read_caps	vmlinux	EXPORT_SYMBOL_GPL	
++0x5cd9de97	mmc_send_status	vmlinux	EXPORT_SYMBOL_GPL	
++0xdf14fdc9	devm_regmap_add_irq_chip_fwnode	vmlinux	EXPORT_SYMBOL_GPL	
++0x8a52cd2b	sg_scsi_ioctl	vmlinux	EXPORT_SYMBOL_GPL	
++0xc96170a9	__alloc_disk_node	vmlinux	EXPORT_SYMBOL	
++0xc22a3091	vm_unmap_aliases	vmlinux	EXPORT_SYMBOL_GPL	
++0x1e8fac8e	wireless_nlevent_flush	vmlinux	EXPORT_SYMBOL_GPL	
++0xe1d636f7	xfrm_state_lookup_byspi	vmlinux	EXPORT_SYMBOL	
++0x7f011bca	netlink_capable	vmlinux	EXPORT_SYMBOL	
++0x2f33c299	gnet_stats_finish_copy	vmlinux	EXPORT_SYMBOL	
++0xf4123b17	skb_checksum_trimmed	vmlinux	EXPORT_SYMBOL	
++0x6add5c9a	dmi_find_device	vmlinux	EXPORT_SYMBOL	
++0x27c39a7a	scsi_get_device_flags_keyed	vmlinux	EXPORT_SYMBOL	
++0xe38a4ddb	device_show_int	vmlinux	EXPORT_SYMBOL_GPL	
++0x0eb91227	uart_handle_cts_change	vmlinux	EXPORT_SYMBOL_GPL	
++0x7cd50e2a	uart_handle_dcd_change	vmlinux	EXPORT_SYMBOL_GPL	
++0x2ccbc5f0	pwm_capture	vmlinux	EXPORT_SYMBOL_GPL	
++0xcf29b95f	__tracepoint_pnfs_mds_fallback_read_pagelist	vmlinux	EXPORT_SYMBOL_GPL	
++0xc743cfe0	free_inode_nonrcu	vmlinux	EXPORT_SYMBOL	
++0x6d7e46db	dma_pool_create	vmlinux	EXPORT_SYMBOL	
++0x69d674f7	bpf_map_inc_with_uref	vmlinux	EXPORT_SYMBOL_GPL	
++0x892f45c2	__ip6_local_out	vmlinux	EXPORT_SYMBOL_GPL	
++0x041a5dab	napi_complete_done	vmlinux	EXPORT_SYMBOL	
++0x88cc5015	of_resolve_phandles	vmlinux	EXPORT_SYMBOL_GPL	
++0xa6ae9d43	sdio_writeb	vmlinux	EXPORT_SYMBOL_GPL	
++0xaf6910fa	DWC_TIME	vmlinux	EXPORT_SYMBOL	
++0x78876d94	usb_hcd_pci_probe	vmlinux	EXPORT_SYMBOL_GPL	
++0x5c9e1503	iscsi_remove_conn	vmlinux	EXPORT_SYMBOL_GPL	
++0x2b1abc9a	tty_name	vmlinux	EXPORT_SYMBOL	
++0xe5bad54c	get_disk_and_module	vmlinux	EXPORT_SYMBOL	
++0x8b0fcde9	vfs_parse_fs_param	vmlinux	EXPORT_SYMBOL	
++0xb5aa7165	dma_pool_destroy	vmlinux	EXPORT_SYMBOL	
++0xfba1b29e	irq_create_strict_mappings	vmlinux	EXPORT_SYMBOL_GPL	
++0x96ff2ba2	udp6_csum_init	vmlinux	EXPORT_SYMBOL	
++0x5a304148	dst_cache_set_ip4	vmlinux	EXPORT_SYMBOL_GPL	
++0x43ebd1e9	of_dev_put	vmlinux	EXPORT_SYMBOL	
++0xdb884e1f	of_dev_get	vmlinux	EXPORT_SYMBOL	
++0x2d912bca	dmi_get_bios_year	vmlinux	EXPORT_SYMBOL	
++0x61874afe	power_supply_register	vmlinux	EXPORT_SYMBOL_GPL	
++0x77f0ef3d	serial8250_register_8250_port	vmlinux	EXPORT_SYMBOL	
++0xc38259af	__this_cpu_preempt_check	vmlinux	EXPORT_SYMBOL	
++0x56c3db64	__tracepoint_kmalloc	vmlinux	EXPORT_SYMBOL	
++0xa45d2643	perf_event_release_kernel	vmlinux	EXPORT_SYMBOL_GPL	
++0x8c03d20c	destroy_workqueue	vmlinux	EXPORT_SYMBOL_GPL	
++0x9ffd5af8	inet_twsk_put	vmlinux	EXPORT_SYMBOL_GPL	
++0x5eb417e0	__SCK__tp_func_neigh_timer_handler	vmlinux	EXPORT_SYMBOL_GPL	
++0xc945f050	fib_default_rule_add	vmlinux	EXPORT_SYMBOL	
++0x18385af8	devm_extcon_register_notifier_all	vmlinux	EXPORT_SYMBOL	
++0xb5b6684f	usb_initialize_gadget	vmlinux	EXPORT_SYMBOL_GPL	
++0x1454eb7d	regcache_drop_region	vmlinux	EXPORT_SYMBOL_GPL	
++0x8709a8f9	pm_generic_runtime_suspend	vmlinux	EXPORT_SYMBOL_GPL	
++0xd47c6244	do_SAK	vmlinux	EXPORT_SYMBOL	
++0xd6bcf562	clk_hw_register_fixed_factor	vmlinux	EXPORT_SYMBOL_GPL	
++0x0bc031b1	pci_load_and_free_saved_state	vmlinux	EXPORT_SYMBOL_GPL	
++0xdf1b21fd	pci_save_state	vmlinux	EXPORT_SYMBOL	
++0x4c7606a2	nfs_pgio_header_free	vmlinux	EXPORT_SYMBOL_GPL	
++0x7a06ae11	fat_get_dotdot_entry	vmlinux	EXPORT_SYMBOL_GPL	
++0xec97f94a	writeback_inodes_sb	vmlinux	EXPORT_SYMBOL	
++0xa2e1b3ef	trace_printk_init_buffers	vmlinux	EXPORT_SYMBOL_GPL	
++0x35be36a0	console_atomic_lock	vmlinux	EXPORT_SYMBOL	
++0x6926815d	param_get_uint	vmlinux	EXPORT_SYMBOL	
++0xbe4b2619	elv_register	vmlinux	EXPORT_SYMBOL_GPL	
++0x3c185c61	page_put_link	vmlinux	EXPORT_SYMBOL	
++0xe4525f1a	release_pages	vmlinux	EXPORT_SYMBOL	
++0x1d1001a9	rpc_sleep_on	vmlinux	EXPORT_SYMBOL_GPL	
++0x17fc73df	mmc_cqe_start_req	vmlinux	EXPORT_SYMBOL	
++0x5c171dc1	fixed_phy_register	vmlinux	EXPORT_SYMBOL_GPL	
++0xfa031d4c	devm_regulator_put	vmlinux	EXPORT_SYMBOL_GPL	
++0x34a7b942	pci_enable_msi	vmlinux	EXPORT_SYMBOL	
++0xd75b20aa	rsa_parse_priv_key	vmlinux	EXPORT_SYMBOL_GPL	
++0x9d0ad3f6	pnfs_generic_commit_pagelist	vmlinux	EXPORT_SYMBOL_GPL	
++0x14d41027	km_state_expired	vmlinux	EXPORT_SYMBOL	
++0x08897f03	of_phandle_iterator_next	vmlinux	EXPORT_SYMBOL_GPL	
++0xb915a54d	dev_pm_opp_get_suspend_opp_freq	vmlinux	EXPORT_SYMBOL_GPL	
++0xab49904a	watchdog_set_restart_priority	vmlinux	EXPORT_SYMBOL_GPL	
++0xa1fa1075	platform_msi_domain_alloc_irqs	vmlinux	EXPORT_SYMBOL_GPL	
++0x9199fe78	component_bind_all	vmlinux	EXPORT_SYMBOL_GPL	
++0x4388bab3	clk_hw_rate_is_protected	vmlinux	EXPORT_SYMBOL_GPL	
++0xb0e10781	get_option	vmlinux	EXPORT_SYMBOL	
++0x737d6fbc	blk_mq_freeze_queue	vmlinux	EXPORT_SYMBOL_GPL	
++0x0aebca68	__tracepoint_ff_layout_read_error	vmlinux	EXPORT_SYMBOL_GPL	
++0x1a531f87	nfs4_find_or_create_ds_client	vmlinux	EXPORT_SYMBOL_GPL	
++0xdf2738bb	cpu_cgrp_subsys_enabled_key	vmlinux	EXPORT_SYMBOL_GPL	
++0x132f183a	rt_write_unlock	vmlinux	EXPORT_SYMBOL	
++0x60352082	register_inet6addr_notifier	vmlinux	EXPORT_SYMBOL	
++0xe73171f4	inet_accept	vmlinux	EXPORT_SYMBOL	
++0xc288e41e	tcp_select_initial_window	vmlinux	EXPORT_SYMBOL	
++0x95160371	register_pernet_device	vmlinux	EXPORT_SYMBOL_GPL	
++0xa36e604d	sock_set_priority	vmlinux	EXPORT_SYMBOL	
++0x5349cca4	hidraw_connect	vmlinux	EXPORT_SYMBOL_GPL	
++0xdafb5890	__mmc_send_status	vmlinux	EXPORT_SYMBOL_GPL	
++0x69eec98a	class_for_each_device	vmlinux	EXPORT_SYMBOL_GPL	
++0x3b9dd512	pci_free_irq_vectors	vmlinux	EXPORT_SYMBOL	
++0x2bfbab10	__memmove	vmlinux	EXPORT_SYMBOL	
++0x38e1fde7	mpi_set	vmlinux	EXPORT_SYMBOL_GPL	
++0x558b281d	aes_expandkey	vmlinux	EXPORT_SYMBOL	
++0x2d30596c	from_kqid_munged	vmlinux	EXPORT_SYMBOL	
++0x6d54c16e	bpf_offload_dev_create	vmlinux	EXPORT_SYMBOL_GPL	
++0x05883efb	__traceiter_suspend_resume	vmlinux	EXPORT_SYMBOL_GPL	
++0x1fdb7e48	up_read	vmlinux	EXPORT_SYMBOL	
++0x815f2897	empty_zero_page	vmlinux	EXPORT_SYMBOL	
++0x8647b7fb	tso_count_descs	vmlinux	EXPORT_SYMBOL	
++0xd01f2828	ndo_dflt_bridge_getlink	vmlinux	EXPORT_SYMBOL_GPL	
++0xcfe81e0c	__pskb_pull_tail	vmlinux	EXPORT_SYMBOL	
++0xec774acb	cpufreq_frequency_table_verify	vmlinux	EXPORT_SYMBOL_GPL	
++0x8ccca20e	i2c_match_id	vmlinux	EXPORT_SYMBOL_GPL	
++0x1eed9e61	usb_gadget_ep_match_desc	vmlinux	EXPORT_SYMBOL_GPL	
++0x21391968	devm_hwrng_unregister	vmlinux	EXPORT_SYMBOL_GPL	
++0x403c62f4	tty_wait_until_sent	vmlinux	EXPORT_SYMBOL	
++0x752a6e65	bcm_dma_start	vmlinux	EXPORT_SYMBOL_GPL	
++0x960c6eec	get_nfs_open_context	vmlinux	EXPORT_SYMBOL_GPL	
++0x5dc5f8ac	fscache_object_init	vmlinux	EXPORT_SYMBOL	
++0x3ef1a391	dquot_load_quota_sb	vmlinux	EXPORT_SYMBOL	
++0x56256e8a	orderly_poweroff	vmlinux	EXPORT_SYMBOL_GPL	
++0xed53de70	skb_consume_udp	vmlinux	EXPORT_SYMBOL_GPL	
++0x197ad091	tcp_leave_memory_pressure	vmlinux	EXPORT_SYMBOL_GPL	
++0x6ad3233c	device_remove_groups	vmlinux	EXPORT_SYMBOL_GPL	
++0xdffc80fc	vesa_modes	vmlinux	EXPORT_SYMBOL	
++0xdb6074e9	gpiod_set_raw_array_value_cansleep	vmlinux	EXPORT_SYMBOL_GPL	
++0xfb642f3d	remap_vmalloc_range_partial	vmlinux	EXPORT_SYMBOL	
++0xcb7c267e	alarm_forward	vmlinux	EXPORT_SYMBOL_GPL	
++0xd2f02803	__netif_schedule	vmlinux	EXPORT_SYMBOL	
++0xbe96dfd8	of_reconfig_notifier_unregister	vmlinux	EXPORT_SYMBOL_GPL	
++0xf12f461a	mmc_retune_unpause	vmlinux	EXPORT_SYMBOL	
++0xb187a2fb	cpuidle_get_driver	vmlinux	EXPORT_SYMBOL_GPL	
++0x424ae486	clk_fractional_divider_ops	vmlinux	EXPORT_SYMBOL_GPL	
++0xf261c184	generic_fh_to_parent	vmlinux	EXPORT_SYMBOL_GPL	
++0x50f50422	generic_fillattr	vmlinux	EXPORT_SYMBOL	
++0xc972449f	mempool_alloc_slab	vmlinux	EXPORT_SYMBOL	
++0xb352a541	param_set_invbool	vmlinux	EXPORT_SYMBOL	
++0xbb455bf0	__inet_hash	vmlinux	EXPORT_SYMBOL	
++0x15717d2c	cpuidle_unregister_driver	vmlinux	EXPORT_SYMBOL_GPL	
++0x8c62cb97	i2c_register_driver	vmlinux	EXPORT_SYMBOL	
++0x82fd370a	__traceiter_xhci_dbg_quirks	vmlinux	EXPORT_SYMBOL_GPL	
++0x21027e91	fixed_phy_unregister	vmlinux	EXPORT_SYMBOL_GPL	
++0xf3377bd5	pci_bus_alloc_resource	vmlinux	EXPORT_SYMBOL	
++0x5fc31de4	gpiod_set_array_value	vmlinux	EXPORT_SYMBOL_GPL	
++0x2846b898	of_phy_provider_unregister	vmlinux	EXPORT_SYMBOL_GPL	
++0x0c0f79af	ZSTD_getDictID_fromFrame	vmlinux	EXPORT_SYMBOL	
++0x789c73d9	rcu_cpu_stall_suppress_at_boot	vmlinux	EXPORT_SYMBOL_GPL	
++0x92d5838e	request_threaded_irq	vmlinux	EXPORT_SYMBOL	
++0xfef216eb	_raw_spin_trylock	vmlinux	EXPORT_SYMBOL	
++0x9d2f49ef	__SCK__tp_func_pelt_se_tp	vmlinux	EXPORT_SYMBOL_GPL	
++0xc2e584c0	has_capability	vmlinux	EXPORT_SYMBOL	
++0xb4f13d2a	abort	vmlinux	EXPORT_SYMBOL	
++0x1abc9c86	svc_drop	vmlinux	EXPORT_SYMBOL_GPL	
++0x4be7fada	tcp_sendpage_locked	vmlinux	EXPORT_SYMBOL_GPL	
++0x550338f5	mbox_flush	vmlinux	EXPORT_SYMBOL_GPL	
++0xb9be00ef	pm_clk_add_notifier	vmlinux	EXPORT_SYMBOL_GPL	
++0x59f32720	mpi_subm	vmlinux	EXPORT_SYMBOL_GPL	
++0xc575c737	debug_locks_off	vmlinux	EXPORT_SYMBOL_GPL	
++0xb6d74f88	jbd2_journal_forget	vmlinux	EXPORT_SYMBOL	
++0x7c28fb45	skb_clone	vmlinux	EXPORT_SYMBOL	
++0x21ce6d03	devm_mbox_controller_unregister	vmlinux	EXPORT_SYMBOL_GPL	
++0xeabe1377	input_get_keycode	vmlinux	EXPORT_SYMBOL	
++0x50ba095d	regmap_can_raw_write	vmlinux	EXPORT_SYMBOL_GPL	
++0xdcbe8f34	of_genpd_del_provider	vmlinux	EXPORT_SYMBOL_GPL	
++0xfdcc8a0e	fb_find_best_display	vmlinux	EXPORT_SYMBOL	
++0x8374df86	xa_erase	vmlinux	EXPORT_SYMBOL	
++0xb3eacd9d	set_task_ioprio	vmlinux	EXPORT_SYMBOL_GPL	
++0xf74944aa	crypto_find_alg	vmlinux	EXPORT_SYMBOL_GPL	
++0xb7b70b73	setup_arg_pages	vmlinux	EXPORT_SYMBOL	
++0x8beb9941	pagevec_lookup_range	vmlinux	EXPORT_SYMBOL	
++0xa70fb761	flow_keys_basic_dissector	vmlinux	EXPORT_SYMBOL	
++0xd56e1bd8	sdhci_switch_external_dma	vmlinux	EXPORT_SYMBOL_GPL	
++0x06ab026a	bcm_phy_write_exp	vmlinux	EXPORT_SYMBOL_GPL	
++0x86d6e339	of_get_regulator_init_data	vmlinux	EXPORT_SYMBOL_GPL	
++0xef29fcdd	clk_bulk_put	vmlinux	EXPORT_SYMBOL_GPL	
++0x7af2b796	amba_request_regions	vmlinux	EXPORT_SYMBOL	
++0xfffdf870	devm_fwnode_gpiod_get_index	vmlinux	EXPORT_SYMBOL_GPL	
++0x6539127f	inode_dio_wait	vmlinux	EXPORT_SYMBOL	
++0x7ee677e3	irq_chip_request_resources_parent	vmlinux	EXPORT_SYMBOL_GPL	
++0x9e472f5f	snmp_fold_field	vmlinux	EXPORT_SYMBOL_GPL	
++0x541c9e67	iscsi_session_event	vmlinux	EXPORT_SYMBOL_GPL	
++0xce67ba93	pci_disable_link_state	vmlinux	EXPORT_SYMBOL	
++0x466faabc	crypto_unregister_akcipher	vmlinux	EXPORT_SYMBOL_GPL	
++0xdba16034	crypto_unregister_skcipher	vmlinux	EXPORT_SYMBOL_GPL	
++0xaa310a11	jbd2_journal_start	vmlinux	EXPORT_SYMBOL	
++0x29d7f6c1	dquot_quota_on	vmlinux	EXPORT_SYMBOL	
++0xd67364f7	eventfd_ctx_fdget	vmlinux	EXPORT_SYMBOL_GPL	
++0x739fd00f	__SCK__tp_func_module_get	vmlinux	EXPORT_SYMBOL	
++0x18615d35	efivar_supports_writes	vmlinux	EXPORT_SYMBOL_GPL	
++0x612ac229	cpufreq_policy_transition_delay_us	vmlinux	EXPORT_SYMBOL_GPL	
++0x987f58ca	thermal_zone_device_unregister	vmlinux	EXPORT_SYMBOL_GPL	
++0x5e8e6506	__i2c_transfer	vmlinux	EXPORT_SYMBOL	
++0xb796cab7	devm_ioremap_wc	vmlinux	EXPORT_SYMBOL	
++0xb62b28d0	devm_ioremap_uc	vmlinux	EXPORT_SYMBOL_GPL	
++0x22f6730e	vfs_lock_file	vmlinux	EXPORT_SYMBOL_GPL	
++0xcabb993b	make_bad_inode	vmlinux	EXPORT_SYMBOL	
++0x2588a497	__d_drop	vmlinux	EXPORT_SYMBOL	
++0x4a8a4d49	__mmdrop	vmlinux	EXPORT_SYMBOL_GPL	
++0x40e601c9	gss_mech_unregister	vmlinux	EXPORT_SYMBOL_GPL	
++0xdf1ea967	unix_detach_fds	vmlinux	EXPORT_SYMBOL	
++0x59b4ac3e	tcp_memory_allocated	vmlinux	EXPORT_SYMBOL	
++0x56501748	hid_check_keys_pressed	vmlinux	EXPORT_SYMBOL_GPL	
++0x47aad3b9	have_governor_per_policy	vmlinux	EXPORT_SYMBOL_GPL	
++0x37bf579e	scsi_bus_type	vmlinux	EXPORT_SYMBOL_GPL	
++0xd0b63ef7	scsi_alloc_sgtables	vmlinux	EXPORT_SYMBOL	
++0x29475afd	fwnode_graph_parse_endpoint	vmlinux	EXPORT_SYMBOL	
++0x47d327fe	regulator_map_voltage_pickable_linear_range	vmlinux	EXPORT_SYMBOL_GPL	
++0xc120bc73	jbd2_journal_force_commit_nested	vmlinux	EXPORT_SYMBOL	
++0x78948ef4	seq_pad	vmlinux	EXPORT_SYMBOL	
++0x0b5c8199	seq_release_private	vmlinux	EXPORT_SYMBOL	
++0x016bfbe6	ww_mutex_lock	vmlinux	EXPORT_SYMBOL_GPL	
++0x082683fc	__mdiobus_modify_changed	vmlinux	EXPORT_SYMBOL_GPL	
++0x16dfbf36	add_interrupt_randomness	vmlinux	EXPORT_SYMBOL_GPL	
++0x3cad1345	uart_console_write	vmlinux	EXPORT_SYMBOL_GPL	
++0x30972d00	gpiod_get_array_value_cansleep	vmlinux	EXPORT_SYMBOL_GPL	
++0x1bee4974	sg_alloc_table_chained	vmlinux	EXPORT_SYMBOL_GPL	
++0x57f576b9	mpi_ec_curve_point	vmlinux	EXPORT_SYMBOL_GPL	
++0x436a0e05	writeback_inodes_sb_nr	vmlinux	EXPORT_SYMBOL	
++0xf3f15242	vfs_removexattr	vmlinux	EXPORT_SYMBOL_GPL	
++0xa588594e	lock_page_memcg	vmlinux	EXPORT_SYMBOL	
++0x512d8e9d	sdio_readsb	vmlinux	EXPORT_SYMBOL_GPL	
++0xab24f1e5	rtc_set_time	vmlinux	EXPORT_SYMBOL_GPL	
++0x48019b57	usb_stor_host_template_init	vmlinux	EXPORT_SYMBOL_GPL	USB_STORAGE
++0x4bf94f4f	usb_phy_roothub_alloc	vmlinux	EXPORT_SYMBOL_GPL	
++0x01341f5d	mipi_dsi_dcs_set_display_off	vmlinux	EXPORT_SYMBOL	
++0x1d1441de	pcix_get_mmrbc	vmlinux	EXPORT_SYMBOL	
++0x7f0bca54	__traceiter_pnfs_mds_fallback_read_done	vmlinux	EXPORT_SYMBOL_GPL	
++0xf7801360	nfs41_maxgetdevinfo_overhead	vmlinux	EXPORT_SYMBOL_GPL	
++0x87587d66	jbd2_journal_check_used_features	vmlinux	EXPORT_SYMBOL	
++0xcd91b127	system_highpri_wq	vmlinux	EXPORT_SYMBOL_GPL	
++0x18a107d1	auth_domain_lookup	vmlinux	EXPORT_SYMBOL_GPL	
++0xb526ecc4	xfrm_audit_state_delete	vmlinux	EXPORT_SYMBOL_GPL	
++0xc2806f04	divider_recalc_rate	vmlinux	EXPORT_SYMBOL_GPL	
++0xa6557afc	fb_get_mode	vmlinux	EXPORT_SYMBOL	
++0xe4040acf	nfs4_schedule_session_recovery	vmlinux	EXPORT_SYMBOL_GPL	
++0xd21f1d35	__SCK__tp_func_tcp_send_reset	vmlinux	EXPORT_SYMBOL_GPL	
++0x199e5913	mmc_detect_change	vmlinux	EXPORT_SYMBOL	
++0x01a3fa43	gov_attr_set_init	vmlinux	EXPORT_SYMBOL_GPL	
++0x330a71e2	crypto_shash_setkey	vmlinux	EXPORT_SYMBOL_GPL	
++0x61aa2642	crypto_ahash_setkey	vmlinux	EXPORT_SYMBOL_GPL	
++0x186dbf45	tracing_cond_snapshot_data	vmlinux	EXPORT_SYMBOL_GPL	
++0x3e5e5251	rt_mutex_trylock	vmlinux	EXPORT_SYMBOL_GPL	
++0x1f0cb5bf	pm_power_off_prepare	vmlinux	EXPORT_SYMBOL_GPL	
++0x582b6275	xfrm_if_unregister_cb	vmlinux	EXPORT_SYMBOL	
++0x1b03403e	rtnl_link_get_net	vmlinux	EXPORT_SYMBOL	
++0x3b3d809b	sdio_readl	vmlinux	EXPORT_SYMBOL_GPL	
++0xddd8805f	sdio_readw	vmlinux	EXPORT_SYMBOL_GPL	
++0xfdc6dfd5	sdio_readb	vmlinux	EXPORT_SYMBOL_GPL	
++0x43db0959	cpufreq_freq_attr_scaling_available_freqs	vmlinux	EXPORT_SYMBOL_GPL	
++0x98e72785	usb_remove_phy	vmlinux	EXPORT_SYMBOL_GPL	
++0x39da0e9f	usb_remove_hcd	vmlinux	EXPORT_SYMBOL_GPL	
++0x3f7ca65f	device_store_bool	vmlinux	EXPORT_SYMBOL_GPL	
++0x7c110464	nfs_fs_type	vmlinux	EXPORT_SYMBOL_GPL	
++0xa1d3b04c	nfs_server_insert_lists	vmlinux	EXPORT_SYMBOL_GPL	
++0x027566d9	irq_work_queue	vmlinux	EXPORT_SYMBOL_GPL	
++0x16395796	tcp_disconnect	vmlinux	EXPORT_SYMBOL	
++0x37ae900b	__skb_ext_del	vmlinux	EXPORT_SYMBOL	
++0x708aa719	extcon_get_extcon_dev	vmlinux	EXPORT_SYMBOL_GPL	
++0x2c12310c	power_supply_put_battery_info	vmlinux	EXPORT_SYMBOL_GPL	
++0x3bc2e2a0	power_supply_get_battery_info	vmlinux	EXPORT_SYMBOL_GPL	
++0xc1dd8a14	put_device	vmlinux	EXPORT_SYMBOL_GPL	
++0x49bb459f	mark_info_dirty	vmlinux	EXPORT_SYMBOL	
++0x2469810f	__rcu_read_unlock	vmlinux	EXPORT_SYMBOL_GPL	
++0x248bc867	raw_notifier_call_chain_robust	vmlinux	EXPORT_SYMBOL_GPL	
++0x648eb59d	gc_inflight_list	vmlinux	EXPORT_SYMBOL	
++0x126321f3	nf_unregister_net_hooks	vmlinux	EXPORT_SYMBOL	
++0x2a68f48b	hid_hw_open	vmlinux	EXPORT_SYMBOL_GPL	
++0x16522f3a	devm_power_supply_register_no_ws	vmlinux	EXPORT_SYMBOL_GPL	
++0xb684be35	devm_input_allocate_device	vmlinux	EXPORT_SYMBOL	
++0xde9ea0fd	usb_phy_roothub_resume	vmlinux	EXPORT_SYMBOL_GPL	
++0xb9cc1a1d	spi_alloc_device	vmlinux	EXPORT_SYMBOL_GPL	
++0x5b3949ad	register_filesystem	vmlinux	EXPORT_SYMBOL	
++0x9820426f	__static_key_slow_dec_deferred	vmlinux	EXPORT_SYMBOL_GPL	
++0x93170790	blk_fill_rwbs	vmlinux	EXPORT_SYMBOL_GPL	
++0xa5d13f52	sched_trace_rq_nr_running	vmlinux	EXPORT_SYMBOL_GPL	
++0xba497f13	loops_per_jiffy	vmlinux	EXPORT_SYMBOL	
++0xc87e7d69	inet_confirm_addr	vmlinux	EXPORT_SYMBOL	
++0x995a4d13	eth_validate_addr	vmlinux	EXPORT_SYMBOL	
++0x9425bb34	nvmem_dev_name	vmlinux	EXPORT_SYMBOL_GPL	
++0x6fbff47d	hid_hw_close	vmlinux	EXPORT_SYMBOL_GPL	
++0xee0aedd5	mmc_gpio_set_cd_isr	vmlinux	EXPORT_SYMBOL	
++0x2c208607	power_supply_is_system_supplied	vmlinux	EXPORT_SYMBOL_GPL	
++0xe628bb9f	phy_fibre_port_array	vmlinux	EXPORT_SYMBOL_GPL	
++0x978cece6	clk_hw_unregister_divider	vmlinux	EXPORT_SYMBOL_GPL	
++0x16e0170c	btree_init	vmlinux	EXPORT_SYMBOL_GPL	
++0x02b8ab42	sg_copy_to_buffer	vmlinux	EXPORT_SYMBOL	
++0x30a44ac3	__SCK__tp_func_ff_layout_write_error	vmlinux	EXPORT_SYMBOL_GPL	
++0x7d0db45c	jiffies_to_clock_t	vmlinux	EXPORT_SYMBOL	
++0x7ab88a45	system_freezing_cnt	vmlinux	EXPORT_SYMBOL	
++0xa74c9877	refcount_dec_and_rtnl_lock	vmlinux	EXPORT_SYMBOL	
++0xa38cad19	sock_no_sendmsg_locked	vmlinux	EXPORT_SYMBOL	
++0x6ddb8b31	hidraw_disconnect	vmlinux	EXPORT_SYMBOL_GPL	
++0x30fd683e	usb_debug_root	vmlinux	EXPORT_SYMBOL_GPL	
++0xc567608f	tty_kopen	vmlinux	EXPORT_SYMBOL_GPL	
++0x368b9512	regulator_get_exclusive	vmlinux	EXPORT_SYMBOL_GPL	
++0xc4bdf03a	btree_merge	vmlinux	EXPORT_SYMBOL_GPL	
++0xacab29b7	seq_hlist_start_percpu	vmlinux	EXPORT_SYMBOL	
++0x87245506	generic_file_llseek_size	vmlinux	EXPORT_SYMBOL	
++0x1c87a811	__round_jiffies_up	vmlinux	EXPORT_SYMBOL_GPL	
++0x8ec98beb	nexthop_for_each_fib6_nh	vmlinux	EXPORT_SYMBOL_GPL	
++0x02124474	ip_send_check	vmlinux	EXPORT_SYMBOL	
++0xd78cea32	netdev_name_node_alt_create	vmlinux	EXPORT_SYMBOL	
++0x3c666805	__vfs_setxattr_locked	vmlinux	EXPORT_SYMBOL_GPL	
++0x23b9d6e2	mangle_path	vmlinux	EXPORT_SYMBOL	
++0xd894e201	mbox_controller_register	vmlinux	EXPORT_SYMBOL_GPL	
++0x278365e9	__genphy_config_aneg	vmlinux	EXPORT_SYMBOL	
++0xc5604800	clk_set_rate_exclusive	vmlinux	EXPORT_SYMBOL_GPL	
++0xfdd9e1a3	pci_get_domain_bus_and_slot	vmlinux	EXPORT_SYMBOL	
++0x83fb5951	pinctrl_find_gpio_range_from_pin_nolock	vmlinux	EXPORT_SYMBOL_GPL	
++0x2b576535	anon_inode_getfd	vmlinux	EXPORT_SYMBOL_GPL	
++0xd3add9e2	bd_abort_claiming	vmlinux	EXPORT_SYMBOL	
++0xb09084af	filemap_flush	vmlinux	EXPORT_SYMBOL	
++0x2e0ee1fa	ethnl_cable_test_free	vmlinux	EXPORT_SYMBOL_GPL	
++0x72b2f5cf	tcf_idr_create	vmlinux	EXPORT_SYMBOL	
++0x64ea5232	mbox_controller_unregister	vmlinux	EXPORT_SYMBOL_GPL	
++0x5c9011f9	serial8250_rpm_put_tx	vmlinux	EXPORT_SYMBOL_GPL	
++0x31699ab4	pinconf_generic_dt_node_to_map	vmlinux	EXPORT_SYMBOL_GPL	
++0xcfde3c72	pin_get_name	vmlinux	EXPORT_SYMBOL_GPL	
++0x5558e2a0	blk_stack_limits	vmlinux	EXPORT_SYMBOL	
++0xad9da84a	rpc_mkpipe_data	vmlinux	EXPORT_SYMBOL_GPL	
++0x77192c20	unix_domain_find	vmlinux	EXPORT_SYMBOL_GPL	
++0x0ecf3398	__fib_lookup	vmlinux	EXPORT_SYMBOL_GPL	
++0x1b248ed2	tcp_set_state	vmlinux	EXPORT_SYMBOL_GPL	
++0xa9361c74	i2c_smbus_read_i2c_block_data	vmlinux	EXPORT_SYMBOL	
++0xd91f6ab6	strnlen_user	vmlinux	EXPORT_SYMBOL	
++0x19cead4e	input_set_poll_interval	vmlinux	EXPORT_SYMBOL	
++0x37939ebc	of_genpd_add_device	vmlinux	EXPORT_SYMBOL_GPL	
++0x97686881	serial8250_modem_status	vmlinux	EXPORT_SYMBOL_GPL	
++0xb76dcf48	set_create_files_as	vmlinux	EXPORT_SYMBOL	
++0xfebeaee1	dev_get_by_name	vmlinux	EXPORT_SYMBOL	
++0xef78c13c	sdhci_dumpregs	vmlinux	EXPORT_SYMBOL_GPL	
++0xbd1435f7	power_supply_set_battery_charged	vmlinux	EXPORT_SYMBOL_GPL	
++0x42a7ed69	serial8250_init_port	vmlinux	EXPORT_SYMBOL_GPL	
++0x7732eb79	pci_enable_msix_range	vmlinux	EXPORT_SYMBOL	
++0xd1e989e7	iov_iter_get_pages	vmlinux	EXPORT_SYMBOL	
++0x8693b8b6	__page_symlink	vmlinux	EXPORT_SYMBOL	
++0xa38a9f71	get_itimerspec64	vmlinux	EXPORT_SYMBOL_GPL	
++0x30a80826	__kfifo_from_user	vmlinux	EXPORT_SYMBOL	
++0x8ddd0f4e	cdev_set_parent	vmlinux	EXPORT_SYMBOL	
++0x69d788c7	irq_work_sync	vmlinux	EXPORT_SYMBOL_GPL	
++0x6ea8b77c	unregister_kretprobes	vmlinux	EXPORT_SYMBOL_GPL	
++0x0b1bb9f9	synchronize_rcu_tasks	vmlinux	EXPORT_SYMBOL_GPL	
++0x28c63f47	udp_prot	vmlinux	EXPORT_SYMBOL	
++0x1b92e41d	inet_putpeer	vmlinux	EXPORT_SYMBOL_GPL	
++0xa01b247f	__hw_addr_ref_unsync_dev	vmlinux	EXPORT_SYMBOL	
++0xc702ba4b	netif_set_xps_queue	vmlinux	EXPORT_SYMBOL	
++0x15cfac41	i2c_adapter_type	vmlinux	EXPORT_SYMBOL_GPL	
++0xea2d0f8c	pci_msi_vec_count	vmlinux	EXPORT_SYMBOL	
++0x5f69f869	__dev_set_mtu	vmlinux	EXPORT_SYMBOL	
++0x0dca2153	rc_keydown_notimeout	vmlinux	EXPORT_SYMBOL_GPL	
++0xc3945517	clkdev_hw_alloc	vmlinux	EXPORT_SYMBOL	
++0x2a31e8a1	unregister_quota_format	vmlinux	EXPORT_SYMBOL	
++0x47efc640	rt_write_trylock	vmlinux	EXPORT_SYMBOL	
++0xf1e98c74	avenrun	vmlinux	EXPORT_SYMBOL	
++0x2d3385d3	system_wq	vmlinux	EXPORT_SYMBOL	
++0xa5574b28	ethtool_set_ethtool_phy_ops	vmlinux	EXPORT_SYMBOL_GPL	
++0x4618e67c	mmc_calc_max_discard	vmlinux	EXPORT_SYMBOL	
++0x3f9d5270	dev_pm_opp_set_sharing_cpus	vmlinux	EXPORT_SYMBOL_GPL	
++0x15ed136a	mark_page_accessed	vmlinux	EXPORT_SYMBOL	
++0x1edb69d6	ktime_get_raw_ts64	vmlinux	EXPORT_SYMBOL	
++0x200b2041	in6addr_any	vmlinux	EXPORT_SYMBOL	
++0xef71c46b	inet_protos	vmlinux	EXPORT_SYMBOL	
++0x02a18c74	nf_conntrack_destroy	vmlinux	EXPORT_SYMBOL	
++0xf876deb9	scsi_report_bus_reset	vmlinux	EXPORT_SYMBOL	
++0xac30c328	tty_port_install	vmlinux	EXPORT_SYMBOL_GPL	
++0xdcd11690	phy_set_mode_ext	vmlinux	EXPORT_SYMBOL_GPL	
++0x57a3cf1a	of_get_next_available_child	vmlinux	EXPORT_SYMBOL	
++0xb1666cd6	hid_output_report	vmlinux	EXPORT_SYMBOL_GPL	
++0x64557490	cpuidle_get_cpu_driver	vmlinux	EXPORT_SYMBOL_GPL	
++0x8855558a	__usb_create_hcd	vmlinux	EXPORT_SYMBOL_GPL	
++0x4401e6c2	mpi_cmpabs	vmlinux	EXPORT_SYMBOL_GPL	
++0x9bece81b	mpi_cmp_ui	vmlinux	EXPORT_SYMBOL_GPL	
++0x2ec6bba0	errseq_set	vmlinux	EXPORT_SYMBOL	
++0x862c8035	bitmap_alloc_node	vmlinux	EXPORT_SYMBOL	
++0x0146a80d	vfs_parse_fs_string	vmlinux	EXPORT_SYMBOL	
++0x6d912df1	cdev_add	vmlinux	EXPORT_SYMBOL	
++0x788bfbad	ring_buffer_empty	vmlinux	EXPORT_SYMBOL_GPL	
++0xd260af0d	ring_buffer_write	vmlinux	EXPORT_SYMBOL_GPL	
++0xeeacab69	rpc_update_rtt	vmlinux	EXPORT_SYMBOL_GPL	
++0x4ec8c7ae	xfrm_input	vmlinux	EXPORT_SYMBOL	
++0x9c30fe45	dev_mc_del	vmlinux	EXPORT_SYMBOL	
++0xe71951ce	dev_mc_add	vmlinux	EXPORT_SYMBOL	
++0xadbe6d75	dev_uc_del	vmlinux	EXPORT_SYMBOL	
++0xd697c2fe	dev_uc_add	vmlinux	EXPORT_SYMBOL	
++0xdc31dd9c	register_pernet_subsys	vmlinux	EXPORT_SYMBOL_GPL	
++0x668eb048	__skb_ext_put	vmlinux	EXPORT_SYMBOL	
++0x6076b4ae	rtc_update_irq	vmlinux	EXPORT_SYMBOL_GPL	
++0x5eae2b12	fb_blank	vmlinux	EXPORT_SYMBOL	
++0x7f8bb165	devm_gpiod_get	vmlinux	EXPORT_SYMBOL_GPL	
++0xc3018722	blk_queue_update_dma_pad	vmlinux	EXPORT_SYMBOL	
++0x3cd10e0d	blkdev_get_by_path	vmlinux	EXPORT_SYMBOL	
++0x69f0e9f3	open_exec	vmlinux	EXPORT_SYMBOL	
++0x389c3a49	inet_gro_receive	vmlinux	EXPORT_SYMBOL	
++0x392d03bd	iscsi_remove_session	vmlinux	EXPORT_SYMBOL_GPL	
++0xaf4870fb	cpu_subsys	vmlinux	EXPORT_SYMBOL_GPL	
++0x9d61e994	ucs2_strncmp	vmlinux	EXPORT_SYMBOL	
++0xa77b3b62	des3_ede_expand_key	vmlinux	EXPORT_SYMBOL_GPL	
++0xbd462b55	__kfifo_init	vmlinux	EXPORT_SYMBOL	
++0x2da0499c	blkcg_activate_policy	vmlinux	EXPORT_SYMBOL_GPL	
++0x47a0cdcb	mb_cache_entry_find_next	vmlinux	EXPORT_SYMBOL	
++0xd3c32c0c	inode_init_owner	vmlinux	EXPORT_SYMBOL	
++0xb0b88af8	__traceiter_signal_generate	vmlinux	EXPORT_SYMBOL	
++0x8000c2d4	file_ns_capable	vmlinux	EXPORT_SYMBOL	
++0x2a992c08	xfrm_dev_state_add	vmlinux	EXPORT_SYMBOL_GPL	
++0x58e0ed73	of_clk_set_defaults	vmlinux	EXPORT_SYMBOL_GPL	
++0xd9c86fd8	pci_find_next_capability	vmlinux	EXPORT_SYMBOL_GPL	
++0x75be2a4c	__xa_insert	vmlinux	EXPORT_SYMBOL	
++0x20ee0152	nfs_ssc_client_tbl	vmlinux	EXPORT_SYMBOL_GPL	
++0x400977fe	fs_context_for_reconfigure	vmlinux	EXPORT_SYMBOL	
++0xdbf4f585	list_lru_count_one	vmlinux	EXPORT_SYMBOL_GPL	
++0xa2b0820d	__SCK__tp_func_cpu_idle	vmlinux	EXPORT_SYMBOL_GPL	
++0xbb6508da	random_get_entropy_fallback	vmlinux	EXPORT_SYMBOL_GPL	
++0x62b3106f	rt_mutex_destroy	vmlinux	EXPORT_SYMBOL_GPL	
++0x2821571f	queue_delayed_work_on	vmlinux	EXPORT_SYMBOL	
++0xd4034828	system_freezable_wq	vmlinux	EXPORT_SYMBOL_GPL	
++0x4af43ab2	qdisc_put_unlocked	vmlinux	EXPORT_SYMBOL	
++0x84e2100b	skb_gso_validate_mac_len	vmlinux	EXPORT_SYMBOL_GPL	
++0x6f670b49	iscsi_destroy_endpoint	vmlinux	EXPORT_SYMBOL_GPL	
++0x2403ad87	pm_genpd_add_device	vmlinux	EXPORT_SYMBOL_GPL	
++0x419530ea	devres_open_group	vmlinux	EXPORT_SYMBOL_GPL	
++0xe73a97fa	pci_read_config_dword	vmlinux	EXPORT_SYMBOL	
++0x0828163f	__set_page_dirty_nobuffers	vmlinux	EXPORT_SYMBOL	
++0x70d24254	bpf_prog_inc_not_zero	vmlinux	EXPORT_SYMBOL_GPL	
++0x26fe0fe0	svc_xprt_copy_addrs	vmlinux	EXPORT_SYMBOL_GPL	
++0xc15594db	usbnet_unlink_rx_urbs	vmlinux	EXPORT_SYMBOL_GPL	
++0x7e7759f5	clk_hw_unregister	vmlinux	EXPORT_SYMBOL_GPL	
++0x8e4347a6	devm_pwm_get	vmlinux	EXPORT_SYMBOL_GPL	
++0x765da84d	gpiochip_line_is_open_source	vmlinux	EXPORT_SYMBOL_GPL	
++0x98503a63	mpi_alloc	vmlinux	EXPORT_SYMBOL_GPL	
++0x06c18050	mempool_create_node	vmlinux	EXPORT_SYMBOL	
++0x8ffe792f	tracepoint_probe_register_prio_may_exist	vmlinux	EXPORT_SYMBOL_GPL	
++0x85c1f567	find_get_pid	vmlinux	EXPORT_SYMBOL_GPL	
++0x7119b4be	dev_set_promiscuity	vmlinux	EXPORT_SYMBOL	
++0x5263cdba	usb_stor_transparent_scsi_command	vmlinux	EXPORT_SYMBOL_GPL	USB_STORAGE
++0x54b4b108	scsi_bios_ptable	vmlinux	EXPORT_SYMBOL	
++0x23daa989	mipi_dsi_create_packet	vmlinux	EXPORT_SYMBOL	
++0xfa7741c2	pci_write_vpd	vmlinux	EXPORT_SYMBOL	
++0x07134a9a	pci_generic_config_write32	vmlinux	EXPORT_SYMBOL_GPL	
++0x3b2606ad	configfs_depend_item_unlocked	vmlinux	EXPORT_SYMBOL	
++0x6d37d963	start_critical_timings	vmlinux	EXPORT_SYMBOL_GPL	
++0xd72706bc	tcp_unregister_ulp	vmlinux	EXPORT_SYMBOL_GPL	
++0xd0cd12a6	__traceiter_neigh_cleanup_and_release	vmlinux	EXPORT_SYMBOL_GPL	
++0x1c3c7749	neigh_connected_output	vmlinux	EXPORT_SYMBOL	
++0xc529584d	nvme_reset_ctrl_sync	vmlinux	EXPORT_SYMBOL_GPL	
++0x2421097b	mpi_const	vmlinux	EXPORT_SYMBOL_GPL	
++0xe9f7149c	zlib_deflate_workspacesize	vmlinux	EXPORT_SYMBOL	
++0x6109633f	posix_acl_create	vmlinux	EXPORT_SYMBOL_GPL	
++0x38f2cc3b	irq_domain_translate_twocell	vmlinux	EXPORT_SYMBOL_GPL	
++0x6a94e349	irq_set_chained_handler_and_data	vmlinux	EXPORT_SYMBOL_GPL	
++0x3c57e1a4	__percpu_init_rwsem	vmlinux	EXPORT_SYMBOL_GPL	
++0x7bc8b769	down_read_killable	vmlinux	EXPORT_SYMBOL	
++0x125045cb	param_set_ushort	vmlinux	EXPORT_SYMBOL	
++0x76b78908	svc_recv	vmlinux	EXPORT_SYMBOL_GPL	
++0x392ac2e3	udp_flush_pending_frames	vmlinux	EXPORT_SYMBOL	
++0xc0ffe201	xdp_rxq_info_is_reg	vmlinux	EXPORT_SYMBOL_GPL	
++0x317b1da1	dev_get_stats	vmlinux	EXPORT_SYMBOL	
++0x6340ba8c	skb_vlan_untag	vmlinux	EXPORT_SYMBOL	
++0x446d767c	of_property_read_variable_u64_array	vmlinux	EXPORT_SYMBOL_GPL	
++0x9bbbfb45	of_property_read_variable_u32_array	vmlinux	EXPORT_SYMBOL_GPL	
++0x934b4059	of_property_read_variable_u16_array	vmlinux	EXPORT_SYMBOL_GPL	
++0x851e6003	usb_phy_roothub_calibrate	vmlinux	EXPORT_SYMBOL_GPL	
++0xbd4ae209	genphy_c45_pma_setup_forced	vmlinux	EXPORT_SYMBOL_GPL	
++0x4e68e9be	rb_next_postorder	vmlinux	EXPORT_SYMBOL	
++0x319e145a	parse_OID	vmlinux	EXPORT_SYMBOL_GPL	
++0x86fb9b05	bitmap_parse_user	vmlinux	EXPORT_SYMBOL	
++0x488498b9	pnfs_generic_pg_writepages	vmlinux	EXPORT_SYMBOL_GPL	
++0xaa8975ca	__fs_parse	vmlinux	EXPORT_SYMBOL	
++0x01000e51	schedule	vmlinux	EXPORT_SYMBOL	
++0x1e3941e3	nlmsg_notify	vmlinux	EXPORT_SYMBOL	
++0xe7c22714	watchdog_unregister_device	vmlinux	EXPORT_SYMBOL_GPL	
++0x0f889363	dma_fence_free	vmlinux	EXPORT_SYMBOL	
++0x29c53309	serial8250_do_set_divisor	vmlinux	EXPORT_SYMBOL_GPL	
++0xa1c01e62	blk_mq_tag_to_rq	vmlinux	EXPORT_SYMBOL	
++0x807c1501	proc_create_net_single_write	vmlinux	EXPORT_SYMBOL_GPL	
++0x8b822459	ww_mutex_unlock	vmlinux	EXPORT_SYMBOL	
++0xb0f657d1	mmput	vmlinux	EXPORT_SYMBOL_GPL	
++0x1ee67361	init_task	vmlinux	EXPORT_SYMBOL	
++0xb8fdf222	vlan_dev_vlan_proto	vmlinux	EXPORT_SYMBOL	
++0xc9201883	__hw_addr_sync_dev	vmlinux	EXPORT_SYMBOL	
++0x2c4b4d00	skb_eth_push	vmlinux	EXPORT_SYMBOL	
++0x5391a730	usbnet_set_link_ksettings	vmlinux	EXPORT_SYMBOL_GPL	
++0xfb1b43b7	usbnet_get_link_ksettings	vmlinux	EXPORT_SYMBOL_GPL	
++0x3b574c6f	__bcm_phy_read_exp	vmlinux	EXPORT_SYMBOL_GPL	
++0xdbaf059c	nvme_complete_async_event	vmlinux	EXPORT_SYMBOL_GPL	
++0x593b8d7b	pcibios_resource_to_bus	vmlinux	EXPORT_SYMBOL	
++0xc9c37143	refcount_dec_and_lock	vmlinux	EXPORT_SYMBOL	
++0x5fa9ed20	csum_and_copy_from_iter_full	vmlinux	EXPORT_SYMBOL	
++0xacd25f62	nfs_check_cache_invalid	vmlinux	EXPORT_SYMBOL_GPL	
++0x9367c81f	__fscache_wait_on_page_write	vmlinux	EXPORT_SYMBOL	
++0xe6afadc4	rpc_sleep_on_priority_timeout	vmlinux	EXPORT_SYMBOL_GPL	
++0x0a992891	gnet_stats_copy_app	vmlinux	EXPORT_SYMBOL	
++0x4d248021	i2c_verify_client	vmlinux	EXPORT_SYMBOL	
++0x1e139d0c	input_allocate_device	vmlinux	EXPORT_SYMBOL	
++0x8bd4f98d	pm_runtime_barrier	vmlinux	EXPORT_SYMBOL_GPL	
++0xf42c568b	dev_printk	vmlinux	EXPORT_SYMBOL	
++0xcf60c97d	pci_set_pcie_reset_state	vmlinux	EXPORT_SYMBOL_GPL	
++0x3ab4a866	phy_power_on	vmlinux	EXPORT_SYMBOL_GPL	
++0x1b015d25	bitmap_parselist	vmlinux	EXPORT_SYMBOL	
++0x779e8954	__insert_inode_hash	vmlinux	EXPORT_SYMBOL	
++0xf474fdcb	kfree_const	vmlinux	EXPORT_SYMBOL	
++0xf9093f5b	__tracepoint_cpu_frequency	vmlinux	EXPORT_SYMBOL_GPL	
++0x1032eec1	revert_creds	vmlinux	EXPORT_SYMBOL	
++0xdf929370	fs_overflowgid	vmlinux	EXPORT_SYMBOL	
++0x032c8bd0	tasklet_unlock_spin_wait	vmlinux	EXPORT_SYMBOL	
++0xbc488897	reuseport_attach_prog	vmlinux	EXPORT_SYMBOL	
++0x0158f9e1	usb_del_gadget	vmlinux	EXPORT_SYMBOL_GPL	
++0x554a3fcf	reset_controller_unregister	vmlinux	EXPORT_SYMBOL_GPL	
++0xc8a91f5b	cpumask_local_spread	vmlinux	EXPORT_SYMBOL	
++0xc66a8304	cpu_rmap_add	vmlinux	EXPORT_SYMBOL	
++0x9f49dcc4	__stack_chk_fail	vmlinux	EXPORT_SYMBOL	
++0x78a2dd0a	xfrm_policy_walk	vmlinux	EXPORT_SYMBOL	
++0xe554c983	nf_log_unset	vmlinux	EXPORT_SYMBOL	
++0x596eecea	dev_pm_opp_of_remove_table	vmlinux	EXPORT_SYMBOL_GPL	
++0x38dbd735	fbcon_set_rotate	vmlinux	EXPORT_SYMBOL	
++0xc202a8b7	pcie_get_speed_cap	vmlinux	EXPORT_SYMBOL	
++0x97de2b83	debug_locks_silent	vmlinux	EXPORT_SYMBOL_GPL	
++0x43c1337b	nfs_client_init_is_complete	vmlinux	EXPORT_SYMBOL_GPL	
++0x831ce4d0	blocking_notifier_call_chain	vmlinux	EXPORT_SYMBOL_GPL	
++0xe1d81e94	has_capability_noaudit	vmlinux	EXPORT_SYMBOL	
++0x110e045a	ping_hash	vmlinux	EXPORT_SYMBOL_GPL	
++0x6628f5a8	__napi_schedule_irqoff	vmlinux	EXPORT_SYMBOL	
++0x5b1254eb	regmap_read	vmlinux	EXPORT_SYMBOL_GPL	
++0xf3332307	regulator_set_suspend_voltage	vmlinux	EXPORT_SYMBOL_GPL	
++0xc917e389	crypto_unregister_skciphers	vmlinux	EXPORT_SYMBOL_GPL	
++0xd1dcd2eb	nfs_init_commit	vmlinux	EXPORT_SYMBOL_GPL	
++0x81372b16	dquot_quota_off	vmlinux	EXPORT_SYMBOL	
++0x6b106e5e	kthread_flush_work	vmlinux	EXPORT_SYMBOL_GPL	
++0x5023cc56	xfrm_audit_state_add	vmlinux	EXPORT_SYMBOL_GPL	
++0x7a09f336	__skb_checksum_complete	vmlinux	EXPORT_SYMBOL	
++0xe6ebf977	power_supply_register_no_ws	vmlinux	EXPORT_SYMBOL_GPL	
++0x81b2fdc6	genphy_read_lpa	vmlinux	EXPORT_SYMBOL	
++0xacf86cbb	tty_lock	vmlinux	EXPORT_SYMBOL	
++0x6c60b777	regulator_register	vmlinux	EXPORT_SYMBOL_GPL	
++0xd5b3d0d5	xxh64_copy_state	vmlinux	EXPORT_SYMBOL	
++0xbe5a24e9	xxh32_copy_state	vmlinux	EXPORT_SYMBOL	
++0x755f4ba3	blake2s_compress_generic	vmlinux	EXPORT_SYMBOL	
++0xb5a459dc	unregister_blkdev	vmlinux	EXPORT_SYMBOL	
++0x1b2ede85	key_alloc	vmlinux	EXPORT_SYMBOL	
++0xeab04164	nfs_ssc_unregister	vmlinux	EXPORT_SYMBOL_GPL	
++0x40b3cf36	write_inode_now	vmlinux	EXPORT_SYMBOL	
++0x2d00dc6a	init_pseudo	vmlinux	EXPORT_SYMBOL	
++0x6005c351	zpool_has_pool	vmlinux	EXPORT_SYMBOL	
++0xa7cba284	housekeeping_any_cpu	vmlinux	EXPORT_SYMBOL_GPL	
++0x111666a8	__inval_dcache_area	vmlinux	EXPORT_SYMBOL	
++0x50f85302	__arm_smccc_hvc	vmlinux	EXPORT_SYMBOL	
++0xf93aae46	__arm_smccc_smc	vmlinux	EXPORT_SYMBOL	
++0x2f0d9053	usb_otg_state_string	vmlinux	EXPORT_SYMBOL_GPL	
++0x6c257ac0	tty_termios_hw_change	vmlinux	EXPORT_SYMBOL	
++0x776b4643	gpiochip_line_is_valid	vmlinux	EXPORT_SYMBOL_GPL	
++0x59094597	radix_tree_replace_slot	vmlinux	EXPORT_SYMBOL	
++0x414f6873	crypto_rng_reset	vmlinux	EXPORT_SYMBOL_GPL	
++0x7b5a4926	sha1_zero_message_hash	vmlinux	EXPORT_SYMBOL_GPL	
++0xaeecf28a	security_dentry_create_files_as	vmlinux	EXPORT_SYMBOL	
++0x962c6aa6	fat_search_long	vmlinux	EXPORT_SYMBOL_GPL	
++0xd49bb78b	seq_path	vmlinux	EXPORT_SYMBOL	
++0xcc5005fe	msleep_interruptible	vmlinux	EXPORT_SYMBOL	
++0xdc6596fa	irq_set_parent	vmlinux	EXPORT_SYMBOL_GPL	
++0xd7673035	g_verify_token_header	vmlinux	EXPORT_SYMBOL_GPL	
++0x41e439a3	dev_addr_add	vmlinux	EXPORT_SYMBOL	
++0x2d03be11	netdev_err	vmlinux	EXPORT_SYMBOL	
++0x62849ac7	dev_valid_name	vmlinux	EXPORT_SYMBOL	
++0x196449a3	kfree_skb_partial	vmlinux	EXPORT_SYMBOL	
++0x167cb470	__sk_mem_reduce_allocated	vmlinux	EXPORT_SYMBOL	
++0x0f49425b	of_node_name_prefix	vmlinux	EXPORT_SYMBOL	
++0x89bbafc6	usb_register_notify	vmlinux	EXPORT_SYMBOL_GPL	
++0x781ec4eb	radix_tree_tag_clear	vmlinux	EXPORT_SYMBOL	
++0xb0a0da0c	rational_best_approximation	vmlinux	EXPORT_SYMBOL	
++0x1af267f8	int_pow	vmlinux	EXPORT_SYMBOL_GPL	
++0xf888ca21	sg_init_table	vmlinux	EXPORT_SYMBOL	
++0x5f12e0e4	blk_pre_runtime_resume	vmlinux	EXPORT_SYMBOL	
++0xf8b11c6b	fsnotify	vmlinux	EXPORT_SYMBOL_GPL	
++0xe98fcaa4	generic_file_open	vmlinux	EXPORT_SYMBOL	
++0x2d521519	fixup_user_fault	vmlinux	EXPORT_SYMBOL_GPL	
++0xb43f9365	ktime_get	vmlinux	EXPORT_SYMBOL_GPL	
++0x56c423bf	regset_get	vmlinux	EXPORT_SYMBOL	
++0xd19fa77d	inet_addr_type_dev_table	vmlinux	EXPORT_SYMBOL	
++0xccfe7b40	__mdiobus_register	vmlinux	EXPORT_SYMBOL	
++0x7204ad70	genphy_update_link	vmlinux	EXPORT_SYMBOL	
++0x37fcfdfa	arizona_clk32k_disable	vmlinux	EXPORT_SYMBOL_GPL	
++0xb48f0638	software_node_register	vmlinux	EXPORT_SYMBOL_GPL	
++0x6749d53f	hdmi_vendor_infoframe_init	vmlinux	EXPORT_SYMBOL	
++0xaa328ea2	generic_cont_expand_simple	vmlinux	EXPORT_SYMBOL	
++0x9b26545a	__vfs_setxattr	vmlinux	EXPORT_SYMBOL	
++0x6d09b50e	d_instantiate	vmlinux	EXPORT_SYMBOL	
++0xfeadaf88	irq_chip_unmask_parent	vmlinux	EXPORT_SYMBOL_GPL	
++0x59a5ad12	rpc_clnt_swap_deactivate	vmlinux	EXPORT_SYMBOL_GPL	
++0x11e9c2e8	__icmpv6_send	vmlinux	EXPORT_SYMBOL	
++0x19821689	__tracepoint_fdb_delete	vmlinux	EXPORT_SYMBOL_GPL	
++0x174211d9	skb_set_owner_w	vmlinux	EXPORT_SYMBOL	
++0x4936b0d8	register_sound_special_device	vmlinux	EXPORT_SYMBOL	
++0xf236ab38	thermal_zone_of_sensor_register	vmlinux	EXPORT_SYMBOL_GPL	
++0x118f4daf	iscsi_ping_comp_event	vmlinux	EXPORT_SYMBOL_GPL	
++0xe73f7f45	__nla_put_64bit	vmlinux	EXPORT_SYMBOL	
++0x0efdebb7	__nla_parse	vmlinux	EXPORT_SYMBOL	
++0xf642931d	page_mapping	vmlinux	EXPORT_SYMBOL	
++0xc8362698	usb_of_get_interface_node	vmlinux	EXPORT_SYMBOL_GPL	
++0x4df02057	crc32_be	vmlinux	EXPORT_SYMBOL	
++0x5bbdfa26	scatterwalk_ffwd	vmlinux	EXPORT_SYMBOL_GPL	
++0x09d879ba	__fscache_unregister_netfs	vmlinux	EXPORT_SYMBOL	
++0x4b5d5253	iomap_readpage	vmlinux	EXPORT_SYMBOL_GPL	
++0x26520970	vm_memory_committed	vmlinux	EXPORT_SYMBOL_GPL	
++0x5df4acf1	rpc_restart_call	vmlinux	EXPORT_SYMBOL_GPL	
++0x3d08c141	xfrm_output_resume	vmlinux	EXPORT_SYMBOL_GPL	
++0x935beb24	dev_get_phys_port_name	vmlinux	EXPORT_SYMBOL	
++0x836c25e1	skb_find_text	vmlinux	EXPORT_SYMBOL	
++0x4d88d4af	i2c_unregister_device	vmlinux	EXPORT_SYMBOL_GPL	
++0x09bc3362	regulator_unregister	vmlinux	EXPORT_SYMBOL_GPL	
++0x236f852f	pci_clear_master	vmlinux	EXPORT_SYMBOL	
++0x20fff6ec	ZSTD_DStreamInSize	vmlinux	EXPORT_SYMBOL	
++0xe96e2117	dump_align	vmlinux	EXPORT_SYMBOL	
++0xbbe80fdb	kmalloc_order	vmlinux	EXPORT_SYMBOL	
++0x5b78bde6	__dec_node_page_state	vmlinux	EXPORT_SYMBOL	
++0x96967746	__inc_node_page_state	vmlinux	EXPORT_SYMBOL	
++0x342beb50	__mod_node_page_state	vmlinux	EXPORT_SYMBOL	
++0x134cdd34	inet_frag_rbtree_purge	vmlinux	EXPORT_SYMBOL	
++0x15d0e36b	skb_queue_tail	vmlinux	EXPORT_SYMBOL	
++0xc42a0945	dwc_cc_cdid	vmlinux	EXPORT_SYMBOL	
++0x45341fc8	dwc_cc_chid	vmlinux	EXPORT_SYMBOL	
++0x7732159c	free_irq_cpu_rmap	vmlinux	EXPORT_SYMBOL	
++0xe70dcfe0	crypto_lookup_template	vmlinux	EXPORT_SYMBOL_GPL	
++0x31108339	__register_nls	vmlinux	EXPORT_SYMBOL	
++0xa02f5066	register_sysctl	vmlinux	EXPORT_SYMBOL	
++0xea23043c	vfs_test_lock	vmlinux	EXPORT_SYMBOL_GPL	
++0x952664c5	do_exit	vmlinux	EXPORT_SYMBOL_GPL	
++0x5e78f834	l3mdev_master_upper_ifindex_by_index_rcu	vmlinux	EXPORT_SYMBOL_GPL	
++0x857a03e4	devm_device_add_groups	vmlinux	EXPORT_SYMBOL_GPL	
++0xeec87dcd	sbitmap_get_shallow	vmlinux	EXPORT_SYMBOL_GPL	
++0x3666c84e	set_capacity_revalidate_and_notify	vmlinux	EXPORT_SYMBOL_GPL	
++0x6085edbd	nfs_map_string_to_numeric	vmlinux	EXPORT_SYMBOL_GPL	
++0x572ae58e	mark_buffer_dirty_inode	vmlinux	EXPORT_SYMBOL	
++0x6261bdb1	DWC_VSNPRINTF	vmlinux	EXPORT_SYMBOL	
++0xaa87fc27	dev_pm_qos_remove_request	vmlinux	EXPORT_SYMBOL_GPL	
++0x879c0d06	fwnode_connection_find_match	vmlinux	EXPORT_SYMBOL_GPL	
++0x2ec8f5b6	dma_wait_for_async_tx	vmlinux	EXPORT_SYMBOL_GPL	
++0xf98b7093	devm_clk_bulk_get	vmlinux	EXPORT_SYMBOL_GPL	
++0xc04add1d	simple_dentry_operations	vmlinux	EXPORT_SYMBOL	
++0xead3e41b	__traceiter_cpu_frequency	vmlinux	EXPORT_SYMBOL_GPL	
++0xb1c3a01a	oops_in_progress	vmlinux	EXPORT_SYMBOL	
++0xf0fd9f78	netdev_lower_dev_get_private	vmlinux	EXPORT_SYMBOL	
++0x4c7a8fd6	tty_check_change	vmlinux	EXPORT_SYMBOL	
++0x420b7fb7	tty_insert_flip_string_fixed_flag	vmlinux	EXPORT_SYMBOL	
++0x2076e9b0	tty_register_ldisc	vmlinux	EXPORT_SYMBOL	
++0x027f0344	tty_throttle	vmlinux	EXPORT_SYMBOL	
++0x7019af27	btree_lookup	vmlinux	EXPORT_SYMBOL_GPL	
++0xa3cefaa0	blake2s_update	vmlinux	EXPORT_SYMBOL	
++0xeaad987d	public_key_subtype	vmlinux	EXPORT_SYMBOL_GPL	
++0xb77d98ea	kill_fasync	vmlinux	EXPORT_SYMBOL	
++0x8170fd75	sget_fc	vmlinux	EXPORT_SYMBOL	
++0x7e67b3b4	param_get_byte	vmlinux	EXPORT_SYMBOL	
++0xad995dac	netdev_stats_to_stats64	vmlinux	EXPORT_SYMBOL	
++0x1b71dce6	dev_disable_lro	vmlinux	EXPORT_SYMBOL	
++0x2132f9f8	sock_alloc	vmlinux	EXPORT_SYMBOL	
++0x6d5ef163	vchiq_release_message	vmlinux	EXPORT_SYMBOL	
++0x85ebbb0a	mmc_sanitize	vmlinux	EXPORT_SYMBOL_GPL	
++0x7a9e4c23	software_node_register_node_group	vmlinux	EXPORT_SYMBOL_GPL	
++0x9060131f	attribute_container_classdev_to_container	vmlinux	EXPORT_SYMBOL_GPL	
++0x21bdb523	errseq_check_and_advance	vmlinux	EXPORT_SYMBOL	
++0x77ff6b0c	lockref_get	vmlinux	EXPORT_SYMBOL	
++0xe93a2338	debugfs_create_u8	vmlinux	EXPORT_SYMBOL_GPL	
++0x2402e759	fscrypt_set_test_dummy_encryption	vmlinux	EXPORT_SYMBOL_GPL	
++0x9cfbd63e	kill_pid_usb_asyncio	vmlinux	EXPORT_SYMBOL_GPL	
++0x50e90a51	store_sampling_rate	vmlinux	EXPORT_SYMBOL_GPL	
++0x72cba52a	regulator_list_voltage	vmlinux	EXPORT_SYMBOL_GPL	
++0x099ada82	pci_wait_for_pending_transaction	vmlinux	EXPORT_SYMBOL	
++0x7351904f	gen_pool_create	vmlinux	EXPORT_SYMBOL	
++0xcb3ae215	call_blocking_lsm_notifier	vmlinux	EXPORT_SYMBOL	
++0xdd0762df	set_worker_desc	vmlinux	EXPORT_SYMBOL_GPL	
++0x6dbf1fe7	__flush_dcache_area	vmlinux	EXPORT_SYMBOL	
++0x693b44f0	tcf_idr_cleanup	vmlinux	EXPORT_SYMBOL	
++0xbaa13355	devm_nvmem_register	vmlinux	EXPORT_SYMBOL_GPL	
++0xdf36aaed	DWC_TASK_SCHEDULE	vmlinux	EXPORT_SYMBOL	
++0x5995428c	mdio_driver_register	vmlinux	EXPORT_SYMBOL	
++0x6eb04e79	regmap_get_reg_stride	vmlinux	EXPORT_SYMBOL_GPL	
++0xa531471e	clk_save_context	vmlinux	EXPORT_SYMBOL_GPL	
++0x4e4fda4b	xa_set_mark	vmlinux	EXPORT_SYMBOL	
++0x4b24168e	xa_get_mark	vmlinux	EXPORT_SYMBOL	
++0xd25bc5d4	csum_tcpudp_nofold	vmlinux	EXPORT_SYMBOL	
++0x9f5df2d1	gen_pool_destroy	vmlinux	EXPORT_SYMBOL	
++0x1911acb8	blk_mq_tagset_busy_iter	vmlinux	EXPORT_SYMBOL	
++0xed57cb49	nfs_file_llseek	vmlinux	EXPORT_SYMBOL_GPL	
++0xf7c48778	__tracepoint_kmalloc_node	vmlinux	EXPORT_SYMBOL	
++0xec5ad73b	trace_seq_bitmask	vmlinux	EXPORT_SYMBOL_GPL	
++0x8ddd8aad	schedule_timeout	vmlinux	EXPORT_SYMBOL	
++0x73310b18	irq_chip_mask_parent	vmlinux	EXPORT_SYMBOL_GPL	
++0x98ce4782	_mutex_trylock	vmlinux	EXPORT_SYMBOL	
++0x65ccb6f0	call_netevent_notifiers	vmlinux	EXPORT_SYMBOL_GPL	
++0xccb4eb69	mmc_start_request	vmlinux	EXPORT_SYMBOL	
++0xa6328cf0	serdev_device_set_tiocm	vmlinux	EXPORT_SYMBOL_GPL	
++0xc656f36e	serdev_device_get_tiocm	vmlinux	EXPORT_SYMBOL_GPL	
++0xa5382395	crypto_alloc_base	vmlinux	EXPORT_SYMBOL_GPL	
++0xd393cdfa	nfs4_decode_mp_ds_addr	vmlinux	EXPORT_SYMBOL_GPL	
++0xb3888902	is_subdir	vmlinux	EXPORT_SYMBOL	
++0x826673f1	alarm_start	vmlinux	EXPORT_SYMBOL_GPL	
++0x452ba683	ipv6_ext_hdr	vmlinux	EXPORT_SYMBOL	
++0x56db1fbe	neigh_destroy	vmlinux	EXPORT_SYMBOL	
++0xf99284f6	netdev_warn	vmlinux	EXPORT_SYMBOL	
++0x55bf1787	hid_validate_values	vmlinux	EXPORT_SYMBOL_GPL	
++0xf6743317	sdio_retune_hold_now	vmlinux	EXPORT_SYMBOL_GPL	
++0xcefcd99a	serial8250_unregister_port	vmlinux	EXPORT_SYMBOL	
++0x289e788a	__xfrm_policy_check	vmlinux	EXPORT_SYMBOL	
++0x8c373059	usbnet_get_link	vmlinux	EXPORT_SYMBOL_GPL	
++0x19368f78	devm_pci_remap_iospace	vmlinux	EXPORT_SYMBOL	
++0xb776b5e0	pci_read_config_word	vmlinux	EXPORT_SYMBOL	
++0x76e75cba	gpiod_count	vmlinux	EXPORT_SYMBOL_GPL	
++0x1c4cb45e	rhashtable_walk_next	vmlinux	EXPORT_SYMBOL_GPL	
++0x0878adad	blk_lld_busy	vmlinux	EXPORT_SYMBOL_GPL	
++0xa52a8102	blk_sync_queue	vmlinux	EXPORT_SYMBOL	
++0x9f69b30b	__kthread_init_worker	vmlinux	EXPORT_SYMBOL_GPL	
++0x9c29f779	copy_highpage	vmlinux	EXPORT_SYMBOL	
++0x4e3b0a0e	lwtunnel_output	vmlinux	EXPORT_SYMBOL_GPL	
++0xf32950d3	hid_open_report	vmlinux	EXPORT_SYMBOL_GPL	
++0xae66224d	dev_pm_opp_of_cpumask_remove_table	vmlinux	EXPORT_SYMBOL_GPL	
++0x2fb54792	phy_advertise_supported	vmlinux	EXPORT_SYMBOL	
++0xe2635deb	scsi_schedule_eh	vmlinux	EXPORT_SYMBOL_GPL	
++0xb87b4588	regmap_attach_dev	vmlinux	EXPORT_SYMBOL_GPL	
++0xb9b619a1	pm_runtime_irq_safe	vmlinux	EXPORT_SYMBOL_GPL	
++0x4097f653	class_unregister	vmlinux	EXPORT_SYMBOL_GPL	
++0x3d7a341b	fat_alloc_new_dir	vmlinux	EXPORT_SYMBOL_GPL	
++0xe99eeee1	simple_write_end	vmlinux	EXPORT_SYMBOL	
++0x1234e483	get_cpu_iowait_time_us	vmlinux	EXPORT_SYMBOL_GPL	
++0x0ac87d9a	unix_get_socket	vmlinux	EXPORT_SYMBOL	
++0xea93b5c6	ping_init_sock	vmlinux	EXPORT_SYMBOL_GPL	
++0xc860fa84	netdev_update_features	vmlinux	EXPORT_SYMBOL	
++0x4fcd2de7	dev_get_port_parent_id	vmlinux	EXPORT_SYMBOL	
++0xfc43c563	spi_async	vmlinux	EXPORT_SYMBOL_GPL	
++0x307c0c94	regmap_mmio_detach_clk	vmlinux	EXPORT_SYMBOL_GPL	
++0xf679a5f1	regmap_mmio_attach_clk	vmlinux	EXPORT_SYMBOL_GPL	
++0x7bd2118a	regmap_raw_write_async	vmlinux	EXPORT_SYMBOL_GPL	
++0x274dd1a3	sg_free_table_chained	vmlinux	EXPORT_SYMBOL_GPL	
++0x2a916c60	nfs_async_iocounter_wait	vmlinux	EXPORT_SYMBOL_GPL	
++0x5da819a6	ftrace_set_filter_ip	vmlinux	EXPORT_SYMBOL_GPL	
++0xa0eae826	smp_call_function	vmlinux	EXPORT_SYMBOL	
++0xef6c3f70	round_jiffies_up_relative	vmlinux	EXPORT_SYMBOL_GPL	
++0xd328acfe	eth_header_cache	vmlinux	EXPORT_SYMBOL	
++0x5cad8fc3	power_supply_ocv2cap_simple	vmlinux	EXPORT_SYMBOL_GPL	
++0x491dba1e	i2c_smbus_read_byte_data	vmlinux	EXPORT_SYMBOL	
++0x37b37dae	scsi_print_sense_hdr	vmlinux	EXPORT_SYMBOL	
++0x3a3da2ff	scsi_host_lookup	vmlinux	EXPORT_SYMBOL	
++0x74d4d131	uart_set_options	vmlinux	EXPORT_SYMBOL_GPL	
++0x47d2eac4	regulator_is_supported_voltage	vmlinux	EXPORT_SYMBOL_GPL	
++0xd8d0dcc6	of_get_videomode	vmlinux	EXPORT_SYMBOL_GPL	
++0x34d7a07f	pci_find_capability	vmlinux	EXPORT_SYMBOL	
++0x1060116f	phy_get	vmlinux	EXPORT_SYMBOL_GPL	
++0xb678366f	int_sqrt	vmlinux	EXPORT_SYMBOL	
++0x248e1473	kfree_strarray	vmlinux	EXPORT_SYMBOL_GPL	
++0xb9d025c9	llist_del_first	vmlinux	EXPORT_SYMBOL_GPL	
++0x015fdf05	dec_zone_page_state	vmlinux	EXPORT_SYMBOL	
++0xdf93b9d8	timespec64_to_jiffies	vmlinux	EXPORT_SYMBOL	
++0x4eac8d37	sunrpc_cache_pipe_upcall_timeout	vmlinux	EXPORT_SYMBOL_GPL	
++0xc7a7e770	clk_bulk_enable	vmlinux	EXPORT_SYMBOL_GPL	
++0xd4e6d7e0	linear_range_get_value	vmlinux	EXPORT_SYMBOL_GPL	
++0xe532b732	badblocks_exit	vmlinux	EXPORT_SYMBOL_GPL	
++0xeda3690c	config_item_put	vmlinux	EXPORT_SYMBOL	
++0x6e3fe9c3	config_item_get	vmlinux	EXPORT_SYMBOL	
++0xcaaf140a	mnt_drop_write_file	vmlinux	EXPORT_SYMBOL	
++0x2122d725	generic_update_time	vmlinux	EXPORT_SYMBOL	
++0xe8b5c3c3	__tracepoint_module_get	vmlinux	EXPORT_SYMBOL	
++0x1eb9516e	round_jiffies_relative	vmlinux	EXPORT_SYMBOL_GPL	
++0x2128f6f0	dma_unmap_resource	vmlinux	EXPORT_SYMBOL	
++0xa7eedcc4	call_usermodehelper	vmlinux	EXPORT_SYMBOL	
++0x453efa54	svc_pool_map	vmlinux	EXPORT_SYMBOL_GPL	
++0xf58633ff	sock_pfree	vmlinux	EXPORT_SYMBOL	
++0x24662acc	mbox_client_txdone	vmlinux	EXPORT_SYMBOL_GPL	
++0x29d69671	dev_pm_opp_find_freq_ceil_by_volt	vmlinux	EXPORT_SYMBOL_GPL	
++0x8a0dc91f	__i2c_smbus_xfer	vmlinux	EXPORT_SYMBOL	
++0x238b099f	mipi_dsi_packet_format_is_short	vmlinux	EXPORT_SYMBOL	
++0xdab464fc	klist_iter_init_node	vmlinux	EXPORT_SYMBOL_GPL	
++0xc8ddd5b5	kstrdup_quotable	vmlinux	EXPORT_SYMBOL_GPL	
++0x0634100a	bitmap_parselist_user	vmlinux	EXPORT_SYMBOL	
++0xae656e43	blk_queue_update_dma_alignment	vmlinux	EXPORT_SYMBOL	
++0x3b966ef7	pnfs_layoutcommit_inode	vmlinux	EXPORT_SYMBOL_GPL	
++0x73733d28	__fscache_disable_cookie	vmlinux	EXPORT_SYMBOL	
++0xbaf6850c	fsnotify_wait_marks_destroyed	vmlinux	EXPORT_SYMBOL_GPL	
++0xc8f183ea	hrtimer_try_to_cancel	vmlinux	EXPORT_SYMBOL_GPL	
++0x0bdf0818	irq_chip_get_parent_state	vmlinux	EXPORT_SYMBOL_GPL	
++0x6376daf9	irq_chip_set_parent_state	vmlinux	EXPORT_SYMBOL_GPL	
++0xe010c934	__dev_get_by_name	vmlinux	EXPORT_SYMBOL	
++0x5b9a2640	skb_copy_and_csum_dev	vmlinux	EXPORT_SYMBOL	
++0x469d54b7	input_unregister_handle	vmlinux	EXPORT_SYMBOL	
++0xd8cba586	usb_hcd_map_urb_for_dma	vmlinux	EXPORT_SYMBOL_GPL	
++0x0878fd50	idr_replace	vmlinux	EXPORT_SYMBOL	
++0x656c1a0e	string_escape_mem	vmlinux	EXPORT_SYMBOL	
++0xd4518d3f	blk_mq_quiesce_queue	vmlinux	EXPORT_SYMBOL_GPL	
++0x23f18cf5	register_asymmetric_key_parser	vmlinux	EXPORT_SYMBOL_GPL	
++0xb349ca15	mod_node_page_state	vmlinux	EXPORT_SYMBOL	
++0x2c7db649	irq_dispose_mapping	vmlinux	EXPORT_SYMBOL_GPL	
++0xae69b1c1	usermodehelper_read_unlock	vmlinux	EXPORT_SYMBOL_GPL	
++0xf2894d12	xdr_stream_decode_opaque_dup	vmlinux	EXPORT_SYMBOL_GPL	
++0x9e9d4ec9	flow_rule_match_control	vmlinux	EXPORT_SYMBOL	
++0xce64d1ec	register_netdev	vmlinux	EXPORT_SYMBOL	
++0x82ee7374	mdiobus_write_nested	vmlinux	EXPORT_SYMBOL	
++0x987a956f	nvme_unfreeze	vmlinux	EXPORT_SYMBOL_GPL	
++0x8a659869	device_get_dma_attr	vmlinux	EXPORT_SYMBOL_GPL	
++0x797622b6	blk_limits_io_opt	vmlinux	EXPORT_SYMBOL	
++0x4fba889b	pnfs_alloc_commit_array	vmlinux	EXPORT_SYMBOL_GPL	
++0xf7af0c99	proc_create	vmlinux	EXPORT_SYMBOL	
++0x7aa1756e	kvfree	vmlinux	EXPORT_SYMBOL	
++0xee690bab	ping_err	vmlinux	EXPORT_SYMBOL_GPL	
++0xddf5db59	inet_twsk_purge	vmlinux	EXPORT_SYMBOL_GPL	
++0x37db8f19	dmi_get_date	vmlinux	EXPORT_SYMBOL	
++0x1efaa06f	__tracepoint_xhci_dbg_quirks	vmlinux	EXPORT_SYMBOL_GPL	
++0xdc076966	bcm_phy_enable_jumbo	vmlinux	EXPORT_SYMBOL_GPL	
++0xfcef5d97	iscsi_create_endpoint	vmlinux	EXPORT_SYMBOL_GPL	
++0x6e8f3d69	component_del	vmlinux	EXPORT_SYMBOL_GPL	
++0x3d45b482	serdev_device_write_flush	vmlinux	EXPORT_SYMBOL_GPL	
++0x9e341363	radix_tree_tag_get	vmlinux	EXPORT_SYMBOL	
++0xadfdfcef	__bitmap_andnot	vmlinux	EXPORT_SYMBOL	
++0x4c833fae	blkg_rwstat_recursive_sum	vmlinux	EXPORT_SYMBOL_GPL	
++0x39434365	pnfs_generic_ds_cinfo_release_lseg	vmlinux	EXPORT_SYMBOL_GPL	
++0xb02a996f	posix_acl_from_xattr	vmlinux	EXPORT_SYMBOL	
++0xa957cd91	clear_nlink	vmlinux	EXPORT_SYMBOL	
++0x9a3fa9a8	set_anon_super_fc	vmlinux	EXPORT_SYMBOL	
++0x74c7bffa	stack_trace_snprint	vmlinux	EXPORT_SYMBOL_GPL	
++0x555baa40	dev_loopback_xmit	vmlinux	EXPORT_SYMBOL	
++0x278a32c3	skb_seq_read	vmlinux	EXPORT_SYMBOL	
++0x5fd192f6	i2c_transfer	vmlinux	EXPORT_SYMBOL	
++0x40184ee4	scsi_device_lookup	vmlinux	EXPORT_SYMBOL	
++0xd117b52b	of_irq_parse_and_map_pci	vmlinux	EXPORT_SYMBOL_GPL	
++0xd8610592	gpiod_get_raw_value_cansleep	vmlinux	EXPORT_SYMBOL_GPL	
++0x85c88363	bcm2836_arm_irqchip_spin_gpu_irq	vmlinux	EXPORT_SYMBOL	
++0x29086e18	memcpy_mcs	vmlinux	EXPORT_SYMBOL	
++0x64127b67	bitmap_find_next_zero_area_off	vmlinux	EXPORT_SYMBOL	
++0x1e985192	skcipher_walk_aead_decrypt	vmlinux	EXPORT_SYMBOL_GPL	
++0x67f50da8	__traceiter_pnfs_mds_fallback_pg_init_read	vmlinux	EXPORT_SYMBOL_GPL	
++0x80e5f86f	fscrypt_fname_alloc_buffer	vmlinux	EXPORT_SYMBOL	
++0xf6b31562	wbc_detach_inode	vmlinux	EXPORT_SYMBOL_GPL	
++0x21e7c711	cgroup_path_ns	vmlinux	EXPORT_SYMBOL_GPL	
++0xc54dabb7	param_set_int	vmlinux	EXPORT_SYMBOL	
++0x25d5a1b0	xdr_inline_pages	vmlinux	EXPORT_SYMBOL_GPL	
++0x356461c8	rtc_time64_to_tm	vmlinux	EXPORT_SYMBOL	
++0xddf1e78a	part_start_io_acct	vmlinux	EXPORT_SYMBOL_GPL	
++0x46b7a091	crypto_drop_spawn	vmlinux	EXPORT_SYMBOL_GPL	
++0x716ddb7a	security_socket_socketpair	vmlinux	EXPORT_SYMBOL	
++0x358575ac	dquot_writeback_dquots	vmlinux	EXPORT_SYMBOL	
++0x95edbb8c	tty_port_register_device_attr_serdev	vmlinux	EXPORT_SYMBOL_GPL	
++0x20cc5e58	blk_mq_init_queue	vmlinux	EXPORT_SYMBOL	
++0x89ae7aa0	rsa_parse_pub_key	vmlinux	EXPORT_SYMBOL_GPL	
++0xc90b22ed	param_set_short	vmlinux	EXPORT_SYMBOL	
++0x254c8a73	pci_scan_bus	vmlinux	EXPORT_SYMBOL	
++0x77bc13a0	strim	vmlinux	EXPORT_SYMBOL	
++0x69cf0632	mpi_fromstr	vmlinux	EXPORT_SYMBOL_GPL	
++0x89a0cd52	crc32c_impl	vmlinux	EXPORT_SYMBOL	
++0x8fbe17ec	shash_register_instance	vmlinux	EXPORT_SYMBOL_GPL	
++0xe9160de0	debugfs_lookup	vmlinux	EXPORT_SYMBOL_GPL	
++0xf28f6ac1	seq_write	vmlinux	EXPORT_SYMBOL	
++0x74e01f1d	no_seek_end_llseek	vmlinux	EXPORT_SYMBOL	
++0xa12bd913	generic_file_llseek	vmlinux	EXPORT_SYMBOL	
++0xe9c329ce	do_wait_intr_irq	vmlinux	EXPORT_SYMBOL	
++0x657340f7	get_mm_exe_file	vmlinux	EXPORT_SYMBOL	
++0x0d90026d	udp_tunnel_nic_ops	vmlinux	EXPORT_SYMBOL_GPL	
++0x4a31b64f	tc_setup_cb_destroy	vmlinux	EXPORT_SYMBOL	
++0x445a09c0	nvmem_device_cell_write	vmlinux	EXPORT_SYMBOL_GPL	
++0x877fbfc9	rtc_update_irq_enable	vmlinux	EXPORT_SYMBOL_GPL	
++0x14e09da7	_dev_err	vmlinux	EXPORT_SYMBOL	
++0x999e8297	vfree	vmlinux	EXPORT_SYMBOL	
++0xe4f98b9b	wait_on_page_bit	vmlinux	EXPORT_SYMBOL	
++0x39a82ff1	hrtimer_sleeper_start_expires	vmlinux	EXPORT_SYMBOL_GPL	
++0xc11d44d8	mmc_detect_card_removed	vmlinux	EXPORT_SYMBOL	
++0x4e396eb0	scsi_get_host_dev	vmlinux	EXPORT_SYMBOL	
++0x120b336a	__rb_insert_augmented	vmlinux	EXPORT_SYMBOL	
++0x2f0fa1a1	pnfs_generic_pg_readpages	vmlinux	EXPORT_SYMBOL_GPL	
++0x357cda3f	fscache_object_retrying_stale	vmlinux	EXPORT_SYMBOL	
++0x452f257b	simple_symlink_inode_operations	vmlinux	EXPORT_SYMBOL	
++0x023e6316	fs_file_read_update_args_by_trace	vmlinux	EXPORT_SYMBOL_GPL	
++0x678b96ec	dma_pool_alloc	vmlinux	EXPORT_SYMBOL	
++0xb6c9e882	tcp_v4_do_rcv	vmlinux	EXPORT_SYMBOL	
++0xf11b94db	of_device_get_match_data	vmlinux	EXPORT_SYMBOL	
++0xdc82291c	get_device	vmlinux	EXPORT_SYMBOL_GPL	
++0x2d4c773a	hdmi_spd_infoframe_init	vmlinux	EXPORT_SYMBOL	
++0x494656d0	iov_iter_gap_alignment	vmlinux	EXPORT_SYMBOL	
++0x8596128e	blk_dump_rq_flags	vmlinux	EXPORT_SYMBOL	
++0x16cb95b8	exportfs_decode_fh	vmlinux	EXPORT_SYMBOL_GPL	
++0xc523c00e	sysfs_create_group	vmlinux	EXPORT_SYMBOL_GPL	
++0xffd9137a	trace_hardirqs_off_caller	vmlinux	EXPORT_SYMBOL	
++0x38d3dce5	g_make_token_header	vmlinux	EXPORT_SYMBOL_GPL	
++0x86b903d0	xprt_release_rqst_cong	vmlinux	EXPORT_SYMBOL_GPL	
++0x5fb115cd	secure_tcpv6_ts_off	vmlinux	EXPORT_SYMBOL	
++0x3294c854	consume_skb	vmlinux	EXPORT_SYMBOL	
++0xc8a3efdb	hid_lookup_quirk	vmlinux	EXPORT_SYMBOL_GPL	
++0xa7b52c45	DWC_MUTEX_UNLOCK	vmlinux	EXPORT_SYMBOL	
++0x3b41df63	usbnet_status_start	vmlinux	EXPORT_SYMBOL_GPL	
++0x719e7164	scsi_add_device	vmlinux	EXPORT_SYMBOL	
++0xa7a630d8	pci_match_id	vmlinux	EXPORT_SYMBOL	
++0x1856844e	pcie_set_mps	vmlinux	EXPORT_SYMBOL	
++0x4ab9fc1e	pci_dev_run_wake	vmlinux	EXPORT_SYMBOL_GPL	
++0x8636e6d4	nfs_sync_inode	vmlinux	EXPORT_SYMBOL_GPL	
++0x25ba6fa0	generic_fadvise	vmlinux	EXPORT_SYMBOL	
++0x649b919f	rpc_alloc_iostats	vmlinux	EXPORT_SYMBOL_GPL	
++0x7704b717	__fib6_flush_trees	vmlinux	EXPORT_SYMBOL	
++0x5a04acad	tcf_action_dump_1	vmlinux	EXPORT_SYMBOL	
++0x55d0f441	flow_rule_match_enc_ipv6_addrs	vmlinux	EXPORT_SYMBOL	
++0x90381625	flow_rule_match_enc_ipv4_addrs	vmlinux	EXPORT_SYMBOL	
++0x3e1adf66	i2c_add_numbered_adapter	vmlinux	EXPORT_SYMBOL_GPL	
++0x04793c57	usb_unanchor_urb	vmlinux	EXPORT_SYMBOL_GPL	
++0xc4ced64b	scsi_check_sense	vmlinux	EXPORT_SYMBOL_GPL	
++0x0b9a91ed	dma_get_slave_channel	vmlinux	EXPORT_SYMBOL_GPL	
++0x97b606a0	pcie_aspm_enabled	vmlinux	EXPORT_SYMBOL_GPL	
++0x3470968f	phy_power_off	vmlinux	EXPORT_SYMBOL_GPL	
++0xff7e33bf	mpi_sub_ui	vmlinux	EXPORT_SYMBOL_GPL	
++0xc91277a1	kgdb_schedule_breakpoint	vmlinux	EXPORT_SYMBOL_GPL	
++0x83ba8de1	mr_mfc_seq_next	vmlinux	EXPORT_SYMBOL	
++0x2a9b64ed	tcp_prot	vmlinux	EXPORT_SYMBOL	
++0x5e1e54ed	of_graph_get_remote_endpoint	vmlinux	EXPORT_SYMBOL	
++0xc978a7d0	root_device_unregister	vmlinux	EXPORT_SYMBOL_GPL	
++0x0d500196	mipi_dsi_turn_on_peripheral	vmlinux	EXPORT_SYMBOL	
++0xce58afd5	textsearch_prepare	vmlinux	EXPORT_SYMBOL	
++0x4c2eb698	migrate_page_copy	vmlinux	EXPORT_SYMBOL	
++0x09758957	proc_dointvec_ms_jiffies	vmlinux	EXPORT_SYMBOL	
++0x02e53a4b	inet_frag_kill	vmlinux	EXPORT_SYMBOL	
++0x5117fb18	led_update_brightness	vmlinux	EXPORT_SYMBOL_GPL	
++0xa1d8004a	videomode_from_timing	vmlinux	EXPORT_SYMBOL_GPL	
++0x6d6601c1	blk_queue_max_zone_append_sectors	vmlinux	EXPORT_SYMBOL_GPL	
++0x7df15379	simple_setattr	vmlinux	EXPORT_SYMBOL	
++0xea3d50c3	simple_getattr	vmlinux	EXPORT_SYMBOL	
++0xb04b6b6b	mempool_free	vmlinux	EXPORT_SYMBOL	
++0x1109888a	tcf_em_tree_validate	vmlinux	EXPORT_SYMBOL	
++0x76b1d1b6	neigh_carrier_down	vmlinux	EXPORT_SYMBOL	
++0x236d46a8	usb_stor_Bulk_reset	vmlinux	EXPORT_SYMBOL_GPL	USB_STORAGE
++0x1babe057	attribute_container_unregister	vmlinux	EXPORT_SYMBOL_GPL	
++0xdb2a2daa	driver_for_each_device	vmlinux	EXPORT_SYMBOL_GPL	
++0xfcd1819a	hdmi_spd_infoframe_check	vmlinux	EXPORT_SYMBOL	
++0xabcfdbfe	gen_pool_first_fit_order_align	vmlinux	EXPORT_SYMBOL	
++0x9123e00a	btree_last	vmlinux	EXPORT_SYMBOL_GPL	
++0x3e51705b	bdget_disk	vmlinux	EXPORT_SYMBOL	
++0xf3afe750	configfs_register_subsystem	vmlinux	EXPORT_SYMBOL	
++0x26e510d4	fib4_rule_default	vmlinux	EXPORT_SYMBOL_GPL	
++0x02ee8a1f	tcp_rcv_state_process	vmlinux	EXPORT_SYMBOL	
++0x461d9f36	skb_to_sgvec	vmlinux	EXPORT_SYMBOL_GPL	
++0x52e76438	nvme_ctrl_from_file	vmlinux	EXPORT_SYMBOL_GPL	NVME_TARGET_PASSTHRU
++0xbcab6ee6	sscanf	vmlinux	EXPORT_SYMBOL	
++0x77e35ccc	nlmsvc_unlock_all_by_ip	vmlinux	EXPORT_SYMBOL_GPL	
++0x21565c97	nlmsvc_unlock_all_by_sb	vmlinux	EXPORT_SYMBOL_GPL	
++0x75957ee1	__breadahead	vmlinux	EXPORT_SYMBOL	
++0x61a23010	perf_event_sysfs_show	vmlinux	EXPORT_SYMBOL_GPL	
++0x02394899	play_idle_precise	vmlinux	EXPORT_SYMBOL_GPL	
++0xca326d66	rpc_bind_new_program	vmlinux	EXPORT_SYMBOL_GPL	
++0x0a9eeebf	pfifo_fast_ops	vmlinux	EXPORT_SYMBOL	
++0xf1956d8e	unregister_fib_notifier	vmlinux	EXPORT_SYMBOL	
++0xcd067f45	led_classdev_suspend	vmlinux	EXPORT_SYMBOL_GPL	
++0x296ee05c	iscsi_destroy_iface	vmlinux	EXPORT_SYMBOL_GPL	
++0xe5c3099f	platform_device_register_full	vmlinux	EXPORT_SYMBOL_GPL	
++0xebda772b	devm_gpio_free	vmlinux	EXPORT_SYMBOL_GPL	
++0x0bfc1d1a	check_zeroed_user	vmlinux	EXPORT_SYMBOL	
++0xc0fbde6e	blk_mq_queue_stopped	vmlinux	EXPORT_SYMBOL	
++0x9968aacb	__audit_log_nfcfg	vmlinux	EXPORT_SYMBOL_GPL	
++0x25974000	wait_for_completion	vmlinux	EXPORT_SYMBOL	
++0x09969421	__cpuhp_setup_state	vmlinux	EXPORT_SYMBOL	
++0x63f79eff	csum_partial_copy_to_xdr	vmlinux	EXPORT_SYMBOL_GPL	
++0x5ea12303	dev_get_by_name_rcu	vmlinux	EXPORT_SYMBOL	
++0x04094e89	i2c_smbus_write_byte_data	vmlinux	EXPORT_SYMBOL	
++0x208dd777	usb_unlink_urb	vmlinux	EXPORT_SYMBOL_GPL	
++0x1ce0a147	dev_pm_domain_start	vmlinux	EXPORT_SYMBOL_GPL	
++0x2bc2a81f	gpiod_get_from_of_node	vmlinux	EXPORT_SYMBOL_GPL	
++0x108a0acd	bstr_printf	vmlinux	EXPORT_SYMBOL_GPL	
++0x1d24c881	___ratelimit	vmlinux	EXPORT_SYMBOL	
++0x79f697e4	lzorle1x_1_compress	vmlinux	EXPORT_SYMBOL_GPL	
++0x11fb926a	iomap_fiemap	vmlinux	EXPORT_SYMBOL_GPL	
++0x41bdc0d0	sock_diag_destroy	vmlinux	EXPORT_SYMBOL_GPL	
++0x6b8bf149	netif_receive_skb_list	vmlinux	EXPORT_SYMBOL	
++0x6c5dae23	scsi_kmap_atomic_sg	vmlinux	EXPORT_SYMBOL	
++0x173b1c2d	platform_device_add_data	vmlinux	EXPORT_SYMBOL_GPL	
++0xc50f6b57	dmaengine_desc_attach_metadata	vmlinux	EXPORT_SYMBOL_GPL	
++0xa8fb743d	des_expand_key	vmlinux	EXPORT_SYMBOL_GPL	
++0xa4efe134	fscrypt_ioctl_get_policy	vmlinux	EXPORT_SYMBOL	
++0xb7380979	fscrypt_ioctl_set_policy	vmlinux	EXPORT_SYMBOL	
++0xc4287d87	register_kprobes	vmlinux	EXPORT_SYMBOL_GPL	
++0xcdc86b55	sched_clock	vmlinux	EXPORT_SYMBOL_GPL	
++0x40e227a2	put_rpccred	vmlinux	EXPORT_SYMBOL_GPL	
++0xf784ec82	rpcauth_init_cred	vmlinux	EXPORT_SYMBOL_GPL	
++0x4dc798d0	xfrm_audit_state_replay_overflow	vmlinux	EXPORT_SYMBOL_GPL	
++0xe578fdf2	unregister_netdevice_notifier_dev_net	vmlinux	EXPORT_SYMBOL	
++0x2d67336d	sock_create_lite	vmlinux	EXPORT_SYMBOL	
++0xdf205489	security_locked_down	vmlinux	EXPORT_SYMBOL	
++0xe810b620	jbd2_journal_free_reserved	vmlinux	EXPORT_SYMBOL	
++0xfbffd601	net_prio_cgrp_subsys_on_dfl_key	vmlinux	EXPORT_SYMBOL_GPL	
++0xad7e17da	irq_domain_free_irqs_parent	vmlinux	EXPORT_SYMBOL_GPL	
++0x58e3306d	bit_wait_io	vmlinux	EXPORT_SYMBOL	
++0x871b00c6	cpufreq_unregister_governor	vmlinux	EXPORT_SYMBOL_GPL	
++0xde17d62a	pm_clk_destroy	vmlinux	EXPORT_SYMBOL_GPL	
++0x3a633afa	regulator_suspend_enable	vmlinux	EXPORT_SYMBOL_GPL	
++0xe566f1ea	pci_iomap_wc_range	vmlinux	EXPORT_SYMBOL_GPL	
++0x9f79470b	d_obtain_alias	vmlinux	EXPORT_SYMBOL	
++0xdf83c122	irq_domain_set_info	vmlinux	EXPORT_SYMBOL	
++0x1da99436	ip4_datagram_connect	vmlinux	EXPORT_SYMBOL	
++0x620e4421	tcp_timewait_state_process	vmlinux	EXPORT_SYMBOL	
++0x3e0551c0	__tcp_send_ack	vmlinux	EXPORT_SYMBOL_GPL	
++0xf9549c4d	security_inode_init_security	vmlinux	EXPORT_SYMBOL	
++0x6a460dc5	schedule_hrtimeout	vmlinux	EXPORT_SYMBOL_GPL	
++0x16eb6e60	flow_rule_match_enc_opts	vmlinux	EXPORT_SYMBOL	
++0x7853d64b	bpf_getorigdst_opt	vmlinux	EXPORT_SYMBOL	
++0x271e63c2	starget_for_each_device	vmlinux	EXPORT_SYMBOL	
++0xb74f83fc	subsys_interface_register	vmlinux	EXPORT_SYMBOL_GPL	
++0xf3916987	global_cursor_default	vmlinux	EXPORT_SYMBOL	
++0xb6e6d99d	clk_disable	vmlinux	EXPORT_SYMBOL_GPL	
++0x7f38b3d8	radix_tree_iter_delete	vmlinux	EXPORT_SYMBOL	
++0x5a754fa5	nobh_writepage	vmlinux	EXPORT_SYMBOL	
++0xfedcdb60	seq_hlist_next_percpu	vmlinux	EXPORT_SYMBOL	
++0xd0760fc0	kfree_sensitive	vmlinux	EXPORT_SYMBOL	
++0xe94258ec	clear_page_dirty_for_io	vmlinux	EXPORT_SYMBOL	
++0x397e2142	__SCK__tp_func_sched_cpu_capacity_tp	vmlinux	EXPORT_SYMBOL_GPL	
++0xdf28055e	srcu_init_notifier_head	vmlinux	EXPORT_SYMBOL_GPL	
++0x5d112304	__memcpy_fromio	vmlinux	EXPORT_SYMBOL	
++0xfafb30d6	xdr_commit_encode	vmlinux	EXPORT_SYMBOL_GPL	
++0xa73a0db2	of_phy_register_fixed_link	vmlinux	EXPORT_SYMBOL	
++0x11831681	devm_free_pages	vmlinux	EXPORT_SYMBOL_GPL	
++0x9d7a9e45	dump_skip	vmlinux	EXPORT_SYMBOL	
++0x22f93f5a	locks_start_grace	vmlinux	EXPORT_SYMBOL_GPL	
++0xdbeeece6	tracepoint_probe_unregister	vmlinux	EXPORT_SYMBOL_GPL	
++0x0cadd447	svc_create_xprt	vmlinux	EXPORT_SYMBOL_GPL	
++0xb74408ad	dma_fence_add_callback	vmlinux	EXPORT_SYMBOL	
++0x1a76696b	fwnode_property_read_string_array	vmlinux	EXPORT_SYMBOL_GPL	
++0x1b4ff3e4	tty_devnum	vmlinux	EXPORT_SYMBOL	
++0xb82f789a	__clk_hw_register_mux	vmlinux	EXPORT_SYMBOL_GPL	
++0x1c79a1da	pcie_flr	vmlinux	EXPORT_SYMBOL_GPL	
++0xc3c4c6cc	hash_algo_name	vmlinux	EXPORT_SYMBOL_GPL	
++0x1e478ed4	pnfs_write_done_resend_to_mds	vmlinux	EXPORT_SYMBOL_GPL	
++0xaac32c77	nfs_server_copy_userdata	vmlinux	EXPORT_SYMBOL_GPL	
++0x7ceaa5c7	__vfs_removexattr	vmlinux	EXPORT_SYMBOL	
++0x8f33c92f	dev_pm_opp_of_cpumask_add_table	vmlinux	EXPORT_SYMBOL_GPL	
++0xacc6b5d6	genphy_c37_config_aneg	vmlinux	EXPORT_SYMBOL	
++0xd7f03732	genphy_c45_config_aneg	vmlinux	EXPORT_SYMBOL_GPL	
++0x76eeeb0f	sha384_zero_message_hash	vmlinux	EXPORT_SYMBOL_GPL	
++0x946dd559	sha224_zero_message_hash	vmlinux	EXPORT_SYMBOL_GPL	
++0x089206b0	write_dirty_buffer	vmlinux	EXPORT_SYMBOL	
++0x2d2979c4	noop_llseek	vmlinux	EXPORT_SYMBOL	
++0x0555bc42	trace_array_put	vmlinux	EXPORT_SYMBOL_GPL	
++0x3061cfce	ring_buffer_entries_cpu	vmlinux	EXPORT_SYMBOL_GPL	
++0x1b971d6a	__udp_enqueue_schedule_skb	vmlinux	EXPORT_SYMBOL_GPL	
++0x9c9ca9cf	cpufreq_driver_fast_switch	vmlinux	EXPORT_SYMBOL_GPL	
++0xef2eeb52	devm_i2c_add_adapter	vmlinux	EXPORT_SYMBOL_GPL	
++0x85565f39	input_free_device	vmlinux	EXPORT_SYMBOL	
++0xc1397b10	phy_remove_link_mode	vmlinux	EXPORT_SYMBOL	
++0x1662db94	regulator_notifier_call_chain	vmlinux	EXPORT_SYMBOL_GPL	
++0xa0b6b956	skcipher_alloc_instance_simple	vmlinux	EXPORT_SYMBOL_GPL	
++0x191339ce	cpu_chill	vmlinux	EXPORT_SYMBOL	
++0x3e9110fa	__hw_addr_unsync	vmlinux	EXPORT_SYMBOL	
++0x9fdecf39	of_platform_default_populate	vmlinux	EXPORT_SYMBOL_GPL	
++0x9a8f0389	usb_hid_driver	vmlinux	EXPORT_SYMBOL_GPL	
++0x8e9bd9f3	i2c_verify_adapter	vmlinux	EXPORT_SYMBOL	
++0x6395130f	vc_mem_get_current_size	vmlinux	EXPORT_SYMBOL_GPL	
++0x919c58f3	__clzsi2	vmlinux	EXPORT_SYMBOL	
++0xc4777aa9	__ctzsi2	vmlinux	EXPORT_SYMBOL	
++0xbba33b68	security_kernel_read_file	vmlinux	EXPORT_SYMBOL_GPL	
++0xfcc363eb	remap_vmalloc_hugepage_range	vmlinux	EXPORT_SYMBOL	
++0x15ba50a6	jiffies	vmlinux	EXPORT_SYMBOL	
++0x8cda7249	fib_alias_hw_flags_set	vmlinux	EXPORT_SYMBOL_GPL	
++0xa68f7e57	dev_queue_xmit	vmlinux	EXPORT_SYMBOL	
++0x8448232c	of_device_alloc	vmlinux	EXPORT_SYMBOL	
++0x15346968	devm_device_remove_group	vmlinux	EXPORT_SYMBOL_GPL	
++0x13d0adf7	__kfifo_out	vmlinux	EXPORT_SYMBOL	
++0xe06141e9	security_sk_clone	vmlinux	EXPORT_SYMBOL	
++0xf999267e	pnfs_generic_commit_release	vmlinux	EXPORT_SYMBOL_GPL	
++0xb904c3a2	nfs_get_lock_context	vmlinux	EXPORT_SYMBOL_GPL	
++0x56174def	jbd2_wait_inode_data	vmlinux	EXPORT_SYMBOL	
++0x79038492	proc_mkdir	vmlinux	EXPORT_SYMBOL	
++0x36769b07	lookup_positive_unlocked	vmlinux	EXPORT_SYMBOL	
++0x4b0f75f4	dummy_irq_chip	vmlinux	EXPORT_SYMBOL_GPL	
++0xb0c2f0ac	tasklet_unlock	vmlinux	EXPORT_SYMBOL_GPL	
++0x4eac5fc1	cpu_mitigations_auto_nosmt	vmlinux	EXPORT_SYMBOL_GPL	
++0xfa087666	devm_usb_get_phy_by_phandle	vmlinux	EXPORT_SYMBOL_GPL	
++0xca00da88	usb_hcd_start_port_resume	vmlinux	EXPORT_SYMBOL_GPL	
++0xe6cd527a	usbnet_update_max_qlen	vmlinux	EXPORT_SYMBOL_GPL	
++0x5e0a4522	phy_destroy	vmlinux	EXPORT_SYMBOL_GPL	
++0x211b89aa	get_cached_acl_rcu	vmlinux	EXPORT_SYMBOL	
++0x3c6e7cba	get_mem_cgroup_from_mm	vmlinux	EXPORT_SYMBOL	
++0x36c3fbde	alarm_start_relative	vmlinux	EXPORT_SYMBOL_GPL	
++0x929034f7	proc_dointvec_jiffies	vmlinux	EXPORT_SYMBOL	
++0x5b9c6620	tcp_peek_len	vmlinux	EXPORT_SYMBOL	
++0xc7000e98	dev_change_carrier	vmlinux	EXPORT_SYMBOL	
++0x0a042f34	__napi_schedule	vmlinux	EXPORT_SYMBOL	
++0x04252b27	sk_stream_wait_memory	vmlinux	EXPORT_SYMBOL	
++0x3e92b292	hid_bus_type	vmlinux	EXPORT_SYMBOL	
++0x39512329	dev_pm_opp_put_supported_hw	vmlinux	EXPORT_SYMBOL_GPL	
++0xd2946123	usb_set_interface	vmlinux	EXPORT_SYMBOL_GPL	
++0xff53af14	seqno_fence_ops	vmlinux	EXPORT_SYMBOL	
++0x0cf7b2b9	dma_resv_wait_timeout_rcu	vmlinux	EXPORT_SYMBOL_GPL	
++0xff4639a9	tty_unlock	vmlinux	EXPORT_SYMBOL	
++0xb23027c1	kstrtos16_from_user	vmlinux	EXPORT_SYMBOL	
++0xa084749a	__bitmap_or	vmlinux	EXPORT_SYMBOL	
++0x67b0a078	security_req_classify_flow	vmlinux	EXPORT_SYMBOL	
++0xdf6991a4	__SCK__tp_func_pnfs_mds_fallback_write_pagelist	vmlinux	EXPORT_SYMBOL_GPL	
++0x5ce462a3	__tracepoint_pnfs_mds_fallback_write_done	vmlinux	EXPORT_SYMBOL_GPL	
++0x69dbc338	get_dcookie	vmlinux	EXPORT_SYMBOL_GPL	
++0x892e8157	trace_event_raw_init	vmlinux	EXPORT_SYMBOL_GPL	
++0x85a7754e	relay_late_setup_files	vmlinux	EXPORT_SYMBOL_GPL	
++0x955e802d	netlink_broadcast_filtered	vmlinux	EXPORT_SYMBOL	
++0x4761f17c	register_netevent_notifier	vmlinux	EXPORT_SYMBOL_GPL	
++0xfd8a1e6c	of_device_uevent_modalias	vmlinux	EXPORT_SYMBOL_GPL	
++0xec79409a	i2c_new_scanned_device	vmlinux	EXPORT_SYMBOL_GPL	
++0x3dc526a9	arizona_of_match	vmlinux	EXPORT_SYMBOL_GPL	
++0xc29bf967	strspn	vmlinux	EXPORT_SYMBOL	
++0x98cf60b3	strlen	vmlinux	EXPORT_SYMBOL	
++0xdd62bb73	security_kernel_post_load_data	vmlinux	EXPORT_SYMBOL_GPL	
++0x9e94e6b7	__fscache_alloc_page	vmlinux	EXPORT_SYMBOL	
++0x5819a3b4	trace_array_set_clr_event	vmlinux	EXPORT_SYMBOL_GPL	
++0x1ee14d3f	scsi_host_block	vmlinux	EXPORT_SYMBOL_GPL	
++0x6a84358d	regulator_set_pull_down_regmap	vmlinux	EXPORT_SYMBOL_GPL	
++0xedbaee5e	nla_strcmp	vmlinux	EXPORT_SYMBOL	
++0xc0ff12fb	nla_strdup	vmlinux	EXPORT_SYMBOL	
++0xc16410b9	ZSTD_getDictID_fromDDict	vmlinux	EXPORT_SYMBOL	
++0xaf3b6c5b	gen_pool_size	vmlinux	EXPORT_SYMBOL_GPL	
++0xfeebc7c4	__kfifo_from_user_r	vmlinux	EXPORT_SYMBOL	
++0xcc445ceb	__sg_page_iter_dma_next	vmlinux	EXPORT_SYMBOL	
++0xe3d9fb69	svc_return_autherr	vmlinux	EXPORT_SYMBOL_GPL	
++0x44b6a43d	tcp_get_cookie_sock	vmlinux	EXPORT_SYMBOL	
++0x435e75b5	fib_add_nexthop	vmlinux	EXPORT_SYMBOL_GPL	
++0xe71c78eb	__skb_flow_dissect	vmlinux	EXPORT_SYMBOL	
++0x4321dea6	skb_trim	vmlinux	EXPORT_SYMBOL	
++0xe9922d05	usb_enable_autosuspend	vmlinux	EXPORT_SYMBOL_GPL	
++0xd3e5a434	__clk_hw_register_fixed_rate	vmlinux	EXPORT_SYMBOL_GPL	
++0x403f9529	gpio_request_one	vmlinux	EXPORT_SYMBOL_GPL	
++0x0abf68b8	blk_mq_unfreeze_queue	vmlinux	EXPORT_SYMBOL_GPL	
++0x5101838b	perf_tp_event	vmlinux	EXPORT_SYMBOL_GPL	
++0x589c1dfa	svc_proc_register	vmlinux	EXPORT_SYMBOL_GPL	
++0x18d9d28e	xfrm_policy_delete	vmlinux	EXPORT_SYMBOL	
++0x54f70dc0	inet_frags_init	vmlinux	EXPORT_SYMBOL	
++0x84cc5b4d	power_supply_changed	vmlinux	EXPORT_SYMBOL_GPL	
++0xceed277e	i2c_get_device_id	vmlinux	EXPORT_SYMBOL_GPL	
++0x65da44b6	pci_scan_root_bus_bridge	vmlinux	EXPORT_SYMBOL	
++0x50973af1	radix_tree_tag_set	vmlinux	EXPORT_SYMBOL	
++0x4e3567f7	match_int	vmlinux	EXPORT_SYMBOL	
++0x6b9b29f1	blk_queue_required_elevator_features	vmlinux	EXPORT_SYMBOL_GPL	
++0xf840afa7	debugfs_create_x64	vmlinux	EXPORT_SYMBOL_GPL	
++0x8c4174a0	fscrypt_ioctl_remove_key	vmlinux	EXPORT_SYMBOL_GPL	
++0xc8575a0e	tcf_idrinfo_destroy	vmlinux	EXPORT_SYMBOL	
++0x44230eaa	skb_cow_data	vmlinux	EXPORT_SYMBOL_GPL	
++0x1d9de59b	scsi_internal_device_block_nowait	vmlinux	EXPORT_SYMBOL_GPL	
++0x1441bb91	pci_fixup_cardbus	vmlinux	EXPORT_SYMBOL	
++0xa48c383b	encrypt_blob	vmlinux	EXPORT_SYMBOL_GPL	
++0xcd44a55a	posix_acl_update_mode	vmlinux	EXPORT_SYMBOL	
++0x64f74abf	__tracepoint_pelt_cfs_tp	vmlinux	EXPORT_SYMBOL_GPL	
++0x8fda0db4	ip4_datagram_release_cb	vmlinux	EXPORT_SYMBOL_GPL	
++0x01dbd0b7	i2c_get_adapter	vmlinux	EXPORT_SYMBOL	
++0x868acba5	get_options	vmlinux	EXPORT_SYMBOL	
++0x4b1270a6	vfs_iter_write	vmlinux	EXPORT_SYMBOL	
++0xf5e7ea40	ktime_get_coarse_ts64	vmlinux	EXPORT_SYMBOL	
++0xe12bfb1c	fib_new_table	vmlinux	EXPORT_SYMBOL_GPL	
++0x8a3f8aba	xdp_do_redirect	vmlinux	EXPORT_SYMBOL_GPL	
++0xdcac8612	input_unregister_handler	vmlinux	EXPORT_SYMBOL	
++0x3955fcf6	__kfifo_in_r	vmlinux	EXPORT_SYMBOL	
++0x26058b96	iomap_dio_iopoll	vmlinux	EXPORT_SYMBOL_GPL	
++0xcbefbb1a	fscrypt_prepare_symlink	vmlinux	EXPORT_SYMBOL_GPL	
++0x4000f1be	bh_uptodate_or_lock	vmlinux	EXPORT_SYMBOL	
++0x398ae1c4	mem_cgroup_from_task	vmlinux	EXPORT_SYMBOL	
++0x2782b393	xfrm_state_walk_init	vmlinux	EXPORT_SYMBOL	
++0xbacec72e	udp4_hwcsum	vmlinux	EXPORT_SYMBOL_GPL	
++0xb7cc0cff	__tracepoint_br_fdb_add	vmlinux	EXPORT_SYMBOL_GPL	
++0x469c7558	of_graph_get_port_by_id	vmlinux	EXPORT_SYMBOL	
++0xfb210de4	rc_register_device	vmlinux	EXPORT_SYMBOL_GPL	
++0x3499da02	rtc_read_alarm	vmlinux	EXPORT_SYMBOL_GPL	
++0xe2cf518d	device_match_of_node	vmlinux	EXPORT_SYMBOL_GPL	
++0x48a91171	string_get_size	vmlinux	EXPORT_SYMBOL	
++0x25712fb4	security_path_mknod	vmlinux	EXPORT_SYMBOL	
++0x3315e89e	fat_fill_super	vmlinux	EXPORT_SYMBOL_GPL	
++0x45608eae	dquot_initialize	vmlinux	EXPORT_SYMBOL	
++0x4d8fa234	vmf_insert_mixed	vmlinux	EXPORT_SYMBOL	
++0x670a13c5	regset_get_alloc	vmlinux	EXPORT_SYMBOL	
++0x8643117d	param_get_hexint	vmlinux	EXPORT_SYMBOL	
++0xc2e8e186	__sock_cmsg_send	vmlinux	EXPORT_SYMBOL	
++0xf7f46e1a	of_mdio_find_bus	vmlinux	EXPORT_SYMBOL	
++0x06e25842	pci_bus_write_config_word	vmlinux	EXPORT_SYMBOL	
++0x3a2f6702	sg_alloc_table	vmlinux	EXPORT_SYMBOL	
++0x28c9a301	handle_simple_irq	vmlinux	EXPORT_SYMBOL_GPL	
++0x286cc647	async_synchronize_cookie_domain	vmlinux	EXPORT_SYMBOL_GPL	
++0x02046f6d	call_usermodehelper_exec	vmlinux	EXPORT_SYMBOL	
++0x62175e70	dev_pm_opp_put_regulators	vmlinux	EXPORT_SYMBOL_GPL	
++0xcb84f357	power_supply_batinfo_ocv2cap	vmlinux	EXPORT_SYMBOL_GPL	
++0xfad1d6b9	pci_release_region	vmlinux	EXPORT_SYMBOL	
++0x7a0ead78	io_uring_get_socket	vmlinux	EXPORT_SYMBOL	
++0x141f38bf	ktime_get_raw_fast_ns	vmlinux	EXPORT_SYMBOL_GPL	
++0xd308de3d	inet_addr_type_table	vmlinux	EXPORT_SYMBOL	
++0xa92d0dd0	bpf_redirect_info	vmlinux	EXPORT_SYMBOL_GPL	
++0xa8c0fb60	power_supply_unregister	vmlinux	EXPORT_SYMBOL_GPL	
++0xcdca35f1	DWC_MEMMOVE	vmlinux	EXPORT_SYMBOL	
++0x89c02fb9	genphy_c37_read_status	vmlinux	EXPORT_SYMBOL	
++0x7485917b	genphy_c45_read_status	vmlinux	EXPORT_SYMBOL_GPL	
++0xc569d8ce	__clk_get_name	vmlinux	EXPORT_SYMBOL_GPL	
++0x999a13aa	gen_pool_dma_alloc	vmlinux	EXPORT_SYMBOL	
++0x74530ecd	fscache_op_debug_id	vmlinux	EXPORT_SYMBOL	
++0xff1e9dd8	seq_list_start	vmlinux	EXPORT_SYMBOL	
++0xc45ffa68	irq_find_matching_fwspec	vmlinux	EXPORT_SYMBOL_GPL	
++0x365b45d1	__tracepoint_sched_update_nr_running_tp	vmlinux	EXPORT_SYMBOL_GPL	
++0x4f882947	kthread_queue_work	vmlinux	EXPORT_SYMBOL_GPL	
++0x0049ca83	xfrm_aead_get_byname	vmlinux	EXPORT_SYMBOL_GPL	
++0x5aff5671	km_state_notify	vmlinux	EXPORT_SYMBOL	
++0x5afee0b6	lwtunnel_encap_del_ops	vmlinux	EXPORT_SYMBOL_GPL	
++0xffd361ab	cpuidle_enable_device	vmlinux	EXPORT_SYMBOL_GPL	
++0x754ecf42	dma_run_dependencies	vmlinux	EXPORT_SYMBOL_GPL	
++0x9af5590a	sbitmap_prepare_to_wait	vmlinux	EXPORT_SYMBOL_GPL	
++0x2d678c65	btree_grim_visitor	vmlinux	EXPORT_SYMBOL_GPL	
++0xdbacc616	bpf_prog_add	vmlinux	EXPORT_SYMBOL_GPL	
++0x24709b2f	trace_seq_putmem	vmlinux	EXPORT_SYMBOL_GPL	
++0xddf6ad7a	completion_done	vmlinux	EXPORT_SYMBOL	
++0xb94339c4	qdisc_put_stab	vmlinux	EXPORT_SYMBOL	
++0x73b0849e	devm_led_trigger_register	vmlinux	EXPORT_SYMBOL_GPL	
++0xce4cdb8e	fb_find_best_mode	vmlinux	EXPORT_SYMBOL	
++0x3450ad94	mpi_set_ui	vmlinux	EXPORT_SYMBOL_GPL	
++0xa18f6650	__traceiter_block_unplug	vmlinux	EXPORT_SYMBOL_GPL	
++0x2609df9d	pnfs_set_layoutcommit	vmlinux	EXPORT_SYMBOL_GPL	
++0xec2f8add	nfs_setsecurity	vmlinux	EXPORT_SYMBOL_GPL	
++0xeb118828	seq_printf	vmlinux	EXPORT_SYMBOL	
++0x89ae2b1e	vmap_hugepage	vmlinux	EXPORT_SYMBOL	
++0x574151f0	flow_indr_dev_unregister	vmlinux	EXPORT_SYMBOL	
++0x2c97763e	mmc_free_host	vmlinux	EXPORT_SYMBOL	
++0xe9180146	devres_release	vmlinux	EXPORT_SYMBOL_GPL	
++0x9136ab0d	pci_dev_driver	vmlinux	EXPORT_SYMBOL	
++0xb631d890	xas_create_range	vmlinux	EXPORT_SYMBOL_GPL	
++0x0b742fd7	simple_strtol	vmlinux	EXPORT_SYMBOL	
++0x6d95a078	setattr_prepare	vmlinux	EXPORT_SYMBOL	
++0x629bc59f	ilookup5_nowait	vmlinux	EXPORT_SYMBOL	
++0x299e2f71	irq_gc_mask_clr_bit	vmlinux	EXPORT_SYMBOL_GPL	
++0xed4904ff	irq_gc_mask_set_bit	vmlinux	EXPORT_SYMBOL_GPL	
++0xded39a6b	gen_kill_estimator	vmlinux	EXPORT_SYMBOL	
++0xa4e9bdd3	devm_add_action	vmlinux	EXPORT_SYMBOL_GPL	
++0x82635ac3	serdev_device_set_parity	vmlinux	EXPORT_SYMBOL_GPL	
++0x1914d22d	pci_set_power_state	vmlinux	EXPORT_SYMBOL	
++0xc4b134bf	blk_queue_alignment_offset	vmlinux	EXPORT_SYMBOL	
++0x7c9722ba	nfs_dreq_bytes_left	vmlinux	EXPORT_SYMBOL_GPL	
++0xa8e9e1ae	send_implementation_id	vmlinux	EXPORT_SYMBOL_GPL	
++0x41a9ce5e	dquot_alloc	vmlinux	EXPORT_SYMBOL	
++0x6a45cd76	wait_on_page_writeback	vmlinux	EXPORT_SYMBOL_GPL	
++0xdd849d51	scsi_get_sense_info_fld	vmlinux	EXPORT_SYMBOL	
++0xf97dce43	mipi_dsi_shutdown_peripheral	vmlinux	EXPORT_SYMBOL	
++0x2e7bc89d	pci_bus_size_bridges	vmlinux	EXPORT_SYMBOL	
++0x67429c91	__SCK__tp_func_block_bio_remap	vmlinux	EXPORT_SYMBOL_GPL	
++0xd681f3a5	sysfs_create_groups	vmlinux	EXPORT_SYMBOL_GPL	
++0xdba9c9d6	vfs_setpos	vmlinux	EXPORT_SYMBOL	
++0xf8c482ed	vm_node_stat	vmlinux	EXPORT_SYMBOL	
++0xa0fbac79	wake_up_bit	vmlinux	EXPORT_SYMBOL	
++0x1958cfa8	__traceiter_sched_util_est_se_tp	vmlinux	EXPORT_SYMBOL_GPL	
++0x7c270d7e	sdhci_execute_tuning	vmlinux	EXPORT_SYMBOL_GPL	
++0x7440b7b2	dev_pm_opp_init_cpufreq_table	vmlinux	EXPORT_SYMBOL_GPL	
++0x4b818132	scsi_free_sgtables	vmlinux	EXPORT_SYMBOL_GPL	
++0x9a8bef92	pm_genpd_opp_to_performance_state	vmlinux	EXPORT_SYMBOL_GPL	
++0x02cf9276	tty_do_resize	vmlinux	EXPORT_SYMBOL	
++0x6aeefac4	zlib_deflateReset	vmlinux	EXPORT_SYMBOL	
++0x306af8ac	compat_only_sysfs_link_entry_to_kobj	vmlinux	EXPORT_SYMBOL_GPL	
++0x354050e9	fscrypt_put_encryption_info	vmlinux	EXPORT_SYMBOL	
++0x9a5fadc7	fscrypt_get_encryption_info	vmlinux	EXPORT_SYMBOL	
++0x2ff43d88	jump_label_update_timeout	vmlinux	EXPORT_SYMBOL_GPL	
++0xcdca3691	nr_irqs	vmlinux	EXPORT_SYMBOL_GPL	
++0x8518a4a6	_raw_spin_trylock_bh	vmlinux	EXPORT_SYMBOL	
++0x51e77c97	pfn_valid	vmlinux	EXPORT_SYMBOL	
++0xdaf5c16e	__cookie_v4_check	vmlinux	EXPORT_SYMBOL_GPL	
++0x56c8799d	scsi_kunmap_atomic_sg	vmlinux	EXPORT_SYMBOL	
++0xa0c284ff	scsi_block_when_processing_errors	vmlinux	EXPORT_SYMBOL	
++0x0dd17c58	wait_for_key_construction	vmlinux	EXPORT_SYMBOL	
++0x17e4c291	nfs_post_op_update_inode	vmlinux	EXPORT_SYMBOL_GPL	
++0xd867f7d5	jbd2_journal_set_triggers	vmlinux	EXPORT_SYMBOL	
++0x26c845d7	f_setown	vmlinux	EXPORT_SYMBOL	
++0x2065ce6a	free_workqueue_attrs	vmlinux	EXPORT_SYMBOL_GPL	
++0x05e807a9	xdr_encode_string	vmlinux	EXPORT_SYMBOL_GPL	
++0xeceb36e5	ip6_dst_hoplimit	vmlinux	EXPORT_SYMBOL	
++0xc697b0f7	nvmem_device_read	vmlinux	EXPORT_SYMBOL_GPL	
++0x6d240bf3	usb_clear_halt	vmlinux	EXPORT_SYMBOL_GPL	
++0x18e4f8aa	swphy_read_reg	vmlinux	EXPORT_SYMBOL_GPL	
++0x24b45f76	amba_device_unregister	vmlinux	EXPORT_SYMBOL	
++0xbd316f42	of_pwm_get	vmlinux	EXPORT_SYMBOL_GPL	
++0x1a1bac9c	ZSTD_decompressDCtx	vmlinux	EXPORT_SYMBOL	
++0x4bc8d5fa	elv_unregister	vmlinux	EXPORT_SYMBOL_GPL	
++0x15372245	x509_cert_parse	vmlinux	EXPORT_SYMBOL_GPL	
++0x9c3885be	__rt_rwlock_init	vmlinux	EXPORT_SYMBOL	
++0x5f0dfde6	sched_autogroup_detach	vmlinux	EXPORT_SYMBOL	
++0x887241b2	flow_rule_match_vlan	vmlinux	EXPORT_SYMBOL	
++0x9abefdd4	dev_mc_sync_multiple	vmlinux	EXPORT_SYMBOL	
++0x79a82696	dev_uc_sync_multiple	vmlinux	EXPORT_SYMBOL	
++0xc56926e5	of_pci_dma_range_parser_init	vmlinux	EXPORT_SYMBOL_GPL	
++0xaa2d4bbf	devm_gpiod_get_array_optional	vmlinux	EXPORT_SYMBOL_GPL	
++0x4de134b0	submit_bh	vmlinux	EXPORT_SYMBOL	
++0xd043d772	mnt_clone_write	vmlinux	EXPORT_SYMBOL_GPL	
++0x28c4e702	page_mkclean	vmlinux	EXPORT_SYMBOL_GPL	
++0x1acd18c8	cpuset_cgrp_subsys_on_dfl_key	vmlinux	EXPORT_SYMBOL_GPL	
++0xea2f7931	mr_mfc_find_any_parent	vmlinux	EXPORT_SYMBOL	
++0x248cb004	passthru_features_check	vmlinux	EXPORT_SYMBOL	
++0xfa209370	skb_checksum_setup	vmlinux	EXPORT_SYMBOL	
++0xc640769c	usb_anchor_empty	vmlinux	EXPORT_SYMBOL_GPL	
++0xe0b1c103	clk_set_max_rate	vmlinux	EXPORT_SYMBOL_GPL	
++0xa5526619	rb_insert_color	vmlinux	EXPORT_SYMBOL	
++0x1cb2c6d8	kvasprintf	vmlinux	EXPORT_SYMBOL	
++0xe2fb3558	skcipher_walk_aead_encrypt	vmlinux	EXPORT_SYMBOL_GPL	
++0xeb96cd43	debugfs_write_file_bool	vmlinux	EXPORT_SYMBOL_GPL	
++0x2a87cbcf	page_get_link	vmlinux	EXPORT_SYMBOL	
++0xe2a57d1b	kthread_flush_worker	vmlinux	EXPORT_SYMBOL_GPL	
++0x1b05a96a	svcauth_unix_set_client	vmlinux	EXPORT_SYMBOL_GPL	
++0x385323cd	__xfrm_init_state	vmlinux	EXPORT_SYMBOL	
++0x313592bf	xdp_rxq_info_reg	vmlinux	EXPORT_SYMBOL_GPL	
++0x45b5be1f	hid_dump_field	vmlinux	EXPORT_SYMBOL_GPL	
++0x32d71c70	__scsi_init_queue	vmlinux	EXPORT_SYMBOL_GPL	
++0x5790e7a0	pci_unlock_rescan_remove	vmlinux	EXPORT_SYMBOL_GPL	
++0x532b90b5	kprobe_event_cmd_init	vmlinux	EXPORT_SYMBOL_GPL	
++0x66d87d38	symbol_put_addr	vmlinux	EXPORT_SYMBOL_GPL	
++0x70c3aad5	hrtimer_start_range_ns	vmlinux	EXPORT_SYMBOL_GPL	
++0x6b7c78e0	i2c_smbus_read_word_data	vmlinux	EXPORT_SYMBOL	
++0x89fed4a6	device_for_each_child_reverse	vmlinux	EXPORT_SYMBOL_GPL	
++0x452f44c7	tty_port_unregister_device	vmlinux	EXPORT_SYMBOL_GPL	
++0x1ab15de2	tty_buffer_request_room	vmlinux	EXPORT_SYMBOL_GPL	
++0x30a73650	d_alloc	vmlinux	EXPORT_SYMBOL	
++0xe54884df	regmap_multi_reg_write_bypassed	vmlinux	EXPORT_SYMBOL_GPL	
++0x97db529b	submit_bio_noacct	vmlinux	EXPORT_SYMBOL	
++0x93255b2b	ring_buffer_lock_reserve	vmlinux	EXPORT_SYMBOL_GPL	
++0x28f26684	irq_set_affinity_hint	vmlinux	EXPORT_SYMBOL_GPL	
++0x3686e120	finish_swait	vmlinux	EXPORT_SYMBOL	
++0x399c1474	inet_sk_rx_dst_set	vmlinux	EXPORT_SYMBOL	
++0x273121f5	netdev_port_same_parent_id	vmlinux	EXPORT_SYMBOL	
++0xdd0a9a94	of_clk_get_from_provider	vmlinux	EXPORT_SYMBOL_GPL	
++0x76d9b876	clk_set_rate	vmlinux	EXPORT_SYMBOL_GPL	
++0x556e4390	clk_get_rate	vmlinux	EXPORT_SYMBOL_GPL	
++0xff81487d	gpiod_remove_lookup_table	vmlinux	EXPORT_SYMBOL_GPL	
++0xd001d66e	blk_execute_rq_nowait	vmlinux	EXPORT_SYMBOL_GPL	
++0x35cfc9e4	blk_set_stacking_limits	vmlinux	EXPORT_SYMBOL	
++0xec73ceeb	security_inode_mkdir	vmlinux	EXPORT_SYMBOL_GPL	
++0xf55ddab5	fscache_object_lookup_negative	vmlinux	EXPORT_SYMBOL	
++0xf84bd6ee	bpf_stats_enabled_key	vmlinux	EXPORT_SYMBOL	
++0xb02a880e	xdr_stream_decode_opaque	vmlinux	EXPORT_SYMBOL_GPL	
++0x958bce7e	tcf_chain_get_by_act	vmlinux	EXPORT_SYMBOL	
++0x743afd91	kernel_sendpage	vmlinux	EXPORT_SYMBOL	
++0x197d4297	pci_choose_state	vmlinux	EXPORT_SYMBOL	
++0x1dab1e0f	nfs_access_add_cache	vmlinux	EXPORT_SYMBOL_GPL	
++0x10127dcf	dquot_quotactl_sysfile_ops	vmlinux	EXPORT_SYMBOL	
++0xe784ac2a	delete_from_page_cache	vmlinux	EXPORT_SYMBOL	
++0x6b2b69f7	static_key_enable	vmlinux	EXPORT_SYMBOL_GPL	
++0xa9320d27	ktime_get_seconds	vmlinux	EXPORT_SYMBOL_GPL	
++0x20463df4	wait_for_completion_killable	vmlinux	EXPORT_SYMBOL	
++0x8dcb38d5	led_trigger_write	vmlinux	EXPORT_SYMBOL_GPL	
++0x041f06cc	uart_insert_char	vmlinux	EXPORT_SYMBOL_GPL	
++0x0e7ccdf6	logfc	vmlinux	EXPORT_SYMBOL	
++0x949f7342	__alloc_percpu	vmlinux	EXPORT_SYMBOL_GPL	
++0xe02ba436	trace_print_hex_seq	vmlinux	EXPORT_SYMBOL	
++0x6ebe366f	ktime_get_mono_fast_ns	vmlinux	EXPORT_SYMBOL_GPL	
++0x430961fc	__percpu_down_read	vmlinux	EXPORT_SYMBOL_GPL	
++0x176cbee2	__raw_v4_lookup	vmlinux	EXPORT_SYMBOL_GPL	
++0x785ec78b	led_trigger_unregister	vmlinux	EXPORT_SYMBOL_GPL	
++0x694a3e5c	clear_inode	vmlinux	EXPORT_SYMBOL	
++0xb83b239d	svc_close_xprt	vmlinux	EXPORT_SYMBOL_GPL	
++0x99517682	udp_encap_enable	vmlinux	EXPORT_SYMBOL	
++0x5ce16fa5	qdisc_hash_add	vmlinux	EXPORT_SYMBOL	
++0xcbefc058	neigh_parms_release	vmlinux	EXPORT_SYMBOL	
++0xc8a7a8a6	led_set_brightness_nosleep	vmlinux	EXPORT_SYMBOL_GPL	
++0x70fbd18b	usb_hcd_link_urb_to_ep	vmlinux	EXPORT_SYMBOL_GPL	
++0x3612437e	device_release_driver	vmlinux	EXPORT_SYMBOL_GPL	
++0xa98bf299	crypto_grab_akcipher	vmlinux	EXPORT_SYMBOL_GPL	
++0x7dce7561	crypto_grab_skcipher	vmlinux	EXPORT_SYMBOL_GPL	
++0x390bf1f1	security_path_rename	vmlinux	EXPORT_SYMBOL	
++0xe953b21f	get_next_ino	vmlinux	EXPORT_SYMBOL	
++0xc6181c70	queue_rcu_work	vmlinux	EXPORT_SYMBOL	
++0x97e99fce	efivar_entry_size	vmlinux	EXPORT_SYMBOL_GPL	
++0x3a2d65bf	sdhci_cqe_disable	vmlinux	EXPORT_SYMBOL_GPL	
++0x4815aa79	dev_pm_opp_cpumask_remove_table	vmlinux	EXPORT_SYMBOL_GPL	
++0xdb259f6f	usb_stor_bulk_srb	vmlinux	EXPORT_SYMBOL_GPL	USB_STORAGE
++0xa57c4de6	usb_alloc_streams	vmlinux	EXPORT_SYMBOL_GPL	
++0xf993dcc1	fixed_phy_change_carrier	vmlinux	EXPORT_SYMBOL_GPL	
++0x59341d7a	scsi_register_interface	vmlinux	EXPORT_SYMBOL	
++0xb3ecd6a0	pinctrl_utils_add_config	vmlinux	EXPORT_SYMBOL_GPL	
++0x2f55bec1	nfs4_schedule_lease_moved_recovery	vmlinux	EXPORT_SYMBOL_GPL	
++0x920901b4	vfs_setlease	vmlinux	EXPORT_SYMBOL_GPL	
++0x1d43e846	find_get_pages_range_tag	vmlinux	EXPORT_SYMBOL	
++0xa183a3b6	from_kgid_munged	vmlinux	EXPORT_SYMBOL	
++0x40d04664	console_trylock	vmlinux	EXPORT_SYMBOL	
++0xe06879a1	i2c_smbus_read_block_data	vmlinux	EXPORT_SYMBOL	
++0x878de505	usb_put_intf	vmlinux	EXPORT_SYMBOL_GPL	
++0x12e9d073	__regmap_init_mmio_clk	vmlinux	EXPORT_SYMBOL_GPL	
++0x46c5be22	clk_multiplier_ops	vmlinux	EXPORT_SYMBOL_GPL	
++0x274ddf3f	nla_put_64bit	vmlinux	EXPORT_SYMBOL	
++0x81f372a2	unregister_ftrace_export	vmlinux	EXPORT_SYMBOL_GPL	
++0x4a3ad70e	wait_for_completion_timeout	vmlinux	EXPORT_SYMBOL	
++0x025483b1	set_current_groups	vmlinux	EXPORT_SYMBOL	
++0xc227c729	rt_dst_clone	vmlinux	EXPORT_SYMBOL	
++0x0b94d8d8	neigh_proc_dointvec_jiffies	vmlinux	EXPORT_SYMBOL	
++0xaf34e6c8	skb_copy_header	vmlinux	EXPORT_SYMBOL	
++0xb95583da	usb_stor_probe2	vmlinux	EXPORT_SYMBOL_GPL	USB_STORAGE
++0x89810133	usb_stor_probe1	vmlinux	EXPORT_SYMBOL_GPL	USB_STORAGE
++0x35e50800	update_region	vmlinux	EXPORT_SYMBOL	
++0x88f4071a	dma_request_chan_by_mask	vmlinux	EXPORT_SYMBOL_GPL	
++0x81db6ebb	xz_dec_reset	vmlinux	EXPORT_SYMBOL	
++0x16ac761b	public_key_signature_free	vmlinux	EXPORT_SYMBOL_GPL	
++0xb6bdf673	pnfs_generic_pg_test	vmlinux	EXPORT_SYMBOL_GPL	
++0x04ca3286	nfs_show_options	vmlinux	EXPORT_SYMBOL_GPL	
++0x88e1d0f0	page_frag_free	vmlinux	EXPORT_SYMBOL	
++0x661601de	sprint_symbol	vmlinux	EXPORT_SYMBOL_GPL	
++0x602427b3	rt_spin_unlock	vmlinux	EXPORT_SYMBOL	
++0x06055a23	__tracepoint_pelt_se_tp	vmlinux	EXPORT_SYMBOL_GPL	
++0x15c60a71	__tracepoint_pelt_dl_tp	vmlinux	EXPORT_SYMBOL_GPL	
++0x90d937b4	__tracepoint_pelt_rt_tp	vmlinux	EXPORT_SYMBOL_GPL	
++0xb167423e	tcf_em_unregister	vmlinux	EXPORT_SYMBOL	
++0x01ef697a	scm_fp_dup	vmlinux	EXPORT_SYMBOL	
++0x05610897	of_changeset_destroy	vmlinux	EXPORT_SYMBOL_GPL	
++0xf8d53c0e	led_stop_software_blink	vmlinux	EXPORT_SYMBOL_GPL	
++0xdfaec61d	rc_g_keycode_from_table	vmlinux	EXPORT_SYMBOL_GPL	
++0xb3d6f8ee	arizona_free_irq	vmlinux	EXPORT_SYMBOL_GPL	
++0xe59ff4d1	devres_remove	vmlinux	EXPORT_SYMBOL_GPL	
++0xdac31e39	mipi_dsi_dcs_set_tear_on	vmlinux	EXPORT_SYMBOL	
++0x7e156b3c	tty_vhangup	vmlinux	EXPORT_SYMBOL	
++0x0248efd3	kstrtobool_from_user	vmlinux	EXPORT_SYMBOL	
++0xb2c2ee33	shrink_dcache_parent	vmlinux	EXPORT_SYMBOL	
++0xb9f89246	trace_seq_vprintf	vmlinux	EXPORT_SYMBOL_GPL	
++0x609f1c7e	synchronize_net	vmlinux	EXPORT_SYMBOL	
++0xedcaf9d1	netdev_adjacent_change_abort	vmlinux	EXPORT_SYMBOL	
++0x737b7ecd	mdiobus_register_device	vmlinux	EXPORT_SYMBOL	
++0x1c94605e	bus_for_each_drv	vmlinux	EXPORT_SYMBOL_GPL	
++0x109b9d21	bus_for_each_dev	vmlinux	EXPORT_SYMBOL_GPL	
++0x84f2c49c	bsg_job_done	vmlinux	EXPORT_SYMBOL_GPL	
++0x6091797f	synchronize_rcu	vmlinux	EXPORT_SYMBOL_GPL	
++0x42825ce2	rcu_scheduler_active	vmlinux	EXPORT_SYMBOL_GPL	
++0xe523ad75	synchronize_irq	vmlinux	EXPORT_SYMBOL	
++0x692815cb	flow_rule_alloc	vmlinux	EXPORT_SYMBOL	
++0x2609c168	pneigh_lookup	vmlinux	EXPORT_SYMBOL	
++0xce55dd03	usb_gadget_udc_reset	vmlinux	EXPORT_SYMBOL_GPL	
++0x0a452256	component_master_del	vmlinux	EXPORT_SYMBOL_GPL	
++0xdf8c695a	__ndelay	vmlinux	EXPORT_SYMBOL	
++0x9e7d6bd0	__udelay	vmlinux	EXPORT_SYMBOL	
++0x985453e1	lease_unregister_notifier	vmlinux	EXPORT_SYMBOL_GPL	
++0xcd3482da	kern_path_create	vmlinux	EXPORT_SYMBOL	
++0xf6f9d58d	init_on_free	vmlinux	EXPORT_SYMBOL	
++0x1dd877e8	irq_create_mapping_affinity	vmlinux	EXPORT_SYMBOL_GPL	
++0x47b29219	xdr_terminate_string	vmlinux	EXPORT_SYMBOL_GPL	
++0x9afcfd10	rpc_net_ns	vmlinux	EXPORT_SYMBOL_GPL	
++0x1e9aa906	fib_rules_dump	vmlinux	EXPORT_SYMBOL_GPL	
++0x6e726b81	pci_irq_vector	vmlinux	EXPORT_SYMBOL	
++0xe2ffeef3	scsi_req_init	vmlinux	EXPORT_SYMBOL	
++0x56d5fe28	fsnotify_find_mark	vmlinux	EXPORT_SYMBOL_GPL	
++0xa2f1733a	super_setup_bdi	vmlinux	EXPORT_SYMBOL	
++0x525d0aa3	trace_seq_printf	vmlinux	EXPORT_SYMBOL_GPL	
++0xb44e18ea	audit_enabled	vmlinux	EXPORT_SYMBOL_GPL	
++0x39461d6a	in_egroup_p	vmlinux	EXPORT_SYMBOL	
++0xa5ccf658	eth_gro_complete	vmlinux	EXPORT_SYMBOL	
++0x9f64714c	phy_package_leave	vmlinux	EXPORT_SYMBOL_GPL	
++0xd9b8eaea	__SCK__tp_func_dma_fence_signaled	vmlinux	EXPORT_SYMBOL	
++0x409873e3	tty_termios_baud_rate	vmlinux	EXPORT_SYMBOL	
++0x40b745ae	rdev_get_regmap	vmlinux	EXPORT_SYMBOL_GPL	
++0x07a890c8	fb_alloc_cmap	vmlinux	EXPORT_SYMBOL	
++0xd90987b2	perf_event_addr_filters_sync	vmlinux	EXPORT_SYMBOL_GPL	
++0x129a3976	irq_chip_set_type_parent	vmlinux	EXPORT_SYMBOL_GPL	
++0xf1b47efd	ping_seq_start	vmlinux	EXPORT_SYMBOL_GPL	
++0x09c3b4bc	tcp_sock_set_keepintvl	vmlinux	EXPORT_SYMBOL	
++0x9f54ead7	gro_cells_destroy	vmlinux	EXPORT_SYMBOL	
++0x93d48daa	input_mt_sync_frame	vmlinux	EXPORT_SYMBOL	
++0x44f8fc3c	phy_speed_up	vmlinux	EXPORT_SYMBOL_GPL	
++0x5a100bfe	devm_spi_mem_dirmap_create	vmlinux	EXPORT_SYMBOL_GPL	
++0xa9beb800	devm_regmap_field_bulk_alloc	vmlinux	EXPORT_SYMBOL_GPL	
++0xc6d09aa9	release_firmware	vmlinux	EXPORT_SYMBOL	
++0x1224ea7e	blk_mq_start_stopped_hw_queue	vmlinux	EXPORT_SYMBOL_GPL	
++0x12127bce	set_posix_acl	vmlinux	EXPORT_SYMBOL	
++0x9e0c711d	vzalloc_node	vmlinux	EXPORT_SYMBOL	
++0x7f24de73	jiffies_to_usecs	vmlinux	EXPORT_SYMBOL	
++0x37befc70	jiffies_to_msecs	vmlinux	EXPORT_SYMBOL	
++0x96a5cc73	iptun_encaps	vmlinux	EXPORT_SYMBOL	
++0x31d22246	inet_frag_queue_insert	vmlinux	EXPORT_SYMBOL	
++0x9d2f0bf5	tcp_child_process	vmlinux	EXPORT_SYMBOL	
++0x051401ef	sock_diag_put_filterinfo	vmlinux	EXPORT_SYMBOL	
++0x703519e0	netdev_set_tc_queue	vmlinux	EXPORT_SYMBOL	
++0x323a8f6c	devm_power_supply_register	vmlinux	EXPORT_SYMBOL_GPL	
++0x670ca4f9	phy_start_machine	vmlinux	EXPORT_SYMBOL_GPL	
++0x56dc9144	devm_mdiobus_alloc_size	vmlinux	EXPORT_SYMBOL	
++0x37511acc	__pm_runtime_suspend	vmlinux	EXPORT_SYMBOL_GPL	
++0xc6055c9e	kvasprintf_const	vmlinux	EXPORT_SYMBOL	
++0x4c193371	param_get_charp	vmlinux	EXPORT_SYMBOL	
++0x54047985	xdp_rxq_info_unreg	vmlinux	EXPORT_SYMBOL_GPL	
++0x4177d44d	netdev_next_lower_dev_rcu	vmlinux	EXPORT_SYMBOL	
++0x74383eeb	validate_xmit_skb_list	vmlinux	EXPORT_SYMBOL_GPL	
++0x8dccfd2b	of_find_matching_node_and_match	vmlinux	EXPORT_SYMBOL	
++0xff632c32	mdiobus_write	vmlinux	EXPORT_SYMBOL	
++0xaa4fc5ef	__devm_mdiobus_register	vmlinux	EXPORT_SYMBOL	
++0xa3fc9aac	tty_port_destroy	vmlinux	EXPORT_SYMBOL	
++0x95657ba3	bsg_unregister_queue	vmlinux	EXPORT_SYMBOL_GPL	
++0xf13f861c	bio_trim	vmlinux	EXPORT_SYMBOL_GPL	
++0x422769dd	dquot_claim_space_nodirty	vmlinux	EXPORT_SYMBOL	
++0xaa08a1d3	blkdev_read_iter	vmlinux	EXPORT_SYMBOL_GPL	
++0xba36a6b3	irq_domain_remove_sim	vmlinux	EXPORT_SYMBOL_GPL	
++0xa5da633a	tcp_v4_destroy_sock	vmlinux	EXPORT_SYMBOL	
++0x11d65856	pm_clk_remove_clk	vmlinux	EXPORT_SYMBOL_GPL	
++0xa7c9d4d4	remove_conflicting_pci_framebuffers	vmlinux	EXPORT_SYMBOL	
++0xcfb8cad7	gpiod_export	vmlinux	EXPORT_SYMBOL_GPL	
++0xdf2c2742	rb_last	vmlinux	EXPORT_SYMBOL	
++0x04c4f603	mpi_get_buffer	vmlinux	EXPORT_SYMBOL_GPL	
++0x8a3f84ba	linear_range_get_selector_low	vmlinux	EXPORT_SYMBOL_GPL	
++0xd3b75f41	sysfs_create_mount_point	vmlinux	EXPORT_SYMBOL_GPL	
++0x87b66f26	mount_bdev	vmlinux	EXPORT_SYMBOL	
++0xcc5d22d9	can_do_mlock	vmlinux	EXPORT_SYMBOL	
++0x60a13e90	rcu_barrier	vmlinux	EXPORT_SYMBOL_GPL	
++0x9d432916	i2c_new_smbus_alert_device	vmlinux	EXPORT_SYMBOL_GPL	
++0x3c3ff9fd	sprintf	vmlinux	EXPORT_SYMBOL	
++0x39f9103c	dup_iter	vmlinux	EXPORT_SYMBOL	
++0xda3d10a8	security_tun_dev_open	vmlinux	EXPORT_SYMBOL	
++0xe60355c9	nfs_umount_begin	vmlinux	EXPORT_SYMBOL_GPL	
++0xcad2d06e	simple_attr_write	vmlinux	EXPORT_SYMBOL_GPL	
++0x17974c22	simple_unlink	vmlinux	EXPORT_SYMBOL	
++0x08778cfc	generic_listxattr	vmlinux	EXPORT_SYMBOL	
++0x97441e61	apply_to_existing_page_range	vmlinux	EXPORT_SYMBOL_GPL	
++0xf6ebc03b	net_ratelimit	vmlinux	EXPORT_SYMBOL	
++0x64a78634	dev_addr_init	vmlinux	EXPORT_SYMBOL	
++0x23f4ddb6	platform_device_add_properties	vmlinux	EXPORT_SYMBOL_GPL	
++0x1ebf6c2a	pci_power_names	vmlinux	EXPORT_SYMBOL_GPL	
++0x01df6921	shash_ahash_update	vmlinux	EXPORT_SYMBOL_GPL	
++0xf2e5bd87	security_free_mnt_opts	vmlinux	EXPORT_SYMBOL	
++0x88c0fad6	posix_acl_valid	vmlinux	EXPORT_SYMBOL	
++0x0f1843d2	invalidate_inode_buffers	vmlinux	EXPORT_SYMBOL	
++0xf97c8d79	PageMovable	vmlinux	EXPORT_SYMBOL	
++0xc3055d20	usleep_range_state	vmlinux	EXPORT_SYMBOL	
++0xa2954422	cpu_hwcaps	vmlinux	EXPORT_SYMBOL	
++0x1d77b0f8	unix_socket_table	vmlinux	EXPORT_SYMBOL_GPL	
++0x3dd1c5f8	nl_table	vmlinux	EXPORT_SYMBOL_GPL	
++0xe67b270b	usb_autopm_get_interface_async	vmlinux	EXPORT_SYMBOL_GPL	
++0x4e8a56c6	bcm_phy_cable_test_start	vmlinux	EXPORT_SYMBOL_GPL	
++0x230fc42e	mipi_dsi_dcs_exit_sleep_mode	vmlinux	EXPORT_SYMBOL	
++0x742578a5	wait_for_random_bytes	vmlinux	EXPORT_SYMBOL	
++0x6391d1ae	regulator_register_notifier	vmlinux	EXPORT_SYMBOL_GPL	
++0xa63b48ff	crypto_shash_update	vmlinux	EXPORT_SYMBOL_GPL	
++0xb00b09ab	find_vma	vmlinux	EXPORT_SYMBOL	
++0xeea7f5c6	svc_print_addr	vmlinux	EXPORT_SYMBOL_GPL	
++0xf005e93d	kernel_connect	vmlinux	EXPORT_SYMBOL	
++0x802f23f7	of_phandle_iterator_init	vmlinux	EXPORT_SYMBOL_GPL	
++0x2fb5d9e9	devm_regulator_unregister	vmlinux	EXPORT_SYMBOL_GPL	
++0x4af7e7c8	gen_pool_get	vmlinux	EXPORT_SYMBOL_GPL	
++0x7fe458d6	dquot_destroy	vmlinux	EXPORT_SYMBOL	
++0x9c14671d	single_open_size	vmlinux	EXPORT_SYMBOL	
++0x8a10c04a	inet_stream_connect	vmlinux	EXPORT_SYMBOL	
++0x778732bc	peernet2id	vmlinux	EXPORT_SYMBOL	
++0xa8d96095	mdiobus_read_nested	vmlinux	EXPORT_SYMBOL	
++0xaa33e548	dma_buf_end_cpu_access	vmlinux	EXPORT_SYMBOL_GPL	
++0xd35a6d31	mempool_kmalloc	vmlinux	EXPORT_SYMBOL	
++0x6af5e0b8	rpc_mkpipe_dentry	vmlinux	EXPORT_SYMBOL_GPL	
++0xdd90ac6f	qdisc_warn_nonwc	vmlinux	EXPORT_SYMBOL	
++0xda74b89f	vga_remove_vgacon	vmlinux	EXPORT_SYMBOL	
++0xaed0f569	pci_release_regions	vmlinux	EXPORT_SYMBOL	
++0x3a015f24	xfrma_policy	vmlinux	EXPORT_SYMBOL_GPL	
++0x75fb9062	arch_timer_read_counter	vmlinux	EXPORT_SYMBOL_GPL	
++0x553b49a4	cpufreq_get_driver_data	vmlinux	EXPORT_SYMBOL_GPL	
++0x25a35960	blk_queue_physical_block_size	vmlinux	EXPORT_SYMBOL	
++0xca2b3e8d	nlmclnt_done	vmlinux	EXPORT_SYMBOL_GPL	
++0x3223d677	relay_subbufs_consumed	vmlinux	EXPORT_SYMBOL_GPL	
++0xb8212341	timecounter_cyc2time	vmlinux	EXPORT_SYMBOL_GPL	
++0x0464bc92	ip_route_output_tunnel	vmlinux	EXPORT_SYMBOL_GPL	
++0x09d6f6e0	sock_diag_check_cookie	vmlinux	EXPORT_SYMBOL_GPL	
++0x23412816	rtc_tm_to_ktime	vmlinux	EXPORT_SYMBOL_GPL	
++0xe4125646	bcm_phy_28nm_a0b0_afe_config_init	vmlinux	EXPORT_SYMBOL_GPL	
++0x838d2bc8	siphash_3u32	vmlinux	EXPORT_SYMBOL	
++0x70002fe8	siphash_1u32	vmlinux	EXPORT_SYMBOL	
++0xa095e02e	generic_check_addressable	vmlinux	EXPORT_SYMBOL	
++0x82666698	get_tree_nodev	vmlinux	EXPORT_SYMBOL	
++0x04c43355	perf_event_read_value	vmlinux	EXPORT_SYMBOL_GPL	
++0x04482cdb	__refrigerator	vmlinux	EXPORT_SYMBOL	
++0xf558bf8f	irqchip_fwnode_ops	vmlinux	EXPORT_SYMBOL_GPL	
++0xbf30cf55	netdev_refcnt_read	vmlinux	EXPORT_SYMBOL	
++0x29d2c3f4	i2c_recover_bus	vmlinux	EXPORT_SYMBOL_GPL	
++0x3f90ec0c	input_mt_init_slots	vmlinux	EXPORT_SYMBOL	
++0x8e321ad6	usb_disable_lpm	vmlinux	EXPORT_SYMBOL_GPL	
++0xb9943585	usb_disable_ltm	vmlinux	EXPORT_SYMBOL_GPL	
++0x5c5c6826	phy_10gbit_full_features	vmlinux	EXPORT_SYMBOL_GPL	
++0x07580976	devres_close_group	vmlinux	EXPORT_SYMBOL_GPL	
++0xf5f370e0	async_schedule_node	vmlinux	EXPORT_SYMBOL_GPL	
++0x1bc41892	tcp_rcv_established	vmlinux	EXPORT_SYMBOL	
++0x7643fe5d	inet_getpeer	vmlinux	EXPORT_SYMBOL_GPL	
++0x55c59097	ipv4_update_pmtu	vmlinux	EXPORT_SYMBOL_GPL	
++0xda80fa0c	usb_enable_lpm	vmlinux	EXPORT_SYMBOL_GPL	
++0xed26d55f	usb_enable_ltm	vmlinux	EXPORT_SYMBOL_GPL	
++0xd7e56a4e	simple_strtoll	vmlinux	EXPORT_SYMBOL	
++0x20000329	simple_strtoul	vmlinux	EXPORT_SYMBOL	
++0x28b3d3e9	klist_next	vmlinux	EXPORT_SYMBOL_GPL	
++0x5fa625ed	mpi_ec_mul_point	vmlinux	EXPORT_SYMBOL_GPL	
++0xde111582	nfs_initiate_commit	vmlinux	EXPORT_SYMBOL_GPL	
++0xe19c8e76	fsnotify_destroy_mark	vmlinux	EXPORT_SYMBOL_GPL	
++0xec38b1d9	balance_dirty_pages_ratelimited	vmlinux	EXPORT_SYMBOL	
++0x1844e101	mini_qdisc_pair_block_init	vmlinux	EXPORT_SYMBOL	
++0x9f3c7bbc	net_ns_type_operations	vmlinux	EXPORT_SYMBOL_GPL	
++0x7f52939e	usb_add_phy_dev	vmlinux	EXPORT_SYMBOL_GPL	
++0x1afc6be9	phy_free_interrupt	vmlinux	EXPORT_SYMBOL	
++0x7c0b7013	mipi_dsi_dcs_write_buffer	vmlinux	EXPORT_SYMBOL	
++0xf20dd789	proc_symlink	vmlinux	EXPORT_SYMBOL	
++0x49608959	migrate_disable	vmlinux	EXPORT_SYMBOL_GPL	
++0xc662ecda	__tracepoint_br_fdb_external_learn_add	vmlinux	EXPORT_SYMBOL_GPL	
++0x4cd5b869	__rtnl_link_unregister	vmlinux	EXPORT_SYMBOL_GPL	
++0xe4b0ea76	rtnl_kfree_skbs	vmlinux	EXPORT_SYMBOL	
++0x827449e2	dev_pm_opp_find_freq_ceil	vmlinux	EXPORT_SYMBOL_GPL	
++0xd0c1f28a	usb_hcd_pci_pm_ops	vmlinux	EXPORT_SYMBOL_GPL	
++0x52d55340	cdc_parse_cdc_header	vmlinux	EXPORT_SYMBOL	
++0xc6a4a872	__clk_is_enabled	vmlinux	EXPORT_SYMBOL_GPL	
++0x0e17678a	siphash_4u64	vmlinux	EXPORT_SYMBOL	
++0xa0ae1e73	siphash_3u64	vmlinux	EXPORT_SYMBOL	
++0x12cabc89	siphash_2u64	vmlinux	EXPORT_SYMBOL	
++0x3126a9e8	siphash_1u64	vmlinux	EXPORT_SYMBOL	
++0x5e0ccb9f	sha1_transform	vmlinux	EXPORT_SYMBOL	
++0x631d06aa	cpu_rmap_put	vmlinux	EXPORT_SYMBOL	
++0x6f8f427f	blk_queue_dma_alignment	vmlinux	EXPORT_SYMBOL	
++0x1e0ac139	security_path_unlink	vmlinux	EXPORT_SYMBOL	
++0xc71b5c56	bd_prepare_to_claim	vmlinux	EXPORT_SYMBOL_GPL	
++0x737aa162	remap_vmalloc_range	vmlinux	EXPORT_SYMBOL	
++0x87761528	__traceiter_kmem_cache_alloc	vmlinux	EXPORT_SYMBOL	
++0x424ab51b	noop_backing_dev_info	vmlinux	EXPORT_SYMBOL_GPL	
++0xd985dc99	mempool_free_pages	vmlinux	EXPORT_SYMBOL	
++0x326d91d5	irq_domain_set_hwirq_and_chip	vmlinux	EXPORT_SYMBOL_GPL	
++0xfcec0987	enable_irq	vmlinux	EXPORT_SYMBOL	
++0x1e7bbcb3	kernel_restart	vmlinux	EXPORT_SYMBOL_GPL	
++0x2c110e4f	ip_cmsg_recv_offset	vmlinux	EXPORT_SYMBOL	
++0xabeb9438	skb_flow_dissector_init	vmlinux	EXPORT_SYMBOL	
++0xcc39c03e	nvmem_unregister	vmlinux	EXPORT_SYMBOL_GPL	
++0xbb3cee97	of_pci_get_max_link_speed	vmlinux	EXPORT_SYMBOL_GPL	
++0x90576ec4	vmemdup_user	vmlinux	EXPORT_SYMBOL	
++0xa7073a81	filemap_page_mkwrite	vmlinux	EXPORT_SYMBOL	
++0x170cc36c	put_timespec64	vmlinux	EXPORT_SYMBOL_GPL	
++0x138f1c0c	tcf_block_put_ext	vmlinux	EXPORT_SYMBOL	
++0x34a6731e	__get_hash_from_flowi6	vmlinux	EXPORT_SYMBOL	
++0x0f90b709	phy_ethtool_get_stats	vmlinux	EXPORT_SYMBOL	
++0xa3b6d273	stmpe_reg_read	vmlinux	EXPORT_SYMBOL_GPL	
++0xe7431a64	mipi_dsi_generic_write	vmlinux	EXPORT_SYMBOL	
++0xa07a37f0	memchr	vmlinux	EXPORT_SYMBOL	
++0x7c03e081	__fscrypt_prepare_lookup	vmlinux	EXPORT_SYMBOL_GPL	
++0x4be1b41b	kern_unmount_array	vmlinux	EXPORT_SYMBOL	
++0xdd760384	of_get_parent	vmlinux	EXPORT_SYMBOL	
++0xc364bcb9	stmpe_reg_write	vmlinux	EXPORT_SYMBOL_GPL	
++0xad84b9d6	clk_hw_get_name	vmlinux	EXPORT_SYMBOL_GPL	
++0x02f0e145	pci_destroy_slot	vmlinux	EXPORT_SYMBOL_GPL	
++0x5d58321b	nfs_request_add_commit_list	vmlinux	EXPORT_SYMBOL_GPL	
++0x3aa48952	nfs_invalidate_atime	vmlinux	EXPORT_SYMBOL_GPL	
++0xc8542be5	nfs_rename	vmlinux	EXPORT_SYMBOL_GPL	
++0xff1d5cb3	vfs_kern_mount	vmlinux	EXPORT_SYMBOL_GPL	
++0x31a95e8b	ring_buffer_record_enable_cpu	vmlinux	EXPORT_SYMBOL_GPL	
++0x267df662	smp_call_on_cpu	vmlinux	EXPORT_SYMBOL_GPL	
++0x9ec6ca96	ktime_get_real_ts64	vmlinux	EXPORT_SYMBOL	
++0x229df423	insert_resource	vmlinux	EXPORT_SYMBOL_GPL	
++0xdf7cebc3	sock_diag_register	vmlinux	EXPORT_SYMBOL_GPL	
++0xc1c82d63	sk_net_capable	vmlinux	EXPORT_SYMBOL	
++0x4dc9f54c	spi_bus_type	vmlinux	EXPORT_SYMBOL_GPL	
++0xaf2f76b3	anon_transport_class_unregister	vmlinux	EXPORT_SYMBOL_GPL	
++0x928a2007	mipi_dsi_dcs_nop	vmlinux	EXPORT_SYMBOL	
++0x5a0b73d0	zlib_deflateInit2	vmlinux	EXPORT_SYMBOL	
++0xcdaa9cde	submit_bio	vmlinux	EXPORT_SYMBOL	
++0x057632f6	alloc_page_buffers	vmlinux	EXPORT_SYMBOL_GPL	
++0x622c7922	register_oom_notifier	vmlinux	EXPORT_SYMBOL_GPL	
++0x73f36cf9	trace_event_buffer_lock_reserve	vmlinux	EXPORT_SYMBOL_GPL	
++0x549525ef	handle_nested_irq	vmlinux	EXPORT_SYMBOL_GPL	
++0x2592fc6c	console_printk	vmlinux	EXPORT_SYMBOL_GPL	
++0x73ac6341	neigh_lookup	vmlinux	EXPORT_SYMBOL	
++0x8c710f25	mmc_remove_host	vmlinux	EXPORT_SYMBOL	
++0x2555d644	usb_put_hcd	vmlinux	EXPORT_SYMBOL_GPL	
++0xccfd2ebc	scsi_dev_info_list_del_keyed	vmlinux	EXPORT_SYMBOL	
++0x2bc9901f	uart_get_rs485_mode	vmlinux	EXPORT_SYMBOL_GPL	
++0x75e9c735	pci_ats_disabled	vmlinux	EXPORT_SYMBOL_GPL	
++0x28ecb4f1	debugfs_create_u32_array	vmlinux	EXPORT_SYMBOL_GPL	
++0x8c947222	bpf_map_inc_not_zero	vmlinux	EXPORT_SYMBOL_GPL	
++0xca2a9a89	trace_array_printk	vmlinux	EXPORT_SYMBOL_GPL	
++0xf46d2eb9	tcp_mtup_init	vmlinux	EXPORT_SYMBOL	
++0x46066e5b	perf_pmu_name	vmlinux	EXPORT_SYMBOL_GPL	
++0x0a2e6b3f	mmc_cqe_request_done	vmlinux	EXPORT_SYMBOL	
++0x9a012635	cpuidle_register	vmlinux	EXPORT_SYMBOL_GPL	
++0x22898336	devm_clk_unregister	vmlinux	EXPORT_SYMBOL_GPL	
++0xdf256037	kstrtou8_from_user	vmlinux	EXPORT_SYMBOL	
++0xf7d31de9	kstrtoul_from_user	vmlinux	EXPORT_SYMBOL	
++0xfabb8e6a	nfs_init_timeout_values	vmlinux	EXPORT_SYMBOL_GPL	
++0xea7266ef	__clocksource_update_freq_scale	vmlinux	EXPORT_SYMBOL_GPL	
++0xe2ee1e3f	sched_set_fifo_low	vmlinux	EXPORT_SYMBOL_GPL	
++0xbea5ff1e	static_key_initialized	vmlinux	EXPORT_SYMBOL_GPL	
++0x0cd929e1	cache_purge	vmlinux	EXPORT_SYMBOL_GPL	
++0x67dde08f	rpc_sleep_on_timeout	vmlinux	EXPORT_SYMBOL_GPL	
++0xd26c7e0b	dbs_update	vmlinux	EXPORT_SYMBOL_GPL	
++0xcc23002a	hdmi_infoframe_pack_only	vmlinux	EXPORT_SYMBOL	
++0x222e7ce2	sysfs_streq	vmlinux	EXPORT_SYMBOL	
++0xafcca622	sbitmap_bitmap_show	vmlinux	EXPORT_SYMBOL_GPL	
++0x9228a43a	bio_associate_blkg	vmlinux	EXPORT_SYMBOL_GPL	
++0x085f6e9f	alloc_buffer_head	vmlinux	EXPORT_SYMBOL	
++0x699f4f21	bpf_event_output	vmlinux	EXPORT_SYMBOL_GPL	
++0x723d4ed2	dma_unmap_sg_attrs	vmlinux	EXPORT_SYMBOL	
++0xd067d3c5	system_freezable_power_efficient_wq	vmlinux	EXPORT_SYMBOL_GPL	
++0x5122e2bd	xdr_write_pages	vmlinux	EXPORT_SYMBOL_GPL	
++0x1fe912f1	netdev_alloc_frag	vmlinux	EXPORT_SYMBOL	
++0x998e44ab	usbnet_get_endpoints	vmlinux	EXPORT_SYMBOL_GPL	
++0xf0ccf42a	nvme_sync_io_queues	vmlinux	EXPORT_SYMBOL_GPL	
++0x1c9f7a1c	pci_bus_read_dev_vendor_id	vmlinux	EXPORT_SYMBOL	
++0x26884ff7	nfs_alloc_fhandle	vmlinux	EXPORT_SYMBOL_GPL	
++0x23729d79	fscrypt_decrypt_block_inplace	vmlinux	EXPORT_SYMBOL	
++0x5a8d9940	fscrypt_encrypt_block_inplace	vmlinux	EXPORT_SYMBOL	
++0x555612a3	nvme_stop_queues	vmlinux	EXPORT_SYMBOL_GPL	
++0xdd873082	device_remove_file	vmlinux	EXPORT_SYMBOL_GPL	
++0x1b8822d8	pinctrl_gpio_direction_output	vmlinux	EXPORT_SYMBOL_GPL	
++0x111f8dab	security_inode_invalidate_secctx	vmlinux	EXPORT_SYMBOL	
++0x64b2c7da	param_set_bool_enable_only	vmlinux	EXPORT_SYMBOL_GPL	
++0xf71556b2	ipv6_skip_exthdr	vmlinux	EXPORT_SYMBOL	
++0xcc44b676	ip_options_compile	vmlinux	EXPORT_SYMBOL	
++0x79cb3855	sock_diag_unregister	vmlinux	EXPORT_SYMBOL_GPL	
++0x923ad762	pcibios_bus_to_resource	vmlinux	EXPORT_SYMBOL	
++0x4ad02ad2	param_get_ulong	vmlinux	EXPORT_SYMBOL	
++0xc18c21f6	kill_pid	vmlinux	EXPORT_SYMBOL	
++0x32644eda	unix_outq_len	vmlinux	EXPORT_SYMBOL_GPL	
++0x067150a3	udp_seq_start	vmlinux	EXPORT_SYMBOL	
++0xa38f8f87	device_store_int	vmlinux	EXPORT_SYMBOL_GPL	
++0x42b71c93	dim_turn	vmlinux	EXPORT_SYMBOL	
++0xf488805d	blkg_rwstat_exit	vmlinux	EXPORT_SYMBOL_GPL	
++0x4e17c549	blkg_rwstat_init	vmlinux	EXPORT_SYMBOL_GPL	
++0x64999478	congestion_wait	vmlinux	EXPORT_SYMBOL	
++0xa90191df	__cgroup_bpf_run_filter_sk	vmlinux	EXPORT_SYMBOL	
++0x60ebc96f	ring_buffer_read_prepare	vmlinux	EXPORT_SYMBOL_GPL	
++0x6c60962b	tcp_get_syncookie_mss	vmlinux	EXPORT_SYMBOL_GPL	
++0xbcc579f2	inet_pton_with_scope	vmlinux	EXPORT_SYMBOL	
++0xa4d8c34e	mmc_retune_release	vmlinux	EXPORT_SYMBOL	
++0x5ac09e5d	i2c_del_driver	vmlinux	EXPORT_SYMBOL	
++0x0f5d33ad	device_property_read_u64_array	vmlinux	EXPORT_SYMBOL_GPL	
++0x95534d4b	device_property_read_u32_array	vmlinux	EXPORT_SYMBOL_GPL	
++0x0bf87af3	device_property_read_u16_array	vmlinux	EXPORT_SYMBOL_GPL	
++0xf2fe7a8d	jbd2_fc_wait_bufs	vmlinux	EXPORT_SYMBOL	
++0x6bf83e49	config_item_set_name	vmlinux	EXPORT_SYMBOL	
++0x71ae3acc	dquot_release	vmlinux	EXPORT_SYMBOL	
++0x75e51945	__SCK__tp_func_error_report_end	vmlinux	EXPORT_SYMBOL_GPL	
++0x77222306	ring_buffer_read_page	vmlinux	EXPORT_SYMBOL_GPL	
++0x1bf196a2	usb_hcd_setup_local_mem	vmlinux	EXPORT_SYMBOL_GPL	
++0x18fcbd8c	__dma_request_channel	vmlinux	EXPORT_SYMBOL_GPL	
++0x1ec8fcc2	clk_hw_is_enabled	vmlinux	EXPORT_SYMBOL_GPL	
++0xfe916dc6	hex_dump_to_buffer	vmlinux	EXPORT_SYMBOL	
++0xfe75566d	nfs_generic_pgio	vmlinux	EXPORT_SYMBOL_GPL	
++0xe7e202ad	file_ra_state_init	vmlinux	EXPORT_SYMBOL_GPL	
++0x3dac779a	bpf_sk_lookup_enabled	vmlinux	EXPORT_SYMBOL	
++0xe952c39f	usb_alloc_coherent	vmlinux	EXPORT_SYMBOL_GPL	
++0xe517ca77	crypto_larval_kill	vmlinux	EXPORT_SYMBOL_GPL	
++0x15d1d2ec	irq_set_default_host	vmlinux	EXPORT_SYMBOL_GPL	
++0xff784584	inet_csk_get_port	vmlinux	EXPORT_SYMBOL_GPL	
++0xfe57301c	netdev_is_rx_handler_busy	vmlinux	EXPORT_SYMBOL_GPL	
++0x0437e467	hid_match_device	vmlinux	EXPORT_SYMBOL_GPL	
++0x63711e5c	mmc_flush_cache	vmlinux	EXPORT_SYMBOL	
++0x07bff3ea	i2c_clients_command	vmlinux	EXPORT_SYMBOL	
++0xc776d4bb	touchscreen_parse_properties	vmlinux	EXPORT_SYMBOL	
++0x6591a848	rdma_dim	vmlinux	EXPORT_SYMBOL	
++0x3d8ec2ed	kiocb_set_cancel_fn	vmlinux	EXPORT_SYMBOL	
++0x8bc8d098	unregister_kprobe	vmlinux	EXPORT_SYMBOL_GPL	
++0xb23b1574	dev_get_flags	vmlinux	EXPORT_SYMBOL	
++0x8607f143	dev_pm_opp_get_max_volt_latency	vmlinux	EXPORT_SYMBOL_GPL	
++0x1915bf41	thermal_zone_device_disable	vmlinux	EXPORT_SYMBOL_GPL	
++0x855b19b3	usb_get_status	vmlinux	EXPORT_SYMBOL_GPL	
++0xc82c721f	klist_remove	vmlinux	EXPORT_SYMBOL_GPL	
++0x6fb8658c	crypto_sha256_update	vmlinux	EXPORT_SYMBOL	
++0x4e7d9487	crypto_shash_alg_has_setkey	vmlinux	EXPORT_SYMBOL_GPL	
++0xe4e5ad55	__wait_on_bit_lock	vmlinux	EXPORT_SYMBOL	
++0x509d1d58	svc_auth_register	vmlinux	EXPORT_SYMBOL_GPL	
++0x81179ab7	fib_nl_delrule	vmlinux	EXPORT_SYMBOL_GPL	
++0xd13d2086	fib_nl_newrule	vmlinux	EXPORT_SYMBOL_GPL	
++0x664a2b1c	gen_new_estimator	vmlinux	EXPORT_SYMBOL	
++0x7cd6f042	cpufreq_get_current_driver	vmlinux	EXPORT_SYMBOL_GPL	
++0xe4c9d844	input_class	vmlinux	EXPORT_SYMBOL_GPL	
++0x7ebcf663	dwc_notify	vmlinux	EXPORT_SYMBOL	
++0x07ad0425	platform_unregister_drivers	vmlinux	EXPORT_SYMBOL_GPL	
++0xb41fc9c9	pci_set_master	vmlinux	EXPORT_SYMBOL	
++0xc474572c	iov_iter_pipe	vmlinux	EXPORT_SYMBOL	
++0xc5a53feb	blk_mq_stop_hw_queue	vmlinux	EXPORT_SYMBOL	
++0x7f47367c	crypto_alg_mod_lookup	vmlinux	EXPORT_SYMBOL_GPL	
++0xd9ccb764	debugfs_create_ulong	vmlinux	EXPORT_SYMBOL_GPL	
++0x2a0f4f8a	jbd2_journal_inode_ranged_wait	vmlinux	EXPORT_SYMBOL	
++0x82960c06	freeze_super	vmlinux	EXPORT_SYMBOL	
++0x8cf83af4	__devm_request_region	vmlinux	EXPORT_SYMBOL	
++0xd7f473a3	l3mdev_fib_table_by_index	vmlinux	EXPORT_SYMBOL_GPL	
++0x380c0c13	hid_connect	vmlinux	EXPORT_SYMBOL_GPL	
++0x26487902	mmc_set_data_timeout	vmlinux	EXPORT_SYMBOL	
++0xf99386f4	i2c_new_dummy_device	vmlinux	EXPORT_SYMBOL_GPL	
++0xc18669b7	usb_set_device_state	vmlinux	EXPORT_SYMBOL_GPL	
++0x7e870f35	nvme_stop_admin_queue	vmlinux	EXPORT_SYMBOL_GPL	
++0x8da79867	scsi_autopm_put_device	vmlinux	EXPORT_SYMBOL_GPL	
++0xa2613225	scsi_autopm_get_device	vmlinux	EXPORT_SYMBOL_GPL	
++0xe84f8b40	scsi_eh_finish_cmd	vmlinux	EXPORT_SYMBOL	
++0x76706d66	vc_cons	vmlinux	EXPORT_SYMBOL	
++0xb24105ad	dma_async_device_unregister	vmlinux	EXPORT_SYMBOL	
++0xca21ebd3	bitmap_free	vmlinux	EXPORT_SYMBOL	
++0x33cc6218	nfs_pageio_resend	vmlinux	EXPORT_SYMBOL_GPL	
++0xbc63b384	nfs_clear_verifier_delegated	vmlinux	EXPORT_SYMBOL_GPL	
++0x93aebcf9	jbd2_journal_submit_inode_data_buffers	vmlinux	EXPORT_SYMBOL	
++0xa42261a7	find_inode_nowait	vmlinux	EXPORT_SYMBOL	
++0x1dadc65a	DWC_WORKQ_WAIT_WORK_DONE	vmlinux	EXPORT_SYMBOL	
++0x22126456	fsl8250_handle_irq	vmlinux	EXPORT_SYMBOL_GPL	
++0x26a05a13	devm_of_clk_del_provider	vmlinux	EXPORT_SYMBOL	
++0xc90419e7	gpiod_get_value	vmlinux	EXPORT_SYMBOL_GPL	
++0xf9c0b663	strlcat	vmlinux	EXPORT_SYMBOL	
++0x2e2b40d2	strncat	vmlinux	EXPORT_SYMBOL	
++0x39b8d49c	cpu_rmap_update	vmlinux	EXPORT_SYMBOL	
++0x68c45a71	blk_queue_max_discard_sectors	vmlinux	EXPORT_SYMBOL	
++0xbb6f025a	asymmetric_key_generate_id	vmlinux	EXPORT_SYMBOL_GPL	
++0xb3f7646e	kthread_should_stop	vmlinux	EXPORT_SYMBOL	
++0x605d5bfa	cache_line_size	vmlinux	EXPORT_SYMBOL_GPL	
++0x9a48cd2c	mr_mfc_seq_idx	vmlinux	EXPORT_SYMBOL	
++0x72ec97a0	netdev_notice	vmlinux	EXPORT_SYMBOL	
++0xa910fd78	blk_rq_map_kern	vmlinux	EXPORT_SYMBOL	
++0xedf6cf96	sync_mapping_buffers	vmlinux	EXPORT_SYMBOL	
++0x927b4885	noop_invalidatepage	vmlinux	EXPORT_SYMBOL_GPL	
++0x3cc9b305	__do_mmap_mm	vmlinux	EXPORT_SYMBOL	
++0x77ab4e8c	inet_ehash_nolisten	vmlinux	EXPORT_SYMBOL_GPL	
++0xabdbeb22	phy_get_internal_delay	vmlinux	EXPORT_SYMBOL	
++0xfde78a09	__scsi_add_device	vmlinux	EXPORT_SYMBOL	
++0xeabebd8b	dma_async_device_channel_unregister	vmlinux	EXPORT_SYMBOL_GPL	
++0xe388558e	desc_to_gpio	vmlinux	EXPORT_SYMBOL_GPL	
++0xd18bb06c	fat_scan	vmlinux	EXPORT_SYMBOL_GPL	
++0x3a534fea	datagram_poll	vmlinux	EXPORT_SYMBOL	
++0x6cf0e274	__scsi_print_sense	vmlinux	EXPORT_SYMBOL	
++0x338a5a46	regmap_update_bits_base	vmlinux	EXPORT_SYMBOL_GPL	
++0xc1d797a7	__tty_alloc_driver	vmlinux	EXPORT_SYMBOL	
++0x496ea509	gpiochip_irq_domain_deactivate	vmlinux	EXPORT_SYMBOL_GPL	
++0x4d4d7b79	blk_mq_map_queues	vmlinux	EXPORT_SYMBOL_GPL	
++0xdce50e7f	rsa_parse_pub_key_raw	vmlinux	EXPORT_SYMBOL_GPL	
++0x1e9edfb7	seq_hlist_start_head_rcu	vmlinux	EXPORT_SYMBOL	
++0xab7a9595	current_time	vmlinux	EXPORT_SYMBOL	
++0x72302d97	user_path_at_empty	vmlinux	EXPORT_SYMBOL	
++0x34bd8e37	__tcf_em_tree_match	vmlinux	EXPORT_SYMBOL	
++0xc2dc94a5	dev_mc_flush	vmlinux	EXPORT_SYMBOL	
++0x006640ab	dev_uc_flush	vmlinux	EXPORT_SYMBOL	
++0x3ac67c80	usb_stor_Bulk_transport	vmlinux	EXPORT_SYMBOL_GPL	USB_STORAGE
++0x786ec407	DWC_THREAD_SHOULD_STOP	vmlinux	EXPORT_SYMBOL	
++0x50953eb9	xhci_suspend	vmlinux	EXPORT_SYMBOL_GPL	
++0x39ca9a26	usb_show_dynids	vmlinux	EXPORT_SYMBOL_GPL	
++0xf60795e4	pinctrl_enable	vmlinux	EXPORT_SYMBOL_GPL	
++0xed61f6b3	security_release_secctx	vmlinux	EXPORT_SYMBOL	
++0x2d994605	security_inode_copy_up_xattr	vmlinux	EXPORT_SYMBOL	
++0x5be9151d	jbd2_journal_check_available_features	vmlinux	EXPORT_SYMBOL	
++0x1cc11154	__SCK__tp_func_mmap_lock_start_locking	vmlinux	EXPORT_SYMBOL	
++0x862258db	timecounter_init	vmlinux	EXPORT_SYMBOL_GPL	
++0x4ffe9bfe	dma_free_attrs	vmlinux	EXPORT_SYMBOL	
++0x93d3354e	inet_addr_type	vmlinux	EXPORT_SYMBOL	
++0x3117441e	inet_recvmsg	vmlinux	EXPORT_SYMBOL	
++0x55e31703	ethtool_convert_link_mode_to_legacy_u32	vmlinux	EXPORT_SYMBOL	
++0x18801d30	mdiobus_unregister	vmlinux	EXPORT_SYMBOL	
++0xe123f3d9	dma_fence_release	vmlinux	EXPORT_SYMBOL	
++0xa6ee15ca	__tracepoint_rpm_suspend	vmlinux	EXPORT_SYMBOL_GPL	
++0x92db8f68	do_trace_rcu_torture_read	vmlinux	EXPORT_SYMBOL_GPL	
++0xc5c429da	vchiq_initialise	vmlinux	EXPORT_SYMBOL	
++0x0e705e24	phy_detach	vmlinux	EXPORT_SYMBOL	
++0xd628dea0	phy_driver_is_genphy_10g	vmlinux	EXPORT_SYMBOL_GPL	
++0x6086f8b6	mii_link_ok	vmlinux	EXPORT_SYMBOL	
++0x7b62dec4	pnfs_generic_ds_cinfo_destroy	vmlinux	EXPORT_SYMBOL_GPL	
++0xb3d05c08	nfs_commitdata_alloc	vmlinux	EXPORT_SYMBOL_GPL	
++0x98c59274	__tracepoint_rpm_idle	vmlinux	EXPORT_SYMBOL_GPL	
++0x5714c872	mr_fill_mroute	vmlinux	EXPORT_SYMBOL	
++0xabdd7bc9	gov_attr_set_put	vmlinux	EXPORT_SYMBOL_GPL	
++0x39060f3d	gov_attr_set_get	vmlinux	EXPORT_SYMBOL_GPL	
++0xe5cf486b	stop_tty	vmlinux	EXPORT_SYMBOL	
++0x2dce2f1c	__irq_regs	vmlinux	EXPORT_SYMBOL	
++0x69fb7759	btree_visitor	vmlinux	EXPORT_SYMBOL_GPL	
++0x7beb8883	pnfs_unregister_layoutdriver	vmlinux	EXPORT_SYMBOL_GPL	
++0x5d63996e	fscache_fsdef_index	vmlinux	EXPORT_SYMBOL	
++0x0431e75a	dquot_get_dqblk	vmlinux	EXPORT_SYMBOL	
++0xa584f086	sdio_writel	vmlinux	EXPORT_SYMBOL_GPL	
++0x4725eda1	ir_raw_encode_carrier	vmlinux	EXPORT_SYMBOL	
++0x856a5ef3	des3_ede_encrypt	vmlinux	EXPORT_SYMBOL_GPL	
++0x9b9e8943	nfs_pageio_reset_write_mds	vmlinux	EXPORT_SYMBOL_GPL	
++0x5c50cf7c	unlock_page_memcg	vmlinux	EXPORT_SYMBOL	
++0x08249512	iwe_stream_add_point	vmlinux	EXPORT_SYMBOL	
++0xb2798761	xfrm_policy_destroy	vmlinux	EXPORT_SYMBOL	
++0xec5c2421	inet_del_offload	vmlinux	EXPORT_SYMBOL	
++0x9cdfb3f7	sysctl_fb_tunnels_only_for_init_net	vmlinux	EXPORT_SYMBOL	
++0x887b9013	sdhci_pltfm_register	vmlinux	EXPORT_SYMBOL_GPL	
++0x97238f8c	sdio_memcpy_toio	vmlinux	EXPORT_SYMBOL_GPL	
++0x44f12e94	devm_hwmon_device_register_with_info	vmlinux	EXPORT_SYMBOL_GPL	
++0xd71bf50e	gpiod_get_index_optional	vmlinux	EXPORT_SYMBOL_GPL	
++0x39e6f0f6	security_kernel_load_data	vmlinux	EXPORT_SYMBOL_GPL	
++0x99db0bfc	jbd2_journal_stop	vmlinux	EXPORT_SYMBOL	
++0x7598a03a	__trace_note_message	vmlinux	EXPORT_SYMBOL_GPL	
++0x4a932757	neigh_ifdown	vmlinux	EXPORT_SYMBOL	
++0x9a5e5d58	__traceiter_iscsi_dbg_tcp	vmlinux	EXPORT_SYMBOL_GPL	
++0x05ec5969	regmap_field_bulk_free	vmlinux	EXPORT_SYMBOL_GPL	
++0x1ac5d3cb	strcspn	vmlinux	EXPORT_SYMBOL	
++0x8b91ca26	zero_fill_bio_iter	vmlinux	EXPORT_SYMBOL	
++0x96c28009	freq_qos_remove_notifier	vmlinux	EXPORT_SYMBOL_GPL	
++0x5a265c8c	mmput_async	vmlinux	EXPORT_SYMBOL_GPL	
++0x4c988b0b	thermal_zone_unbind_cooling_device	vmlinux	EXPORT_SYMBOL_GPL	
++0xd4e55f1e	__tracepoint_iscsi_dbg_sw_tcp	vmlinux	EXPORT_SYMBOL_GPL	
++0x10bfad93	devm_get_free_pages	vmlinux	EXPORT_SYMBOL_GPL	
++0x5e798ffb	divider_get_val	vmlinux	EXPORT_SYMBOL_GPL	
++0x57e32e24	pci_scan_bridge	vmlinux	EXPORT_SYMBOL	
++0xe118e788	pci_generic_config_read	vmlinux	EXPORT_SYMBOL_GPL	
++0xf1f368a9	blk_mq_delay_kick_requeue_list	vmlinux	EXPORT_SYMBOL	
++0x5e52c9a5	jbd2_journal_extend	vmlinux	EXPORT_SYMBOL	
++0x3dabf271	memcg_sockets_enabled_key	vmlinux	EXPORT_SYMBOL	
++0xb2c1732e	rcu_gp_set_torture_wait	vmlinux	EXPORT_SYMBOL_GPL	
++0x8b84ba99	skb_copy_and_csum_datagram_msg	vmlinux	EXPORT_SYMBOL	
++0x8d5c45ad	hid_parse_report	vmlinux	EXPORT_SYMBOL_GPL	
++0x721b77b2	genpd_dev_pm_attach	vmlinux	EXPORT_SYMBOL_GPL	
++0x5a77c0ab	sbitmap_queue_init_node	vmlinux	EXPORT_SYMBOL_GPL	
++0xb29287e0	gen_pool_free_owner	vmlinux	EXPORT_SYMBOL	
++0x5fc72f0e	alloc_pages_exact	vmlinux	EXPORT_SYMBOL	
++0x685e31ca	groups_sort	vmlinux	EXPORT_SYMBOL	
++0xa13acdb8	svc_pool_map_put	vmlinux	EXPORT_SYMBOL_GPL	
++0xb312d0c4	svc_pool_map_get	vmlinux	EXPORT_SYMBOL_GPL	
++0x19dabdf4	xdp_rxq_info_unused	vmlinux	EXPORT_SYMBOL_GPL	
++0x35187fda	nvme_wait_reset	vmlinux	EXPORT_SYMBOL_GPL	
++0x00e82e47	regmap_get_device	vmlinux	EXPORT_SYMBOL_GPL	
++0xef1d01ba	devm_regulator_bulk_get	vmlinux	EXPORT_SYMBOL_GPL	
++0x98b5c81d	regulator_get_hardware_vsel_register	vmlinux	EXPORT_SYMBOL_GPL	
++0xe22c5a83	of_clk_hw_simple_get	vmlinux	EXPORT_SYMBOL_GPL	
++0x5befbf37	fs_lookup_param	vmlinux	EXPORT_SYMBOL	
++0xdd68f298	svc_find_xprt	vmlinux	EXPORT_SYMBOL_GPL	
++0xdf2c0c90	svc_process	vmlinux	EXPORT_SYMBOL_GPL	
++0x740991e0	rpc_force_rebind	vmlinux	EXPORT_SYMBOL_GPL	
++0xae60d657	nf_register_net_hook	vmlinux	EXPORT_SYMBOL	
++0xf469c3f5	register_sound_special	vmlinux	EXPORT_SYMBOL	
++0xd6644742	of_parse_phandle_with_args	vmlinux	EXPORT_SYMBOL	
++0x6b812276	usbnet_skb_return	vmlinux	EXPORT_SYMBOL_GPL	
++0x80ee5e1e	gpiod_to_chip	vmlinux	EXPORT_SYMBOL_GPL	
++0x2b00e873	__nla_reserve	vmlinux	EXPORT_SYMBOL	
++0xe3ec2f2b	alloc_chrdev_region	vmlinux	EXPORT_SYMBOL	
++0x3f36640a	inc_zone_page_state	vmlinux	EXPORT_SYMBOL	
++0xdd6ddcec	__traceiter_error_report_end	vmlinux	EXPORT_SYMBOL_GPL	
++0x5e173309	cpu_cgrp_subsys_on_dfl_key	vmlinux	EXPORT_SYMBOL_GPL	
++0x023abee4	rpc_killall_tasks	vmlinux	EXPORT_SYMBOL_GPL	
++0x2c1c4cd5	netdev_bind_sb_channel_queue	vmlinux	EXPORT_SYMBOL	
++0x0e5c0bb6	skb_checksum	vmlinux	EXPORT_SYMBOL	
++0x8b008a58	kfree_skb_list	vmlinux	EXPORT_SYMBOL	
++0x85dafa9f	DWC_BE32_TO_CPU	vmlinux	EXPORT_SYMBOL	
++0xfb0171d2	DWC_LE32_TO_CPU	vmlinux	EXPORT_SYMBOL	
++0xa58650f1	pci_pme_capable	vmlinux	EXPORT_SYMBOL	
++0xca9360b5	rb_next	vmlinux	EXPORT_SYMBOL	
++0xd2bddbbd	fscrypt_fname_disk_to_usr	vmlinux	EXPORT_SYMBOL	
++0xde1cd351	fiemap_prep	vmlinux	EXPORT_SYMBOL	
++0x66a04d9d	inode_permission	vmlinux	EXPORT_SYMBOL	
++0x6617af32	buffer_migrate_page	vmlinux	EXPORT_SYMBOL	
++0xccd35507	finish_wait	vmlinux	EXPORT_SYMBOL	
++0x3c603a62	svc_xprt_init	vmlinux	EXPORT_SYMBOL_GPL	
++0x97384a6d	xdp_return_frame_rx_napi	vmlinux	EXPORT_SYMBOL_GPL	
++0x3186bb5f	phy_start_aneg	vmlinux	EXPORT_SYMBOL	
++0x2deae882	scsi_print_result	vmlinux	EXPORT_SYMBOL	
++0x61b7b126	simple_strtoull	vmlinux	EXPORT_SYMBOL	
++0x8daedb79	cpumask_any_but	vmlinux	EXPORT_SYMBOL	
++0x63c4d61f	__bitmap_weight	vmlinux	EXPORT_SYMBOL	
++0x2534b103	nfs4_pnfs_ds_add	vmlinux	EXPORT_SYMBOL_GPL	
++0x3c4a8ceb	nfs_get_client	vmlinux	EXPORT_SYMBOL_GPL	
++0x619cb7dd	simple_read_from_buffer	vmlinux	EXPORT_SYMBOL	
++0xbbc3e455	clockevent_delta2ns	vmlinux	EXPORT_SYMBOL_GPL	
++0xe9107bc2	irq_domain_simple_ops	vmlinux	EXPORT_SYMBOL_GPL	
++0xbe5909b0	nf_checksum	vmlinux	EXPORT_SYMBOL_GPL	
++0x420f3d01	nvmem_unregister_notifier	vmlinux	EXPORT_SYMBOL_GPL	
++0x224afb7d	dwc_cc_ck	vmlinux	EXPORT_SYMBOL	
++0x45006cee	default_red	vmlinux	EXPORT_SYMBOL	
++0x3b83157a	clk_mux_val_to_index	vmlinux	EXPORT_SYMBOL_GPL	
++0x0397edd5	fb_edid_to_monspecs	vmlinux	EXPORT_SYMBOL	
++0xa7a75019	pci_d3cold_enable	vmlinux	EXPORT_SYMBOL_GPL	
++0x24db9490	gpiochip_add_pin_range	vmlinux	EXPORT_SYMBOL_GPL	
++0xa681fe88	generate_random_uuid	vmlinux	EXPORT_SYMBOL	
++0x92e953c7	get_mem_cgroup_from_page	vmlinux	EXPORT_SYMBOL	
++0x9c397c98	xfrm_policy_hash_rebuild	vmlinux	EXPORT_SYMBOL	
++0x37441043	get_net_ns_by_pid	vmlinux	EXPORT_SYMBOL_GPL	
++0xe40b60bc	mbox_chan_received_data	vmlinux	EXPORT_SYMBOL_GPL	
++0x5d85b1b3	_dev_warn	vmlinux	EXPORT_SYMBOL	
++0x55279170	fb_deferred_io_cleanup	vmlinux	EXPORT_SYMBOL_GPL	
++0xce0108d4	vfs_statfs	vmlinux	EXPORT_SYMBOL	
++0x0cc27454	__mdiobus_read	vmlinux	EXPORT_SYMBOL	
++0xb95adcf1	_dev_alert	vmlinux	EXPORT_SYMBOL	
++0x5c3ca252	mipi_dsi_driver_register_full	vmlinux	EXPORT_SYMBOL	
++0x438610bd	security_tun_dev_alloc_security	vmlinux	EXPORT_SYMBOL	
++0xacc58c74	list_lru_walk_one	vmlinux	EXPORT_SYMBOL_GPL	
++0x3fc7a1e0	xdr_buf_trim	vmlinux	EXPORT_SYMBOL_GPL	
++0xcfbe4f8f	xfrm_input_register_afinfo	vmlinux	EXPORT_SYMBOL	
++0x31274d6a	udp_ioctl	vmlinux	EXPORT_SYMBOL	
++0x008bdca5	__mdiobus_write	vmlinux	EXPORT_SYMBOL	
++0x8a13f7b0	genphy_loopback	vmlinux	EXPORT_SYMBOL	
++0xd9f95e8d	tty_port_default_client_ops	vmlinux	EXPORT_SYMBOL_GPL	
++0xceb1f126	mpi_read_raw_data	vmlinux	EXPORT_SYMBOL_GPL	
++0x2b08671a	__nla_reserve_nohdr	vmlinux	EXPORT_SYMBOL	
++0x6199ad5d	crypto_has_skcipher	vmlinux	EXPORT_SYMBOL_GPL	
++0xdcfd1dd5	nfs4_pnfs_ds_connect	vmlinux	EXPORT_SYMBOL_GPL	
++0xcb656f3a	nfs_try_get_tree	vmlinux	EXPORT_SYMBOL_GPL	
++0x7dda30af	unregister_tracepoint_module_notifier	vmlinux	EXPORT_SYMBOL_GPL	
++0x64b0592a	alarm_forward_now	vmlinux	EXPORT_SYMBOL_GPL	
++0x8fbbddcc	rtnetlink_put_metrics	vmlinux	EXPORT_SYMBOL	
++0x5ed90adc	int_to_scsilun	vmlinux	EXPORT_SYMBOL	
++0x86c0d5fb	pwm_get_chip_data	vmlinux	EXPORT_SYMBOL_GPL	
++0x6afb329b	pwm_set_chip_data	vmlinux	EXPORT_SYMBOL_GPL	
++0x188b1afc	blk_queue_max_write_same_sectors	vmlinux	EXPORT_SYMBOL	
++0xdab4a6d1	may_umount	vmlinux	EXPORT_SYMBOL	
++0xe60a5e8d	pids_cgrp_subsys_enabled_key	vmlinux	EXPORT_SYMBOL_GPL	
++0xb8ce22eb	rpc_switch_client_transport	vmlinux	EXPORT_SYMBOL_GPL	
++0x699fe53e	iscsi_get_discovery_parent_name	vmlinux	EXPORT_SYMBOL_GPL	
++0x1050fd2c	genpd_dev_pm_attach_by_id	vmlinux	EXPORT_SYMBOL_GPL	
++0x94388759	tty_buffer_unlock_exclusive	vmlinux	EXPORT_SYMBOL_GPL	
++0xe98274ff	regulator_map_voltage_linear_range	vmlinux	EXPORT_SYMBOL_GPL	
++0x9466011d	pcix_get_max_mmrbc	vmlinux	EXPORT_SYMBOL	
++0x58d09b99	block_read_full_page	vmlinux	EXPORT_SYMBOL	
++0xbca3a8b2	console_drivers	vmlinux	EXPORT_SYMBOL_GPL	
++0xb5a13ecf	mmc_sw_reset	vmlinux	EXPORT_SYMBOL	
++0x651f9f4c	mmc_hw_reset	vmlinux	EXPORT_SYMBOL	
++0x2045b15f	bus_sort_breadthfirst	vmlinux	EXPORT_SYMBOL_GPL	
++0xa90be265	pci_alloc_host_bridge	vmlinux	EXPORT_SYMBOL	
++0x9fe939e1	mpi_powm	vmlinux	EXPORT_SYMBOL_GPL	
++0xea6f9a36	zlib_deflate_dfltcc_enabled	vmlinux	EXPORT_SYMBOL	
++0x3f20a90c	nfs_mark_client_ready	vmlinux	EXPORT_SYMBOL_GPL	
++0xf6ed2c71	dec_node_page_state	vmlinux	EXPORT_SYMBOL	
++0xbb50a9b2	tcp_v4_connect	vmlinux	EXPORT_SYMBOL	
++0xe37fb4e0	tcp_sync_mss	vmlinux	EXPORT_SYMBOL	
++0xd6076074	ir_raw_event_store_with_timeout	vmlinux	EXPORT_SYMBOL_GPL	
++0x452a9239	rc_free_device	vmlinux	EXPORT_SYMBOL_GPL	
++0xb8794003	regmap_raw_write	vmlinux	EXPORT_SYMBOL_GPL	
++0x488278be	devm_regulator_unregister_notifier	vmlinux	EXPORT_SYMBOL_GPL	
++0x9dcfee96	regulator_bulk_disable	vmlinux	EXPORT_SYMBOL_GPL	
++0x3fe2ccbe	memweight	vmlinux	EXPORT_SYMBOL	
++0x816e3353	jbd2_journal_ack_err	vmlinux	EXPORT_SYMBOL	
++0xd0c05159	emergency_restart	vmlinux	EXPORT_SYMBOL_GPL	
++0x82d623d7	__netpoll_free	vmlinux	EXPORT_SYMBOL_GPL	
++0x9ad3bc79	netdev_upper_dev_link	vmlinux	EXPORT_SYMBOL	
++0x02f3d1ca	regmap_field_read	vmlinux	EXPORT_SYMBOL_GPL	
++0x42f728aa	mctrl_gpio_get_outputs	vmlinux	EXPORT_SYMBOL_GPL	
++0x76444629	reset_control_get_count	vmlinux	EXPORT_SYMBOL_GPL	
++0x1f503f78	clk_fixed_factor_ops	vmlinux	EXPORT_SYMBOL_GPL	
++0x479f7d4b	clk_bulk_disable	vmlinux	EXPORT_SYMBOL_GPL	
++0x45f02615	framebuffer_alloc	vmlinux	EXPORT_SYMBOL	
++0x47cfd825	kstrtouint_from_user	vmlinux	EXPORT_SYMBOL	
++0xaaf56630	__traceiter_ff_layout_write_error	vmlinux	EXPORT_SYMBOL_GPL	
++0x3ab69a2f	xfrm_policy_byid	vmlinux	EXPORT_SYMBOL	
++0x066a3c61	mbox_free_channel	vmlinux	EXPORT_SYMBOL_GPL	
++0xc1afdd20	of_io_request_and_map	vmlinux	EXPORT_SYMBOL	
++0x3e66493a	cpufreq_driver_target	vmlinux	EXPORT_SYMBOL_GPL	
++0x19c20269	soc_device_unregister	vmlinux	EXPORT_SYMBOL_GPL	
++0x63ef1487	amba_apb_device_add	vmlinux	EXPORT_SYMBOL_GPL	
++0xafb4177d	pci_prepare_to_sleep	vmlinux	EXPORT_SYMBOL	
++0x048a1229	ahash_register_instance	vmlinux	EXPORT_SYMBOL_GPL	
++0xd460ee71	load_nls_default	vmlinux	EXPORT_SYMBOL	
++0x790a1e19	nonseekable_open	vmlinux	EXPORT_SYMBOL	
++0xf339ede0	kmem_cache_create	vmlinux	EXPORT_SYMBOL	
++0x73a56dd2	queue_work_node	vmlinux	EXPORT_SYMBOL_GPL	
++0xece5ce66	inet_get_local_port_range	vmlinux	EXPORT_SYMBOL	
++0x0fa4003d	devm_nvmem_device_get	vmlinux	EXPORT_SYMBOL_GPL	
++0x93266dd9	devm_nvmem_device_put	vmlinux	EXPORT_SYMBOL_GPL	
++0x0a7a6cb9	of_graph_get_endpoint_count	vmlinux	EXPORT_SYMBOL	
++0x4b358628	usb_phy_get_charger_current	vmlinux	EXPORT_SYMBOL_GPL	
++0xccf9331f	usb_phy_set_charger_current	vmlinux	EXPORT_SYMBOL_GPL	
++0x24b3638d	phy_get_eee_err	vmlinux	EXPORT_SYMBOL	
++0x4e2fbde4	nvme_reset_ctrl	vmlinux	EXPORT_SYMBOL_GPL	
++0xf77337a1	hdmi_audio_infoframe_check	vmlinux	EXPORT_SYMBOL	
++0xac58daf0	pci_bus_claim_resources	vmlinux	EXPORT_SYMBOL	
++0xa7bcc168	gen_pool_avail	vmlinux	EXPORT_SYMBOL_GPL	
++0xbf6ca066	__seq_open_private	vmlinux	EXPORT_SYMBOL	
++0xc6b14765	seq_escape	vmlinux	EXPORT_SYMBOL	
++0xd6f50cf7	xfrm_ealg_get_byname	vmlinux	EXPORT_SYMBOL_GPL	
++0x4aea804b	__sk_queue_drop_skb	vmlinux	EXPORT_SYMBOL	
++0xcb7ba402	sock_alloc_file	vmlinux	EXPORT_SYMBOL	
++0x1ceaa423	of_graph_is_present	vmlinux	EXPORT_SYMBOL	
++0x1638dd18	usb_stor_resume	vmlinux	EXPORT_SYMBOL_GPL	USB_STORAGE
++0xa93c63cd	DWC_TIMER_CANCEL	vmlinux	EXPORT_SYMBOL	
++0x279d35d7	of_mdiobus_register	vmlinux	EXPORT_SYMBOL	
++0x24c576e8	device_match_any	vmlinux	EXPORT_SYMBOL_GPL	
++0x0447b8de	__generic_file_write_iter	vmlinux	EXPORT_SYMBOL	
++0xdaec288d	pr_flush	vmlinux	EXPORT_SYMBOL	
++0x74dee782	xfrm_lookup	vmlinux	EXPORT_SYMBOL	
++0x694790eb	skb_store_bits	vmlinux	EXPORT_SYMBOL	
++0x54253c23	dma_resv_fini	vmlinux	EXPORT_SYMBOL	
++0x8dfce236	nfs_access_set_mask	vmlinux	EXPORT_SYMBOL_GPL	
++0xc9e69942	search_trusted_key	vmlinux	EXPORT_SYMBOL_GPL	
++0x9380d075	__cgroup_bpf_run_filter_skb	vmlinux	EXPORT_SYMBOL	
++0x65e01af9	__sync_icache_dcache	vmlinux	EXPORT_SYMBOL_GPL	
++0x77ce6571	inet_unregister_protosw	vmlinux	EXPORT_SYMBOL	
++0xffbab2e7	cpufreq_dbs_governor_stop	vmlinux	EXPORT_SYMBOL_GPL	
++0x9af3349c	i2c_smbus_read_byte	vmlinux	EXPORT_SYMBOL	
++0xaa2b4a07	i2c_probe_func_quick_read	vmlinux	EXPORT_SYMBOL_GPL	
++0x50fb7cf5	iscsi_scan_finished	vmlinux	EXPORT_SYMBOL_GPL	
++0x3785e561	__tracepoint_iscsi_dbg_session	vmlinux	EXPORT_SYMBOL_GPL	
++0x1d446c5d	_dev_info	vmlinux	EXPORT_SYMBOL	
++0x22f31abb	add_hwgenerator_randomness	vmlinux	EXPORT_SYMBOL_GPL	
++0x6dcf857f	uuid_null	vmlinux	EXPORT_SYMBOL	
++0xeafc141f	__posix_acl_chmod	vmlinux	EXPORT_SYMBOL	
++0x058c6377	for_each_kernel_tracepoint	vmlinux	EXPORT_SYMBOL_GPL	
++0x2c821558	svc_xprt_put	vmlinux	EXPORT_SYMBOL_GPL	
++0x119ea09e	led_classdev_register_ext	vmlinux	EXPORT_SYMBOL_GPL	
++0x0c94cf9a	devres_for_each_res	vmlinux	EXPORT_SYMBOL_GPL	
++0x10140e43	device_remove_file_self	vmlinux	EXPORT_SYMBOL_GPL	
++0x6326edb0	pci_alloc_dev	vmlinux	EXPORT_SYMBOL	
++0x7da9e8ce	security_inet_conn_established	vmlinux	EXPORT_SYMBOL	
++0x607b6544	jbd2_journal_finish_inode_data_buffers	vmlinux	EXPORT_SYMBOL	
++0x3dfc897c	seq_hlist_start_head	vmlinux	EXPORT_SYMBOL	
++0x97ca4eb9	clocksource_change_rating	vmlinux	EXPORT_SYMBOL	
++0x39991865	icmp_global_allow	vmlinux	EXPORT_SYMBOL	
++0x0a3f86bd	peernet2id_alloc	vmlinux	EXPORT_SYMBOL_GPL	
++0x04d4ce37	sdio_set_block_size	vmlinux	EXPORT_SYMBOL_GPL	
++0xf0eb1dc5	usb_stor_post_reset	vmlinux	EXPORT_SYMBOL_GPL	USB_STORAGE
++0xd1b2d6a3	DWC_PRINTF	vmlinux	EXPORT_SYMBOL	
++0xd36760ef	__usb_get_extra_descriptor	vmlinux	EXPORT_SYMBOL_GPL	
++0x3423dc86	pci_bus_assign_resources	vmlinux	EXPORT_SYMBOL	
++0x8c468884	crypto_aead_decrypt	vmlinux	EXPORT_SYMBOL_GPL	
++0xf62b9e7e	crypto_aead_encrypt	vmlinux	EXPORT_SYMBOL_GPL	
++0x4f350e06	nfs_file_fsync	vmlinux	EXPORT_SYMBOL_GPL	
++0xbbe47389	mark_buffer_write_io_error	vmlinux	EXPORT_SYMBOL	
++0xa389a49a	profile_event_register	vmlinux	EXPORT_SYMBOL_GPL	
++0x054f07fd	cpu_latency_qos_request_active	vmlinux	EXPORT_SYMBOL_GPL	
++0xb98bb315	phy_gbit_fibre_features	vmlinux	EXPORT_SYMBOL_GPL	
++0xadae6df8	blake2s_final	vmlinux	EXPORT_SYMBOL	
++0x615911d7	__bitmap_set	vmlinux	EXPORT_SYMBOL	
++0x5a23acf2	nfs_generic_pg_test	vmlinux	EXPORT_SYMBOL_GPL	
++0x4018b4a1	nfs_init_server_rpcclient	vmlinux	EXPORT_SYMBOL_GPL	
++0xafdf03fe	sysfs_rename_link_ns	vmlinux	EXPORT_SYMBOL_GPL	
++0x3694dde6	__dquot_transfer	vmlinux	EXPORT_SYMBOL	
++0x1a6bf28f	fsnotify_get_cookie	vmlinux	EXPORT_SYMBOL_GPL	
++0x4b959fbe	lock_two_nondirectories	vmlinux	EXPORT_SYMBOL	
++0xd954053e	unregister_kprobes	vmlinux	EXPORT_SYMBOL_GPL	
++0xc924988d	register_netdevice	vmlinux	EXPORT_SYMBOL	
++0x48f63441	user_describe	vmlinux	EXPORT_SYMBOL_GPL	
++0x787a7316	__traceiter_nfs_fsync_exit	vmlinux	EXPORT_SYMBOL_GPL	
++0x5308fcc6	blkdev_put	vmlinux	EXPORT_SYMBOL	
++0x57c92967	finish_no_open	vmlinux	EXPORT_SYMBOL	
++0xac14778a	bpf_prog_get_type_path	vmlinux	EXPORT_SYMBOL	
++0x95603a01	__neigh_set_probe_once	vmlinux	EXPORT_SYMBOL	
++0x7e7d4b42	build_skb	vmlinux	EXPORT_SYMBOL	
++0x590d4973	get_tz_trend	vmlinux	EXPORT_SYMBOL	
++0xcd224222	fwnode_handle_put	vmlinux	EXPORT_SYMBOL_GPL	
++0x52252316	clk_unregister_fixed_rate	vmlinux	EXPORT_SYMBOL_GPL	
++0x2d2dd36f	kobj_ns_grab_current	vmlinux	EXPORT_SYMBOL_GPL	
++0x56cabea8	fscache_enqueue_operation	vmlinux	EXPORT_SYMBOL	
++0x0d1a263d	nexthop_find_by_id	vmlinux	EXPORT_SYMBOL_GPL	
++0xa7c922b4	tcp_get_info	vmlinux	EXPORT_SYMBOL_GPL	
++0x5d8476d3	bpf_sk_storage_diag_alloc	vmlinux	EXPORT_SYMBOL_GPL	
++0x2c33a251	skb_to_sgvec_nomark	vmlinux	EXPORT_SYMBOL_GPL	
++0x75cfcf2a	__alloc_skb	vmlinux	EXPORT_SYMBOL	
++0x37068649	regmap_get_val_bytes	vmlinux	EXPORT_SYMBOL_GPL	
++0x7c6ebc94	blk_mq_complete_request_remote	vmlinux	EXPORT_SYMBOL_GPL	
++0xcb747ae4	jbd2_trans_will_send_data_barrier	vmlinux	EXPORT_SYMBOL	
++0x73b75273	jbd2_journal_begin_ordered_truncate	vmlinux	EXPORT_SYMBOL	
++0x02ba1187	vm_zone_stat	vmlinux	EXPORT_SYMBOL	
++0x1908a6d7	file_fdatawait_range	vmlinux	EXPORT_SYMBOL	
++0x055e77e8	jiffies_64	vmlinux	EXPORT_SYMBOL	
++0xf386bbb4	housekeeping_cpumask	vmlinux	EXPORT_SYMBOL_GPL	
++0xe4f1f289	svc_create	vmlinux	EXPORT_SYMBOL_GPL	
++0x45fec3db	blk_mq_start_stopped_hw_queues	vmlinux	EXPORT_SYMBOL	
++0xbcbb0931	xfrm_trans_queue_net	vmlinux	EXPORT_SYMBOL	
++0x2979f851	led_set_brightness	vmlinux	EXPORT_SYMBOL_GPL	
++0xc1f3855c	mpage_readahead	vmlinux	EXPORT_SYMBOL	
++0xa57bde0b	dcache_readdir	vmlinux	EXPORT_SYMBOL	
++0x411e602c	inode_add_bytes	vmlinux	EXPORT_SYMBOL	
++0x77e37e92	thaw_super	vmlinux	EXPORT_SYMBOL	
++0x1ad166de	generic_file_mmap	vmlinux	EXPORT_SYMBOL	
++0x5b6b0329	swiotlb_max_segment	vmlinux	EXPORT_SYMBOL_GPL	
++0xc0dd5249	abort_creds	vmlinux	EXPORT_SYMBOL	
++0x4188d439	neigh_rand_reach_time	vmlinux	EXPORT_SYMBOL	
++0x6b4616af	dev_forward_skb	vmlinux	EXPORT_SYMBOL_GPL	
++0x4df2ea84	gen_estimator_read	vmlinux	EXPORT_SYMBOL	
++0x23a27a4a	sock_common_setsockopt	vmlinux	EXPORT_SYMBOL	
++0x84c808e6	sock_common_getsockopt	vmlinux	EXPORT_SYMBOL	
++0x628e01ba	n_tty_inherit_ops	vmlinux	EXPORT_SYMBOL_GPL	
++0xd1bb6285	idr_find	vmlinux	EXPORT_SYMBOL_GPL	
++0x65408378	zlib_inflate_blob	vmlinux	EXPORT_SYMBOL	
++0xcea0c0ff	security_sctp_sk_clone	vmlinux	EXPORT_SYMBOL	
++0x3079f053	try_to_writeback_inodes_sb	vmlinux	EXPORT_SYMBOL	
++0x48dbbd96	vfs_mknod	vmlinux	EXPORT_SYMBOL	
++0x4b5f7d61	skb_dequeue	vmlinux	EXPORT_SYMBOL	
++0xb6a70e20	usbnet_manage_power	vmlinux	EXPORT_SYMBOL	
++0x9c08f120	clk_hw_register	vmlinux	EXPORT_SYMBOL_GPL	
++0x4794f97f	__SCK__tp_func_fs_file_release	vmlinux	EXPORT_SYMBOL_GPL	
++0x27bbf221	disable_irq_nosync	vmlinux	EXPORT_SYMBOL	
++0x4c15dbec	xdr_reserve_space_vec	vmlinux	EXPORT_SYMBOL_GPL	
++0x386f768f	inet_rtx_syn_ack	vmlinux	EXPORT_SYMBOL	
++0x2e0f7a21	bcm_phy_cable_test_get_status	vmlinux	EXPORT_SYMBOL_GPL	
++0xf3f93d80	__traceiter_dma_fence_enable_signal	vmlinux	EXPORT_SYMBOL	
++0x9c6febfc	add_uevent_var	vmlinux	EXPORT_SYMBOL_GPL	
++0x65241bd2	find_font	vmlinux	EXPORT_SYMBOL	
++0xe273d75d	alloc_cpu_rmap	vmlinux	EXPORT_SYMBOL	
++0x760b3e4c	blk_queue_chunk_sectors	vmlinux	EXPORT_SYMBOL	
++0x6604c91c	blk_clear_pm_only	vmlinux	EXPORT_SYMBOL_GPL	
++0xb18efd9d	pnfs_destroy_layout	vmlinux	EXPORT_SYMBOL_GPL	
++0xc2c1c427	perf_event_cgrp_subsys_on_dfl_key	vmlinux	EXPORT_SYMBOL_GPL	
++0x370d5776	tcp_filter	vmlinux	EXPORT_SYMBOL	
++0x11fe850a	netdev_features_change	vmlinux	EXPORT_SYMBOL	
++0x759f0acf	extcon_unregister_notifier_all	vmlinux	EXPORT_SYMBOL_GPL	
++0x403c8d92	platform_get_resource_byname	vmlinux	EXPORT_SYMBOL_GPL	
++0x83efb532	fbcon_update_vcs	vmlinux	EXPORT_SYMBOL	
++0xc1bdbb96	of_find_node_by_type	vmlinux	EXPORT_SYMBOL	
++0x54264a75	usb_stor_adjust_quirks	vmlinux	EXPORT_SYMBOL_GPL	USB_STORAGE
++0xce89029c	usbnet_set_rx_mode	vmlinux	EXPORT_SYMBOL_GPL	
++0x49e12b9f	phy_start	vmlinux	EXPORT_SYMBOL	
++0x3ab7b1cc	scsi_set_sense_field_pointer	vmlinux	EXPORT_SYMBOL	
++0x047becf7	devres_find	vmlinux	EXPORT_SYMBOL_GPL	
++0xf7a2687e	user_free_preparse	vmlinux	EXPORT_SYMBOL_GPL	
++0xa9bb755a	__SCK__tp_func_fs_file_read	vmlinux	EXPORT_SYMBOL_GPL	
++0xf7f7f745	page_mapped	vmlinux	EXPORT_SYMBOL	
++0x00513f58	get_timespec64	vmlinux	EXPORT_SYMBOL_GPL	
++0x0d066410	proc_dostring	vmlinux	EXPORT_SYMBOL	
++0x6b8c05ad	genlmsg_put	vmlinux	EXPORT_SYMBOL	
++0xe81b9acd	of_get_display_timing	vmlinux	EXPORT_SYMBOL_GPL	
++0x0779f8b3	pci_bus_write_config_byte	vmlinux	EXPORT_SYMBOL	
++0xedd9b60c	devm_gpiod_put_array	vmlinux	EXPORT_SYMBOL_GPL	
++0x47709e42	free_anon_bdev	vmlinux	EXPORT_SYMBOL	
++0x4b4af77d	raw_hash_sk	vmlinux	EXPORT_SYMBOL_GPL	
++0x33025624	tcp_seq_start	vmlinux	EXPORT_SYMBOL	
++0xea6d2e81	dst_cache_get	vmlinux	EXPORT_SYMBOL_GPL	
++0xd62ecd49	rps_sock_flow_table	vmlinux	EXPORT_SYMBOL	
++0x0a1ec38c	usb_stor_control_msg	vmlinux	EXPORT_SYMBOL_GPL	USB_STORAGE
++0x6e4bc056	spi_res_free	vmlinux	EXPORT_SYMBOL_GPL	
++0x31bb1358	of_genpd_add_subdomain	vmlinux	EXPORT_SYMBOL_GPL	
++0x2f41fdb4	__memcpy_mcs	vmlinux	EXPORT_SYMBOL	
++0x4583416a	blk_mq_complete_request	vmlinux	EXPORT_SYMBOL	
++0x6d7e951e	rcu_exp_batches_completed	vmlinux	EXPORT_SYMBOL_GPL	
++0xdbdb0e8b	request_any_context_irq	vmlinux	EXPORT_SYMBOL_GPL	
++0x19cd4b2c	rpc_clnt_swap_activate	vmlinux	EXPORT_SYMBOL_GPL	
++0xa84975b9	udplite_table	vmlinux	EXPORT_SYMBOL	
++0x01df602c	cpufreq_driver_resolve_freq	vmlinux	EXPORT_SYMBOL_GPL	
++0xa0f5780e	mipi_dsi_dcs_set_page_address	vmlinux	EXPORT_SYMBOL	
++0xa83f1eb9	serial8250_do_set_mctrl	vmlinux	EXPORT_SYMBOL_GPL	
++0xd150666b	serial8250_do_get_mctrl	vmlinux	EXPORT_SYMBOL_GPL	
++0x9a3431e8	msi_desc_to_pci_dev	vmlinux	EXPORT_SYMBOL	
++0xb336b45c	blk_queue_max_segment_size	vmlinux	EXPORT_SYMBOL	
++0x53d673bb	nfs_wb_all	vmlinux	EXPORT_SYMBOL_GPL	
++0x640eeb2a	ip_fraglist_init	vmlinux	EXPORT_SYMBOL	
++0xd8d68ab1	dmi_memdev_type	vmlinux	EXPORT_SYMBOL_GPL	
++0x050877b9	dmi_first_match	vmlinux	EXPORT_SYMBOL	
++0x6861524c	usb_gadget_unmap_request	vmlinux	EXPORT_SYMBOL_GPL	
++0x600683d3	do_unblank_screen	vmlinux	EXPORT_SYMBOL	
++0x2ebd6b78	pci_find_ext_capability	vmlinux	EXPORT_SYMBOL_GPL	
++0x4f1853e0	klist_add_tail	vmlinux	EXPORT_SYMBOL_GPL	
++0x63fdc919	look_up_OID	vmlinux	EXPORT_SYMBOL_GPL	
++0xdea1a06f	kernel_read_file	vmlinux	EXPORT_SYMBOL_GPL	
++0x6e9dd606	__symbol_put	vmlinux	EXPORT_SYMBOL	
++0x8e3b0051	netpoll_send_udp	vmlinux	EXPORT_SYMBOL	
++0x20835a9f	__xdp_release_frame	vmlinux	EXPORT_SYMBOL_GPL	
++0xf665f74f	sock_load_diag_module	vmlinux	EXPORT_SYMBOL	
++0x39b2fc49	genphy_restart_aneg	vmlinux	EXPORT_SYMBOL	
++0x36401eeb	bcm_dma_chan_alloc	vmlinux	EXPORT_SYMBOL_GPL	
++0xc49d337e	pci_claim_resource	vmlinux	EXPORT_SYMBOL	
++0x59923eb3	__tracepoint_nfs_xdr_status	vmlinux	EXPORT_SYMBOL_GPL	
++0xf09b5d9a	get_zeroed_page	vmlinux	EXPORT_SYMBOL	
++0x66c6f473	get_kernel_page	vmlinux	EXPORT_SYMBOL_GPL	
++0xa8282468	bpf_prog_put	vmlinux	EXPORT_SYMBOL_GPL	
++0x8970ae78	ndo_dflt_fdb_dump	vmlinux	EXPORT_SYMBOL	
++0xd0463684	mbox_request_channel	vmlinux	EXPORT_SYMBOL_GPL	
++0x5ff2fe1b	of_translate_dma_address	vmlinux	EXPORT_SYMBOL	
++0x35d26730	of_device_is_available	vmlinux	EXPORT_SYMBOL	
++0xa409680f	input_close_device	vmlinux	EXPORT_SYMBOL	
++0x533206b5	sort_r	vmlinux	EXPORT_SYMBOL	
++0xb8d27196	key_validate	vmlinux	EXPORT_SYMBOL	
++0x14b89635	arm64_const_caps_ready	vmlinux	EXPORT_SYMBOL	
++0xf5a51a3d	rpc_init_pipe_dir_head	vmlinux	EXPORT_SYMBOL_GPL	
++0x1af58e14	rtnl_create_link	vmlinux	EXPORT_SYMBOL	
++0x6a57c76a	of_usb_get_phy_mode	vmlinux	EXPORT_SYMBOL_GPL	
++0x199717d9	phy_connect_direct	vmlinux	EXPORT_SYMBOL	
++0x1281ec12	mfd_remove_devices_late	vmlinux	EXPORT_SYMBOL	
++0x907b5d07	_dev_notice	vmlinux	EXPORT_SYMBOL	
++0x74542ea3	tty_insert_flip_string_flags	vmlinux	EXPORT_SYMBOL	
++0x42c6c2d5	__sbitmap_queue_get_shallow	vmlinux	EXPORT_SYMBOL_GPL	
++0xd56fa469	address_space_init_once	vmlinux	EXPORT_SYMBOL	
++0xac159e2d	bdi_dev_name	vmlinux	EXPORT_SYMBOL_GPL	
++0x9714e0bb	ktime_get_raw	vmlinux	EXPORT_SYMBOL_GPL	
++0x99c9a305	prepare_to_wait_exclusive	vmlinux	EXPORT_SYMBOL	
++0x3734086e	xfrm_audit_state_replay	vmlinux	EXPORT_SYMBOL_GPL	
++0xc5c5883b	inet_dev_addr_type	vmlinux	EXPORT_SYMBOL	
++0xf2ef02c3	tcf_action_exec	vmlinux	EXPORT_SYMBOL	
++0x9d6478fe	vchiq_use_service	vmlinux	EXPORT_SYMBOL	
++0xe61ff4dd	platform_device_add	vmlinux	EXPORT_SYMBOL_GPL	
++0x537e8e81	clk_hw_get_num_parents	vmlinux	EXPORT_SYMBOL_GPL	
++0xc7fa4aa9	kobj_ns_drop	vmlinux	EXPORT_SYMBOL_GPL	
++0x460d01e5	debugfs_create_size_t	vmlinux	EXPORT_SYMBOL_GPL	
++0x7b43c3be	remove_proc_entry	vmlinux	EXPORT_SYMBOL	
++0xeeb0d7b3	fsnotify_add_mark	vmlinux	EXPORT_SYMBOL_GPL	
++0x3f2301ea	xfrm_spd_getinfo	vmlinux	EXPORT_SYMBOL	
++0xac38fbd3	dm_kobject_release	vmlinux	EXPORT_SYMBOL	
++0xf8d3ce58	genphy_setup_forced	vmlinux	EXPORT_SYMBOL	
++0x329c203b	pci_walk_bus	vmlinux	EXPORT_SYMBOL_GPL	
++0xfd0b8f74	block_is_partially_uptodate	vmlinux	EXPORT_SYMBOL	
++0xa4ab7c1c	ring_buffer_overruns	vmlinux	EXPORT_SYMBOL_GPL	
++0xc09438d7	l3mdev_table_lookup_unregister	vmlinux	EXPORT_SYMBOL_GPL	
++0xcee467f3	xprt_load_transport	vmlinux	EXPORT_SYMBOL_GPL	
++0x6e46eb7b	alloc_etherdev_mqs	vmlinux	EXPORT_SYMBOL	
++0x5be63c5b	crc32c_csum_stub	vmlinux	EXPORT_SYMBOL	
++0x94541606	uart_resume_port	vmlinux	EXPORT_SYMBOL	
++0x79260261	gpiod_get_value_cansleep	vmlinux	EXPORT_SYMBOL_GPL	
++0xb05fc310	sysctl_rmem_max	vmlinux	EXPORT_SYMBOL	
++0xfac8865f	sysctl_wmem_max	vmlinux	EXPORT_SYMBOL	
++0xcf357b6d	sdhci_adma_write_desc	vmlinux	EXPORT_SYMBOL_GPL	
++0xff6a930c	DWC_TIMER_FREE	vmlinux	EXPORT_SYMBOL	
++0xff62c527	dwc_cc_add	vmlinux	EXPORT_SYMBOL	
++0x06209f49	phy_lookup_setting	vmlinux	EXPORT_SYMBOL_GPL	
++0x3cea2ad6	pci_user_write_config_byte	vmlinux	EXPORT_SYMBOL_GPL	
++0x214be481	__sbitmap_queue_get	vmlinux	EXPORT_SYMBOL_GPL	
++0x451553ab	crypto_grab_spawn	vmlinux	EXPORT_SYMBOL_GPL	
++0xfc8476de	jbd2_journal_errno	vmlinux	EXPORT_SYMBOL	
++0x9906f0a3	dquot_transfer	vmlinux	EXPORT_SYMBOL	
++0x26ed2186	register_vmap_purge_notifier	vmlinux	EXPORT_SYMBOL_GPL	
++0x467df16d	netdev_rss_key_fill	vmlinux	EXPORT_SYMBOL	
++0x5cf53ce2	input_free_minor	vmlinux	EXPORT_SYMBOL	
++0xd194d37a	phy_ethtool_ksettings_set	vmlinux	EXPORT_SYMBOL	
++0x8c6371c5	phy_ethtool_ksettings_get	vmlinux	EXPORT_SYMBOL	
++0x375792b7	pci_write_config_byte	vmlinux	EXPORT_SYMBOL	
++0x6df7db29	pwm_get	vmlinux	EXPORT_SYMBOL_GPL	
++0xf25237f4	pagecache_write_end	vmlinux	EXPORT_SYMBOL	
++0xdf1f9b52	preempt_schedule_lock	vmlinux	EXPORT_SYMBOL	
++0xb79dfbdb	rpc_clone_client	vmlinux	EXPORT_SYMBOL_GPL	
++0x49e7f0ed	xfrm_audit_state_icvfail	vmlinux	EXPORT_SYMBOL_GPL	
++0x07be6905	net_inc_egress_queue	vmlinux	EXPORT_SYMBOL_GPL	
++0x06026d13	of_get_next_child	vmlinux	EXPORT_SYMBOL	
++0x8d408746	hid_resolv_usage	vmlinux	EXPORT_SYMBOL_GPL	
++0x3d06350c	hidinput_get_led_field	vmlinux	EXPORT_SYMBOL_GPL	
++0x55ab9ef0	psci_ops	vmlinux	EXPORT_SYMBOL	
++0xa63676e8	sdio_f0_readb	vmlinux	EXPORT_SYMBOL_GPL	
++0x0f306ea1	dev_pm_opp_set_supported_hw	vmlinux	EXPORT_SYMBOL_GPL	
++0x3209ef0b	pm_genpd_add_subdomain	vmlinux	EXPORT_SYMBOL_GPL	
++0xb077e70a	clk_unprepare	vmlinux	EXPORT_SYMBOL_GPL	
++0xb12cbacb	fb_unregister_client	vmlinux	EXPORT_SYMBOL	
++0xf9ca2eb4	kstrtoint_from_user	vmlinux	EXPORT_SYMBOL	
++0x51cb2610	crypto_skcipher_encrypt	vmlinux	EXPORT_SYMBOL_GPL	
++0x47e6ab58	perf_get_aux	vmlinux	EXPORT_SYMBOL_GPL	
++0xa2500ef6	__SCK__tp_func_powernv_throttle	vmlinux	EXPORT_SYMBOL_GPL	
++0x9d221656	alloc_workqueue_attrs	vmlinux	EXPORT_SYMBOL_GPL	
++0x59730d5e	inet_csk_init_xmit_timers	vmlinux	EXPORT_SYMBOL	
++0xa77fbfd8	dev_pm_opp_remove	vmlinux	EXPORT_SYMBOL_GPL	
++0x1b47c0a2	irq_set_chip_and_handler_name	vmlinux	EXPORT_SYMBOL_GPL	
++0x2a7316da	__SCK__tp_func_neigh_cleanup_and_release	vmlinux	EXPORT_SYMBOL_GPL	
++0x3efe1703	phy_unregister_fixup_for_id	vmlinux	EXPORT_SYMBOL	
++0xc6235ebe	dev_pm_put_subsys_data	vmlinux	EXPORT_SYMBOL_GPL	
++0xda02479f	dev_pm_get_subsys_data	vmlinux	EXPORT_SYMBOL_GPL	
++0xf3bbf337	transport_add_device	vmlinux	EXPORT_SYMBOL_GPL	
++0x6942b119	kill_device	vmlinux	EXPORT_SYMBOL_GPL	
++0xd1481de7	mpi_clear	vmlinux	EXPORT_SYMBOL_GPL	
++0x2f16db63	vfs_readlink	vmlinux	EXPORT_SYMBOL	
++0x26cc73c3	complete_and_exit	vmlinux	EXPORT_SYMBOL	
++0xea0356d1	inet6_lookup	vmlinux	EXPORT_SYMBOL_GPL	
++0xc3be2905	udp_seq_stop	vmlinux	EXPORT_SYMBOL	
++0x19d52f1f	hid_quirks_exit	vmlinux	EXPORT_SYMBOL_GPL	
++0x155a1e03	regmap_reinit_cache	vmlinux	EXPORT_SYMBOL_GPL	
++0x978cdd45	of_clk_parent_fill	vmlinux	EXPORT_SYMBOL_GPL	
++0xff6878cf	fb_default_cmap	vmlinux	EXPORT_SYMBOL	
++0x58bce744	sysfs_remove_group	vmlinux	EXPORT_SYMBOL_GPL	
++0x0955289b	sysfs_remove_file_from_group	vmlinux	EXPORT_SYMBOL_GPL	
++0x197725e4	__alloc_pages_bulk	vmlinux	EXPORT_SYMBOL_GPL	
++0x521afa92	dma_alloc_noncoherent	vmlinux	EXPORT_SYMBOL_GPL	
++0xd54a0659	down_read_trylock	vmlinux	EXPORT_SYMBOL	
++0x9e34a061	hid_hw_start	vmlinux	EXPORT_SYMBOL_GPL	
++0xed5cc574	cpufreq_register_driver	vmlinux	EXPORT_SYMBOL_GPL	
++0xe5880d33	serial8250_handle_irq	vmlinux	EXPORT_SYMBOL_GPL	
++0x8f47d712	path_has_submounts	vmlinux	EXPORT_SYMBOL	
++0xdbe52223	open_with_fake_path	vmlinux	EXPORT_SYMBOL	
++0xd5580c1a	inet6_offloads	vmlinux	EXPORT_SYMBOL	
++0x6e18a4e9	nf_getsockopt	vmlinux	EXPORT_SYMBOL	
++0xbc27b709	nf_setsockopt	vmlinux	EXPORT_SYMBOL	
++0x579e0bf5	rtnl_unregister_all	vmlinux	EXPORT_SYMBOL_GPL	
++0x91c3eb8b	netif_rx_ni	vmlinux	EXPORT_SYMBOL	
++0x628aa12f	netif_tx_wake_queue	vmlinux	EXPORT_SYMBOL	
++0x02f8c431	vchiq_queue_kernel_message	vmlinux	EXPORT_SYMBOL	
++0x3131b773	ir_raw_encode_scancode	vmlinux	EXPORT_SYMBOL	
++0xa734d49c	i2c_smbus_xfer	vmlinux	EXPORT_SYMBOL	
++0x937b0c6b	dev_pm_qos_remove_notifier	vmlinux	EXPORT_SYMBOL_GPL	
++0x5f3cff74	device_attach	vmlinux	EXPORT_SYMBOL_GPL	
++0x8c7198d9	tty_port_open	vmlinux	EXPORT_SYMBOL	
++0xcfb273da	dma_get_any_slave_channel	vmlinux	EXPORT_SYMBOL_GPL	
++0x3142529c	arm_local_intc	vmlinux	EXPORT_SYMBOL_GPL	
++0x34735c13	blk_rq_map_user_iov	vmlinux	EXPORT_SYMBOL	
++0xfb95d72a	ioc_lookup_icq	vmlinux	EXPORT_SYMBOL	
++0x869aec55	dquot_commit_info	vmlinux	EXPORT_SYMBOL	
++0x6fd1cb8f	seq_puts	vmlinux	EXPORT_SYMBOL	
++0x06e240d6	seq_putc	vmlinux	EXPORT_SYMBOL	
++0xc2a24054	super_setup_bdi_name	vmlinux	EXPORT_SYMBOL	
++0x29b30e9c	down_read_interruptible	vmlinux	EXPORT_SYMBOL	
++0xb8041412	DWC_TIMER_SCHEDULE	vmlinux	EXPORT_SYMBOL	
++0x3009c05e	usb_create_shared_hcd	vmlinux	EXPORT_SYMBOL_GPL	
++0xe130fab4	uart_update_timeout	vmlinux	EXPORT_SYMBOL	
++0x6c205008	mpi_print	vmlinux	EXPORT_SYMBOL_GPL	
++0x4a3d09e9	crypto_register_acomp	vmlinux	EXPORT_SYMBOL_GPL	
++0xdae9b5d7	nfs4_disable_idmapping	vmlinux	EXPORT_SYMBOL_GPL	
++0xcdc76185	d_genocide	vmlinux	EXPORT_SYMBOL	
++0xd8ddf794	__module_put_and_exit	vmlinux	EXPORT_SYMBOL	
++0x6b853d06	ns_to_kernel_old_timeval	vmlinux	EXPORT_SYMBOL	
++0xb481ca92	netlink_add_tap	vmlinux	EXPORT_SYMBOL_GPL	
++0x8a227ad7	__skb_wait_for_more_packets	vmlinux	EXPORT_SYMBOL	
++0x57cf7f70	pm_clk_init	vmlinux	EXPORT_SYMBOL_GPL	
++0x88bdf93d	of_clk_hw_register	vmlinux	EXPORT_SYMBOL_GPL	
++0xc32d982f	find_get_task_by_vpid	vmlinux	EXPORT_SYMBOL_GPL	
++0xf9dea6ca	netdev_txq_to_tc	vmlinux	EXPORT_SYMBOL	
++0x7c983a5d	dmi_walk	vmlinux	EXPORT_SYMBOL_GPL	
++0xee5c005f	nvme_shutdown_ctrl	vmlinux	EXPORT_SYMBOL_GPL	
++0x6d21dde7	fwnode_graph_get_next_endpoint	vmlinux	EXPORT_SYMBOL_GPL	
++0xd7ff1b8a	__ashlti3	vmlinux	EXPORT_SYMBOL	
++0x53fa36d1	ZSTD_decompressBlock	vmlinux	EXPORT_SYMBOL	
++0xba1008c8	__crc32c_le	vmlinux	EXPORT_SYMBOL	
++0x903ca976	end_buffer_write_sync	vmlinux	EXPORT_SYMBOL	
++0xcb3ffe1d	d_rehash	vmlinux	EXPORT_SYMBOL	
++0x8457f50c	d_drop	vmlinux	EXPORT_SYMBOL	
++0x0942105e	file_open_root	vmlinux	EXPORT_SYMBOL	
++0x4cba441d	iwe_stream_add_event	vmlinux	EXPORT_SYMBOL	
++0x3d87a8ea	tso_build_hdr	vmlinux	EXPORT_SYMBOL	
++0x0d0f10d8	sock_recv_errqueue	vmlinux	EXPORT_SYMBOL	
++0x3bfe8848	__mmc_claim_host	vmlinux	EXPORT_SYMBOL	
++0x68f74c22	usb_poison_urb	vmlinux	EXPORT_SYMBOL_GPL	
++0xc55ff962	phy_basic_t1_features_array	vmlinux	EXPORT_SYMBOL_GPL	
++0xe4c79fa6	__SCK__tp_func_iscsi_dbg_eh	vmlinux	EXPORT_SYMBOL_GPL	
++0xed598f37	pci_get_class	vmlinux	EXPORT_SYMBOL	
++0x5e2c89cb	nfs_initiate_pgio	vmlinux	EXPORT_SYMBOL_GPL	
++0x0bee8257	nfs_create_rpc_client	vmlinux	EXPORT_SYMBOL_GPL	
++0xf6a28554	region_intersects	vmlinux	EXPORT_SYMBOL_GPL	
++0xb4ae4496	netif_rx	vmlinux	EXPORT_SYMBOL	
++0x7dbca845	dev_pm_opp_set_regulators	vmlinux	EXPORT_SYMBOL_GPL	
++0xf838e9f7	DWC_SPINLOCK_IRQSAVE	vmlinux	EXPORT_SYMBOL	
++0x05b49d0d	DWC_MEMCMP	vmlinux	EXPORT_SYMBOL	
++0x97071ff8	DWC_MEMCPY	vmlinux	EXPORT_SYMBOL	
++0xc64f4639	DWC_MEMSET	vmlinux	EXPORT_SYMBOL	
++0xcef8e315	bio_clone_fast	vmlinux	EXPORT_SYMBOL	
++0xb1ada83b	dma_sync_sg_for_device	vmlinux	EXPORT_SYMBOL	
++0x955b0e2e	kthread_worker_fn	vmlinux	EXPORT_SYMBOL_GPL	
++0x1ba679ae	iw_handler_set_spy	vmlinux	EXPORT_SYMBOL	
++0x74fd77bb	xfrm_stateonly_find	vmlinux	EXPORT_SYMBOL	
++0xe89679db	tcp_ld_RTO_revert	vmlinux	EXPORT_SYMBOL	
++0x20b359d2	__traceiter_br_fdb_add	vmlinux	EXPORT_SYMBOL_GPL	
++0x39edbe5d	usb_create_hcd	vmlinux	EXPORT_SYMBOL_GPL	
++0x72ea7b2d	scsi_device_type	vmlinux	EXPORT_SYMBOL	
++0x1475656c	elv_bio_merge_ok	vmlinux	EXPORT_SYMBOL	
++0xd5184bbc	nfs_dentry_operations	vmlinux	EXPORT_SYMBOL_GPL	
++0xf88e94fe	rpc_get_sb_net	vmlinux	EXPORT_SYMBOL_GPL	
++0x5f0f6a63	tcf_idr_create_from_flags	vmlinux	EXPORT_SYMBOL	
++0x0947243b	usb_autopm_get_interface_no_resume	vmlinux	EXPORT_SYMBOL_GPL	
++0x58e3e8df	nvme_cancel_tagset	vmlinux	EXPORT_SYMBOL_GPL	
++0xf71349ac	gpiochip_get_data	vmlinux	EXPORT_SYMBOL_GPL	
++0xa965ca81	reciprocal_value	vmlinux	EXPORT_SYMBOL	
++0x8e2943f4	unregister_binfmt	vmlinux	EXPORT_SYMBOL	
++0x1ed570f9	make_kgid	vmlinux	EXPORT_SYMBOL	
++0x9bcf9f7d	housekeeping_enabled	vmlinux	EXPORT_SYMBOL_GPL	
++0x877decff	xdr_init_encode	vmlinux	EXPORT_SYMBOL_GPL	
++0xcaf972a8	tcf_idr_check_alloc	vmlinux	EXPORT_SYMBOL	
++0x15d2af33	sock_no_accept	vmlinux	EXPORT_SYMBOL	
++0x0e338d9d	of_pci_range_to_resource	vmlinux	EXPORT_SYMBOL	
++0xbf70fbb6	of_led_get	vmlinux	EXPORT_SYMBOL_GPL	
++0x161aed05	pinctrl_dev_get_devname	vmlinux	EXPORT_SYMBOL_GPL	
++0x6c3f70e0	guid_gen	vmlinux	EXPORT_SYMBOL_GPL	
++0x4b66b0ae	__cleancache_init_shared_fs	vmlinux	EXPORT_SYMBOL	
++0xa48196c8	kdb_poll_idx	vmlinux	EXPORT_SYMBOL_GPL	
++0x1427225d	set_groups	vmlinux	EXPORT_SYMBOL	
++0xaf6033e3	tcf_generic_walker	vmlinux	EXPORT_SYMBOL	
++0x946aa867	flow_rule_match_eth_addrs	vmlinux	EXPORT_SYMBOL	
++0x2560b1a2	sock_diag_register_inet_compat	vmlinux	EXPORT_SYMBOL_GPL	
++0x66a320ce	netif_schedule_queue	vmlinux	EXPORT_SYMBOL	
++0x49af2b4a	dev_remove_offload	vmlinux	EXPORT_SYMBOL	
++0x5d5bb06d	mmc_unregister_driver	vmlinux	EXPORT_SYMBOL	
++0x25944472	genphy_soft_reset	vmlinux	EXPORT_SYMBOL	
++0xb7efb7b8	phy_modify_changed	vmlinux	EXPORT_SYMBOL_GPL	
++0x64baf227	mm_vc_mem_phys_addr	vmlinux	EXPORT_SYMBOL	
++0x153b60a6	klist_del	vmlinux	EXPORT_SYMBOL_GPL	
++0x5e0c3caa	__lock_buffer	vmlinux	EXPORT_SYMBOL	
++0xf352023f	memory_cgrp_subsys_enabled_key	vmlinux	EXPORT_SYMBOL_GPL	
++0x1dc7fa7b	tcp_openreq_init_rwin	vmlinux	EXPORT_SYMBOL	
++0xbc63b8d5	xdp_rxq_info_reg_mem_model	vmlinux	EXPORT_SYMBOL_GPL	
++0xb023d391	DWC_MUTEX_ALLOC	vmlinux	EXPORT_SYMBOL	
++0xe3bca4ca	dwc_alloc_notification_manager	vmlinux	EXPORT_SYMBOL	
++0x55e8f754	usb_gen_phy_init	vmlinux	EXPORT_SYMBOL_GPL	
++0xbb0ab47b	debug_locks	vmlinux	EXPORT_SYMBOL_GPL	
++0xbf7468f5	aead_geniv_alloc	vmlinux	EXPORT_SYMBOL_GPL	
++0x139f74c4	__traceiter_fs_file_release	vmlinux	EXPORT_SYMBOL_GPL	
++0xf441a3db	__traceiter_mmap_lock_released	vmlinux	EXPORT_SYMBOL	
++0x43c5fb52	perf_event_update_userpage	vmlinux	EXPORT_SYMBOL_GPL	
++0x9a58dd2d	trace_print_bitmask_seq	vmlinux	EXPORT_SYMBOL_GPL	
++0x7c5a7e8e	fib6_check_nexthop	vmlinux	EXPORT_SYMBOL_GPL	
++0x64d22363	eth_header_parse_protocol	vmlinux	EXPORT_SYMBOL	
++0xa3b216db	xdp_return_frame	vmlinux	EXPORT_SYMBOL_GPL	
++0x86a0cacf	bcm_phy_read_rdb	vmlinux	EXPORT_SYMBOL_GPL	
++0x876c3a09	iscsi_destroy_flashnode_sess	vmlinux	EXPORT_SYMBOL_GPL	
++0x20a789ac	irq_set_chip_data	vmlinux	EXPORT_SYMBOL	
++0x2cce52a6	tcp_ioctl	vmlinux	EXPORT_SYMBOL	
++0xbfaf2cd6	tcf_qevent_handle	vmlinux	EXPORT_SYMBOL	
++0x973002c8	bcm_dma_is_busy	vmlinux	EXPORT_SYMBOL_GPL	
++0xdb52d055	registered_fb	vmlinux	EXPORT_SYMBOL	
++0x9029156b	vfs_symlink	vmlinux	EXPORT_SYMBOL	
++0x57c654ec	cgroup_bpf_enabled_key	vmlinux	EXPORT_SYMBOL	
++0xd273b1b1	__round_jiffies_up_relative	vmlinux	EXPORT_SYMBOL_GPL	
++0x08e77bbf	devm_irq_domain_create_sim	vmlinux	EXPORT_SYMBOL_GPL	
++0x392b1fea	wait_for_completion_io	vmlinux	EXPORT_SYMBOL	
++0x1e168a45	find_vpid	vmlinux	EXPORT_SYMBOL_GPL	
++0xd58bbbcb	nvme_delete_wq	vmlinux	EXPORT_SYMBOL_GPL	
++0x7e6d09bc	btree_insert	vmlinux	EXPORT_SYMBOL_GPL	
++0x33b27291	lockref_put_return	vmlinux	EXPORT_SYMBOL	
++0x5e5f5ad8	__alloc_pages	vmlinux	EXPORT_SYMBOL	
++0x82f13c04	unmap_mapping_range	vmlinux	EXPORT_SYMBOL	
++0x7171121c	overflowgid	vmlinux	EXPORT_SYMBOL	
++0x8b618d08	overflowuid	vmlinux	EXPORT_SYMBOL	
++0x0c97a8b5	mr_rtm_dumproute	vmlinux	EXPORT_SYMBOL	
++0x1de6d942	ping_unhash	vmlinux	EXPORT_SYMBOL_GPL	
++0x89102c14	inet_select_addr	vmlinux	EXPORT_SYMBOL	
++0x308fa585	dev_getbyhwaddr_rcu	vmlinux	EXPORT_SYMBOL	
++0x1a146ec3	usb_ep_type_string	vmlinux	EXPORT_SYMBOL_GPL	
++0x6193e637	dma_async_tx_descriptor_init	vmlinux	EXPORT_SYMBOL	
++0x0e73ee81	pci_enable_device	vmlinux	EXPORT_SYMBOL	
++0x7389f805	__nla_validate	vmlinux	EXPORT_SYMBOL	
++0xad5e8b24	vfs_dedupe_file_range	vmlinux	EXPORT_SYMBOL	
++0x1d00b3c2	wireless_send_event	vmlinux	EXPORT_SYMBOL	
++0x53eec126	xprt_release_xprt_cong	vmlinux	EXPORT_SYMBOL_GPL	
++0xd9a33b55	udp_sk_rx_dst_set	vmlinux	EXPORT_SYMBOL	
++0x1c60d406	vchiq_get_service_userdata	vmlinux	EXPORT_SYMBOL	
++0x968f9a23	efivar_entry_iter_begin	vmlinux	EXPORT_SYMBOL_GPL	
++0x34c4b88d	phy_read_mmd	vmlinux	EXPORT_SYMBOL	
++0x0465a073	regmap_reg_in_ranges	vmlinux	EXPORT_SYMBOL_GPL	
++0x1f449588	mctrl_gpio_disable_ms	vmlinux	EXPORT_SYMBOL_GPL	
++0x78186b87	xas_find	vmlinux	EXPORT_SYMBOL_GPL	
++0x746b009b	sbitmap_finish_wait	vmlinux	EXPORT_SYMBOL_GPL	
++0xaa3e6985	blk_mq_debugfs_rq_show	vmlinux	EXPORT_SYMBOL_GPL	
++0xe1d2512f	security_sb_remount	vmlinux	EXPORT_SYMBOL	
++0x98d1859b	dcache_dir_close	vmlinux	EXPORT_SYMBOL	
++0x2c91e17c	vm_get_page_prot	vmlinux	EXPORT_SYMBOL	
++0x1f563160	bpf_offload_dev_priv	vmlinux	EXPORT_SYMBOL_GPL	
++0x7f8aca9c	rpc_wake_up_queued_task	vmlinux	EXPORT_SYMBOL_GPL	
++0x3ff61f33	tcp_enter_quickack_mode	vmlinux	EXPORT_SYMBOL	
++0x11f469ed	ethtool_notify	vmlinux	EXPORT_SYMBOL	
++0x65147ba8	phy_driver_register	vmlinux	EXPORT_SYMBOL	
++0xdf37e64b	scsi_dma_unmap	vmlinux	EXPORT_SYMBOL	
++0x1434df69	vga_set_legacy_decoding	vmlinux	EXPORT_SYMBOL	
++0x85b1e675	regulator_get_voltage_sel_pickable_regmap	vmlinux	EXPORT_SYMBOL_GPL	
++0x7b225ea8	crypto_alloc_rng	vmlinux	EXPORT_SYMBOL_GPL	
++0x6a84c403	relay_reset	vmlinux	EXPORT_SYMBOL_GPL	
++0x418c9a79	hardirq_context	vmlinux	EXPORT_SYMBOL_GPL	
++0xc823049e	inet_put_port	vmlinux	EXPORT_SYMBOL	
++0x85e080eb	tcf_classify_ingress	vmlinux	EXPORT_SYMBOL	
++0x1262c119	sock_no_connect	vmlinux	EXPORT_SYMBOL	
++0xaa089845	sk_set_peek_off	vmlinux	EXPORT_SYMBOL_GPL	
++0x0d90d784	usb_ep_fifo_flush	vmlinux	EXPORT_SYMBOL_GPL	
++0x8c846c47	phy_print_status	vmlinux	EXPORT_SYMBOL	
++0xf517cd15	cpu_device_create	vmlinux	EXPORT_SYMBOL_GPL	
++0x26340f37	clk_register_fractional_divider	vmlinux	EXPORT_SYMBOL_GPL	
++0xa24ab7fb	pci_remove_bus	vmlinux	EXPORT_SYMBOL	
++0x81203084	pinctrl_select_state	vmlinux	EXPORT_SYMBOL_GPL	
++0x68135148	iov_iter_zero	vmlinux	EXPORT_SYMBOL	
++0xc31924b3	crypto_register_aeads	vmlinux	EXPORT_SYMBOL_GPL	
++0x538e790e	fscache_withdraw_cache	vmlinux	EXPORT_SYMBOL	
++0x999a073f	dquot_mark_dquot_dirty	vmlinux	EXPORT_SYMBOL	
++0x3958de9b	vm_numa_stat	vmlinux	EXPORT_SYMBOL	
++0xe85a9fd3	cpu_cluster_pm_exit	vmlinux	EXPORT_SYMBOL_GPL	
++0x1e1e140e	ns_to_timespec64	vmlinux	EXPORT_SYMBOL	
++0x726bc3c7	wait_for_completion_killable_timeout	vmlinux	EXPORT_SYMBOL	
++0x31b9195c	__local_bh_disable_ip	vmlinux	EXPORT_SYMBOL	
++0x10ecc52c	usb_amd_quirk_pll_enable	vmlinux	EXPORT_SYMBOL_GPL	
++0x1f49d52e	of_clk_add_hw_provider	vmlinux	EXPORT_SYMBOL_GPL	
++0xabd8c41e	generic_file_read_iter	vmlinux	EXPORT_SYMBOL	
++0x0768af4a	get_device_system_crosststamp	vmlinux	EXPORT_SYMBOL_GPL	
++0x9a38da7d	xdr_stream_pos	vmlinux	EXPORT_SYMBOL_GPL	
++0xf9cea8a9	dev_get_phys_port_id	vmlinux	EXPORT_SYMBOL	
++0x9cd515a7	i2c_of_match_device	vmlinux	EXPORT_SYMBOL_GPL	
++0x332c80d0	spi_res_release	vmlinux	EXPORT_SYMBOL_GPL	
++0x7655b1c3	xa_store	vmlinux	EXPORT_SYMBOL	
++0x0d61eeee	__bitmap_subset	vmlinux	EXPORT_SYMBOL	
++0x697c5d0d	tracing_snapshot_alloc	vmlinux	EXPORT_SYMBOL_GPL	
++0xe3e29cd6	eth_type_trans	vmlinux	EXPORT_SYMBOL	
++0xd0c07598	of_get_address	vmlinux	EXPORT_SYMBOL	
++0x2e374837	fwnode_get_phy_mode	vmlinux	EXPORT_SYMBOL_GPL	
++0xf3fe1886	gpiochip_free_own_desc	vmlinux	EXPORT_SYMBOL_GPL	
++0x5a74ce50	gen_pool_dma_zalloc_algo	vmlinux	EXPORT_SYMBOL	
++0x6212d098	debugfs_create_blob	vmlinux	EXPORT_SYMBOL_GPL	
++0x2588ab35	posix_acl_access_xattr_handler	vmlinux	EXPORT_SYMBOL_GPL	
++0xac8597d5	mb_cache_entry_get	vmlinux	EXPORT_SYMBOL	
++0xfa7dcfb0	vfs_iocb_iter_write	vmlinux	EXPORT_SYMBOL	
++0x597af8e8	send_sig	vmlinux	EXPORT_SYMBOL	
++0x154d5383	tcp_shutdown	vmlinux	EXPORT_SYMBOL	
++0xf9e703c9	usb_stor_set_xfer_buf	vmlinux	EXPORT_SYMBOL_GPL	USB_STORAGE
++0x63b61640	usbnet_change_mtu	vmlinux	EXPORT_SYMBOL_GPL	
++0xf4689d50	linkmode_set_pause	vmlinux	EXPORT_SYMBOL_GPL	
++0x668ee448	blk_mq_alloc_request	vmlinux	EXPORT_SYMBOL	
++0xcfc7d5c8	rt_read_lock	vmlinux	EXPORT_SYMBOL	
++0x295f1aa6	down_write_trylock	vmlinux	EXPORT_SYMBOL	
++0xbe549fbd	param_set_uint	vmlinux	EXPORT_SYMBOL	
++0xdc0dc2b5	rpc_init_wait_queue	vmlinux	EXPORT_SYMBOL_GPL	
++0xf389fe60	__hw_addr_init	vmlinux	EXPORT_SYMBOL	
++0x199ed0cd	net_disable_timestamp	vmlinux	EXPORT_SYMBOL	
++0x72a2d8dc	sock_cmsg_send	vmlinux	EXPORT_SYMBOL	
++0x866f9f4f	sdio_set_host_pm_flags	vmlinux	EXPORT_SYMBOL_GPL	
++0xefbe6d91	usb_stor_ctrl_transfer	vmlinux	EXPORT_SYMBOL_GPL	USB_STORAGE
++0x2733a698	pwmchip_add	vmlinux	EXPORT_SYMBOL_GPL	
++0x65af15cc	blk_queue_max_discard_segments	vmlinux	EXPORT_SYMBOL_GPL	
++0x6045fc15	pkcs7_parse_message	vmlinux	EXPORT_SYMBOL_GPL	
++0x6532b56a	ip_fib_metrics_init	vmlinux	EXPORT_SYMBOL_GPL	
++0xf40661ab	flow_block_cb_decref	vmlinux	EXPORT_SYMBOL	
++0xf8229b89	of_prop_next_string	vmlinux	EXPORT_SYMBOL_GPL	
++0x8a67f8e6	cpufreq_enable_fast_switch	vmlinux	EXPORT_SYMBOL_GPL	
++0xad17e770	spi_register_controller	vmlinux	EXPORT_SYMBOL_GPL	
++0x5f04e559	scsi_partsize	vmlinux	EXPORT_SYMBOL	
++0xced6a67e	pcie_capability_write_word	vmlinux	EXPORT_SYMBOL	
++0x61a8b7d2	copy_page_to_iter	vmlinux	EXPORT_SYMBOL	
++0xf4b8ace3	dquot_set_dqinfo	vmlinux	EXPORT_SYMBOL	
++0xa55d0721	css_next_descendant_pre	vmlinux	EXPORT_SYMBOL_GPL	
++0xe7698027	ioremap_cache	vmlinux	EXPORT_SYMBOL	
++0xdf61c134	qdisc_hash_del	vmlinux	EXPORT_SYMBOL	
++0x4175200c	of_find_device_by_node	vmlinux	EXPORT_SYMBOL	
++0xc33dce8d	iscsi_conn_error_event	vmlinux	EXPORT_SYMBOL_GPL	
++0x1bda03b5	__blkdev_issue_zeroout	vmlinux	EXPORT_SYMBOL	
++0x78e1e51c	kblockd_mod_delayed_work_on	vmlinux	EXPORT_SYMBOL	
++0x6cb0ce87	irq_get_percpu_devid_partition	vmlinux	EXPORT_SYMBOL_GPL	
++0x3e2b0ba6	groups_alloc	vmlinux	EXPORT_SYMBOL	
++0x655bb80d	svc_rqst_free	vmlinux	EXPORT_SYMBOL_GPL	
++0x352b7300	get_srcport	vmlinux	EXPORT_SYMBOL	
++0xdf54a8f7	netlink_unregister_notifier	vmlinux	EXPORT_SYMBOL	
++0xa6651f0c	lwtunnel_build_state	vmlinux	EXPORT_SYMBOL_GPL	
++0x90854665	devm_rtc_allocate_device	vmlinux	EXPORT_SYMBOL_GPL	
++0xac657eab	simple_release_fs	vmlinux	EXPORT_SYMBOL	
++0x6626afca	down	vmlinux	EXPORT_SYMBOL	
++0x065aafce	__spi_alloc_controller	vmlinux	EXPORT_SYMBOL_GPL	
++0x4727016f	sync_file_create	vmlinux	EXPORT_SYMBOL	
++0xbc0f0675	clk_divider_ro_ops	vmlinux	EXPORT_SYMBOL_GPL	
++0xa755ab99	irq_chip_set_affinity_parent	vmlinux	EXPORT_SYMBOL_GPL	
++0x467d82a0	tcp_rtx_synack	vmlinux	EXPORT_SYMBOL	
++0xfcb7f977	skb_put	vmlinux	EXPORT_SYMBOL	
++0x327c3232	vchiq_msg_hold	vmlinux	EXPORT_SYMBOL	
++0x6564ea50	scsi_host_put	vmlinux	EXPORT_SYMBOL	
++0x3a4771ec	vga_default_device	vmlinux	EXPORT_SYMBOL_GPL	
++0x7df3d76c	pcim_set_mwi	vmlinux	EXPORT_SYMBOL	
++0x873c78ce	fwnode_gpiod_get_index	vmlinux	EXPORT_SYMBOL_GPL	
++0x875d0786	alarm_restart	vmlinux	EXPORT_SYMBOL_GPL	
++0x94bc7226	ethtool_op_get_ts_info	vmlinux	EXPORT_SYMBOL	
++0x31fcfef0	sk_capable	vmlinux	EXPORT_SYMBOL	
++0x8c6163b8	get_governor_parent_kobj	vmlinux	EXPORT_SYMBOL_GPL	
++0xf3fbee70	pinctrl_put	vmlinux	EXPORT_SYMBOL_GPL	
++0x4aaf4d1c	pinctrl_get	vmlinux	EXPORT_SYMBOL_GPL	
++0xa6f0347e	configfs_depend_item	vmlinux	EXPORT_SYMBOL	
++0x5d1f5b64	generic_block_fiemap	vmlinux	EXPORT_SYMBOL	
++0x38cb73a8	add_wait_queue	vmlinux	EXPORT_SYMBOL	
++0xc4fb316b	param_ops_invbool	vmlinux	EXPORT_SYMBOL	
++0x67e3a7ff	dev_add_pack	vmlinux	EXPORT_SYMBOL	
++0xb926f819	usb_hub_clear_tt_buffer	vmlinux	EXPORT_SYMBOL_GPL	
++0xb225b393	regulator_list_voltage_linear_range	vmlinux	EXPORT_SYMBOL_GPL	
++0xc6242699	gpiod_get	vmlinux	EXPORT_SYMBOL_GPL	
++0x4841bdee	strnchr	vmlinux	EXPORT_SYMBOL	
++0x9f984513	strrchr	vmlinux	EXPORT_SYMBOL	
++0x7cfe368d	net_dim_get_def_tx_moderation	vmlinux	EXPORT_SYMBOL	
++0xd20bf6ba	dcookie_unregister	vmlinux	EXPORT_SYMBOL_GPL	
++0x3a55981a	static_key_enable_cpuslocked	vmlinux	EXPORT_SYMBOL_GPL	
++0x9ea53d7f	vsnprintf	vmlinux	EXPORT_SYMBOL	
++0x7fe32873	rb_replace_node	vmlinux	EXPORT_SYMBOL	
++0x5bd0748f	crypto_del_default_rng	vmlinux	EXPORT_SYMBOL_GPL	
++0x668402aa	crypto_put_default_rng	vmlinux	EXPORT_SYMBOL_GPL	
++0x6ff607b6	crypto_get_default_rng	vmlinux	EXPORT_SYMBOL_GPL	
++0x32bce1b8	crypto_mod_put	vmlinux	EXPORT_SYMBOL_GPL	
++0x0f01076e	__tracepoint_pnfs_mds_fallback_pg_get_mirror_count	vmlinux	EXPORT_SYMBOL_GPL	
++0x974a1614	__tracepoint_pnfs_mds_fallback_pg_init_write	vmlinux	EXPORT_SYMBOL_GPL	
++0xfcc53e3a	__fscache_uncache_page	vmlinux	EXPORT_SYMBOL	
++0xae0d5c8f	filemap_map_pages	vmlinux	EXPORT_SYMBOL	
++0x856e816e	cancel_work_sync	vmlinux	EXPORT_SYMBOL_GPL	
++0x5c5ab37d	pingv6_ops	vmlinux	EXPORT_SYMBOL_GPL	
++0xbcd60789	nf_log_set	vmlinux	EXPORT_SYMBOL	
++0xfe7dd188	input_set_keycode	vmlinux	EXPORT_SYMBOL	
++0x8f510b4b	subsys_virtual_register	vmlinux	EXPORT_SYMBOL_GPL	
++0x32ce3777	radix_tree_preload	vmlinux	EXPORT_SYMBOL	
++0xc5104631	kobject_get_unless_zero	vmlinux	EXPORT_SYMBOL	
++0x88d4d31d	blkdev_ioctl	vmlinux	EXPORT_SYMBOL_GPL	
++0x0f8c9d6d	__quota_error	vmlinux	EXPORT_SYMBOL	
++0x38a9d247	vfs_dup_fs_context	vmlinux	EXPORT_SYMBOL	
++0x2f3abbd8	dev_set_alias	vmlinux	EXPORT_SYMBOL	
++0x096b8f8c	__i2c_board_lock	vmlinux	EXPORT_SYMBOL_GPL	
++0x93c7edeb	usb_find_common_endpoints	vmlinux	EXPORT_SYMBOL_GPL	
++0xbbf4dfbe	phy_basic_t1_features	vmlinux	EXPORT_SYMBOL_GPL	
++0xbbebc9c9	set_selection_kernel	vmlinux	EXPORT_SYMBOL_GPL	
++0x6a873229	tty_ldisc_flush	vmlinux	EXPORT_SYMBOL_GPL	
++0xdc6e62a7	regulator_set_voltage_sel_pickable_regmap	vmlinux	EXPORT_SYMBOL_GPL	
++0xb86f9ee2	idr_alloc_cyclic	vmlinux	EXPORT_SYMBOL	
++0x537a92d5	__blkg_prfill_rwstat	vmlinux	EXPORT_SYMBOL_GPL	
++0x653cf6d4	crypto_register_instance	vmlinux	EXPORT_SYMBOL_GPL	
++0x10962bc2	nfs_auth_info_match	vmlinux	EXPORT_SYMBOL_GPL	
++0x9f35acce	dma_need_sync	vmlinux	EXPORT_SYMBOL_GPL	
++0xbba11adc	rpc_machine_cred	vmlinux	EXPORT_SYMBOL_GPL	
++0x21974b7e	skb_tstamp_tx	vmlinux	EXPORT_SYMBOL_GPL	
++0x93022ba6	__scsi_format_command	vmlinux	EXPORT_SYMBOL	
++0xdee6e54f	tty_set_operations	vmlinux	EXPORT_SYMBOL	
++0xba624d10	regulator_register_supply_alias	vmlinux	EXPORT_SYMBOL_GPL	
++0xf812cff6	memscan	vmlinux	EXPORT_SYMBOL	
++0xab67a0ac	dql_init	vmlinux	EXPORT_SYMBOL	
++0x09191960	fscache_object_destroy	vmlinux	EXPORT_SYMBOL	
++0x7b3678ce	mark_buffer_dirty	vmlinux	EXPORT_SYMBOL	
++0x21b6d3fc	get_super	vmlinux	EXPORT_SYMBOL	
++0xc7cd4ea4	stop_critical_timings	vmlinux	EXPORT_SYMBOL_GPL	
++0x9c1e5bf5	queued_spin_lock_slowpath	vmlinux	EXPORT_SYMBOL	
++0x2de54340	write_bytes_to_xdr_buf	vmlinux	EXPORT_SYMBOL_GPL	
++0x8b25445d	skb_copy_and_csum_bits	vmlinux	EXPORT_SYMBOL	
++0x0146c9ec	devm_hwmon_device_register_with_groups	vmlinux	EXPORT_SYMBOL_GPL	
++0x55784228	regmap_irq_get_virq	vmlinux	EXPORT_SYMBOL_GPL	
++0xb29b726c	clk_mux_ro_ops	vmlinux	EXPORT_SYMBOL_GPL	
++0x55b6c018	ll_rw_block	vmlinux	EXPORT_SYMBOL	
++0x69e2c90d	block_write_begin	vmlinux	EXPORT_SYMBOL	
++0xa19db8ce	irq_domain_associate_many	vmlinux	EXPORT_SYMBOL_GPL	
++0xbc6bec66	free_percpu_irq	vmlinux	EXPORT_SYMBOL_GPL	
++0x5d49bab6	fb_deferred_io_fsync	vmlinux	EXPORT_SYMBOL_GPL	
++0x4710bbc3	pci_alloc_irq_vectors_affinity	vmlinux	EXPORT_SYMBOL	
++0xa8593297	blk_mq_sched_mark_restart_hctx	vmlinux	EXPORT_SYMBOL_GPL	
++0x3a391b35	blk_mq_start_hw_queues	vmlinux	EXPORT_SYMBOL	
++0xe1761617	security_inet_conn_request	vmlinux	EXPORT_SYMBOL	
++0x11f9c79e	sysfs_remove_groups	vmlinux	EXPORT_SYMBOL_GPL	
++0xb719a183	DWC_SPRINTF	vmlinux	EXPORT_SYMBOL	
++0xbb1fa3e4	DWC_VPRINTF	vmlinux	EXPORT_SYMBOL	
++0xdc3a79b8	of_usb_update_otg_caps	vmlinux	EXPORT_SYMBOL_GPL	
++0xc3c3dded	dev_pm_domain_attach_by_id	vmlinux	EXPORT_SYMBOL_GPL	
++0xd684dc5c	component_match_add_release	vmlinux	EXPORT_SYMBOL	
++0x482c9be5	regulator_list_voltage_pickable_linear_range	vmlinux	EXPORT_SYMBOL_GPL	
++0x778c8df7	gpiod_set_array_value_cansleep	vmlinux	EXPORT_SYMBOL_GPL	
++0x7429e20c	kstrtos8	vmlinux	EXPORT_SYMBOL	
++0xfdbd7a17	crypto_get_attr_type	vmlinux	EXPORT_SYMBOL_GPL	
++0x0e6aec74	pnfs_generic_recover_commit_reqs	vmlinux	EXPORT_SYMBOL_GPL	
++0xb746d8bc	bdi_alloc	vmlinux	EXPORT_SYMBOL	
++0x460c2b4c	svc_proc_unregister	vmlinux	EXPORT_SYMBOL_GPL	
++0x21224d83	svc_rpcbind_set_version	vmlinux	EXPORT_SYMBOL_GPL	
++0x6735d56e	tcp_ca_get_name_by_key	vmlinux	EXPORT_SYMBOL_GPL	
++0xc0ff21c1	input_get_new_minor	vmlinux	EXPORT_SYMBOL	
++0xae84f6c1	phy_modify	vmlinux	EXPORT_SYMBOL_GPL	
++0x26c90ea4	scsi_eh_get_sense	vmlinux	EXPORT_SYMBOL_GPL	
++0xac7c7c71	device_create_bin_file	vmlinux	EXPORT_SYMBOL_GPL	
++0xae7ad568	pci_intx	vmlinux	EXPORT_SYMBOL_GPL	
++0x88abb78b	ZSTD_insertBlock	vmlinux	EXPORT_SYMBOL	
++0xdd19b44d	crypto_alloc_aead	vmlinux	EXPORT_SYMBOL_GPL	
++0x9b3a32f8	crypto_spawn_tfm2	vmlinux	EXPORT_SYMBOL_GPL	
++0x496dea97	pnfs_generic_pg_init_write	vmlinux	EXPORT_SYMBOL_GPL	
++0x9796d8ba	pnfs_error_mark_layout_for_return	vmlinux	EXPORT_SYMBOL_GPL	
++0x50fad434	round_jiffies_up	vmlinux	EXPORT_SYMBOL_GPL	
++0x93812d3f	register_nexthop_notifier	vmlinux	EXPORT_SYMBOL	
++0x841cdeab	dev_get_mac_address	vmlinux	EXPORT_SYMBOL	
++0x6ee75669	dev_set_mac_address	vmlinux	EXPORT_SYMBOL	
++0xeade3ede	sk_mc_loop	vmlinux	EXPORT_SYMBOL	
++0xc628ae5a	of_remove_property	vmlinux	EXPORT_SYMBOL_GPL	
++0x22b325d5	kd_mksound	vmlinux	EXPORT_SYMBOL	
++0x7c3d59e2	xas_store	vmlinux	EXPORT_SYMBOL_GPL	
++0x570f1ed8	crypto_register_scomps	vmlinux	EXPORT_SYMBOL_GPL	
++0xe783e261	sysfs_emit	vmlinux	EXPORT_SYMBOL_GPL	
++0xddf32520	__tracepoint_powernv_throttle	vmlinux	EXPORT_SYMBOL_GPL	
++0xe1dcf64a	audit_log_format	vmlinux	EXPORT_SYMBOL	
++0x6d2fc5a6	net_namespace_list	vmlinux	EXPORT_SYMBOL_GPL	
++0xe3b6383f	sock_register	vmlinux	EXPORT_SYMBOL	
++0x80024768	loop_register_transfer	vmlinux	EXPORT_SYMBOL	
++0x02b6a809	regulator_get_bypass_regmap	vmlinux	EXPORT_SYMBOL_GPL	
++0xe67f3722	vchan_init	vmlinux	EXPORT_SYMBOL_GPL	
++0x1bca9090	pci_find_bus	vmlinux	EXPORT_SYMBOL	
++0x89203e86	pinctrl_unregister	vmlinux	EXPORT_SYMBOL_GPL	
++0x2e900aed	_proc_mkdir	vmlinux	EXPORT_SYMBOL_GPL	
++0x82860370	register_ftrace_function	vmlinux	EXPORT_SYMBOL_GPL	
++0x2de33345	cgrp_dfl_root	vmlinux	EXPORT_SYMBOL_GPL	
++0x59cc0494	dev_set_group	vmlinux	EXPORT_SYMBOL	
++0xef2dd8d8	netif_set_real_num_rx_queues	vmlinux	EXPORT_SYMBOL	
++0xa011ce02	netif_set_real_num_tx_queues	vmlinux	EXPORT_SYMBOL	
++0x28cbac75	phy_init_hw	vmlinux	EXPORT_SYMBOL	
++0x89de42c1	phy_register_fixup_for_uid	vmlinux	EXPORT_SYMBOL	
++0x204c5067	scsi_dev_info_add_list	vmlinux	EXPORT_SYMBOL	
++0xc9b525a1	pci_find_resource	vmlinux	EXPORT_SYMBOL	
++0xdb007c5b	pci_user_read_config_word	vmlinux	EXPORT_SYMBOL_GPL	
++0xb5963e47	badblocks_check	vmlinux	EXPORT_SYMBOL_GPL	
++0xe85b7b82	nfs_flock	vmlinux	EXPORT_SYMBOL_GPL	
++0x75e5b037	proc_remove	vmlinux	EXPORT_SYMBOL	
++0x0ba58e1b	end_buffer_async_write	vmlinux	EXPORT_SYMBOL	
++0x8a5005dd	perf_event_period	vmlinux	EXPORT_SYMBOL_GPL	
++0x4c342700	sdio_get_host_pm_caps	vmlinux	EXPORT_SYMBOL_GPL	
++0x9258c776	hdmi_vendor_infoframe_pack_only	vmlinux	EXPORT_SYMBOL	
++0x50097088	security_tun_dev_free_security	vmlinux	EXPORT_SYMBOL	
++0x1df05b61	add_swap_extent	vmlinux	EXPORT_SYMBOL_GPL	
++0x87ece904	svc_rpcb_cleanup	vmlinux	EXPORT_SYMBOL_GPL	
++0x8a47043d	LZ4_decompress_safe_continue	vmlinux	EXPORT_SYMBOL	
++0x5e85415b	ring_buffer_consume	vmlinux	EXPORT_SYMBOL_GPL	
++0x1c5b1f28	irq_free_descs	vmlinux	EXPORT_SYMBOL_GPL	
++0x4e5af955	proc_dointvec	vmlinux	EXPORT_SYMBOL	
++0xc56a41e6	vabits_actual	vmlinux	EXPORT_SYMBOL	
++0x5d605237	__inet_lookup_established	vmlinux	EXPORT_SYMBOL_GPL	
++0x5bd6c761	netdev_alert	vmlinux	EXPORT_SYMBOL	
++0xf7b7e8b4	netdev_has_any_upper_dev	vmlinux	EXPORT_SYMBOL	
++0x0321cdbf	of_alias_get_highest_id	vmlinux	EXPORT_SYMBOL_GPL	
++0x7fe31378	__reset_control_get	vmlinux	EXPORT_SYMBOL_GPL	
++0x1aeba3aa	phy_validate	vmlinux	EXPORT_SYMBOL_GPL	
++0x9430b198	trace_dump_stack	vmlinux	EXPORT_SYMBOL_GPL	
++0x4248ae3c	single_task_running	vmlinux	EXPORT_SYMBOL	
++0x0f4fe01b	svc_rpcb_setup	vmlinux	EXPORT_SYMBOL_GPL	
++0x8802e9ef	udp_lib_rehash	vmlinux	EXPORT_SYMBOL	
++0x7a5907f3	udp_lib_unhash	vmlinux	EXPORT_SYMBOL	
++0x05495392	hid_debug	vmlinux	EXPORT_SYMBOL_GPL	
++0xe9162c16	dev_coredumpm	vmlinux	EXPORT_SYMBOL_GPL	
++0x03e6a975	dev_coredumpv	vmlinux	EXPORT_SYMBOL_GPL	
++0xa06137d0	device_show_ulong	vmlinux	EXPORT_SYMBOL_GPL	
++0x3a45ecb8	of_pci_find_child_device	vmlinux	EXPORT_SYMBOL_GPL	
++0xa3a3f229	cpumask_next_and	vmlinux	EXPORT_SYMBOL	
++0xe39b2ea5	sha256	vmlinux	EXPORT_SYMBOL	
++0x00ebbab5	tcp_ca_get_key_by_name	vmlinux	EXPORT_SYMBOL_GPL	
++0x14c67e3e	tcp_tx_delay_enabled	vmlinux	EXPORT_SYMBOL	
++0x14e624ff	nf_hook_slow	vmlinux	EXPORT_SYMBOL	
++0xbb05a3ac	task_cls_state	vmlinux	EXPORT_SYMBOL_GPL	
++0xdf8143bf	dev_pick_tx_cpu_id	vmlinux	EXPORT_SYMBOL	
++0xbc071179	iscsi_get_ipaddress_state_name	vmlinux	EXPORT_SYMBOL_GPL	
++0xce5ac24f	zlib_inflate_workspacesize	vmlinux	EXPORT_SYMBOL	
++0x815fc96f	of_gen_pool_get	vmlinux	EXPORT_SYMBOL_GPL	
++0xc60d0620	__num_online_cpus	vmlinux	EXPORT_SYMBOL	
++0xe70aa57b	svc_age_temp_xprts_now	vmlinux	EXPORT_SYMBOL_GPL	
++0x3d3054b0	tcp_recvmsg	vmlinux	EXPORT_SYMBOL	
++0x11abc494	__SCK__tp_func_nvme_sq	vmlinux	EXPORT_SYMBOL_GPL	
++0x62e2dbcf	vga_client_register	vmlinux	EXPORT_SYMBOL	
++0xca1985cd	bcm_dma_wait_idle	vmlinux	EXPORT_SYMBOL_GPL	
++0x231ad72d	bioset_init	vmlinux	EXPORT_SYMBOL	
++0x46919175	bioset_exit	vmlinux	EXPORT_SYMBOL	
++0x47319974	pnfs_put_lseg	vmlinux	EXPORT_SYMBOL_GPL	
++0x025b4493	nfs_sb_deactive	vmlinux	EXPORT_SYMBOL_GPL	
++0x20e10c02	irq_alloc_generic_chip	vmlinux	EXPORT_SYMBOL_GPL	
++0xd8248571	xfrm_audit_state_notfound_simple	vmlinux	EXPORT_SYMBOL_GPL	
++0x713b561f	udp_destruct_sock	vmlinux	EXPORT_SYMBOL_GPL	
++0x1f0d8b0f	inet_hashinfo2_init_mod	vmlinux	EXPORT_SYMBOL_GPL	
++0x7e36fa26	bpf_verifier_log_write	vmlinux	EXPORT_SYMBOL_GPL	
++0xa84f8025	console_start	vmlinux	EXPORT_SYMBOL	
++0x5b21ee77	proc_dointvec_userhz_jiffies	vmlinux	EXPORT_SYMBOL	
++0x8fd180e7	kernel_neon_begin	vmlinux	EXPORT_SYMBOL	
++0x2a03770c	tcp_simple_retransmit	vmlinux	EXPORT_SYMBOL	
++0xe21e7cc0	of_find_node_with_property	vmlinux	EXPORT_SYMBOL	
++0x018e40d4	pci_check_and_mask_intx	vmlinux	EXPORT_SYMBOL_GPL	
++0x18345b8e	__bitmap_replace	vmlinux	EXPORT_SYMBOL	
++0x03ff80e2	proc_set_user	vmlinux	EXPORT_SYMBOL	
++0xa6e00825	anon_inode_getfile	vmlinux	EXPORT_SYMBOL_GPL	
++0xba09133f	simple_dir_inode_operations	vmlinux	EXPORT_SYMBOL	
++0x389b64a2	static_key_count	vmlinux	EXPORT_SYMBOL_GPL	
++0xcd9ff78d	trace_output_call	vmlinux	EXPORT_SYMBOL_GPL	
++0x31ab2220	irq_domain_xlate_onetwocell	vmlinux	EXPORT_SYMBOL_GPL	
++0x385ad9d9	__traceiter_sched_overutilized_tp	vmlinux	EXPORT_SYMBOL_GPL	
++0x8540c62d	cred_fscmp	vmlinux	EXPORT_SYMBOL	
++0xc2b06577	napi_consume_skb	vmlinux	EXPORT_SYMBOL	
++0x99687295	pci_host_probe	vmlinux	EXPORT_SYMBOL_GPL	
++0x3f536f47	vfs_get_tree	vmlinux	EXPORT_SYMBOL	
++0x604e43b4	dmam_pool_create	vmlinux	EXPORT_SYMBOL	
++0xd08adb2b	trace_seq_hex_dump	vmlinux	EXPORT_SYMBOL	
++0x2c4fc630	register_kretprobe	vmlinux	EXPORT_SYMBOL_GPL	
++0x300bba04	input_mt_get_slot_by_key	vmlinux	EXPORT_SYMBOL	
++0x949019af	input_mt_drop_unused	vmlinux	EXPORT_SYMBOL	
++0x9eb52803	usb_ep_disable	vmlinux	EXPORT_SYMBOL_GPL	
++0x2800e1b5	genphy_suspend	vmlinux	EXPORT_SYMBOL	
++0x7c42bfc6	__platform_create_bundle	vmlinux	EXPORT_SYMBOL_GPL	
++0x89ebb6b2	subsys_system_register	vmlinux	EXPORT_SYMBOL_GPL	
++0x947d306b	bcm2711_dma40_memcpy_init	vmlinux	EXPORT_SYMBOL	
++0x34087963	__find_get_block	vmlinux	EXPORT_SYMBOL	
++0xd440035c	dcache_dir_open	vmlinux	EXPORT_SYMBOL	
++0x3f4547a7	put_unused_fd	vmlinux	EXPORT_SYMBOL	
++0xb1ddf995	jiffies_64_to_clock_t	vmlinux	EXPORT_SYMBOL	
++0x23790929	irq_domain_create_hierarchy	vmlinux	EXPORT_SYMBOL_GPL	
++0xd5300ef9	inet6_lookup_listener	vmlinux	EXPORT_SYMBOL_GPL	
++0x1e5d7bd5	tcp_seq_stop	vmlinux	EXPORT_SYMBOL	
++0x104a8020	dev_pm_opp_of_get_opp_desc_node	vmlinux	EXPORT_SYMBOL_GPL	
++0x9576519f	usbnet_read_cmd	vmlinux	EXPORT_SYMBOL_GPL	
++0x1e8794a5	dev_pm_qos_expose_latency_limit	vmlinux	EXPORT_SYMBOL_GPL	
++0xbae7a7f3	of_dma_simple_xlate	vmlinux	EXPORT_SYMBOL_GPL	
++0x67535f9f	gpiochip_generic_free	vmlinux	EXPORT_SYMBOL_GPL	
++0xece784c2	rb_first	vmlinux	EXPORT_SYMBOL	
++0xc3a2be67	nfs_net_id	vmlinux	EXPORT_SYMBOL_GPL	
++0x6a3acb1c	__traceiter_mmap_lock_acquire_returned	vmlinux	EXPORT_SYMBOL	
++0xa20d01ba	__trace_bprintk	vmlinux	EXPORT_SYMBOL_GPL	
++0x6a5ecb18	unregister_module_notifier	vmlinux	EXPORT_SYMBOL	
++0x3c1c3725	rcu_fwd_progress_check	vmlinux	EXPORT_SYMBOL_GPL	
++0x3dc619d3	swake_up_locked	vmlinux	EXPORT_SYMBOL	
++0xf8f61ebc	wake_up_var	vmlinux	EXPORT_SYMBOL	
++0x2ceaa0c7	flush_delayed_work	vmlinux	EXPORT_SYMBOL	
++0x71c896c9	ethnl_cable_test_alloc	vmlinux	EXPORT_SYMBOL_GPL	
++0x20379438	skb_zerocopy_headlen	vmlinux	EXPORT_SYMBOL_GPL	
++0xe61840d4	mmc_switch	vmlinux	EXPORT_SYMBOL_GPL	
++0x8dc224aa	DWC_STRNCMP	vmlinux	EXPORT_SYMBOL	
++0xce98798c	fwnode_property_present	vmlinux	EXPORT_SYMBOL_GPL	
++0x9537b581	devm_release_action	vmlinux	EXPORT_SYMBOL_GPL	
++0x51b1d94e	rcuwait_wake_up	vmlinux	EXPORT_SYMBOL_GPL	
++0xb74185e2	unix_peer_get	vmlinux	EXPORT_SYMBOL_GPL	
++0x0a1dbc76	tcp_rx_skb_cache_key	vmlinux	EXPORT_SYMBOL	
++0xfb5952cc	devm_extcon_unregister_notifier_all	vmlinux	EXPORT_SYMBOL	
++0xeedd987e	phy_10gbit_features_array	vmlinux	EXPORT_SYMBOL_GPL	
++0xd1d744e0	device_property_read_string	vmlinux	EXPORT_SYMBOL_GPL	
++0x6b85635f	bus_register	vmlinux	EXPORT_SYMBOL_GPL	
++0x082c3213	pci_root_buses	vmlinux	EXPORT_SYMBOL	
++0xd7bca3d7	blk_freeze_queue_start	vmlinux	EXPORT_SYMBOL_GPL	
++0xacf649bf	audit_log_task_info	vmlinux	EXPORT_SYMBOL	
++0xb9f97e9c	tcp_syn_ack_timeout	vmlinux	EXPORT_SYMBOL	
++0x5b2a7121	nf_log_unregister	vmlinux	EXPORT_SYMBOL	
++0xe098df1d	mmc_alloc_host	vmlinux	EXPORT_SYMBOL	
++0x81ac916b	scsi_eh_ready_devs	vmlinux	EXPORT_SYMBOL_GPL	
++0x88159894	dev_pm_genpd_add_notifier	vmlinux	EXPORT_SYMBOL_GPL	
++0xca83f0a9	of_clk_get_by_name	vmlinux	EXPORT_SYMBOL	
++0x42f1b900	fb_pad_unaligned_buffer	vmlinux	EXPORT_SYMBOL	
++0x40072af4	gpiochip_irqchip_add_key	vmlinux	EXPORT_SYMBOL_GPL	
++0x6236a7c7	__traceiter_block_bio_remap	vmlinux	EXPORT_SYMBOL_GPL	
++0xb7f8a6c5	d_hash_and_lookup	vmlinux	EXPORT_SYMBOL	
++0x5f7cce4f	of_property_read_string	vmlinux	EXPORT_SYMBOL_GPL	
++0x4b432a9c	timer_unstable_counter_workaround	vmlinux	EXPORT_SYMBOL_GPL	
++0x840debc0	dmi_kobj	vmlinux	EXPORT_SYMBOL_GPL	
++0x6121bad4	thermal_cooling_device_register	vmlinux	EXPORT_SYMBOL_GPL	
++0xaa72548b	input_open_device	vmlinux	EXPORT_SYMBOL	
++0xc2727abe	regulator_set_bypass_regmap	vmlinux	EXPORT_SYMBOL_GPL	
++0xfe990052	gpio_free	vmlinux	EXPORT_SYMBOL_GPL	
++0xeecc3b0a	nla_policy_len	vmlinux	EXPORT_SYMBOL	
++0xebe24094	_copy_from_iter_nocache	vmlinux	EXPORT_SYMBOL	
++0xd548d253	fsync_bdev	vmlinux	EXPORT_SYMBOL	
++0x65b10335	simple_get_link	vmlinux	EXPORT_SYMBOL	
++0x92ec510d	jiffies64_to_msecs	vmlinux	EXPORT_SYMBOL	
++0xee8d74d6	jiffies64_to_nsecs	vmlinux	EXPORT_SYMBOL	
++0xd27cef08	efivar_entry_set_get_size	vmlinux	EXPORT_SYMBOL_GPL	
++0xc83f1e26	device_for_each_child	vmlinux	EXPORT_SYMBOL_GPL	
++0xe4d9e96e	nfs_reconfigure	vmlinux	EXPORT_SYMBOL_GPL	
++0x40a9b349	vzalloc	vmlinux	EXPORT_SYMBOL	
++0x5fdfcd57	__tracepoint_pelt_thermal_tp	vmlinux	EXPORT_SYMBOL_GPL	
++0x973758fb	mmc_cmdq_enable	vmlinux	EXPORT_SYMBOL_GPL	
++0x748cf17c	pci_probe_reset_slot	vmlinux	EXPORT_SYMBOL_GPL	
++0x49bbb38c	unregister_key_type	vmlinux	EXPORT_SYMBOL	
++0x3df7eefb	nfs_commit_inode	vmlinux	EXPORT_SYMBOL_GPL	
++0x4a4a37ec	__tracepoint_fs_file_read	vmlinux	EXPORT_SYMBOL_GPL	
++0xb57343c2	frontswap_shrink	vmlinux	EXPORT_SYMBOL	
++0x3642c368	rpc_shutdown_client	vmlinux	EXPORT_SYMBOL_GPL	
++0x14f0072d	skb_mpls_pop	vmlinux	EXPORT_SYMBOL_GPL	
++0x2cd73101	dev_pm_opp_remove_table	vmlinux	EXPORT_SYMBOL_GPL	
++0x00b5150c	usb_add_gadget_udc	vmlinux	EXPORT_SYMBOL_GPL	
++0x11089ac7	_ctype	vmlinux	EXPORT_SYMBOL	
++0x8eaea82f	blk_get_queue	vmlinux	EXPORT_SYMBOL	
++0xca7d8764	kthread_freezable_should_stop	vmlinux	EXPORT_SYMBOL_GPL	
++0x941ad624	power_supply_get_by_name	vmlinux	EXPORT_SYMBOL_GPL	
++0xe1d78639	regulator_set_load	vmlinux	EXPORT_SYMBOL_GPL	
++0xed5ee6f7	pcie_capability_write_dword	vmlinux	EXPORT_SYMBOL	
++0x56f5314c	gpiod_is_active_low	vmlinux	EXPORT_SYMBOL_GPL	
++0x7846af3e	__kfifo_len_r	vmlinux	EXPORT_SYMBOL	
++0xbae1916c	__fscache_enable_cookie	vmlinux	EXPORT_SYMBOL	
++0x7366e29f	vfs_create_mount	vmlinux	EXPORT_SYMBOL	
++0xef70eb7e	ring_buffer_iter_advance	vmlinux	EXPORT_SYMBOL_GPL	
++0x6110e194	srcutorture_get_gp_data	vmlinux	EXPORT_SYMBOL_GPL	
++0x3562f983	read_sanitised_ftr_reg	vmlinux	EXPORT_SYMBOL_GPL	
++0x110bd630	svc_xprt_names	vmlinux	EXPORT_SYMBOL_GPL	
++0xa2060911	inet_current_timestamp	vmlinux	EXPORT_SYMBOL	
++0xbeeeee05	inet_sk_rebuild_header	vmlinux	EXPORT_SYMBOL	
++0x8c6bf651	flow_block_cb_is_busy	vmlinux	EXPORT_SYMBOL	
++0x18cea442	skb_copy	vmlinux	EXPORT_SYMBOL	
++0x8b39f220	input_ff_flush	vmlinux	EXPORT_SYMBOL_GPL	
++0xbea4afac	input_inject_event	vmlinux	EXPORT_SYMBOL	
++0xf30e0d31	gadget_find_ep_by_name	vmlinux	EXPORT_SYMBOL_GPL	
++0x4a07f4ae	regmap_field_free	vmlinux	EXPORT_SYMBOL_GPL	
++0x1716d719	serial8250_update_uartclk	vmlinux	EXPORT_SYMBOL_GPL	
++0x00397d6d	pci_bus_read_config_dword	vmlinux	EXPORT_SYMBOL	
++0x27864d57	memparse	vmlinux	EXPORT_SYMBOL	
++0xea20e367	sysfs_remove_mount_point	vmlinux	EXPORT_SYMBOL_GPL	
++0x62c03167	block_truncate_page	vmlinux	EXPORT_SYMBOL	
++0x30131a3c	vfs_tmpfile	vmlinux	EXPORT_SYMBOL	
++0x4d1e1c3e	generic_write_checks	vmlinux	EXPORT_SYMBOL	
++0xf1648042	kthread_park	vmlinux	EXPORT_SYMBOL_GPL	
++0xd6bd7db1	xfrm_dev_state_flush	vmlinux	EXPORT_SYMBOL	
++0x69668826	netdev_increment_features	vmlinux	EXPORT_SYMBOL	
++0x9d66e9c4	mmc_send_tuning	vmlinux	EXPORT_SYMBOL_GPL	
++0x4f2250ba	rtc_tm_to_time64	vmlinux	EXPORT_SYMBOL	
++0xe6e5eaa3	fwnode_property_read_u8_array	vmlinux	EXPORT_SYMBOL_GPL	
++0x68c9ca54	uart_match_port	vmlinux	EXPORT_SYMBOL	
++0x144e7dfb	clk_request_start	vmlinux	EXPORT_SYMBOL_GPL	
++0x8c1af218	debugfs_create_file_size	vmlinux	EXPORT_SYMBOL_GPL	
++0x25e8b05e	vfs_get_link	vmlinux	EXPORT_SYMBOL	
++0x22ff66b0	svc_shutdown_net	vmlinux	EXPORT_SYMBOL_GPL	
++0x6d09843f	copy_bpf_fprog_from_user	vmlinux	EXPORT_SYMBOL_GPL	
++0xf5c717aa	of_thermal_get_trip_points	vmlinux	EXPORT_SYMBOL_GPL	
++0x0f0103d0	regulator_get_linear_step	vmlinux	EXPORT_SYMBOL_GPL	
++0x19f14510	pci_request_selected_regions	vmlinux	EXPORT_SYMBOL	
++0x5fd4b47d	__splice_from_pipe	vmlinux	EXPORT_SYMBOL	
++0xd3bd4af4	unregister_net_sysctl_table	vmlinux	EXPORT_SYMBOL_GPL	
++0xcbc36cf8	inet_gro_complete	vmlinux	EXPORT_SYMBOL	
++0x308788bf	__skb_tstamp_tx	vmlinux	EXPORT_SYMBOL_GPL	
++0x151efae1	sdhci_set_power	vmlinux	EXPORT_SYMBOL_GPL	
++0xdcce07bb	sdio_align_size	vmlinux	EXPORT_SYMBOL_GPL	
++0x459dc445	cpufreq_register_governor	vmlinux	EXPORT_SYMBOL_GPL	
++0x11448c92	dwc_cc_restore_from_data	vmlinux	EXPORT_SYMBOL	
++0x0cb11bc7	__SCK__tp_func_dma_fence_enable_signal	vmlinux	EXPORT_SYMBOL	
++0x0b977b0f	tty_write_room	vmlinux	EXPORT_SYMBOL	
++0x5da12a18	percpu_counter_add_batch	vmlinux	EXPORT_SYMBOL	
++0x929974d7	sysfs_add_file_to_group	vmlinux	EXPORT_SYMBOL_GPL	
++0x653f433c	param_ops_ushort	vmlinux	EXPORT_SYMBOL	
++0x73242dcd	cpu_set_feature	vmlinux	EXPORT_SYMBOL_GPL	
++0xa89551e3	dev_trans_start	vmlinux	EXPORT_SYMBOL	
++0x46dda229	of_graph_get_remote_node	vmlinux	EXPORT_SYMBOL	
++0x9477efb1	usb_unlocked_disable_lpm	vmlinux	EXPORT_SYMBOL_GPL	
++0xac3f7e18	serial8250_rpm_put	vmlinux	EXPORT_SYMBOL_GPL	
++0x64a9c928	default_blu	vmlinux	EXPORT_SYMBOL	
++0x44fd601c	devm_regulator_register	vmlinux	EXPORT_SYMBOL_GPL	
++0x57575f08	dmaengine_put	vmlinux	EXPORT_SYMBOL	
++0x0998cc3c	hdmi_infoframe_unpack	vmlinux	EXPORT_SYMBOL	
++0x4ea25709	dql_reset	vmlinux	EXPORT_SYMBOL	
++0xb0487778	blk_register_region	vmlinux	EXPORT_SYMBOL	
++0xf1e9cf0f	bio_put	vmlinux	EXPORT_SYMBOL	
++0x2ca48247	devm_memunmap	vmlinux	EXPORT_SYMBOL	
++0xf965fa59	devm_memremap	vmlinux	EXPORT_SYMBOL	
++0xb583ab56	bpf_map_inc	vmlinux	EXPORT_SYMBOL_GPL	
++0xc3bc72ad	trace_print_array_seq	vmlinux	EXPORT_SYMBOL	
++0x1b597b7a	swake_up_all	vmlinux	EXPORT_SYMBOL	
++0x83ce5b94	tcf_qevent_destroy	vmlinux	EXPORT_SYMBOL	
++0x9f6ee43e	of_find_compatible_node	vmlinux	EXPORT_SYMBOL	
++0x1a58145e	sdhci_set_ios	vmlinux	EXPORT_SYMBOL_GPL	
++0x091c6198	input_alloc_absinfo	vmlinux	EXPORT_SYMBOL	
++0xa9135232	scsi_is_target_device	vmlinux	EXPORT_SYMBOL	
++0x21cd536a	crypto_put_default_null_skcipher	vmlinux	EXPORT_SYMBOL_GPL	
++0x3061c321	crypto_get_default_null_skcipher	vmlinux	EXPORT_SYMBOL_GPL	
++0xd0ecfaad	__tracepoint_pnfs_mds_fallback_pg_init_read	vmlinux	EXPORT_SYMBOL_GPL	
++0x6c7521b9	ping_bind	vmlinux	EXPORT_SYMBOL_GPL	
++0xfd64b4a6	nf_hook_entries_insert_raw	vmlinux	EXPORT_SYMBOL_GPL	
++0xc5f6347f	sk_dst_check	vmlinux	EXPORT_SYMBOL	
++0x453c8403	pci_msi_enabled	vmlinux	EXPORT_SYMBOL	
++0xd36e3d59	prandom_bytes_state	vmlinux	EXPORT_SYMBOL	
++0x29eb3b0a	nfs_init_client	vmlinux	EXPORT_SYMBOL_GPL	
++0xbf509d2a	inode_needs_sync	vmlinux	EXPORT_SYMBOL	
++0x9413e49d	__wake_up_sync_key	vmlinux	EXPORT_SYMBOL_GPL	
++0x723b3090	inet_csk_complete_hashdance	vmlinux	EXPORT_SYMBOL	
++0xebd1a322	dev_getfirstbyhwtype	vmlinux	EXPORT_SYMBOL	
++0x038a9f39	of_phy_simple_xlate	vmlinux	EXPORT_SYMBOL_GPL	
++0x291876f3	mpi_ec_get_affine	vmlinux	EXPORT_SYMBOL_GPL	
++0xc226b040	mb_cache_entry_delete_or_get	vmlinux	EXPORT_SYMBOL	
++0xc5086cf3	dma_can_mmap	vmlinux	EXPORT_SYMBOL_GPL	
++0xc4c25281	wake_up_process	vmlinux	EXPORT_SYMBOL	
++0x25820c64	fs_overflowuid	vmlinux	EXPORT_SYMBOL	
++0x0d0ea076	gro_find_complete_by_type	vmlinux	EXPORT_SYMBOL	
++0x5f79bcf6	skb_dequeue_tail	vmlinux	EXPORT_SYMBOL	
++0x133ef810	mm_unaccount_pinned_pages	vmlinux	EXPORT_SYMBOL_GPL	
++0x1d5b3ad3	hidinput_count_leds	vmlinux	EXPORT_SYMBOL_GPL	
++0xeb753436	sdhci_setup_host	vmlinux	EXPORT_SYMBOL_GPL	
++0xcc2da17a	input_ff_erase	vmlinux	EXPORT_SYMBOL_GPL	
++0x613a5f55	scsi_target_resume	vmlinux	EXPORT_SYMBOL	
++0x02644abe	pm_genpd_remove	vmlinux	EXPORT_SYMBOL_GPL	
++0xc1b8d4ec	pci_device_is_present	vmlinux	EXPORT_SYMBOL_GPL	
++0xa342d64c	radix_tree_preloads	vmlinux	EXPORT_SYMBOL_GPL	
++0x1dfa5dbd	mpi_invm	vmlinux	EXPORT_SYMBOL_GPL	
++0x0aeae7e3	mpi_key_length	vmlinux	EXPORT_SYMBOL_GPL	
++0x2d6334c8	nfs_do_submount	vmlinux	EXPORT_SYMBOL_GPL	
++0xd3543063	memcg_kmem_enabled_key	vmlinux	EXPORT_SYMBOL	
++0x60223c17	inet_stream_ops	vmlinux	EXPORT_SYMBOL	
++0x591e7bc7	qdisc_reset	vmlinux	EXPORT_SYMBOL	
++0xf423ee56	flow_rule_match_ip	vmlinux	EXPORT_SYMBOL	
++0xd2da1048	register_netdevice_notifier	vmlinux	EXPORT_SYMBOL	
++0x7312b41a	syscon_regmap_lookup_by_phandle	vmlinux	EXPORT_SYMBOL_GPL	
++0xfd6a2d27	regmap_multi_reg_write	vmlinux	EXPORT_SYMBOL_GPL	
++0xce39b041	of_dma_controller_register	vmlinux	EXPORT_SYMBOL_GPL	
++0xc9cb0297	pci_get_device	vmlinux	EXPORT_SYMBOL	
++0xa15660c0	blk_mq_delay_run_hw_queue	vmlinux	EXPORT_SYMBOL	
++0x808ec1a3	crypto_alg_tested	vmlinux	EXPORT_SYMBOL_GPL	
++0xe7f8d7a9	iomap_seek_hole	vmlinux	EXPORT_SYMBOL_GPL	
++0xe769232e	sprint_symbol_no_offset	vmlinux	EXPORT_SYMBOL_GPL	
++0x96f9a01b	__SCK__tp_func_pelt_thermal_tp	vmlinux	EXPORT_SYMBOL_GPL	
++0x57b445ab	led_init_core	vmlinux	EXPORT_SYMBOL_GPL	
++0xe28894bb	of_usb_get_dr_mode_by_phy	vmlinux	EXPORT_SYMBOL_GPL	
++0xd12e6093	idr_get_next	vmlinux	EXPORT_SYMBOL	
++0x612375bd	gen_pool_first_fit	vmlinux	EXPORT_SYMBOL	
++0xc4dbb607	jbd2_fc_get_buf	vmlinux	EXPORT_SYMBOL	
++0x85802d02	dquot_initialize_needed	vmlinux	EXPORT_SYMBOL	
++0x15ae3552	do_xdp_generic	vmlinux	EXPORT_SYMBOL_GPL	
++0x73d069f8	register_netdevice_notifier_net	vmlinux	EXPORT_SYMBOL	
++0xeeef807b	dev_pm_opp_put_opp_table	vmlinux	EXPORT_SYMBOL_GPL	
++0x713d02f9	regmap_async_complete_cb	vmlinux	EXPORT_SYMBOL_GPL	
++0xb71589f0	skip_spaces	vmlinux	EXPORT_SYMBOL	
++0x466c14a7	__delay	vmlinux	EXPORT_SYMBOL	
++0x4d65cbd5	csum_ipv6_magic	vmlinux	EXPORT_SYMBOL	
++0xfe1a7a7b	mpi_point_release	vmlinux	EXPORT_SYMBOL_GPL	
++0xf4076651	nfs42_proc_layouterror	vmlinux	EXPORT_SYMBOL_GPL	
++0xa454abf3	jbd2_fc_release_bufs	vmlinux	EXPORT_SYMBOL	
++0xe3b09712	kprobe_event_delete	vmlinux	EXPORT_SYMBOL_GPL	
++0xf485d7a6	ring_buffer_swap_cpu	vmlinux	EXPORT_SYMBOL_GPL	
++0xbbbdf6a2	param_get_ullong	vmlinux	EXPORT_SYMBOL	
++0x76d451c4	add_taint	vmlinux	EXPORT_SYMBOL	
++0x60a32ea9	pm_power_off	vmlinux	EXPORT_SYMBOL_GPL	
++0x5c20be58	__neigh_for_each_release	vmlinux	EXPORT_SYMBOL	
++0x6fdeb2e3	irq_of_parse_and_map	vmlinux	EXPORT_SYMBOL_GPL	
++0xe648a2d7	spi_busnum_to_master	vmlinux	EXPORT_SYMBOL_GPL	
++0xe05f157c	device_initialize	vmlinux	EXPORT_SYMBOL_GPL	
++0x434dddec	user_destroy	vmlinux	EXPORT_SYMBOL_GPL	
++0x9605d986	nfs4_set_rw_stateid	vmlinux	EXPORT_SYMBOL_GPL	
++0xbc641e6f	dquot_alloc_inode	vmlinux	EXPORT_SYMBOL	
++0x4e38714d	bdput	vmlinux	EXPORT_SYMBOL	
++0x4ed95e04	fsstack_copy_inode_size	vmlinux	EXPORT_SYMBOL_GPL	
++0x427c76f8	dev_get_by_napi_id	vmlinux	EXPORT_SYMBOL	
++0x74af0d61	fwnode_get_named_child_node	vmlinux	EXPORT_SYMBOL_GPL	
++0x32e8a2f7	pci_status_get_and_clear_errors	vmlinux	EXPORT_SYMBOL_GPL	
++0xe0419ac4	kstrtos16	vmlinux	EXPORT_SYMBOL	
++0xfb32b30f	ring_buffer_read_prepare_sync	vmlinux	EXPORT_SYMBOL_GPL	
++0x516960ce	tcf_em_register	vmlinux	EXPORT_SYMBOL	
++0x3f944eed	mmc_get_card	vmlinux	EXPORT_SYMBOL	
++0xd2225baa	mipi_dsi_host_register	vmlinux	EXPORT_SYMBOL	
++0xcc6305a8	devm_init_badblocks	vmlinux	EXPORT_SYMBOL_GPL	
++0x80badff4	__tracepoint_block_unplug	vmlinux	EXPORT_SYMBOL_GPL	
++0xa5306b87	iomap_set_page_dirty	vmlinux	EXPORT_SYMBOL_GPL	
++0x44a6630b	dump_truncate	vmlinux	EXPORT_SYMBOL	
++0x6d74a492	fs_kobj	vmlinux	EXPORT_SYMBOL_GPL	
++0xa1bd74a2	register_netdevice_notifier_dev_net	vmlinux	EXPORT_SYMBOL	
++0x24428be5	strncpy_from_user	vmlinux	EXPORT_SYMBOL	
++0x5ed2969e	string_escape_mem_ascii	vmlinux	EXPORT_SYMBOL	
++0x6e06d838	bio_init	vmlinux	EXPORT_SYMBOL	
++0x7278d328	all_vm_events	vmlinux	EXPORT_SYMBOL_GPL	
++0x41814cb8	dirty_writeback_interval	vmlinux	EXPORT_SYMBOL_GPL	
++0xe86a0552	gss_mech_put	vmlinux	EXPORT_SYMBOL	
++0x2fe20e2c	rpc_max_payload	vmlinux	EXPORT_SYMBOL_GPL	
++0xc68e814e	inet6_hash_connect	vmlinux	EXPORT_SYMBOL_GPL	
++0xc7fbc0e3	iptunnel_handle_offloads	vmlinux	EXPORT_SYMBOL_GPL	
++0x522109ed	tcp_sock_set_quickack	vmlinux	EXPORT_SYMBOL	
++0xf61a270e	gnet_stats_copy_rate_est	vmlinux	EXPORT_SYMBOL	
++0x14924b3a	skb_partial_csum_set	vmlinux	EXPORT_SYMBOL_GPL	
++0x165f26d9	sdio_enable_func	vmlinux	EXPORT_SYMBOL_GPL	
++0x6284a3da	dev_pm_opp_register_set_opp_helper	vmlinux	EXPORT_SYMBOL_GPL	
++0xd70a0942	genphy_c45_aneg_done	vmlinux	EXPORT_SYMBOL_GPL	
++0xf82fe509	pm_runtime_no_callbacks	vmlinux	EXPORT_SYMBOL_GPL	
++0x0cbe3ee2	software_node_unregister	vmlinux	EXPORT_SYMBOL_GPL	
++0xf947c6a8	subsys_dev_iter_next	vmlinux	EXPORT_SYMBOL_GPL	
++0x3c388d75	pci_scan_root_bus	vmlinux	EXPORT_SYMBOL	
++0x6d24c67f	create_empty_buffers	vmlinux	EXPORT_SYMBOL	
++0x850d74ad	init_special_inode	vmlinux	EXPORT_SYMBOL	
++0x24212d86	__frontswap_invalidate_page	vmlinux	EXPORT_SYMBOL	
++0x6ba4782b	__xfrm_dst_lookup	vmlinux	EXPORT_SYMBOL	
++0x54e4763b	ipmr_rule_default	vmlinux	EXPORT_SYMBOL	
++0x265706a2	iptunnel_xmit	vmlinux	EXPORT_SYMBOL_GPL	
++0xa99e2abb	inet_frag_destroy	vmlinux	EXPORT_SYMBOL	
++0xeba6018b	ipv4_sk_update_pmtu	vmlinux	EXPORT_SYMBOL_GPL	
++0xbaecd611	rpi_firmware_get	vmlinux	EXPORT_SYMBOL_GPL	
++0x063e9296	rpi_firmware_put	vmlinux	EXPORT_SYMBOL_GPL	
++0x1915b9f5	of_i2c_get_board_info	vmlinux	EXPORT_SYMBOL_GPL	
++0x4531624f	usb_decode_ctrl	vmlinux	EXPORT_SYMBOL_GPL	
++0x25bb506a	nfs_drop_inode	vmlinux	EXPORT_SYMBOL_GPL	
++0x02d69e0f	configfs_register_default_group	vmlinux	EXPORT_SYMBOL	
++0xa25a44ed	__dec_zone_page_state	vmlinux	EXPORT_SYMBOL	
++0x9c33ffe2	__inc_zone_page_state	vmlinux	EXPORT_SYMBOL	
++0xec6374c1	__mod_zone_page_state	vmlinux	EXPORT_SYMBOL	
++0x27f4f029	ftrace_set_global_filter	vmlinux	EXPORT_SYMBOL_GPL	
++0xe23c9e8c	__put_user_ns	vmlinux	EXPORT_SYMBOL	
++0x1d82f00c	release_resource	vmlinux	EXPORT_SYMBOL	
++0xffdcb269	brioctl_set	vmlinux	EXPORT_SYMBOL	
++0x3135f7ca	input_set_abs_params	vmlinux	EXPORT_SYMBOL	
++0x37581262	spi_mem_dirmap_destroy	vmlinux	EXPORT_SYMBOL_GPL	
++0xd41aaea4	spi_bus_unlock	vmlinux	EXPORT_SYMBOL_GPL	
++0x38aa1397	gpiod_add_lookup_table	vmlinux	EXPORT_SYMBOL_GPL	
++0xb3687850	out_of_line_wait_on_bit_lock	vmlinux	EXPORT_SYMBOL	
++0x789d575c	xprt_free_slot	vmlinux	EXPORT_SYMBOL_GPL	
++0x615026a0	xfrm_state_alloc	vmlinux	EXPORT_SYMBOL	
++0xf212d9d1	netdev_class_create_file_ns	vmlinux	EXPORT_SYMBOL	
++0x85670f1d	rtnl_is_locked	vmlinux	EXPORT_SYMBOL	
++0xd2f45534	devm_kmemdup	vmlinux	EXPORT_SYMBOL_GPL	
++0x970936cc	__clk_hw_register_divider	vmlinux	EXPORT_SYMBOL_GPL	
++0xa8c6509e	nfs_alloc_client	vmlinux	EXPORT_SYMBOL_GPL	
++0x9b6a41cd	fat_remove_entries	vmlinux	EXPORT_SYMBOL_GPL	
++0xb900b888	page_symlink	vmlinux	EXPORT_SYMBOL	
++0xa26d9b4f	workqueue_congested	vmlinux	EXPORT_SYMBOL_GPL	
++0x9b919c03	__xfrm_route_forward	vmlinux	EXPORT_SYMBOL	
++0xcef5997e	udp_gro_complete	vmlinux	EXPORT_SYMBOL	
++0xfb271397	rtnl_get_net_ns_capable	vmlinux	EXPORT_SYMBOL_GPL	
++0x615af56b	mmc_gpiod_request_cd_irq	vmlinux	EXPORT_SYMBOL	
++0xf30a5502	cpufreq_enable_boost_support	vmlinux	EXPORT_SYMBOL_GPL	
++0x08708410	nfsacl_decode	vmlinux	EXPORT_SYMBOL_GPL	
++0x4a6eeaa0	nfsacl_encode	vmlinux	EXPORT_SYMBOL_GPL	
++0x8b9f951a	gen_replace_estimator	vmlinux	EXPORT_SYMBOL	
++0xb0274021	scsi_target_unblock	vmlinux	EXPORT_SYMBOL_GPL	
++0x681c4eac	dev_coredumpsg	vmlinux	EXPORT_SYMBOL_GPL	
++0x11cb752a	devm_clk_hw_unregister	vmlinux	EXPORT_SYMBOL_GPL	
++0x19bd383b	security_secmark_refcount_dec	vmlinux	EXPORT_SYMBOL	
++0x2f03fc4b	security_secmark_refcount_inc	vmlinux	EXPORT_SYMBOL	
++0xdce8566b	vfs_ioc_fssetxattr_check	vmlinux	EXPORT_SYMBOL	
++0x3b03e6d1	inc_node_page_state	vmlinux	EXPORT_SYMBOL	
++0x1f6339ca	param_set_bint	vmlinux	EXPORT_SYMBOL	
++0xb467e3e5	param_get_bool	vmlinux	EXPORT_SYMBOL	
++0x6e3fb4bc	param_set_byte	vmlinux	EXPORT_SYMBOL	
++0xd7824a62	rpc_call_null	vmlinux	EXPORT_SYMBOL_GPL	
++0x66628bf3	ip_tunnel_metadata_cnt	vmlinux	EXPORT_SYMBOL	
++0x7c20ca5d	__ip4_datagram_connect	vmlinux	EXPORT_SYMBOL	
++0xcfb1a245	nf_ipv6_ops	vmlinux	EXPORT_SYMBOL_GPL	
++0x9fdecc31	unregister_netdevice_many	vmlinux	EXPORT_SYMBOL	
++0x3fe6218e	skb_clone_sk	vmlinux	EXPORT_SYMBOL	
++0xb05b02ae	vchiq_release_service	vmlinux	EXPORT_SYMBOL	
++0xea778fab	sg_pcopy_to_buffer	vmlinux	EXPORT_SYMBOL	
++0xa365f713	blk_queue_logical_block_size	vmlinux	EXPORT_SYMBOL	
++0x7a167a21	__frontswap_test	vmlinux	EXPORT_SYMBOL	
++0x828062b1	__frontswap_init	vmlinux	EXPORT_SYMBOL	
++0x11297655	init_srcu_struct	vmlinux	EXPORT_SYMBOL_GPL	
++0x47cf8005	arp_tbl	vmlinux	EXPORT_SYMBOL	
++0x198a46ad	__skb_recv_datagram	vmlinux	EXPORT_SYMBOL	
++0xc405dce5	phy_attach	vmlinux	EXPORT_SYMBOL	
++0x48168fac	gpiochip_remove_pin_ranges	vmlinux	EXPORT_SYMBOL_GPL	
++0x5a8ae15a	ZSTD_initDDict	vmlinux	EXPORT_SYMBOL	
++0x91315b52	list_lru_walk_node	vmlinux	EXPORT_SYMBOL_GPL	
++0x017de3d5	nr_cpu_ids	vmlinux	EXPORT_SYMBOL	
++0x065994f1	xdr_encode_opaque_fixed	vmlinux	EXPORT_SYMBOL_GPL	
++0xf8936008	tcp_splice_read	vmlinux	EXPORT_SYMBOL	
++0xb15ec186	DWC_THREAD_STOP	vmlinux	EXPORT_SYMBOL	
++0x65ccee2e	phy_get_pause	vmlinux	EXPORT_SYMBOL	
++0x08b62fe9	regmap_fields_update_bits_base	vmlinux	EXPORT_SYMBOL_GPL	
++0xe7fa5e25	request_firmware_direct	vmlinux	EXPORT_SYMBOL_GPL	
++0x21a563da	clk_get_accuracy	vmlinux	EXPORT_SYMBOL_GPL	
++0x50f91491	__genradix_ptr	vmlinux	EXPORT_SYMBOL	
++0x5f17c0ab	simple_recursive_removal	vmlinux	EXPORT_SYMBOL	
++0x73e35852	irq_setup_generic_chip	vmlinux	EXPORT_SYMBOL_GPL	
++0xc10fddb8	name_to_dev_t	vmlinux	EXPORT_SYMBOL_GPL	
++0xc32c71af	register_inetaddr_validator_notifier	vmlinux	EXPORT_SYMBOL	
++0x9aaeefce	sysctl_nf_log_all_netns	vmlinux	EXPORT_SYMBOL	
++0x7a53a06d	flow_indr_dev_exists	vmlinux	EXPORT_SYMBOL	
++0x0736dd10	__tracepoint_iscsi_dbg_eh	vmlinux	EXPORT_SYMBOL_GPL	
++0xf5b19f78	platform_msi_domain_free_irqs	vmlinux	EXPORT_SYMBOL_GPL	
++0xcbc88a23	ZSTD_isFrame	vmlinux	EXPORT_SYMBOL	
++0xd05e6713	of_irq_to_resource	vmlinux	EXPORT_SYMBOL_GPL	
++0x9d2e7707	unregister_sysrq_key	vmlinux	EXPORT_SYMBOL	
++0xa3116927	regulator_put	vmlinux	EXPORT_SYMBOL_GPL	
++0x81a7f541	percpu_ref_init	vmlinux	EXPORT_SYMBOL_GPL	
++0x5a5ede7c	crypto_unregister_rngs	vmlinux	EXPORT_SYMBOL_GPL	
++0xf70c493a	crypto_aead_setkey	vmlinux	EXPORT_SYMBOL_GPL	
++0x53349ee5	crypto_unregister_algs	vmlinux	EXPORT_SYMBOL_GPL	
++0xd6cb6f37	nfs_file_read	vmlinux	EXPORT_SYMBOL_GPL	
++0x03300989	simple_transaction_get	vmlinux	EXPORT_SYMBOL	
++0x5371fb1b	simple_transaction_set	vmlinux	EXPORT_SYMBOL	
++0x155db388	register_kretprobes	vmlinux	EXPORT_SYMBOL_GPL	
++0xb55d31d8	find_pid_ns	vmlinux	EXPORT_SYMBOL_GPL	
++0x966e0f08	__nlmsg_put	vmlinux	EXPORT_SYMBOL	
++0x391df607	lock_sock_nested	vmlinux	EXPORT_SYMBOL	
++0xb6729ac6	nvmem_cell_get	vmlinux	EXPORT_SYMBOL_GPL	
++0x071e1645	devm_extcon_register_notifier	vmlinux	EXPORT_SYMBOL	
++0x44721097	hid_add_device	vmlinux	EXPORT_SYMBOL_GPL	
++0x66ffd875	sdio_disable_func	vmlinux	EXPORT_SYMBOL_GPL	
++0xf373a847	power_supply_set_input_current_limit_from_supplier	vmlinux	EXPORT_SYMBOL_GPL	
++0xfd74b73e	devm_usb_put_phy	vmlinux	EXPORT_SYMBOL_GPL	
++0x98d685f4	platform_add_devices	vmlinux	EXPORT_SYMBOL_GPL	
++0xfff389af	device_show_bool	vmlinux	EXPORT_SYMBOL_GPL	
++0xc209bf97	pci_read_config_byte	vmlinux	EXPORT_SYMBOL	
++0x28b117de	gpiochip_add_pingroup_range	vmlinux	EXPORT_SYMBOL_GPL	
++0x2864abc9	klist_node_attached	vmlinux	EXPORT_SYMBOL_GPL	
++0x45d44a04	rhashtable_walk_exit	vmlinux	EXPORT_SYMBOL_GPL	
++0x4713e9b1	sched_trace_rd_span	vmlinux	EXPORT_SYMBOL_GPL	
++0x84a396bb	flush_work	vmlinux	EXPORT_SYMBOL_GPL	
++0x3d172ca7	mm_access	vmlinux	EXPORT_SYMBOL_GPL	
++0x5064c114	of_thermal_is_trip_valid	vmlinux	EXPORT_SYMBOL_GPL	
++0x11ecaf06	usb_deregister	vmlinux	EXPORT_SYMBOL_GPL	
++0x2d616160	phy_ethtool_set_eee	vmlinux	EXPORT_SYMBOL	
++0xbe83414b	phy_ethtool_get_eee	vmlinux	EXPORT_SYMBOL	
++0x74d5d08b	gpiochip_line_is_persistent	vmlinux	EXPORT_SYMBOL_GPL	
++0x02b0c895	create_signature	vmlinux	EXPORT_SYMBOL_GPL	
++0x223b0a7c	__generic_file_fsync	vmlinux	EXPORT_SYMBOL	
++0x10c3f57e	__gnet_stats_copy_queue	vmlinux	EXPORT_SYMBOL	
++0x614adcb7	of_overlay_remove_all	vmlinux	EXPORT_SYMBOL_GPL	
++0x5a573600	of_device_is_compatible	vmlinux	EXPORT_SYMBOL	
++0x6b198c77	led_colors	vmlinux	EXPORT_SYMBOL_GPL	
++0x833a03d8	nvme_complete_rq	vmlinux	EXPORT_SYMBOL_GPL	
++0x6736c06d	rdev_get_drvdata	vmlinux	EXPORT_SYMBOL_GPL	
++0x44930935	pci_msi_unmask_irq	vmlinux	EXPORT_SYMBOL_GPL	
++0x6b2dc060	dump_stack	vmlinux	EXPORT_SYMBOL	
++0xecfe3332	mpage_writepage	vmlinux	EXPORT_SYMBOL	
++0x06cca30b	ring_buffer_record_off	vmlinux	EXPORT_SYMBOL_GPL	
++0xffff299e	set_security_override	vmlinux	EXPORT_SYMBOL	
++0x6ae2444c	raw_seq_start	vmlinux	EXPORT_SYMBOL_GPL	
++0x3332cc17	dst_cow_metrics_generic	vmlinux	EXPORT_SYMBOL	
++0x445387d0	ir_raw_event_store_with_filter	vmlinux	EXPORT_SYMBOL_GPL	
++0xdb1c2bce	rtc_read_time	vmlinux	EXPORT_SYMBOL_GPL	
++0x7adc0fbf	rb_replace_node_rcu	vmlinux	EXPORT_SYMBOL	
++0xe21f18ac	__genradix_iter_peek	vmlinux	EXPORT_SYMBOL	
++0xa5e68bbf	clean_bdev_aliases	vmlinux	EXPORT_SYMBOL	
++0x9eb50e4e	copy_string_kernel	vmlinux	EXPORT_SYMBOL	
++0xb7ec605d	netdev_master_upper_dev_get	vmlinux	EXPORT_SYMBOL	
++0x96757d70	DWC_SPINUNLOCK	vmlinux	EXPORT_SYMBOL	
++0x44e8ac32	__traceiter_dma_fence_signaled	vmlinux	EXPORT_SYMBOL	
++0x9b8e1af3	dmaengine_get_unmap_data	vmlinux	EXPORT_SYMBOL	
++0x6ef7048a	kobject_del	vmlinux	EXPORT_SYMBOL	
++0xf818424d	crypto_unregister_shash	vmlinux	EXPORT_SYMBOL_GPL	
++0x141e4aa2	crypto_unregister_ahash	vmlinux	EXPORT_SYMBOL_GPL	
++0xb8b9f817	kmalloc_order_trace	vmlinux	EXPORT_SYMBOL	
++0xd830e00d	__clean_dcache_area_poc	vmlinux	EXPORT_SYMBOL	
++0x12327d02	rpc_remove_pipe_dir_object	vmlinux	EXPORT_SYMBOL_GPL	
++0xf666765b	rpc_clnt_add_xprt	vmlinux	EXPORT_SYMBOL_GPL	
++0xef7030b5	tcp_sock_set_user_timeout	vmlinux	EXPORT_SYMBOL	
++0x4a4b6dd1	cpufreq_dbs_governor_start	vmlinux	EXPORT_SYMBOL_GPL	
++0xea06e2c1	policy_has_boost_freq	vmlinux	EXPORT_SYMBOL_GPL	
++0x209abe36	usb_reset_endpoint	vmlinux	EXPORT_SYMBOL_GPL	
++0x197cc84e	mctrl_gpio_init_noauto	vmlinux	EXPORT_SYMBOL_GPL	
++0x96554810	register_keyboard_notifier	vmlinux	EXPORT_SYMBOL_GPL	
++0x0ea593f6	hdmi_drm_infoframe_init	vmlinux	EXPORT_SYMBOL	
++0xb6a68816	find_last_bit	vmlinux	EXPORT_SYMBOL	
++0x7f4d7719	poll_initwait	vmlinux	EXPORT_SYMBOL	
++0x6fd9b955	irq_gc_ack_set_bit	vmlinux	EXPORT_SYMBOL_GPL	
++0x812838e3	unregister_console	vmlinux	EXPORT_SYMBOL	
++0x0d804ac1	led_trigger_unregister_simple	vmlinux	EXPORT_SYMBOL_GPL	
++0xbe5e9ed8	usb_stor_reset_resume	vmlinux	EXPORT_SYMBOL_GPL	USB_STORAGE
++0x9b3af9d0	usb_bus_idr	vmlinux	EXPORT_SYMBOL_GPL	
++0xa66a99eb	phy_disconnect	vmlinux	EXPORT_SYMBOL	
++0x0049c379	phy_ethtool_set_link_ksettings	vmlinux	EXPORT_SYMBOL	
++0x57cdd5ba	phy_ethtool_get_link_ksettings	vmlinux	EXPORT_SYMBOL	
++0xea9f2f3d	device_get_mac_address	vmlinux	EXPORT_SYMBOL	
++0x3fd78f3b	register_chrdev_region	vmlinux	EXPORT_SYMBOL	
++0xe7b0353b	__cpu_active_mask	vmlinux	EXPORT_SYMBOL	
++0x6547ceb5	rpcauth_wrap_req_encode	vmlinux	EXPORT_SYMBOL_GPL	
++0x7df50cf8	netdev_state_change	vmlinux	EXPORT_SYMBOL	
++0xb26d47ba	devm_regmap_field_bulk_free	vmlinux	EXPORT_SYMBOL_GPL	
++0xb7c0f443	sort	vmlinux	EXPORT_SYMBOL	
++0xa3f12f69	__crypto_xor	vmlinux	EXPORT_SYMBOL_GPL	
++0xa8fef7bb	security_unix_may_send	vmlinux	EXPORT_SYMBOL	
++0x41c7de7b	vfs_getattr_nosec	vmlinux	EXPORT_SYMBOL	
++0x541bd60a	irq_work_run	vmlinux	EXPORT_SYMBOL_GPL	
++0xfede9222	__tracepoint_suspend_resume	vmlinux	EXPORT_SYMBOL_GPL	
++0x9f7d97b5	tracing_snapshot_cond	vmlinux	EXPORT_SYMBOL_GPL	
++0x4f8b53cb	usb_sg_cancel	vmlinux	EXPORT_SYMBOL_GPL	
++0xc58574c7	devm_gpiod_get_from_of_node	vmlinux	EXPORT_SYMBOL_GPL	
++0xb5b6adc9	debugfs_create_devm_seqfile	vmlinux	EXPORT_SYMBOL_GPL	
++0xba28f813	nfs_probe_fsinfo	vmlinux	EXPORT_SYMBOL_GPL	
++0x098a72ec	fscache_io_error	vmlinux	EXPORT_SYMBOL	
++0xd873152d	kern_path	vmlinux	EXPORT_SYMBOL	
++0xd365fe2b	irq_chip_ack_parent	vmlinux	EXPORT_SYMBOL_GPL	
++0xdc09e02b	rpc_set_connect_timeout	vmlinux	EXPORT_SYMBOL_GPL	
++0x337c90f0	xfrm_dev_resume	vmlinux	EXPORT_SYMBOL_GPL	
++0x8399fab4	nf_register_queue_handler	vmlinux	EXPORT_SYMBOL	
++0x6d2aba8a	netpoll_print_options	vmlinux	EXPORT_SYMBOL	
++0xd3f81fc9	iscsi_destroy_conn	vmlinux	EXPORT_SYMBOL_GPL	
++0xb67e7903	clk_hw_get_flags	vmlinux	EXPORT_SYMBOL_GPL	
++0x7e03ae7a	clk_bulk_get	vmlinux	EXPORT_SYMBOL	
++0x19e1146f	gpiod_set_raw_value_cansleep	vmlinux	EXPORT_SYMBOL_GPL	
++0x260a095a	__sg_alloc_table	vmlinux	EXPORT_SYMBOL	
++0x1d060c5a	shrink_dcache_sb	vmlinux	EXPORT_SYMBOL	
++0xb6d1ae9e	__cleancache_init_fs	vmlinux	EXPORT_SYMBOL	
++0xdf38c6f1	__tracepoint_xdp_bulk_tx	vmlinux	EXPORT_SYMBOL_GPL	
++0x6fb45ff6	percpu_free_rwsem	vmlinux	EXPORT_SYMBOL_GPL	
++0x3919d88d	param_ops_int	vmlinux	EXPORT_SYMBOL	
++0x8f625b43	efivar_entry_iter	vmlinux	EXPORT_SYMBOL_GPL	
++0x203acc9d	dwc_add_observer	vmlinux	EXPORT_SYMBOL	
++0x16076a09	regmap_fields_read	vmlinux	EXPORT_SYMBOL_GPL	
++0x2530124d	pm_runtime_get_if_active	vmlinux	EXPORT_SYMBOL_GPL	
++0x1298898c	serial8250_do_set_ldisc	vmlinux	EXPORT_SYMBOL_GPL	
++0xa0ebd437	hdmi_drm_infoframe_check	vmlinux	EXPORT_SYMBOL	
++0x8a6fdcf5	sbitmap_init_node	vmlinux	EXPORT_SYMBOL_GPL	
++0x57dc6cdd	blkdev_issue_flush	vmlinux	EXPORT_SYMBOL	
++0x499043d3	crypto_init_queue	vmlinux	EXPORT_SYMBOL_GPL	
++0x03b994f5	page_cache_sync_ra	vmlinux	EXPORT_SYMBOL_GPL	
++0x7a575df9	raw_v4_hashinfo	vmlinux	EXPORT_SYMBOL_GPL	
++0xd64ed259	__memcat_p	vmlinux	EXPORT_SYMBOL_GPL	
++0xf5e1b1ee	sysfs_break_active_protection	vmlinux	EXPORT_SYMBOL_GPL	
++0x0a5d5e4e	iomap_zero_range	vmlinux	EXPORT_SYMBOL_GPL	
++0xd666fdb1	fsnotify_put_mark	vmlinux	EXPORT_SYMBOL_GPL	
++0x8ff110da	blockdev_superblock	vmlinux	EXPORT_SYMBOL_GPL	
++0xb308c97d	wait_woken	vmlinux	EXPORT_SYMBOL	
++0xf2ecf521	param_ops_short	vmlinux	EXPORT_SYMBOL	
++0xc0fc8471	rpcb_getport_async	vmlinux	EXPORT_SYMBOL_GPL	
++0x2f24f5eb	skb_zerocopy_iter_dgram	vmlinux	EXPORT_SYMBOL_GPL	
++0x53ffc491	usb_gadget_deactivate	vmlinux	EXPORT_SYMBOL_GPL	
++0x7dfff412	nvme_try_sched_reset	vmlinux	EXPORT_SYMBOL_GPL	
++0x190b72e8	fwnode_irq_get	vmlinux	EXPORT_SYMBOL	
++0xa896523a	amba_device_put	vmlinux	EXPORT_SYMBOL_GPL	
++0x1e64e484	amba_device_add	vmlinux	EXPORT_SYMBOL_GPL	
++0x2484adc3	__kfifo_to_user_r	vmlinux	EXPORT_SYMBOL	
++0xac3201b0	udp_flow_hashrnd	vmlinux	EXPORT_SYMBOL	
++0x9fa6acb0	softnet_data	vmlinux	EXPORT_SYMBOL	
++0xf9a4ca25	extcon_get_edev_name	vmlinux	EXPORT_SYMBOL_GPL	
++0xfc549963	efivar_entry_get	vmlinux	EXPORT_SYMBOL_GPL	
++0xf9f612e6	efivar_entry_set	vmlinux	EXPORT_SYMBOL_GPL	
++0xb2cb360c	gpiod_to_irq	vmlinux	EXPORT_SYMBOL_GPL	
++0xfe5d4bb2	sys_tz	vmlinux	EXPORT_SYMBOL	
++0x1768dc7a	dma_get_sgtable_attrs	vmlinux	EXPORT_SYMBOL	
++0x4fc8bf13	rpc_clnt_iterate_for_each_xprt	vmlinux	EXPORT_SYMBOL_GPL	
++0x9ffa3a75	netdev_max_backlog	vmlinux	EXPORT_SYMBOL	
++0x32169eb9	dev_pm_domain_attach_by_name	vmlinux	EXPORT_SYMBOL_GPL	
++0xddbeeecc	pci_lock_rescan_remove	vmlinux	EXPORT_SYMBOL_GPL	
++0x7c7f5094	pci_speed_string	vmlinux	EXPORT_SYMBOL_GPL	
++0x30a6a55a	kernfs_path_from_node	vmlinux	EXPORT_SYMBOL_GPL	
++0x1d5f9555	frame_vector_destroy	vmlinux	EXPORT_SYMBOL	
++0x0ba585be	unlock_page	vmlinux	EXPORT_SYMBOL	
++0x4f98d766	cpu_pm_unregister_notifier	vmlinux	EXPORT_SYMBOL_GPL	
++0x387e1639	rpc_pipefs_notifier_register	vmlinux	EXPORT_SYMBOL_GPL	
++0xf892b090	netdev_walk_all_upper_dev_rcu	vmlinux	EXPORT_SYMBOL_GPL	
++0x3d9ce9e6	sdio_memcpy_fromio	vmlinux	EXPORT_SYMBOL_GPL	
++0xc1b8528c	dev_pm_opp_set_rate	vmlinux	EXPORT_SYMBOL_GPL	
++0x4b2055f0	bio_release_pages	vmlinux	EXPORT_SYMBOL_GPL	
++0xf3a57892	release_dentry_name_snapshot	vmlinux	EXPORT_SYMBOL	
++0xc916dd46	__SCK__tp_func_kmalloc	vmlinux	EXPORT_SYMBOL	
++0xc1a7facb	alarm_cancel	vmlinux	EXPORT_SYMBOL_GPL	
++0x5a45ba31	svc_auth_unregister	vmlinux	EXPORT_SYMBOL_GPL	
++0x8b330547	xfrm_unregister_type	vmlinux	EXPORT_SYMBOL	
++0x99af9d10	nf_ip_checksum	vmlinux	EXPORT_SYMBOL	
++0x94f74fa6	sock_diag_save_cookie	vmlinux	EXPORT_SYMBOL_GPL	
++0xbbd398b5	led_sysfs_enable	vmlinux	EXPORT_SYMBOL_GPL	
++0xfaa42865	pci_request_regions_exclusive	vmlinux	EXPORT_SYMBOL	
++0x420e87cd	pkcs7_validate_trust	vmlinux	EXPORT_SYMBOL_GPL	
++0xe19f5ee0	__tracepoint_pnfs_mds_fallback_write_pagelist	vmlinux	EXPORT_SYMBOL_GPL	
++0xeca39546	jbd2_log_wait_commit	vmlinux	EXPORT_SYMBOL	
++0x01f6a98c	hrtimer_init_sleeper	vmlinux	EXPORT_SYMBOL_GPL	
++0x21e082ae	xhci_ext_cap_init	vmlinux	EXPORT_SYMBOL_GPL	
++0x526eef2c	hdmi_vendor_infoframe_pack	vmlinux	EXPORT_SYMBOL	
++0x654449c3	memset16	vmlinux	EXPORT_SYMBOL	
++0x310dc3b3	blk_queue_can_use_dma_map_merging	vmlinux	EXPORT_SYMBOL_GPL	
++0x0cc0b971	crypto_comp_compress	vmlinux	EXPORT_SYMBOL_GPL	
++0xf2ad4e7b	dquot_disable	vmlinux	EXPORT_SYMBOL	
++0x252332f1	__SCK__tp_func_mmap_lock_released	vmlinux	EXPORT_SYMBOL	
++0xb4642d35	trace_event_buffer_commit	vmlinux	EXPORT_SYMBOL_GPL	
++0xb619da9f	module_put	vmlinux	EXPORT_SYMBOL	
++0x2459bbcc	console_set_on_cmdline	vmlinux	EXPORT_SYMBOL	
++0x39178a06	__traceiter_napi_poll	vmlinux	EXPORT_SYMBOL_GPL	
++0xb08a22a3	cpufreq_show_cpus	vmlinux	EXPORT_SYMBOL_GPL	
++0x803d3620	usb_get_from_anchor	vmlinux	EXPORT_SYMBOL_GPL	
++0xcb8d3304	genphy_resume	vmlinux	EXPORT_SYMBOL	
++0xf41e6432	inode_get_bytes	vmlinux	EXPORT_SYMBOL	
++0xca102368	__wake_up	vmlinux	EXPORT_SYMBOL	
++0xc448dd10	xdp_rxq_info_unreg_mem_model	vmlinux	EXPORT_SYMBOL_GPL	
++0x7fef7b84	i2c_for_each_dev	vmlinux	EXPORT_SYMBOL_GPL	
++0x92b54894	dev_driver_string	vmlinux	EXPORT_SYMBOL	
++0x79dc8c58	pcie_get_readrq	vmlinux	EXPORT_SYMBOL	
++0x0419e175	vbin_printf	vmlinux	EXPORT_SYMBOL_GPL	
++0xc7a1840e	llist_add_batch	vmlinux	EXPORT_SYMBOL_GPL	
++0xa7f318f0	blk_mq_update_nr_hw_queues	vmlinux	EXPORT_SYMBOL_GPL	
++0x8f7b36dd	bio_reset	vmlinux	EXPORT_SYMBOL	
++0x3625f020	security_d_instantiate	vmlinux	EXPORT_SYMBOL	
++0x9937e81d	iter_file_splice_write	vmlinux	EXPORT_SYMBOL	
++0x0db14728	vfs_mkdir	vmlinux	EXPORT_SYMBOL	
++0xbadbb2d7	srcu_torture_stats_print	vmlinux	EXPORT_SYMBOL_GPL	
++0xcb416b0d	of_match_node	vmlinux	EXPORT_SYMBOL	
++0x16e7d70b	usb_driver_claim_interface	vmlinux	EXPORT_SYMBOL_GPL	
++0xe744cc2d	bcm54xx_auxctl_write	vmlinux	EXPORT_SYMBOL	
++0x2eca1048	fwnode_property_get_reference_args	vmlinux	EXPORT_SYMBOL_GPL	
++0xc5a5c678	uart_parse_earlycon	vmlinux	EXPORT_SYMBOL_GPL	
++0x31bac69e	pinctrl_add_gpio_range	vmlinux	EXPORT_SYMBOL_GPL	
++0xe9637900	jbd2_fc_begin_commit	vmlinux	EXPORT_SYMBOL	
++0x2847d04a	eventfd_ctx_fileget	vmlinux	EXPORT_SYMBOL_GPL	
++0x01139ffc	max_mapnr	vmlinux	EXPORT_SYMBOL	
++0xb5606dd4	verify_pkcs7_signature	vmlinux	EXPORT_SYMBOL_GPL	
++0x539252a1	rpc_pipe_generic_upcall	vmlinux	EXPORT_SYMBOL_GPL	
++0x539b8dfe	xprt_unregister_transport	vmlinux	EXPORT_SYMBOL_GPL	
++0x7559f69a	led_trigger_set	vmlinux	EXPORT_SYMBOL_GPL	
++0x83d0b1b9	of_find_i2c_device_by_node	vmlinux	EXPORT_SYMBOL	
++0x63187451	pcie_aspm_support_enabled	vmlinux	EXPORT_SYMBOL	
++0xcb60bc81	gpiod_get_array_optional	vmlinux	EXPORT_SYMBOL_GPL	
++0xb3a3dbca	eventfd_fget	vmlinux	EXPORT_SYMBOL_GPL	
++0xa9d01fdf	dget_parent	vmlinux	EXPORT_SYMBOL	
++0xa0436e98	in6addr_linklocal_allnodes	vmlinux	EXPORT_SYMBOL	
++0x9052e867	do_tcp_sendpages	vmlinux	EXPORT_SYMBOL_GPL	
++0x11d4e552	hid_dump_input	vmlinux	EXPORT_SYMBOL_GPL	
++0xcc7b42b0	sdhci_send_tuning	vmlinux	EXPORT_SYMBOL_GPL	
++0xc8468a99	usb_disable_autosuspend	vmlinux	EXPORT_SYMBOL_GPL	
++0xc9ca670e	usb_get_dev	vmlinux	EXPORT_SYMBOL_GPL	
++0xda8e1302	software_node_find_by_name	vmlinux	EXPORT_SYMBOL_GPL	
++0xc4b8c460	device_property_match_string	vmlinux	EXPORT_SYMBOL_GPL	
++0x1ed4d2eb	percpu_ref_kill_and_confirm	vmlinux	EXPORT_SYMBOL_GPL	
++0x8d28326e	securityfs_create_dir	vmlinux	EXPORT_SYMBOL_GPL	
++0xdd2c169b	mb_cache_create	vmlinux	EXPORT_SYMBOL	
++0x115e90c3	iunique	vmlinux	EXPORT_SYMBOL	
++0xb3fde1e2	try_lookup_one_len	vmlinux	EXPORT_SYMBOL	
++0x9707d36b	__traceiter_kmem_cache_free	vmlinux	EXPORT_SYMBOL	
++0x121d958a	unregister_die_notifier	vmlinux	EXPORT_SYMBOL_GPL	
++0x4a8cdbf6	xfrm_policy_walk_done	vmlinux	EXPORT_SYMBOL	
++0xab951653	inet_dgram_ops	vmlinux	EXPORT_SYMBOL	
++0x5bfa1440	input_release_device	vmlinux	EXPORT_SYMBOL	
++0x57e37641	usb_add_gadget	vmlinux	EXPORT_SYMBOL_GPL	
++0x4c8f9812	__do_once_done	vmlinux	EXPORT_SYMBOL	
++0xb282e29b	blk_alloc_queue	vmlinux	EXPORT_SYMBOL	
++0x92fbdb0f	nfs4_schedule_stateid_recovery	vmlinux	EXPORT_SYMBOL_GPL	
++0xd5263820	mb_cache_destroy	vmlinux	EXPORT_SYMBOL	
++0xe6bbf2f2	gen_pool_for_each_chunk	vmlinux	EXPORT_SYMBOL	
++0x6fe0176f	proc_doulongvec_minmax	vmlinux	EXPORT_SYMBOL	
++0xc8e49da8	hwmon_device_register	vmlinux	EXPORT_SYMBOL_GPL	
++0xb83b54c7	usb_store_new_id	vmlinux	EXPORT_SYMBOL_GPL	
++0xeab6e3b2	sdev_evt_send_simple	vmlinux	EXPORT_SYMBOL_GPL	
++0x7ab16bf9	of_find_mipi_dsi_host_by_node	vmlinux	EXPORT_SYMBOL	
++0xfe3439c8	crypto_register_akcipher	vmlinux	EXPORT_SYMBOL_GPL	
++0xd47fc4ae	pnfs_generic_pg_init_read	vmlinux	EXPORT_SYMBOL_GPL	
++0x8d5a48b4	simple_attr_open	vmlinux	EXPORT_SYMBOL_GPL	
++0x61202e54	seq_hex_dump	vmlinux	EXPORT_SYMBOL	
++0x065246b8	frame_vector_create	vmlinux	EXPORT_SYMBOL	
++0x80f040e5	truncate_inode_pages_final	vmlinux	EXPORT_SYMBOL	
++0x56e9103b	cpu_pm_enter	vmlinux	EXPORT_SYMBOL_GPL	
++0xc9065b19	__wake_up_locked_key	vmlinux	EXPORT_SYMBOL_GPL	
++0x2d1b02d2	usermodehelper_read_lock_wait	vmlinux	EXPORT_SYMBOL_GPL	
++0x5e6429ac	__cpuhp_setup_state_cpuslocked	vmlinux	EXPORT_SYMBOL	
++0xc1973e03	netdev_adjacent_change_commit	vmlinux	EXPORT_SYMBOL	
++0xf52ff016	sk_clear_memalloc	vmlinux	EXPORT_SYMBOL_GPL	
++0x884efadb	usb_root_hub_lost_power	vmlinux	EXPORT_SYMBOL_GPL	
++0x6853bcb3	pci_stop_and_remove_bus_device	vmlinux	EXPORT_SYMBOL	
++0x7d5e1008	__crc32c_le_shift	vmlinux	EXPORT_SYMBOL	
++0x4578f528	__kfifo_to_user	vmlinux	EXPORT_SYMBOL	
++0x2c61ce0b	blk_mq_sched_request_inserted	vmlinux	EXPORT_SYMBOL_GPL	
++0x49708b4a	done_path_create	vmlinux	EXPORT_SYMBOL	
++0x31b53a15	get_super_exclusive_thawed	vmlinux	EXPORT_SYMBOL	
++0x3cd82624	xfrm4_rcv_encap	vmlinux	EXPORT_SYMBOL	
++0x0d33a414	udp_poll	vmlinux	EXPORT_SYMBOL	
++0x0d45bf43	skb_copy_ubufs	vmlinux	EXPORT_SYMBOL_GPL	
++0x88effef3	dev_pm_opp_attach_genpd	vmlinux	EXPORT_SYMBOL_GPL	
++0x6837cd09	mdiobus_unregister_device	vmlinux	EXPORT_SYMBOL	
++0x89652e54	pci_remove_root_bus	vmlinux	EXPORT_SYMBOL_GPL	
++0x5818fe3c	posix_acl_from_mode	vmlinux	EXPORT_SYMBOL	
++0x6df6d49b	fscrypt_symlink_getattr	vmlinux	EXPORT_SYMBOL_GPL	
++0x9eacf8a5	kstrndup	vmlinux	EXPORT_SYMBOL	
++0x687b6a16	kdbgetsymval	vmlinux	EXPORT_SYMBOL	
++0x4563a6ed	irq_domain_reset_irq_data	vmlinux	EXPORT_SYMBOL_GPL	
++0x61f2cbca	irq_set_chip	vmlinux	EXPORT_SYMBOL	
++0x28a2519d	console_stop	vmlinux	EXPORT_SYMBOL	
++0xa77bfd29	register_inet6addr_validator_notifier	vmlinux	EXPORT_SYMBOL	
++0x7b7a15ff	power_supply_put	vmlinux	EXPORT_SYMBOL_GPL	
++0x772006bf	mfd_add_devices	vmlinux	EXPORT_SYMBOL	
++0x91d1fe52	max_session_slots	vmlinux	EXPORT_SYMBOL_GPL	
++0x2ab7b0d3	fscrypt_ioctl_get_policy_ex	vmlinux	EXPORT_SYMBOL_GPL	
++0x8eb29433	__tracepoint_fs_file_release	vmlinux	EXPORT_SYMBOL_GPL	
++0x08998f9e	__traceiter_rpm_suspend	vmlinux	EXPORT_SYMBOL_GPL	
++0x30ade0bf	sunrpc_init_cache_detail	vmlinux	EXPORT_SYMBOL_GPL	
++0x0ed1f107	xdr_encode_word	vmlinux	EXPORT_SYMBOL_GPL	
++0xff1690f9	auth_domain_find	vmlinux	EXPORT_SYMBOL_GPL	
++0x82a80545	__SCK__tp_func_fdb_delete	vmlinux	EXPORT_SYMBOL_GPL	
++0x8d73278e	hex_asc_upper	vmlinux	EXPORT_SYMBOL	
++0x6a03751f	sgl_free_order	vmlinux	EXPORT_SYMBOL	
++0x852820cc	debugfs_create_file	vmlinux	EXPORT_SYMBOL_GPL	
++0x15d53a32	new_inode	vmlinux	EXPORT_SYMBOL	
++0x7a076e57	rpc_restart_call_prepare	vmlinux	EXPORT_SYMBOL_GPL	
++0x86f85114	net_dec_egress_queue	vmlinux	EXPORT_SYMBOL_GPL	
++0x4a21a5a0	build_skb_around	vmlinux	EXPORT_SYMBOL	
++0x425b94e9	of_get_phy_mode	vmlinux	EXPORT_SYMBOL_GPL	
++0xc701e35f	hwmon_notify_event	vmlinux	EXPORT_SYMBOL_GPL	
++0x1ddc6d01	__rtc_register_device	vmlinux	EXPORT_SYMBOL_GPL	
++0x44173ead	xhci_run	vmlinux	EXPORT_SYMBOL_GPL	
++0x8112b3d2	scsi_build_sense_buffer	vmlinux	EXPORT_SYMBOL	
++0xeaf054f0	dma_fence_array_create	vmlinux	EXPORT_SYMBOL	
++0x51e61a85	regmap_field_update_bits_base	vmlinux	EXPORT_SYMBOL_GPL	
++0xa2ea41e5	platform_find_device_by_driver	vmlinux	EXPORT_SYMBOL_GPL	
++0x5845614c	tty_port_close	vmlinux	EXPORT_SYMBOL	
++0xe0b13336	argv_free	vmlinux	EXPORT_SYMBOL	
++0x1f38a4f6	mpi_set_highbit	vmlinux	EXPORT_SYMBOL_GPL	
++0x65dccf13	xz_dec_end	vmlinux	EXPORT_SYMBOL	
++0x6e5b8651	xz_dec_run	vmlinux	EXPORT_SYMBOL	
++0x5a4314e9	__SCK__tp_func_nfs4_pnfs_commit_ds	vmlinux	EXPORT_SYMBOL_GPL	
++0xb10a13c0	jbd2_journal_clear_err	vmlinux	EXPORT_SYMBOL	
++0x0ad467a4	dma_unmap_page_attrs	vmlinux	EXPORT_SYMBOL	
++0xb785278b	genl_unregister_family	vmlinux	EXPORT_SYMBOL	
++0xe3b54f5e	netdev_upper_get_next_dev_rcu	vmlinux	EXPORT_SYMBOL	
++0x9d0d6206	unregister_netdevice_notifier	vmlinux	EXPORT_SYMBOL	
++0x76a42ea1	of_graph_get_endpoint_by_regs	vmlinux	EXPORT_SYMBOL	
++0xe04b20aa	sdhci_start_tuning	vmlinux	EXPORT_SYMBOL_GPL	
++0xeadc8991	tty_register_driver	vmlinux	EXPORT_SYMBOL	
++0x0fab1ab0	hdmi_spd_infoframe_pack	vmlinux	EXPORT_SYMBOL	
++0xe271128b	cpumask_any_distribute	vmlinux	EXPORT_SYMBOL	
++0xd1363cc1	ucs2_strsize	vmlinux	EXPORT_SYMBOL	
++0xea253ba1	pnfs_read_done_resend_to_mds	vmlinux	EXPORT_SYMBOL_GPL	
++0x3e46a9b6	nfs_refresh_inode	vmlinux	EXPORT_SYMBOL_GPL	
++0xe659ed6f	generic_remap_file_range_prep	vmlinux	EXPORT_SYMBOL	
++0xed9b4be2	wbc_attach_and_unlock_inode	vmlinux	EXPORT_SYMBOL_GPL	
++0xc46324f6	dynevent_create	vmlinux	EXPORT_SYMBOL_GPL	
++0xd676d248	ndo_dflt_fdb_del	vmlinux	EXPORT_SYMBOL	
++0xaac437dc	sdio_release_host	vmlinux	EXPORT_SYMBOL_GPL	
++0xfceb4e50	driver_remove_file	vmlinux	EXPORT_SYMBOL_GPL	
++0x9cbfae18	kset_unregister	vmlinux	EXPORT_SYMBOL	
++0xb810a492	disk_end_io_acct	vmlinux	EXPORT_SYMBOL	
++0x6a2c2204	debugfs_create_u32	vmlinux	EXPORT_SYMBOL_GPL	
++0x08a3ebfc	vfs_iocb_iter_read	vmlinux	EXPORT_SYMBOL	
++0x86c02001	ipi_send_mask	vmlinux	EXPORT_SYMBOL_GPL	
++0x95b9cc29	__rt_spin_lock_init	vmlinux	EXPORT_SYMBOL	
++0x1cec5f2c	netdev_rx_handler_register	vmlinux	EXPORT_SYMBOL_GPL	
++0xcd4922c9	devm_thermal_zone_of_sensor_register	vmlinux	EXPORT_SYMBOL_GPL	
++0xd3559ef4	__memset	vmlinux	EXPORT_SYMBOL	
++0x34fc4ad3	__tracepoint_block_split	vmlinux	EXPORT_SYMBOL_GPL	
++0x2977017f	jbd2_journal_release_jbd_inode	vmlinux	EXPORT_SYMBOL	
++0x93533427	wbc_account_cgroup_owner	vmlinux	EXPORT_SYMBOL_GPL	
++0x6bd1aa56	stack_trace_save	vmlinux	EXPORT_SYMBOL_GPL	
++0xcad8b7e0	inet_csk_reset_keepalive_timer	vmlinux	EXPORT_SYMBOL	
++0x8fa27de8	__traceiter_tcp_send_reset	vmlinux	EXPORT_SYMBOL_GPL	
++0x39977d84	efivar_entry_find	vmlinux	EXPORT_SYMBOL_GPL	
++0x50b88f41	usb_get_gadget_udc_name	vmlinux	EXPORT_SYMBOL_GPL	
++0xd5e392bc	dev_vprintk_emit	vmlinux	EXPORT_SYMBOL	
++0x7c9a7371	clk_prepare	vmlinux	EXPORT_SYMBOL_GPL	
++0x59311adc	rhashtable_insert_slow	vmlinux	EXPORT_SYMBOL_GPL	
++0x01866ddc	user_read	vmlinux	EXPORT_SYMBOL_GPL	
++0x766a0927	mempool_alloc_pages	vmlinux	EXPORT_SYMBOL	
++0x4c78862e	trace_define_field	vmlinux	EXPORT_SYMBOL_GPL	
++0x49788419	__tasklet_hi_schedule	vmlinux	EXPORT_SYMBOL	
++0x5e163885	read_bytes_from_xdr_buf	vmlinux	EXPORT_SYMBOL_GPL	
++0x11e9a540	arp_send	vmlinux	EXPORT_SYMBOL	
++0x07201a62	bcm_phy_set_eee	vmlinux	EXPORT_SYMBOL_GPL	
++0x2f9fde08	dma_fence_signal_locked	vmlinux	EXPORT_SYMBOL	
++0xbb0540aa	zlib_inflateReset	vmlinux	EXPORT_SYMBOL	
++0x281823c5	__kfifo_out_peek	vmlinux	EXPORT_SYMBOL	
++0xc64416e5	security_sctp_assoc_request	vmlinux	EXPORT_SYMBOL	
++0x3cdc6e52	cdev_del	vmlinux	EXPORT_SYMBOL	
++0x6df396e4	pneigh_enqueue	vmlinux	EXPORT_SYMBOL	
++0x449163c3	dev_alloc_name	vmlinux	EXPORT_SYMBOL	
++0xdb5fb89c	of_get_cpu_state_node	vmlinux	EXPORT_SYMBOL	
++0xed98ce1a	soft_cursor	vmlinux	EXPORT_SYMBOL	
++0xd0d156e9	__rht_bucket_nested	vmlinux	EXPORT_SYMBOL_GPL	
++0x89da384a	fsnotify_init_mark	vmlinux	EXPORT_SYMBOL_GPL	
++0x75e1dbbf	ping_seq_stop	vmlinux	EXPORT_SYMBOL_GPL	
++0x23abd4ff	tcp_add_backlog	vmlinux	EXPORT_SYMBOL	
++0x2c3054f9	net_inc_ingress_queue	vmlinux	EXPORT_SYMBOL_GPL	
++0xf906f207	vga_get	vmlinux	EXPORT_SYMBOL	
++0xfe37b5fa	mipi_dsi_dcs_get_display_brightness	vmlinux	EXPORT_SYMBOL	
++0xb60da15b	mipi_dsi_dcs_set_display_brightness	vmlinux	EXPORT_SYMBOL	
++0xf21c58bd	__clk_determine_rate	vmlinux	EXPORT_SYMBOL_GPL	
++0xee00eda5	security_dentry_init_security	vmlinux	EXPORT_SYMBOL	
++0x5207b9bd	generic_fh_to_dentry	vmlinux	EXPORT_SYMBOL_GPL	
++0xc583772a	filemap_fdatawait_keep_errors	vmlinux	EXPORT_SYMBOL	
++0xbbdad277	try_to_del_timer_sync	vmlinux	EXPORT_SYMBOL	
++0xd5e98641	svc_addsock	vmlinux	EXPORT_SYMBOL_GPL	
++0x17f13c4a	qdisc_offload_dump_helper	vmlinux	EXPORT_SYMBOL	
++0x9ceba8d4	dev_pm_opp_add	vmlinux	EXPORT_SYMBOL_GPL	
++0x9ae72637	usb_stor_bulk_transfer_buf	vmlinux	EXPORT_SYMBOL_GPL	USB_STORAGE
++0x025fe2f4	tty_init_termios	vmlinux	EXPORT_SYMBOL_GPL	
++0x78018864	pci_enable_device_io	vmlinux	EXPORT_SYMBOL	
++0xc91fdf58	percpu_ref_is_zero	vmlinux	EXPORT_SYMBOL_GPL	
++0x428cb5ff	nfs_statfs	vmlinux	EXPORT_SYMBOL_GPL	
++0x678b6922	__clocksource_register_scale	vmlinux	EXPORT_SYMBOL_GPL	
++0x7807f0f8	schedule_timeout_idle	vmlinux	EXPORT_SYMBOL	
++0xfe487975	init_wait_entry	vmlinux	EXPORT_SYMBOL	
++0x3145216f	pci_dev_present	vmlinux	EXPORT_SYMBOL	
++0xc3da48b9	pci_dev_put	vmlinux	EXPORT_SYMBOL	
++0x6a77d455	pci_dev_get	vmlinux	EXPORT_SYMBOL	
++0xdd1a8bae	scsi_cmd_blk_ioctl	vmlinux	EXPORT_SYMBOL	
++0x7a4e7f4e	__SCK__tp_func_pnfs_mds_fallback_read_done	vmlinux	EXPORT_SYMBOL_GPL	
++0xfef2793b	jbd2_journal_revoke	vmlinux	EXPORT_SYMBOL	
++0x0ea02d08	config_group_find_item	vmlinux	EXPORT_SYMBOL	
++0xbb7195a5	xdp_warn	vmlinux	EXPORT_SYMBOL_GPL	
++0x84a8d0eb	of_changeset_revert	vmlinux	EXPORT_SYMBOL_GPL	
++0x743ae3c1	usb_ifnum_to_if	vmlinux	EXPORT_SYMBOL_GPL	
++0xfc3d20fa	__traceiter_nvme_sq	vmlinux	EXPORT_SYMBOL_GPL	
++0x598648e4	nvme_change_ctrl_state	vmlinux	EXPORT_SYMBOL_GPL	
++0xcc9654dc	gen_pool_dma_alloc_algo	vmlinux	EXPORT_SYMBOL	
++0xf68f0cca	btree_get_prev	vmlinux	EXPORT_SYMBOL_GPL	
++0xfba7ddd2	match_u64	vmlinux	EXPORT_SYMBOL	
++0x03a65c5f	security_old_inode_init_security	vmlinux	EXPORT_SYMBOL	
++0xd49514fa	debugfs_create_x16	vmlinux	EXPORT_SYMBOL_GPL	
++0x85735c6b	fsnotify_put_group	vmlinux	EXPORT_SYMBOL_GPL	
++0x11d189b1	__tracepoint_kmem_cache_alloc_node	vmlinux	EXPORT_SYMBOL	
++0xc6779093	ring_buffer_record_enable	vmlinux	EXPORT_SYMBOL_GPL	
++0xcea58c7c	phy_device_create	vmlinux	EXPORT_SYMBOL	
++0x061651be	strcat	vmlinux	EXPORT_SYMBOL	
++0x636a8790	free_bucket_spinlocks	vmlinux	EXPORT_SYMBOL	
++0x9f31d3a7	dqstats	vmlinux	EXPORT_SYMBOL	
++0xd35cce70	_raw_spin_unlock_irqrestore	vmlinux	EXPORT_SYMBOL	
++0x7a4e6a60	tcf_classify	vmlinux	EXPORT_SYMBOL	
++0x168a294e	usb_gadget_unregister_driver	vmlinux	EXPORT_SYMBOL_GPL	
++0xbb2656b4	dma_buf_vunmap	vmlinux	EXPORT_SYMBOL_GPL	
++0xe77614d5	crypto_register_shash	vmlinux	EXPORT_SYMBOL_GPL	
++0x093cd9a6	jbd2_journal_invalidatepage	vmlinux	EXPORT_SYMBOL	
++0x5a163891	jbd2_journal_get_write_access	vmlinux	EXPORT_SYMBOL	
++0xe018280b	xprt_unlock_connect	vmlinux	EXPORT_SYMBOL_GPL	
++0xfc1618f2	xfrm_register_type_offload	vmlinux	EXPORT_SYMBOL	
++0xbc57ba3e	pfifo_qdisc_ops	vmlinux	EXPORT_SYMBOL	
++0x0af79ac3	i2c_transfer_buffer_flags	vmlinux	EXPORT_SYMBOL	
++0x722dd8dd	device_change_owner	vmlinux	EXPORT_SYMBOL_GPL	
++0xbdadf644	pwm_adjust_config	vmlinux	EXPORT_SYMBOL_GPL	
++0x0ebb8279	radix_tree_insert	vmlinux	EXPORT_SYMBOL	
++0x2ac249fa	vfs_listxattr	vmlinux	EXPORT_SYMBOL_GPL	
++0xd07cce7c	kern_mount	vmlinux	EXPORT_SYMBOL_GPL	
++0x83041304	__check_sticky	vmlinux	EXPORT_SYMBOL	
++0xc9c95e78	page_cache_ra_unbounded	vmlinux	EXPORT_SYMBOL_GPL	
++0x26c3158f	find_get_pages_contig	vmlinux	EXPORT_SYMBOL	
++0x133969d7	__trace_printk	vmlinux	EXPORT_SYMBOL_GPL	
++0xca4c8e57	xfrm_state_walk_done	vmlinux	EXPORT_SYMBOL	
++0x8de8592a	qdisc_create_dflt	vmlinux	EXPORT_SYMBOL	
++0x38e3b587	flow_rule_match_ipv6_addrs	vmlinux	EXPORT_SYMBOL	
++0x503534e3	flow_rule_match_ipv4_addrs	vmlinux	EXPORT_SYMBOL	
++0x7e37502c	netdev_name_node_alt_destroy	vmlinux	EXPORT_SYMBOL	
++0x20939fd1	sock_bind_add	vmlinux	EXPORT_SYMBOL	
++0xca73c608	of_reserved_mem_device_release	vmlinux	EXPORT_SYMBOL_GPL	
++0x649409ab	usbnet_defer_kevent	vmlinux	EXPORT_SYMBOL_GPL	
++0x22cdd0f8	uart_add_one_port	vmlinux	EXPORT_SYMBOL	
++0x4860a2b9	clk_divider_ops	vmlinux	EXPORT_SYMBOL_GPL	
++0x9a148d6e	key_put	vmlinux	EXPORT_SYMBOL	
++0x46ae414b	bmap	vmlinux	EXPORT_SYMBOL	
++0x66b4cc41	kmemdup	vmlinux	EXPORT_SYMBOL	
++0xc5f64572	dma_free_pages	vmlinux	EXPORT_SYMBOL_GPL	
++0x5dcd7668	param_set_hexint	vmlinux	EXPORT_SYMBOL	
++0x6e60c8d1	_copy_from_pages	vmlinux	EXPORT_SYMBOL_GPL	
++0xa99b39c2	prandom_bytes	vmlinux	EXPORT_SYMBOL	
++0x25e12aca	generic_parse_monolithic	vmlinux	EXPORT_SYMBOL	
++0x19e18423	tcp_gro_complete	vmlinux	EXPORT_SYMBOL	
++0xe970c686	tcp_register_congestion_control	vmlinux	EXPORT_SYMBOL_GPL	
++0xd22628c4	tcp_release_cb	vmlinux	EXPORT_SYMBOL	
++0xb6ec4277	skb_gso_validate_network_len	vmlinux	EXPORT_SYMBOL_GPL	
++0x3882e364	usb_phy_set_event	vmlinux	EXPORT_SYMBOL_GPL	
++0x057ab489	dma_buf_fd	vmlinux	EXPORT_SYMBOL_GPL	
++0x760f163b	devm_platform_ioremap_resource_byname	vmlinux	EXPORT_SYMBOL_GPL	
++0xead54924	mctrl_gpio_to_gpiod	vmlinux	EXPORT_SYMBOL_GPL	
++0xb868ac5c	register_sysrq_key	vmlinux	EXPORT_SYMBOL	
++0x6181e79f	timerqueue_add	vmlinux	EXPORT_SYMBOL_GPL	
++0xbb216010	kstrdup_quotable_file	vmlinux	EXPORT_SYMBOL_GPL	
++0x9764d954	refcount_dec_and_mutex_lock	vmlinux	EXPORT_SYMBOL	
++0xdd160517	sync_filesystem	vmlinux	EXPORT_SYMBOL	
++0x426ad690	tcp_connect	vmlinux	EXPORT_SYMBOL	
++0x9330662d	qdisc_watchdog_init_clockid	vmlinux	EXPORT_SYMBOL	
++0xa0619120	neigh_table_clear	vmlinux	EXPORT_SYMBOL	
++0x77ecf68d	memalloc_socks_key	vmlinux	EXPORT_SYMBOL_GPL	
++0xdac54c2a	led_trigger_event	vmlinux	EXPORT_SYMBOL_GPL	
++0xbd65dad9	thermal_zone_bind_cooling_device	vmlinux	EXPORT_SYMBOL_GPL	
++0x00aac1f7	of_phy_find_device	vmlinux	EXPORT_SYMBOL	
++0xdfa78e34	device_match_fwnode	vmlinux	EXPORT_SYMBOL_GPL	
++0x2396c7f0	clk_set_parent	vmlinux	EXPORT_SYMBOL_GPL	
++0x63150e06	clk_get_parent	vmlinux	EXPORT_SYMBOL_GPL	
++0x1561fa64	pnfs_generic_pg_check_layout	vmlinux	EXPORT_SYMBOL_GPL	
++0x30496988	__tracepoint_nfs_fsync_enter	vmlinux	EXPORT_SYMBOL_GPL	
++0x68c5c4b1	dma_sync_sg_for_cpu	vmlinux	EXPORT_SYMBOL	
++0xf95322f4	kthread_parkme	vmlinux	EXPORT_SYMBOL_GPL	
++0x4067cbfb	__cpuhp_remove_state	vmlinux	EXPORT_SYMBOL	
++0x37a02412	xfrm_aalg_get_byname	vmlinux	EXPORT_SYMBOL_GPL	
++0x68dba186	xfrm_state_flush	vmlinux	EXPORT_SYMBOL	
++0x793fa828	pci_fixup_device	vmlinux	EXPORT_SYMBOL	
++0x595bd096	xas_init_marks	vmlinux	EXPORT_SYMBOL_GPL	
++0x2a9e8098	fat_flush_inodes	vmlinux	EXPORT_SYMBOL_GPL	
++0xadeac67b	__dquot_alloc_space	vmlinux	EXPORT_SYMBOL	
++0x6e308ade	stream_open	vmlinux	EXPORT_SYMBOL	
++0x84a85328	xfrm_find_acq_byseq	vmlinux	EXPORT_SYMBOL	
++0x35993e13	xfrm_policy_unregister_afinfo	vmlinux	EXPORT_SYMBOL	
++0x19fcef7f	reuseport_detach_sock	vmlinux	EXPORT_SYMBOL	
++0x9d897792	skb_zerocopy_iter_stream	vmlinux	EXPORT_SYMBOL_GPL	
++0xf08c67de	napi_alloc_frag	vmlinux	EXPORT_SYMBOL	
++0xfa61512e	governor_sysfs_ops	vmlinux	EXPORT_SYMBOL_GPL	
++0x665da36c	nfs_wait_on_request	vmlinux	EXPORT_SYMBOL_GPL	
++0xac73b511	__vfs_removexattr_locked	vmlinux	EXPORT_SYMBOL_GPL	
++0x054496b4	schedule_timeout_interruptible	vmlinux	EXPORT_SYMBOL	
++0x16043937	secpath_set	vmlinux	EXPORT_SYMBOL	
++0xb83144eb	sdio_retune_release	vmlinux	EXPORT_SYMBOL_GPL	
++0x266f685f	dma_buf_detach	vmlinux	EXPORT_SYMBOL_GPL	
++0x427d9ef6	dma_buf_attach	vmlinux	EXPORT_SYMBOL_GPL	
++0xefe69fb3	fwnode_create_software_node	vmlinux	EXPORT_SYMBOL_GPL	
++0x6be024d1	devm_kasprintf	vmlinux	EXPORT_SYMBOL_GPL	
++0xdac4913a	bitmap_allocate_region	vmlinux	EXPORT_SYMBOL	
++0x65e0d6d7	memory_read_from_buffer	vmlinux	EXPORT_SYMBOL	
++0xdb502837	seq_read_iter	vmlinux	EXPORT_SYMBOL	
++0x959b2b03	alarmtimer_get_rtcdev	vmlinux	EXPORT_SYMBOL_GPL	
++0x6e588ab3	xprt_force_disconnect	vmlinux	EXPORT_SYMBOL_GPL	
++0xb01bebf9	xfrm_get_acqseq	vmlinux	EXPORT_SYMBOL	
++0x8904c9aa	dev_pm_opp_of_add_table	vmlinux	EXPORT_SYMBOL_GPL	
++0x60f671e9	__DWC_DMA_ALLOC_ATOMIC	vmlinux	EXPORT_SYMBOL	
++0x36b0e1b6	__scsi_iterate_devices	vmlinux	EXPORT_SYMBOL	
++0x14605535	dma_fence_context_alloc	vmlinux	EXPORT_SYMBOL	
++0x5ef67fa5	mipi_dsi_dcs_set_pixel_format	vmlinux	EXPORT_SYMBOL	
++0x0028e165	mipi_dsi_dcs_get_pixel_format	vmlinux	EXPORT_SYMBOL	
++0x5dffb495	ZSTD_decompress_usingDDict	vmlinux	EXPORT_SYMBOL	
++0xaafd4acc	max_session_cb_slots	vmlinux	EXPORT_SYMBOL_GPL	
++0x7ad050b9	qid_lt	vmlinux	EXPORT_SYMBOL	
++0xdfd68210	fscrypt_set_context	vmlinux	EXPORT_SYMBOL_GPL	
++0x6140c3bb	svc_reserve	vmlinux	EXPORT_SYMBOL_GPL	
++0xa1498502	qdisc_put	vmlinux	EXPORT_SYMBOL	
++0x449c3c06	eth_gro_receive	vmlinux	EXPORT_SYMBOL	
++0xc2b9773a	__tracepoint_neigh_update_done	vmlinux	EXPORT_SYMBOL_GPL	
++0x71e829cd	genphy_c45_restart_aneg	vmlinux	EXPORT_SYMBOL_GPL	
++0x79625618	dma_fence_chain_find_seqno	vmlinux	EXPORT_SYMBOL	
++0xaf307b4a	platform_bus	vmlinux	EXPORT_SYMBOL_GPL	
++0x56a62af8	xa_extract	vmlinux	EXPORT_SYMBOL	
++0xcb33615a	blk_queue_bounce_limit	vmlinux	EXPORT_SYMBOL	
++0x55339365	flush_delayed_fput	vmlinux	EXPORT_SYMBOL_GPL	
++0x40f8b94e	ring_buffer_iter_dropped	vmlinux	EXPORT_SYMBOL_GPL	
++0xdd9bf6e8	__traceiter_sched_cpu_capacity_tp	vmlinux	EXPORT_SYMBOL_GPL	
++0xfee34aad	netpoll_setup	vmlinux	EXPORT_SYMBOL	
++0x367e7c75	skb_abort_seq_read	vmlinux	EXPORT_SYMBOL	
++0xb7ffedf8	phy_ethtool_get_strings	vmlinux	EXPORT_SYMBOL	
++0xaf44e727	iscsi_host_for_each_session	vmlinux	EXPORT_SYMBOL_GPL	
++0xe23a20a2	iscsi_create_flashnode_sess	vmlinux	EXPORT_SYMBOL_GPL	
++0x10d9f885	scsi_sense_desc_find	vmlinux	EXPORT_SYMBOL	
++0x72b9d287	default_grn	vmlinux	EXPORT_SYMBOL	
++0x21c5e174	clk_hw_register_composite	vmlinux	EXPORT_SYMBOL_GPL	
++0x877a719b	devm_clk_get_optional	vmlinux	EXPORT_SYMBOL	
++0xfea29a26	blk_queue_split	vmlinux	EXPORT_SYMBOL	
++0x6b3664c3	remove_resource	vmlinux	EXPORT_SYMBOL_GPL	
++0x604fdf02	tcp_getsockopt	vmlinux	EXPORT_SYMBOL	
++0x64cf951b	tcp_setsockopt	vmlinux	EXPORT_SYMBOL	
++0x3d707c89	rtnl_unicast	vmlinux	EXPORT_SYMBOL	
++0x63219973	refresh_frequency_limits	vmlinux	EXPORT_SYMBOL	
++0xef464c28	getboottime64	vmlinux	EXPORT_SYMBOL_GPL	
++0x047b6cb3	dequeue_signal	vmlinux	EXPORT_SYMBOL_GPL	
++0x6d0de231	bcm54xx_auxctl_read	vmlinux	EXPORT_SYMBOL_GPL	
++0x62bb09bf	clocks_calc_mult_shift	vmlinux	EXPORT_SYMBOL_GPL	
++0xe455ad73	flow_rule_match_mpls	vmlinux	EXPORT_SYMBOL	
++0x76551230	flow_rule_match_icmp	vmlinux	EXPORT_SYMBOL	
++0x1653f86e	flow_rule_match_meta	vmlinux	EXPORT_SYMBOL	
++0xa1d48657	usbnet_device_suggests_idle	vmlinux	EXPORT_SYMBOL	
++0xea435a32	nvme_setup_cmd	vmlinux	EXPORT_SYMBOL_GPL	
++0x7cf3be0a	__nla_reserve_64bit	vmlinux	EXPORT_SYMBOL	
++0x2f5410ab	pnfs_set_lo_fail	vmlinux	EXPORT_SYMBOL_GPL	
++0x319023e9	fget_raw	vmlinux	EXPORT_SYMBOL	
++0xe4aca6c3	atomic_notifier_call_chain	vmlinux	EXPORT_SYMBOL_GPL	
++0x82dfd8bb	spi_add_device	vmlinux	EXPORT_SYMBOL_GPL	
++0x64b62862	nvme_wq	vmlinux	EXPORT_SYMBOL_GPL	
++0xdf37812e	pci_reset_function_locked	vmlinux	EXPORT_SYMBOL_GPL	
++0x16e6c123	pinctrl_add_gpio_ranges	vmlinux	EXPORT_SYMBOL_GPL	
++0xf9b1dea8	phy_pm_runtime_forbid	vmlinux	EXPORT_SYMBOL_GPL	
++0x8544f980	dev_change_net_namespace	vmlinux	EXPORT_SYMBOL_GPL	
++0x1733c573	mmc_get_ext_csd	vmlinux	EXPORT_SYMBOL_GPL	
++0x6615b5fc	pci_rescan_bus	vmlinux	EXPORT_SYMBOL_GPL	
++0xf1acf476	gen_pool_has_addr	vmlinux	EXPORT_SYMBOL	
++0x3c3e49aa	blk_queue_rq_timeout	vmlinux	EXPORT_SYMBOL_GPL	
++0x510d4165	blk_queue_flag_clear	vmlinux	EXPORT_SYMBOL	
++0x4110bbf4	nfs_path	vmlinux	EXPORT_SYMBOL_GPL	
++0xf4a1b7e2	cache_seq_stop_rcu	vmlinux	EXPORT_SYMBOL_GPL	
++0x73a7fe0e	xdr_init_decode_pages	vmlinux	EXPORT_SYMBOL_GPL	
++0xc0e73644	tcp_twsk_destructor	vmlinux	EXPORT_SYMBOL_GPL	
++0x7e071d51	scm_detach_fds	vmlinux	EXPORT_SYMBOL	
++0xe4c2c66c	rtc_ktime_to_tm	vmlinux	EXPORT_SYMBOL_GPL	
++0xff33f892	usb_stor_pre_reset	vmlinux	EXPORT_SYMBOL_GPL	USB_STORAGE
++0x2f99b2fe	scsi_ioctl_block_when_processing_errors	vmlinux	EXPORT_SYMBOL_GPL	
++0xf8d93d6a	dma_buf_pin	vmlinux	EXPORT_SYMBOL_GPL	
++0x1e0670c6	reset_control_release	vmlinux	EXPORT_SYMBOL_GPL	
++0x9a1a74c3	__tracepoint_nfs4_pnfs_write	vmlinux	EXPORT_SYMBOL_GPL	
++0x89e68c72	nfs_mknod	vmlinux	EXPORT_SYMBOL_GPL	
++0xef70383b	put_pid	vmlinux	EXPORT_SYMBOL_GPL	
++0xdb93e303	of_count_phandle_with_args	vmlinux	EXPORT_SYMBOL	
++0xa8add702	__efivar_entry_delete	vmlinux	EXPORT_SYMBOL_GPL	
++0x0395c06b	regmap_bulk_read	vmlinux	EXPORT_SYMBOL_GPL	
++0x4981a2c9	dev_pm_domain_attach	vmlinux	EXPORT_SYMBOL_GPL	
++0x47ee1adf	fwnode_device_is_available	vmlinux	EXPORT_SYMBOL_GPL	
++0xb3456796	driver_find_device	vmlinux	EXPORT_SYMBOL_GPL	
++0xf64184bf	regulator_is_equal	vmlinux	EXPORT_SYMBOL_GPL	
++0x5aa82dcb	pci_user_read_config_byte	vmlinux	EXPORT_SYMBOL_GPL	
++0x8122b77d	pinconf_generic_parse_dt_config	vmlinux	EXPORT_SYMBOL_GPL	
++0xd04ae7b4	pinctrl_parse_index_with_args	vmlinux	EXPORT_SYMBOL_GPL	
++0xb5b3141b	__inode_attach_wb	vmlinux	EXPORT_SYMBOL_GPL	
++0xa2d7ec8d	__SCK__tp_func_kmem_cache_free	vmlinux	EXPORT_SYMBOL	
++0x956ac400	ring_buffer_dropped_events_cpu	vmlinux	EXPORT_SYMBOL_GPL	
++0x1fd07fff	kdb_grepping_flag	vmlinux	EXPORT_SYMBOL	
++0x099c2fc2	posix_clock_register	vmlinux	EXPORT_SYMBOL_GPL	
++0xd21b61bd	async_schedule_node_domain	vmlinux	EXPORT_SYMBOL_GPL	
++0x23379ae6	usbnet_read_cmd_nopm	vmlinux	EXPORT_SYMBOL_GPL	
++0x41adbd49	spi_mem_default_supports_op	vmlinux	EXPORT_SYMBOL_GPL	
++0x58d31219	get_default_font	vmlinux	EXPORT_SYMBOL	
++0x8abb689e	blk_get_request	vmlinux	EXPORT_SYMBOL	
++0x25bbbcb2	__set_page_dirty	vmlinux	EXPORT_SYMBOL_GPL	
++0x37a10030	bpf_prog_free	vmlinux	EXPORT_SYMBOL_GPL	
++0x9da6620f	kthread_data	vmlinux	EXPORT_SYMBOL_GPL	
++0x1526b301	unix_tot_inflight	vmlinux	EXPORT_SYMBOL	
++0x00c80741	xfrm_ealg_get_byid	vmlinux	EXPORT_SYMBOL_GPL	
++0xee6b71c4	syscon_regmap_lookup_by_compatible	vmlinux	EXPORT_SYMBOL_GPL	
++0x2b3adf02	request_partial_firmware_into_buf	vmlinux	EXPORT_SYMBOL	
++0x64023969	of_mm_gpiochip_remove	vmlinux	EXPORT_SYMBOL_GPL	
++0x5a44f8cb	__crypto_memneq	vmlinux	EXPORT_SYMBOL	
++0x8f8fbced	bio_uninit	vmlinux	EXPORT_SYMBOL	
++0x56054c05	crypto_it_tab	vmlinux	EXPORT_SYMBOL_GPL	
++0x1a10c32b	crypto_ft_tab	vmlinux	EXPORT_SYMBOL_GPL	
++0x6d6fec1f	ktime_mono_to_any	vmlinux	EXPORT_SYMBOL_GPL	
++0xe8219c46	irq_chip_set_vcpu_affinity_parent	vmlinux	EXPORT_SYMBOL_GPL	
++0x92e683f5	down_timeout	vmlinux	EXPORT_SYMBOL	
++0x2b4a0374	proc_do_large_bitmap	vmlinux	EXPORT_SYMBOL	
++0x9d555ceb	xprt_update_rtt	vmlinux	EXPORT_SYMBOL_GPL	
++0xa4d54941	of_reserved_mem_lookup	vmlinux	EXPORT_SYMBOL_GPL	
++0xffa56a71	devm_platform_ioremap_resource	vmlinux	EXPORT_SYMBOL_GPL	
++0xe850a395	mipi_dsi_dcs_write	vmlinux	EXPORT_SYMBOL	
++0xd5301b2c	linear_range_get_max_value	vmlinux	EXPORT_SYMBOL_GPL	
++0xf496428b	__fscache_attr_changed	vmlinux	EXPORT_SYMBOL	
++0x74e73871	housekeeping_overridden	vmlinux	EXPORT_SYMBOL_GPL	
++0xee83c440	dst_blackhole_redirect	vmlinux	EXPORT_SYMBOL_GPL	
++0x102f54c4	misc_deregister	vmlinux	EXPORT_SYMBOL	
++0x3f0eabd2	xxh64_update	vmlinux	EXPORT_SYMBOL	
++0x45535485	xxh32_update	vmlinux	EXPORT_SYMBOL	
++0x27ad47ea	__SCK__tp_func_pnfs_mds_fallback_write_done	vmlinux	EXPORT_SYMBOL_GPL	
++0x90a5530f	nfsiod_workqueue	vmlinux	EXPORT_SYMBOL_GPL	
++0x5c29d971	iomap_ioend_try_merge	vmlinux	EXPORT_SYMBOL_GPL	
++0x953018e7	blkdev_fsync	vmlinux	EXPORT_SYMBOL	
++0x694b7372	lookup_one_len	vmlinux	EXPORT_SYMBOL	
++0xcde042ac	relay_buf_full	vmlinux	EXPORT_SYMBOL_GPL	
++0x32ab06cc	irq_percpu_is_enabled	vmlinux	EXPORT_SYMBOL_GPL	
++0x47c65bfc	unregister_inet6addr_validator_notifier	vmlinux	EXPORT_SYMBOL	
++0xf68285c0	register_inetaddr_notifier	vmlinux	EXPORT_SYMBOL	
++0xf060e6d6	skb_segment_list	vmlinux	EXPORT_SYMBOL_GPL	
++0x765b7c36	skb_headers_offset_update	vmlinux	EXPORT_SYMBOL	
++0x7afc9d8a	unregister_sound_mixer	vmlinux	EXPORT_SYMBOL	
++0x0c8acfc1	extcon_set_property_sync	vmlinux	EXPORT_SYMBOL_GPL	
++0x4351577a	fb_parse_edid	vmlinux	EXPORT_SYMBOL	
++0x696e277c	xa_find	vmlinux	EXPORT_SYMBOL	
++0x5d5d3109	fscrypt_ioctl_add_key	vmlinux	EXPORT_SYMBOL_GPL	
++0xc76993eb	kgdb_unregister_io_module	vmlinux	EXPORT_SYMBOL_GPL	
++0x9eeb4184	atomic_dec_and_mutex_lock	vmlinux	EXPORT_SYMBOL	
++0xc51f5afb	kthread_delayed_work_timer_fn	vmlinux	EXPORT_SYMBOL	
++0xceacd76a	ip_sock_set_tos	vmlinux	EXPORT_SYMBOL	
++0x2ce61f33	__SCK__tp_func_br_fdb_add	vmlinux	EXPORT_SYMBOL_GPL	
++0x05086314	regmap_noinc_write	vmlinux	EXPORT_SYMBOL_GPL	
++0x6161100a	devres_get	vmlinux	EXPORT_SYMBOL_GPL	
++0x1575a1cc	devres_add	vmlinux	EXPORT_SYMBOL_GPL	
++0x6a562d5c	device_link_remove	vmlinux	EXPORT_SYMBOL_GPL	
++0x49fb87b3	mipi_dsi_picture_parameter_set	vmlinux	EXPORT_SYMBOL	
++0xf7f3f2ca	serial8250_set_defaults	vmlinux	EXPORT_SYMBOL_GPL	
++0xcd47435e	crypto_grab_shash	vmlinux	EXPORT_SYMBOL_GPL	
++0x53f51779	crypto_grab_ahash	vmlinux	EXPORT_SYMBOL_GPL	
++0x977a7841	fscrypt_free_inode	vmlinux	EXPORT_SYMBOL	
++0x383d8e39	kernel_read_file_from_path_initns	vmlinux	EXPORT_SYMBOL_GPL	
++0x6a99706d	inode_set_flags	vmlinux	EXPORT_SYMBOL	
++0xde5b5ae1	dma_mmap_attrs	vmlinux	EXPORT_SYMBOL	
++0x38670537	ip_frag_init	vmlinux	EXPORT_SYMBOL	
++0xf55fa2fb	led_trigger_blink_oneshot	vmlinux	EXPORT_SYMBOL_GPL	
++0x131a5ed7	regmap_del_irq_chip	vmlinux	EXPORT_SYMBOL_GPL	
++0x59b799c7	regmap_add_irq_chip	vmlinux	EXPORT_SYMBOL_GPL	
++0xc6b8b337	clk_fixed_rate_ops	vmlinux	EXPORT_SYMBOL_GPL	
++0xce0b833a	pci_set_mwi	vmlinux	EXPORT_SYMBOL	
++0x8ceb10f6	nfs_free_client	vmlinux	EXPORT_SYMBOL_GPL	
++0x5d08ae13	sync_inodes_sb	vmlinux	EXPORT_SYMBOL	
++0x6091b333	unregister_chrdev_region	vmlinux	EXPORT_SYMBOL	
++0xd9bf7cd0	generic_writepages	vmlinux	EXPORT_SYMBOL	
++0xcac93b95	mempool_init	vmlinux	EXPORT_SYMBOL	
++0xee7e54e9	mempool_exit	vmlinux	EXPORT_SYMBOL	
++0xb7e9f47f	cpu_resume	vmlinux	EXPORT_SYMBOL_GPL	
++0xd77ef6c8	udp_cmsg_send	vmlinux	EXPORT_SYMBOL_GPL	
++0x43bdd607	usb_add_phy	vmlinux	EXPORT_SYMBOL_GPL	
++0x58acf24b	mdiobus_register_board_info	vmlinux	EXPORT_SYMBOL	
++0x87ca7fca	gpiochip_is_requested	vmlinux	EXPORT_SYMBOL_GPL	
++0x92ed05f0	blk_set_default_limits	vmlinux	EXPORT_SYMBOL	
++0x13afb3f5	dquot_get_next_dqblk	vmlinux	EXPORT_SYMBOL	
++0x00b4e615	posix_acl_equiv_mode	vmlinux	EXPORT_SYMBOL	
++0x988389ce	__udp_disconnect	vmlinux	EXPORT_SYMBOL	
++0xe335bd21	sock_from_file	vmlinux	EXPORT_SYMBOL	
++0x4162c7a6	cpufreq_generic_attr	vmlinux	EXPORT_SYMBOL_GPL	
++0x1cd34995	cpufreq_generic_init	vmlinux	EXPORT_SYMBOL_GPL	
++0x8055ac50	dev_pm_opp_set_bw	vmlinux	EXPORT_SYMBOL_GPL	
++0xb34184f0	lookup_bdev	vmlinux	EXPORT_SYMBOL	
++0xc839c1ce	trace_seq_to_user	vmlinux	EXPORT_SYMBOL_GPL	
++0x4e66a9ee	clockevents_config_and_register	vmlinux	EXPORT_SYMBOL_GPL	
++0x2391f725	irq_stat	vmlinux	EXPORT_SYMBOL	
++0x5f098b2a	in6addr_interfacelocal_allrouters	vmlinux	EXPORT_SYMBOL	
++0x7a8ca627	xfrm_count_pfkey_enc_supported	vmlinux	EXPORT_SYMBOL_GPL	
++0x76fa069a	raw_seq_stop	vmlinux	EXPORT_SYMBOL_GPL	
++0xd88b8b3c	inet_proto_csum_replace_by_diff	vmlinux	EXPORT_SYMBOL	
++0xfa690589	netdev_cmd_to_name	vmlinux	EXPORT_SYMBOL_GPL	
++0x8196ecc7	gnet_stats_copy_basic	vmlinux	EXPORT_SYMBOL	
++0x02815b5a	mmc_pwrseq_register	vmlinux	EXPORT_SYMBOL_GPL	
++0x3bf17755	mpi_read_buffer	vmlinux	EXPORT_SYMBOL_GPL	
++0x7442f0f9	percpu_counter_destroy	vmlinux	EXPORT_SYMBOL	
++0xdfe85d2f	vfs_parse_fs_param_source	vmlinux	EXPORT_SYMBOL	
++0xdf3200c0	vm_map_ram	vmlinux	EXPORT_SYMBOL	
++0x2cd0c130	filemap_fdatawrite_range	vmlinux	EXPORT_SYMBOL	
++0x4467b14b	inet_sendmsg	vmlinux	EXPORT_SYMBOL	
++0x623b4734	hidinput_report_event	vmlinux	EXPORT_SYMBOL_GPL	
++0x6d1fa473	usb_gen_phy_shutdown	vmlinux	EXPORT_SYMBOL_GPL	
++0x41336635	elevator_alloc	vmlinux	EXPORT_SYMBOL	
++0x6a378197	crypto_alg_sem	vmlinux	EXPORT_SYMBOL_GPL	
++0x752fd834	__iomap_dio_rw	vmlinux	EXPORT_SYMBOL_GPL	
++0x43aa319e	lease_register_notifier	vmlinux	EXPORT_SYMBOL_GPL	
++0x9067e1e9	__getblk_gfp	vmlinux	EXPORT_SYMBOL	
++0x944aa0c0	rpc_call_async	vmlinux	EXPORT_SYMBOL_GPL	
++0x49f2dd22	netlink_strict_get_check	vmlinux	EXPORT_SYMBOL_GPL	
++0xadd139d4	rfs_needed	vmlinux	EXPORT_SYMBOL	
++0x56802ae8	rps_cpu_mask	vmlinux	EXPORT_SYMBOL	
++0x30e1e728	extcon_dev_register	vmlinux	EXPORT_SYMBOL_GPL	
++0x18bf22ce	inverse_translate	vmlinux	EXPORT_SYMBOL_GPL	
++0x932c8d7a	linear_range_get_value_array	vmlinux	EXPORT_SYMBOL_GPL	
++0x81ac5e33	trace_print_hex_dump_seq	vmlinux	EXPORT_SYMBOL	
++0x49242bc7	freezer_cgrp_subsys_on_dfl_key	vmlinux	EXPORT_SYMBOL_GPL	
++0x08890b2e	flush_rcu_work	vmlinux	EXPORT_SYMBOL	
++0x8e5df49d	__cpuhp_state_remove_instance	vmlinux	EXPORT_SYMBOL_GPL	
++0xfe029963	unregister_inetaddr_notifier	vmlinux	EXPORT_SYMBOL	
++0x8c0b0438	mipi_dsi_compression_mode	vmlinux	EXPORT_SYMBOL	
++0xb42f03e4	clk_request_done	vmlinux	EXPORT_SYMBOL_GPL	
++0x0ff1919e	amba_release_regions	vmlinux	EXPORT_SYMBOL	
++0x61ea189b	fb_pad_aligned_buffer	vmlinux	EXPORT_SYMBOL	
++0x1a9a433c	prandom_u32_state	vmlinux	EXPORT_SYMBOL	
++0x90a4fe2c	elv_rqhash_add	vmlinux	EXPORT_SYMBOL_GPL	
++0x32e0bda6	get_kernel_pages	vmlinux	EXPORT_SYMBOL_GPL	
++0x4d2fa166	perf_event_enable	vmlinux	EXPORT_SYMBOL_GPL	
++0xe05e2f85	nexthop_free_rcu	vmlinux	EXPORT_SYMBOL_GPL	
++0xb90d4f14	od_register_powersave_bias_handler	vmlinux	EXPORT_SYMBOL_GPL	
++0xdb533332	phy_reset_after_clk_enable	vmlinux	EXPORT_SYMBOL	
++0x612bfd89	errno_to_blk_status	vmlinux	EXPORT_SYMBOL_GPL	
++0x13889a7c	nobh_write_begin	vmlinux	EXPORT_SYMBOL	
++0x59b8e94d	filemap_check_errors	vmlinux	EXPORT_SYMBOL	
++0x8d3330b6	cpuacct_cgrp_subsys_enabled_key	vmlinux	EXPORT_SYMBOL_GPL	
++0x3ae0ebf6	xfrm_state_free	vmlinux	EXPORT_SYMBOL	
++0x1915a37d	nf_hook_entries_delete_raw	vmlinux	EXPORT_SYMBOL_GPL	
++0x56d95de2	netlink_ack	vmlinux	EXPORT_SYMBOL	
++0x3b21b738	sock_no_bind	vmlinux	EXPORT_SYMBOL	
++0xd738ca1b	phy_unregister_fixup_for_uid	vmlinux	EXPORT_SYMBOL	
++0x96f7c3ce	iscsi_register_transport	vmlinux	EXPORT_SYMBOL_GPL	
++0xc0723e01	dmaengine_unmap_put	vmlinux	EXPORT_SYMBOL_GPL	
++0x63c08029	clk_bulk_unprepare	vmlinux	EXPORT_SYMBOL_GPL	
++0x35a88f28	zlib_inflateInit2	vmlinux	EXPORT_SYMBOL	
++0xbe618d08	nfs_post_op_update_inode_force_wcc	vmlinux	EXPORT_SYMBOL_GPL	
++0x55581523	param_set_charp	vmlinux	EXPORT_SYMBOL	
++0x6e4e566e	xfrm_unregister_type_offload	vmlinux	EXPORT_SYMBOL	
++0xa9f095db	serdev_device_write_wakeup	vmlinux	EXPORT_SYMBOL_GPL	
++0xab6809de	blkg_lookup_slowpath	vmlinux	EXPORT_SYMBOL_GPL	
++0x4071b517	out_of_line_wait_on_bit_timeout	vmlinux	EXPORT_SYMBOL_GPL	
++0xa55a83b1	flow_rule_match_enc_keyid	vmlinux	EXPORT_SYMBOL	
++0x72725815	set_primary_fwnode	vmlinux	EXPORT_SYMBOL_GPL	
++0xf956e7f0	gen_pool_dma_alloc_align	vmlinux	EXPORT_SYMBOL	
++0x4cb81fda	__SCK__tp_func_wbc_writepage	vmlinux	EXPORT_SYMBOL_GPL	
++0x91a7b1da	qdisc_class_hash_remove	vmlinux	EXPORT_SYMBOL	
++0x70634a8a	__put_net	vmlinux	EXPORT_SYMBOL_GPL	
++0x5cfbfa3c	usb_gadget_vbus_disconnect	vmlinux	EXPORT_SYMBOL_GPL	
++0x0af62869	dma_fence_wait_timeout	vmlinux	EXPORT_SYMBOL	
++0x84324542	transport_destroy_device	vmlinux	EXPORT_SYMBOL_GPL	
++0x73206745	serial8250_tx_chars	vmlinux	EXPORT_SYMBOL_GPL	
++0x58d54e3b	gpiochip_enable_irq	vmlinux	EXPORT_SYMBOL_GPL	
++0x2123d603	blk_mq_alloc_tag_set	vmlinux	EXPORT_SYMBOL	
++0xa1f2fa28	blk_steal_bios	vmlinux	EXPORT_SYMBOL_GPL	
++0xc29b09b6	tcf_block_get_ext	vmlinux	EXPORT_SYMBOL	
++0xc3228684	thermal_cdev_update	vmlinux	EXPORT_SYMBOL	
++0x485d4584	tty_unregister_device	vmlinux	EXPORT_SYMBOL	
++0x4ec54e78	bitmap_to_arr32	vmlinux	EXPORT_SYMBOL	
++0xf311e156	key_being_used_for	vmlinux	EXPORT_SYMBOL_GPL	
++0xcc594611	crypto_register_skciphers	vmlinux	EXPORT_SYMBOL_GPL	
++0xd6fde043	is_module_sig_enforced	vmlinux	EXPORT_SYMBOL	
++0xf3808cb1	get_state_synchronize_rcu	vmlinux	EXPORT_SYMBOL_GPL	
++0xfb481954	vprintk	vmlinux	EXPORT_SYMBOL	
++0xb3bcd28b	__udp4_lib_lookup	vmlinux	EXPORT_SYMBOL_GPL	
++0x0f95f9bf	tcp_poll	vmlinux	EXPORT_SYMBOL	
++0x32062d5b	netdev_lower_get_next_private	vmlinux	EXPORT_SYMBOL	
++0xac94e86b	vsprintf	vmlinux	EXPORT_SYMBOL	
++0xb0886c2e	generic_splice_sendpage	vmlinux	EXPORT_SYMBOL	
++0x2d319c37	dma_max_mapping_size	vmlinux	EXPORT_SYMBOL_GPL	
++0x4b638b30	dma_map_resource	vmlinux	EXPORT_SYMBOL	
++0xa1f5ae2e	ip_do_fragment	vmlinux	EXPORT_SYMBOL	
++0xe136c960	attribute_container_find_class_device	vmlinux	EXPORT_SYMBOL_GPL	
++0x9ad012d4	pwm_request_from_chip	vmlinux	EXPORT_SYMBOL_GPL	
++0x8dbac5ca	register_key_type	vmlinux	EXPORT_SYMBOL	
++0xf103d80c	grab_cache_page_write_begin	vmlinux	EXPORT_SYMBOL	
++0xd72ad0eb	rt_mutex_lock_interruptible	vmlinux	EXPORT_SYMBOL_GPL	
++0x9ac18356	scsi_host_busy_iter	vmlinux	EXPORT_SYMBOL_GPL	
++0xfeb35bd2	pci_disable_link_state_locked	vmlinux	EXPORT_SYMBOL	
++0xf7fac0b7	_copy_to_iter	vmlinux	EXPORT_SYMBOL	
++0x29c2c17b	blkg_conf_finish	vmlinux	EXPORT_SYMBOL_GPL	
++0xabf32f29	utf16s_to_utf8s	vmlinux	EXPORT_SYMBOL	
++0x2a578783	iomap_swapfile_activate	vmlinux	EXPORT_SYMBOL_GPL	
++0xee6c633a	devices_cgrp_subsys_on_dfl_key	vmlinux	EXPORT_SYMBOL_GPL	
++0xc4b5bd08	__cond_resched_lock	vmlinux	EXPORT_SYMBOL	
++0xd85af8e9	__put_task_struct	vmlinux	EXPORT_SYMBOL_GPL	
++0x114a0975	unregister_pernet_subsys	vmlinux	EXPORT_SYMBOL_GPL	
++0x7bcdb6a3	devm_led_classdev_register_ext	vmlinux	EXPORT_SYMBOL_GPL	
++0x7ef8b21d	fscrypt_ioctl_get_nonce	vmlinux	EXPORT_SYMBOL_GPL	
++0x98a6e96d	simple_write_begin	vmlinux	EXPORT_SYMBOL	
++0x8f607214	__mmap_lock_do_trace_released	vmlinux	EXPORT_SYMBOL	
++0x69443c23	redirty_page_for_writepage	vmlinux	EXPORT_SYMBOL	
++0xdcd7d7a1	bdi_set_max_ratio	vmlinux	EXPORT_SYMBOL	
++0x01310b74	netpoll_poll_dev	vmlinux	EXPORT_SYMBOL	
++0x70942be1	netdev_emerg	vmlinux	EXPORT_SYMBOL	
++0xd7f5ce8c	sk_stream_kill_queues	vmlinux	EXPORT_SYMBOL	
++0xc6334923	dev_set_name	vmlinux	EXPORT_SYMBOL_GPL	
++0x0b7b038e	fs_param_is_blob	vmlinux	EXPORT_SYMBOL	
++0xeb37101c	audit_log_end	vmlinux	EXPORT_SYMBOL	
++0x7582e178	lwtunnel_fill_encap	vmlinux	EXPORT_SYMBOL_GPL	
++0x4a9ea93a	__sk_dst_check	vmlinux	EXPORT_SYMBOL	
++0xff2d348f	of_platform_populate	vmlinux	EXPORT_SYMBOL_GPL	
++0x638798fb	usb_queue_reset_device	vmlinux	EXPORT_SYMBOL_GPL	
++0xa2660e90	__tracepoint_dma_fence_signaled	vmlinux	EXPORT_SYMBOL	
++0x6b9918ac	devm_of_iomap	vmlinux	EXPORT_SYMBOL	
++0xb10e7df4	__kfifo_dma_in_prepare	vmlinux	EXPORT_SYMBOL	
++0x0a485c5f	hash_and_copy_to_iter	vmlinux	EXPORT_SYMBOL	
++0xd27b25dd	blk_check_plugged	vmlinux	EXPORT_SYMBOL	
++0x716265c7	debugfs_initialized	vmlinux	EXPORT_SYMBOL_GPL	
++0x9d752573	lookup_one_len_unlocked	vmlinux	EXPORT_SYMBOL	
++0xc04de17c	bpf_map_put	vmlinux	EXPORT_SYMBOL_GPL	
++0x3482cef8	tracing_snapshot_cond_enable	vmlinux	EXPORT_SYMBOL_GPL	
++0xe9689b51	task_cputime_adjusted	vmlinux	EXPORT_SYMBOL_GPL	
++0xfffd9d01	xdp_convert_zc_to_xdp_frame	vmlinux	EXPORT_SYMBOL_GPL	
++0xaf4014ff	usb_amd_quirk_pll_check	vmlinux	EXPORT_SYMBOL_GPL	
++0xae809c18	usb_interrupt_msg	vmlinux	EXPORT_SYMBOL_GPL	
++0x1245b0ea	arizona_clk32k_enable	vmlinux	EXPORT_SYMBOL_GPL	
++0xf802701f	pm_generic_runtime_resume	vmlinux	EXPORT_SYMBOL_GPL	
++0xdc5cd226	bus_unregister	vmlinux	EXPORT_SYMBOL_GPL	
++0x7b791a70	set_bh_page	vmlinux	EXPORT_SYMBOL	
++0x3df70c99	trace_clock_global	vmlinux	EXPORT_SYMBOL_GPL	
++0xffe3f9df	kthread_blkcg	vmlinux	EXPORT_SYMBOL	
++0xdaef8311	tcf_action_update_stats	vmlinux	EXPORT_SYMBOL	
++0xf1d10186	efivars_unregister	vmlinux	EXPORT_SYMBOL_GPL	
++0x168ec6a0	clkdev_alloc	vmlinux	EXPORT_SYMBOL	
++0x595d8002	hdmi_infoframe_pack	vmlinux	EXPORT_SYMBOL	
++0xf4db35bc	stpcpy	vmlinux	EXPORT_SYMBOL	
++0xe914e41e	strcpy	vmlinux	EXPORT_SYMBOL	
++0xb0051363	kobj_sysfs_ops	vmlinux	EXPORT_SYMBOL_GPL	
++0x07d59552	crypto_destroy_tfm	vmlinux	EXPORT_SYMBOL_GPL	
++0x3b94feb6	nfs_zap_acl_cache	vmlinux	EXPORT_SYMBOL_GPL	
++0xd92f6560	sysfs_remove_link_from_group	vmlinux	EXPORT_SYMBOL_GPL	
++0xe7ed8930	filemap_fault	vmlinux	EXPORT_SYMBOL	
++0x1bc3edc2	usb_stor_sense_invalidCDB	vmlinux	EXPORT_SYMBOL_GPL	USB_STORAGE
++0xe89c9ff9	__DWC_DMA_ALLOC	vmlinux	EXPORT_SYMBOL	
++0xded6ae80	sdev_enable_disk_events	vmlinux	EXPORT_SYMBOL	
++0x3360d9bc	fb_get_buffer_offset	vmlinux	EXPORT_SYMBOL	
++0x8f534eaa	key_payload_reserve	vmlinux	EXPORT_SYMBOL	
++0x6c2b3976	pnfs_free_commit_array	vmlinux	EXPORT_SYMBOL_GPL	
++0x3e7114c0	pin_user_pages_fast_only	vmlinux	EXPORT_SYMBOL_GPL	
++0x4590bb98	ftrace_set_notrace	vmlinux	EXPORT_SYMBOL_GPL	
++0x5d9840cb	blocking_notifier_chain_register	vmlinux	EXPORT_SYMBOL_GPL	
++0x3c3c85d8	__SCK__tp_func_kfree_skb	vmlinux	EXPORT_SYMBOL_GPL	
++0x6b4d1b79	skb_unlink	vmlinux	EXPORT_SYMBOL	
++0x5f055dcd	sock_zerocopy_callback	vmlinux	EXPORT_SYMBOL_GPL	
++0xff291ecf	clk_unregister_divider	vmlinux	EXPORT_SYMBOL_GPL	
++0x7d306ed2	blk_set_queue_dying	vmlinux	EXPORT_SYMBOL_GPL	
++0x6b74f077	crypto_register_template	vmlinux	EXPORT_SYMBOL_GPL	
++0x320bbeec	nfs_filemap_write_and_wait_range	vmlinux	EXPORT_SYMBOL_GPL	
++0xe7b7da04	node_states	vmlinux	EXPORT_SYMBOL	
++0xf5c3a8e9	vm_iomap_memory	vmlinux	EXPORT_SYMBOL	
++0x49e96999	cond_synchronize_rcu	vmlinux	EXPORT_SYMBOL_GPL	
++0x869d86b2	irq_setup_alt_chip	vmlinux	EXPORT_SYMBOL_GPL	
++0xee7eeaa6	__ethtool_get_link_ksettings	vmlinux	EXPORT_SYMBOL	
++0x56e80c25	of_phy_attach	vmlinux	EXPORT_SYMBOL	
++0x3a74a512	spi_set_cs_timing	vmlinux	EXPORT_SYMBOL_GPL	
++0x5641485b	tty_termios_encode_baud_rate	vmlinux	EXPORT_SYMBOL_GPL	
++0x5050d3fa	tty_release_struct	vmlinux	EXPORT_SYMBOL_GPL	
++0x9a1d8b38	fs_param_is_fd	vmlinux	EXPORT_SYMBOL	
++0xe1fecaff	smp_call_function_single_async	vmlinux	EXPORT_SYMBOL_GPL	
++0xc24f6f7b	sched_trace_rq_avg_dl	vmlinux	EXPORT_SYMBOL_GPL	
++0xca9d5360	inet_csk_delete_keepalive_timer	vmlinux	EXPORT_SYMBOL	
++0x21b838b0	eth_platform_get_mac_address	vmlinux	EXPORT_SYMBOL	
++0x41c9ff98	skb_append_pagefrags	vmlinux	EXPORT_SYMBOL_GPL	
++0xe69d3f0f	mbox_request_channel_byname	vmlinux	EXPORT_SYMBOL_GPL	
++0xc92a0edb	of_reserved_mem_device_init_by_idx	vmlinux	EXPORT_SYMBOL_GPL	
++0xa58068df	of_parse_phandle	vmlinux	EXPORT_SYMBOL	
++0x18a344f8	usb_hcd_pci_shutdown	vmlinux	EXPORT_SYMBOL_GPL	
++0x3d531b86	dev_pm_qos_add_ancestor_request	vmlinux	EXPORT_SYMBOL_GPL	
++0x447ace19	pci_bus_set_ops	vmlinux	EXPORT_SYMBOL	
++0x389617b0	LZ4_decompress_fast_continue	vmlinux	EXPORT_SYMBOL	
++0x658ce1a8	xxh64_reset	vmlinux	EXPORT_SYMBOL	
++0x6673f96d	xxh32_reset	vmlinux	EXPORT_SYMBOL	
++0xf5878bab	nfs_wait_client_init_complete	vmlinux	EXPORT_SYMBOL_GPL	
++0xed064f14	proc_create_single_data	vmlinux	EXPORT_SYMBOL	
++0x22b2c3a4	xfrm_state_register_afinfo	vmlinux	EXPORT_SYMBOL	
++0xd7dccd23	__SCK__tp_func_xhci_dbg_quirks	vmlinux	EXPORT_SYMBOL_GPL	
++0xf402c0f6	usb_register_device_driver	vmlinux	EXPORT_SYMBOL_GPL	
++0x89b9d5da	phy_loopback	vmlinux	EXPORT_SYMBOL	
++0x048c2665	subsys_interface_unregister	vmlinux	EXPORT_SYMBOL_GPL	
++0xf833f199	regulator_list_hardware_vsel	vmlinux	EXPORT_SYMBOL_GPL	
++0xc422a5bd	kmem_cache_size	vmlinux	EXPORT_SYMBOL	
++0xb3e60cba	enable_kprobe	vmlinux	EXPORT_SYMBOL_GPL	
++0xd7e41fd8	inet_ioctl	vmlinux	EXPORT_SYMBOL	
++0x74cdcde1	of_device_register	vmlinux	EXPORT_SYMBOL	
++0xb9454d18	genphy_c45_pma_read_abilities	vmlinux	EXPORT_SYMBOL_GPL	
++0x9a60677c	regmap_get_val_endian	vmlinux	EXPORT_SYMBOL_GPL	
++0x4e9728b1	kobject_get_path	vmlinux	EXPORT_SYMBOL_GPL	
++0x9f2b6269	nfs_symlink	vmlinux	EXPORT_SYMBOL_GPL	
++0x33190b61	sdhci_enable_sdio_irq	vmlinux	EXPORT_SYMBOL_GPL	
++0xaaa64fd9	phy_drivers_register	vmlinux	EXPORT_SYMBOL	
++0x06607a04	nvme_wait_freeze_timeout	vmlinux	EXPORT_SYMBOL_GPL	
++0xa4d62495	scsi_vpd_lun_id	vmlinux	EXPORT_SYMBOL	
++0x77f5dce4	idr_get_next_ul	vmlinux	EXPORT_SYMBOL	
++0xa957a358	decrypt_blob	vmlinux	EXPORT_SYMBOL_GPL	
++0xd6eaaea1	full_name_hash	vmlinux	EXPORT_SYMBOL	
++0xe8e5def3	hrtimer_active	vmlinux	EXPORT_SYMBOL_GPL	
++0x406c4cb1	hrtimer_resolution	vmlinux	EXPORT_SYMBOL_GPL	
++0xc0b3d7ed	start_poll_synchronize_srcu	vmlinux	EXPORT_SYMBOL_GPL	
++0x2e70958e	svc_rqst_alloc	vmlinux	EXPORT_SYMBOL_GPL	
++0x1ea0b3cc	ping_prot	vmlinux	EXPORT_SYMBOL	
++0x91a2855b	watchdog_set_last_hw_keepalive	vmlinux	EXPORT_SYMBOL_GPL	
++0x31a49a8e	nvme_get_features	vmlinux	EXPORT_SYMBOL_GPL	
++0xfad20892	tty_port_hangup	vmlinux	EXPORT_SYMBOL	
++0x49d08865	framebuffer_release	vmlinux	EXPORT_SYMBOL	
++0x1fe6e504	gpiod_add_hogs	vmlinux	EXPORT_SYMBOL_GPL	
++0x2b321e46	pinctrl_utils_reserve_map	vmlinux	EXPORT_SYMBOL_GPL	
++0x3ef051c8	crypto_inc	vmlinux	EXPORT_SYMBOL_GPL	
++0x076c2bca	iomap_file_buffered_write	vmlinux	EXPORT_SYMBOL_GPL	
++0x1e88658e	get_cached_acl	vmlinux	EXPORT_SYMBOL	
++0x4ce08c2f	wait_for_stable_page	vmlinux	EXPORT_SYMBOL_GPL	
++0x0e32bf8e	event_triggers_post_call	vmlinux	EXPORT_SYMBOL_GPL	
++0xa38c1436	cpu_bit_bitmap	vmlinux	EXPORT_SYMBOL_GPL	
++0xfa3b23d7	rpc_free_iostats	vmlinux	EXPORT_SYMBOL_GPL	
++0x679340ee	rpc_destroy_wait_queue	vmlinux	EXPORT_SYMBOL_GPL	
++0x6318926d	fqdir_init	vmlinux	EXPORT_SYMBOL	
++0x38a71b7e	pci_free_resource_list	vmlinux	EXPORT_SYMBOL	
++0xb4a67b0b	blk_mq_sched_try_merge	vmlinux	EXPORT_SYMBOL_GPL	
++0x08b002d1	pkcs7_verify	vmlinux	EXPORT_SYMBOL_GPL	
++0xce997e63	crypto_register_kpp	vmlinux	EXPORT_SYMBOL_GPL	
++0xa596eb6d	touch_buffer	vmlinux	EXPORT_SYMBOL	
++0xfdcdfced	alloc_file_pseudo	vmlinux	EXPORT_SYMBOL	
++0x558a9bce	prepare_to_swait_event	vmlinux	EXPORT_SYMBOL	
++0xba3bc491	__kthread_should_park	vmlinux	EXPORT_SYMBOL_GPL	
++0x12c2c391	svcauth_unix_purge	vmlinux	EXPORT_SYMBOL_GPL	
++0x63a58370	flow_action_cookie_destroy	vmlinux	EXPORT_SYMBOL	
++0x76f3291a	devm_rc_register_device	vmlinux	EXPORT_SYMBOL_GPL	
++0x4eb077fc	usb_hcd_poll_rh_status	vmlinux	EXPORT_SYMBOL_GPL	
++0xf1dc2ab0	of_phy_is_fixed_link	vmlinux	EXPORT_SYMBOL	
++0xcabe7420	dev_pm_qos_hide_flags	vmlinux	EXPORT_SYMBOL_GPL	
++0xc510e8cc	device_find_child	vmlinux	EXPORT_SYMBOL_GPL	
++0x733ca4ac	kobject_move	vmlinux	EXPORT_SYMBOL_GPL	
++0x8ac743de	sg_copy_buffer	vmlinux	EXPORT_SYMBOL	
++0x8182c09f	fat_setattr	vmlinux	EXPORT_SYMBOL_GPL	
++0xf81c07d4	fat_getattr	vmlinux	EXPORT_SYMBOL_GPL	
++0x69de84ba	__fscrypt_prepare_link	vmlinux	EXPORT_SYMBOL_GPL	
++0x1f722958	fscrypt_file_open	vmlinux	EXPORT_SYMBOL_GPL	
++0x8745a2ff	generic_read_dir	vmlinux	EXPORT_SYMBOL	
++0x0f11caf5	trace_hardirqs_off_finish	vmlinux	EXPORT_SYMBOL	
++0xb1cf6c82	xprt_lookup_rqst	vmlinux	EXPORT_SYMBOL_GPL	
++0x2e5c0b10	flow_indr_block_cb_alloc	vmlinux	EXPORT_SYMBOL	
++0xf9694f73	sock_set_mark	vmlinux	EXPORT_SYMBOL	
++0xaf201fa6	usb_ep_enable	vmlinux	EXPORT_SYMBOL_GPL	
++0xd59a1587	linkmode_resolve_pause	vmlinux	EXPORT_SYMBOL_GPL	
++0x0ef2e7c9	devm_gpiod_put	vmlinux	EXPORT_SYMBOL_GPL	
++0xd6644f3d	phy_pm_runtime_get	vmlinux	EXPORT_SYMBOL_GPL	
++0x61fcd5c2	bsg_remove_queue	vmlinux	EXPORT_SYMBOL_GPL	
++0x6cc41e56	truncate_pagecache	vmlinux	EXPORT_SYMBOL	
++0xe809cffb	ring_buffer_time_stamp	vmlinux	EXPORT_SYMBOL_GPL	
++0x2e2997a6	param_ops_bool_enable_only	vmlinux	EXPORT_SYMBOL_GPL	
++0xb73be794	xfrm_ealg_get_byidx	vmlinux	EXPORT_SYMBOL_GPL	
++0x46005030	tso_start	vmlinux	EXPORT_SYMBOL	
++0x955bc54c	sock_no_shutdown	vmlinux	EXPORT_SYMBOL	
++0x95b95844	of_device_unregister	vmlinux	EXPORT_SYMBOL	
++0x29d2c7e5	mmc_cmdq_disable	vmlinux	EXPORT_SYMBOL_GPL	
++0xc97aae93	watchdog_register_device	vmlinux	EXPORT_SYMBOL_GPL	
++0xd54c2387	vc_resize	vmlinux	EXPORT_SYMBOL	
++0xfddbd153	phy_put	vmlinux	EXPORT_SYMBOL_GPL	
++0x88b297e7	phy_pm_runtime_put_sync	vmlinux	EXPORT_SYMBOL_GPL	
++0x69d3558d	pnfs_generic_rw_release	vmlinux	EXPORT_SYMBOL_GPL	
++0x34df665f	nfs4_test_session_trunk	vmlinux	EXPORT_SYMBOL_GPL	
++0x9531dfed	fat_update_time	vmlinux	EXPORT_SYMBOL_GPL	
++0x2d55e4f4	reclaim_pages	vmlinux	EXPORT_SYMBOL_GPL	
++0x24da0093	rcu_inkernel_boot_has_ended	vmlinux	EXPORT_SYMBOL_GPL	
++0x21ef374c	try_wait_for_completion	vmlinux	EXPORT_SYMBOL	
++0xa8e85eae	param_set_ulong	vmlinux	EXPORT_SYMBOL	
++0x83e1f5d8	tcp_mmap	vmlinux	EXPORT_SYMBOL	
++0x1a77903a	of_alias_get_alias_list	vmlinux	EXPORT_SYMBOL_GPL	
++0x863cd59f	spi_unregister_device	vmlinux	EXPORT_SYMBOL_GPL	
++0x6adc9b13	generic_key_instantiate	vmlinux	EXPORT_SYMBOL	
++0x974df8bf	sysfs_unmerge_group	vmlinux	EXPORT_SYMBOL_GPL	
++0x09adbbaa	fs_param_is_path	vmlinux	EXPORT_SYMBOL	
++0xedc8d7cd	__cancel_dirty_page	vmlinux	EXPORT_SYMBOL	
++0xdde2b87d	sched_trace_cfs_rq_path	vmlinux	EXPORT_SYMBOL_GPL	
++0x79defbe1	kthread_should_park	vmlinux	EXPORT_SYMBOL_GPL	
++0x70c52dc5	nf_skb_duplicated	vmlinux	EXPORT_SYMBOL_GPL	
++0x8e5f29ff	fib_notifier_ops_register	vmlinux	EXPORT_SYMBOL	
++0xfaac5274	dma_resv_init	vmlinux	EXPORT_SYMBOL	
++0xd1165666	dummy_con	vmlinux	EXPORT_SYMBOL_GPL	
++0xf9c1f9ab	security_secctx_to_secid	vmlinux	EXPORT_SYMBOL	
++0xf5840a53	sysfs_create_link_nowarn	vmlinux	EXPORT_SYMBOL_GPL	
++0x6246a629	synchronize_rcu_tasks_trace	vmlinux	EXPORT_SYMBOL_GPL	
++0x229eefe9	svc_encode_read_payload	vmlinux	EXPORT_SYMBOL_GPL	
++0x21e13cb3	inet_peer_xrlim_allow	vmlinux	EXPORT_SYMBOL	
++0xf2ff4ae1	nf_ct_attach	vmlinux	EXPORT_SYMBOL	
++0x489ef2f6	tcf_queue_work	vmlinux	EXPORT_SYMBOL	
++0x302d08a6	dev_pm_opp_unregister_notifier	vmlinux	EXPORT_SYMBOL	
++0x2f3ff0f6	devm_phy_put	vmlinux	EXPORT_SYMBOL_GPL	
++0x3e64e9aa	sbitmap_queue_wake_up	vmlinux	EXPORT_SYMBOL_GPL	
++0x73dff4c0	__SCK__tp_func_nfs_xdr_status	vmlinux	EXPORT_SYMBOL_GPL	
++0x13cead77	__SCK__tp_func_kmem_cache_alloc_node	vmlinux	EXPORT_SYMBOL	
++0xef78110f	register_user_hw_breakpoint	vmlinux	EXPORT_SYMBOL_GPL	
++0xc9df055a	xfrm_policy_walk_init	vmlinux	EXPORT_SYMBOL	
++0x468700d9	cpufreq_dbs_governor_limits	vmlinux	EXPORT_SYMBOL_GPL	
++0x72e93317	driver_attach	vmlinux	EXPORT_SYMBOL_GPL	
++0x648ce83b	gpiochip_irq_map	vmlinux	EXPORT_SYMBOL_GPL	
++0x607ff500	textsearch_register	vmlinux	EXPORT_SYMBOL	
++0x8b9ea582	ZSTD_copyDCtx	vmlinux	EXPORT_SYMBOL	
++0x07482403	bio_clone_blkg_association	vmlinux	EXPORT_SYMBOL_GPL	
++0xcad0ea8c	nfs_inode_attach_open_context	vmlinux	EXPORT_SYMBOL_GPL	
++0x6842542c	fscache_op_complete	vmlinux	EXPORT_SYMBOL	
++0x74baf17a	tracing_is_on	vmlinux	EXPORT_SYMBOL_GPL	
++0x381a798a	setup_max_cpus	vmlinux	EXPORT_SYMBOL	
++0x0267e2ca	commit_creds	vmlinux	EXPORT_SYMBOL	
++0x101acdff	iptunnel_metadata_reply	vmlinux	EXPORT_SYMBOL_GPL	
++0xbd8f7a35	ethnl_cable_test_step	vmlinux	EXPORT_SYMBOL_GPL	
++0xef0433dd	dwc_cc_data_for_save	vmlinux	EXPORT_SYMBOL	
++0xb5c59df7	platform_device_register	vmlinux	EXPORT_SYMBOL_GPL	
++0x80d68d3e	fb_register_client	vmlinux	EXPORT_SYMBOL	
++0x574eda34	des3_ede_decrypt	vmlinux	EXPORT_SYMBOL_GPL	
++0xad0413d4	match_hex	vmlinux	EXPORT_SYMBOL	
++0xbb648174	__inet_lookup_listener	vmlinux	EXPORT_SYMBOL_GPL	
++0xeef5e9d3	nf_unregister_sockopt	vmlinux	EXPORT_SYMBOL	
++0x2c54ddfe	skb_realloc_headroom	vmlinux	EXPORT_SYMBOL	
++0x681ae904	software_node_fwnode	vmlinux	EXPORT_SYMBOL_GPL	
++0xd7934469	platform_device_unregister	vmlinux	EXPORT_SYMBOL_GPL	
++0x9783c22f	serial8250_set_isa_configurator	vmlinux	EXPORT_SYMBOL	
++0xa3a04602	btree_geo64	vmlinux	EXPORT_SYMBOL_GPL	
++0xafa7526b	generic_pipe_buf_get	vmlinux	EXPORT_SYMBOL	
++0x10ffa700	pin_user_pages_locked	vmlinux	EXPORT_SYMBOL	
++0x8b573cb1	ipv6_find_hdr	vmlinux	EXPORT_SYMBOL	
++0x5fedcbde	__dev_forward_skb	vmlinux	EXPORT_SYMBOL_GPL	
++0x3f6b290c	sock_set_sndtimeo	vmlinux	EXPORT_SYMBOL	
++0x828d5a0a	sdhci_cqe_irq	vmlinux	EXPORT_SYMBOL_GPL	
++0x5f80bd52	uhci_reset_hc	vmlinux	EXPORT_SYMBOL_GPL	
++0x40a3959e	tty_port_close_end	vmlinux	EXPORT_SYMBOL	
++0x2d450a1e	pcie_bandwidth_available	vmlinux	EXPORT_SYMBOL	
++0x702946da	ucs2_strlen	vmlinux	EXPORT_SYMBOL	
++0x8ddfbd1c	nfs_may_open	vmlinux	EXPORT_SYMBOL_GPL	
++0xe9751640	jbd2_journal_dirty_metadata	vmlinux	EXPORT_SYMBOL	
++0xd54f6248	account_locked_vm	vmlinux	EXPORT_SYMBOL_GPL	
++0x04bf0092	io_cgrp_subsys_enabled_key	vmlinux	EXPORT_SYMBOL_GPL	
++0xfee8ff3b	handle_fasteoi_irq	vmlinux	EXPORT_SYMBOL_GPL	
++0x3affd2c5	__vlan_find_dev_deep_rcu	vmlinux	EXPORT_SYMBOL	
++0x0e14faac	xdr_restrict_buflen	vmlinux	EXPORT_SYMBOL	
++0x30f4aaea	usb_anchor_suspend_wakeups	vmlinux	EXPORT_SYMBOL_GPL	
++0x8fc12788	software_node_unregister_node_group	vmlinux	EXPORT_SYMBOL_GPL	
++0x3f953e75	__close_fd	vmlinux	EXPORT_SYMBOL	
++0x3a7a0f33	page_readlink	vmlinux	EXPORT_SYMBOL	
++0x07bf29cd	get_cached_msi_msg	vmlinux	EXPORT_SYMBOL_GPL	
++0x788222ef	inet_frag_reasm_prepare	vmlinux	EXPORT_SYMBOL	
++0x81777297	dma_fence_chain_init	vmlinux	EXPORT_SYMBOL	
++0x1dd571e6	fb_copy_cmap	vmlinux	EXPORT_SYMBOL	
++0x6eef2ac3	gpiod_set_value	vmlinux	EXPORT_SYMBOL_GPL	
++0xd9d952d1	crypto_aes_sbox	vmlinux	EXPORT_SYMBOL	
++0x27639220	blk_verify_command	vmlinux	EXPORT_SYMBOL	
++0x2d39b0a7	kstrdup	vmlinux	EXPORT_SYMBOL	
++0xc8918ffc	freezing_slow_path	vmlinux	EXPORT_SYMBOL	
++0x325888a3	__tracepoint_neigh_update	vmlinux	EXPORT_SYMBOL_GPL	
++0x92a03f03	of_iomap	vmlinux	EXPORT_SYMBOL	
++0x3fc7c4e5	DWC_CPU_TO_LE16	vmlinux	EXPORT_SYMBOL	
++0x968c8a18	DWC_CPU_TO_LE32	vmlinux	EXPORT_SYMBOL	
++0x332ae976	rtl8152_get_version	vmlinux	EXPORT_SYMBOL_GPL	
++0x75b956c3	is_software_node	vmlinux	EXPORT_SYMBOL_GPL	
++0x8da5956a	xas_pause	vmlinux	EXPORT_SYMBOL_GPL	
++0x595c4d4f	_atomic_dec_and_lock	vmlinux	EXPORT_SYMBOL	
++0x7984eefc	key_update	vmlinux	EXPORT_SYMBOL	
++0x5a12e60c	__SCK__tp_func_sched_update_nr_running_tp	vmlinux	EXPORT_SYMBOL_GPL	
++0xba80e832	l3mdev_master_ifindex_rcu	vmlinux	EXPORT_SYMBOL_GPL	
++0x0b84eb7a	xfrm_register_km	vmlinux	EXPORT_SYMBOL	
++0x184962a2	device_create_with_groups	vmlinux	EXPORT_SYMBOL_GPL	
++0xcf6c2821	fbcon_modechange_possible	vmlinux	EXPORT_SYMBOL_GPL	
++0xab781570	fb_get_options	vmlinux	EXPORT_SYMBOL	
++0x8d23ce2d	phy_init	vmlinux	EXPORT_SYMBOL_GPL	
++0xfb384d37	kasprintf	vmlinux	EXPORT_SYMBOL	
++0x83e61c08	debugfs_create_automount	vmlinux	EXPORT_SYMBOL	
++0xd6dc0fea	__traceiter_nfs4_pnfs_read	vmlinux	EXPORT_SYMBOL_GPL	
++0x5635fe1b	revalidate_disk_size	vmlinux	EXPORT_SYMBOL	
++0xa5a7ab18	simple_rename	vmlinux	EXPORT_SYMBOL	
++0xf737bdd9	vfs_getxattr	vmlinux	EXPORT_SYMBOL_GPL	
++0x7d7a3688	vfs_setxattr	vmlinux	EXPORT_SYMBOL_GPL	
++0x0a463293	__tracepoint_error_report_end	vmlinux	EXPORT_SYMBOL_GPL	
++0xc02bfb81	trace_seq_path	vmlinux	EXPORT_SYMBOL_GPL	
++0x3b610584	__tracepoint_sched_cpu_capacity_tp	vmlinux	EXPORT_SYMBOL_GPL	
++0x466ca674	kernel_param_unlock	vmlinux	EXPORT_SYMBOL	
++0xe33d8b0f	sock_init_data	vmlinux	EXPORT_SYMBOL	
++0x5e6b74eb	tty_set_termios	vmlinux	EXPORT_SYMBOL_GPL	
++0x5c631a96	of_get_pci_domain_nr	vmlinux	EXPORT_SYMBOL_GPL	
++0x3a536bd7	ring_buffer_read_finish	vmlinux	EXPORT_SYMBOL_GPL	
++0x682ff057	ring_buffer_commit_overrun_cpu	vmlinux	EXPORT_SYMBOL_GPL	
++0xba8fbd64	_raw_spin_lock	vmlinux	EXPORT_SYMBOL	
++0xd570af1d	tcp_mtu_to_mss	vmlinux	EXPORT_SYMBOL	
++0x36c0e095	ip_queue_xmit	vmlinux	EXPORT_SYMBOL	
++0x8856e04b	rtnl_register_module	vmlinux	EXPORT_SYMBOL_GPL	
++0x50dd030b	put_cmsg_scm_timestamping64	vmlinux	EXPORT_SYMBOL	
++0xd8f4303a	class_dev_iter_init	vmlinux	EXPORT_SYMBOL_GPL	
++0x1f1c9bd3	clk_register_fixed_rate	vmlinux	EXPORT_SYMBOL_GPL	
++0x661a0ba3	pci_get_slot	vmlinux	EXPORT_SYMBOL	
++0xe4478414	devm_gen_pool_create	vmlinux	EXPORT_SYMBOL	
++0x892dda80	lockref_get_not_dead	vmlinux	EXPORT_SYMBOL	
++0x4683aedd	blk_queue_flag_set	vmlinux	EXPORT_SYMBOL	
++0xd6eaf2d8	jbd2_submit_inode_data	vmlinux	EXPORT_SYMBOL	
++0xeb8ddf4c	__frontswap_store	vmlinux	EXPORT_SYMBOL	
++0x739223de	perf_aux_output_skip	vmlinux	EXPORT_SYMBOL_GPL	
++0x5c7a6601	task_cgroup_path	vmlinux	EXPORT_SYMBOL_GPL	
++0x13ce83f9	km_query	vmlinux	EXPORT_SYMBOL	
++0x4197e607	inet_release	vmlinux	EXPORT_SYMBOL	
++0x643d504f	dev_change_proto_down_reason	vmlinux	EXPORT_SYMBOL	
++0xa2b4739a	usb_udc_vbus_handler	vmlinux	EXPORT_SYMBOL_GPL	
++0x86138bae	jbd2_journal_force_commit	vmlinux	EXPORT_SYMBOL	
++0x84ef4263	xprt_alloc	vmlinux	EXPORT_SYMBOL_GPL	
++0x4e46d50f	usb_stor_CB_transport	vmlinux	EXPORT_SYMBOL_GPL	USB_STORAGE
++0xe3551d43	phy_read_paged	vmlinux	EXPORT_SYMBOL	
++0x88768c48	__SCK__tp_func_iscsi_dbg_tcp	vmlinux	EXPORT_SYMBOL_GPL	
++0x9fce80db	fb_notifier_call_chain	vmlinux	EXPORT_SYMBOL_GPL	
++0x8c8569cb	kstrtoint	vmlinux	EXPORT_SYMBOL	
++0x29b3daf6	blk_mq_sched_try_insert_merge	vmlinux	EXPORT_SYMBOL_GPL	
++0x05a261e3	crypto_alloc_akcipher	vmlinux	EXPORT_SYMBOL_GPL	
++0xff7b6b21	crypto_alloc_skcipher	vmlinux	EXPORT_SYMBOL_GPL	
++0x39e47363	get_tree_single	vmlinux	EXPORT_SYMBOL	
++0x01e1a8de	kgdb_breakpoint	vmlinux	EXPORT_SYMBOL_GPL	
++0xec89d1b8	call_srcu	vmlinux	EXPORT_SYMBOL_GPL	
++0xb0cc9d93	mmc_command_done	vmlinux	EXPORT_SYMBOL	
++0x7ca69fb3	cpufreq_get_policy	vmlinux	EXPORT_SYMBOL	
++0xebd4cc11	mctrl_gpio_enable_ms	vmlinux	EXPORT_SYMBOL_GPL	
++0x80359667	__xas_next	vmlinux	EXPORT_SYMBOL_GPL	
++0xa3fea172	sha224_final	vmlinux	EXPORT_SYMBOL	
++0x3a1e12a0	sysfs_remove_file_self	vmlinux	EXPORT_SYMBOL_GPL	
++0x6bd0cfd3	dquot_set_dqblk	vmlinux	EXPORT_SYMBOL	
++0x793f98bc	__tracepoint_rpm_return_int	vmlinux	EXPORT_SYMBOL_GPL	
++0x8f6cee77	__round_jiffies_relative	vmlinux	EXPORT_SYMBOL_GPL	
++0x8f0748af	rcu_expedite_gp	vmlinux	EXPORT_SYMBOL_GPL	
++0xf22f0798	kthread_use_mm	vmlinux	EXPORT_SYMBOL_GPL	
++0x9121d9b2	svc_pool_stats_open	vmlinux	EXPORT_SYMBOL	
++0x43cc568f	inet_twsk_alloc	vmlinux	EXPORT_SYMBOL_GPL	
++0xb9681621	xdp_do_flush	vmlinux	EXPORT_SYMBOL_GPL	
++0x1331a6ba	dev_pm_opp_of_register_em	vmlinux	EXPORT_SYMBOL_GPL	
++0xebd66076	usb_intf_get_dma_device	vmlinux	EXPORT_SYMBOL_GPL	
++0xe879a004	dev_pm_qos_expose_latency_tolerance	vmlinux	EXPORT_SYMBOL_GPL	
++0x8e69ced0	tty_put_char	vmlinux	EXPORT_SYMBOL_GPL	
++0x7283161b	percpu_ref_switch_to_percpu	vmlinux	EXPORT_SYMBOL_GPL	
++0xc4718ec0	crypto_register_ahashes	vmlinux	EXPORT_SYMBOL_GPL	
++0x037a0cba	kfree	vmlinux	EXPORT_SYMBOL	
++0xf2b33cb7	memory_cgrp_subsys_on_dfl_key	vmlinux	EXPORT_SYMBOL_GPL	
++0x86a74bd5	__rt_mutex_init	vmlinux	EXPORT_SYMBOL	
++0xd9d8fd16	register_restart_handler	vmlinux	EXPORT_SYMBOL	
++0xfc7bac95	vlan_dev_real_dev	vmlinux	EXPORT_SYMBOL	
++0x05951149	xfrm_state_delete	vmlinux	EXPORT_SYMBOL	
++0x15d9dece	nf_register_sockopt	vmlinux	EXPORT_SYMBOL	
++0x649ad758	sock_kmalloc	vmlinux	EXPORT_SYMBOL	
++0x024b961b	genphy_c45_read_mdix	vmlinux	EXPORT_SYMBOL_GPL	
++0x5bfaa2c3	__tracepoint_iscsi_dbg_conn	vmlinux	EXPORT_SYMBOL_GPL	
++0xdfcb6c90	mctrl_gpio_set	vmlinux	EXPORT_SYMBOL_GPL	
++0x3bc9d67d	__alloc_bucket_spinlocks	vmlinux	EXPORT_SYMBOL	
++0xc45e246f	housekeeping_test_cpu	vmlinux	EXPORT_SYMBOL_GPL	
++0x34ecf821	sched_set_normal	vmlinux	EXPORT_SYMBOL_GPL	
++0xb5a806d2	xprt_destroy_backchannel	vmlinux	EXPORT_SYMBOL_GPL	
++0xd19e49c3	ip_tunnel_get_stats64	vmlinux	EXPORT_SYMBOL_GPL	
++0x19ab6c3f	stmpe_disable	vmlinux	EXPORT_SYMBOL_GPL	
++0x6c4b6684	reset_control_assert	vmlinux	EXPORT_SYMBOL_GPL	
++0x70e155c8	nfs_free_inode	vmlinux	EXPORT_SYMBOL_GPL	
++0xe7d4daac	seq_list_next	vmlinux	EXPORT_SYMBOL	
++0xf5aec6e1	__irq_alloc_domain_generic_chips	vmlinux	EXPORT_SYMBOL_GPL	
++0x8eec19bd	__SCK__tp_func_pelt_dl_tp	vmlinux	EXPORT_SYMBOL_GPL	
++0x2fe252cc	unregister_inet6addr_notifier	vmlinux	EXPORT_SYMBOL	
++0x1036fd99	devm_hwmon_device_unregister	vmlinux	EXPORT_SYMBOL_GPL	
++0x3236de8f	usbnet_get_stats64	vmlinux	EXPORT_SYMBOL_GPL	
++0x24b83ccd	gpiochip_line_is_irq	vmlinux	EXPORT_SYMBOL_GPL	
++0x0d053eac	__xa_erase	vmlinux	EXPORT_SYMBOL	
++0x399ad043	__kfifo_dma_out_finish_r	vmlinux	EXPORT_SYMBOL	
++0x16bf735c	devm_bitmap_alloc	vmlinux	EXPORT_SYMBOL_GPL	
++0x832e8f0b	nfs_alloc_fattr	vmlinux	EXPORT_SYMBOL_GPL	
++0x1e1c1e7f	__traceiter_rpm_resume	vmlinux	EXPORT_SYMBOL_GPL	
++0x57c39727	kdb_register_flags	vmlinux	EXPORT_SYMBOL_GPL	
++0xddd291cd	neigh_xmit	vmlinux	EXPORT_SYMBOL	
++0xb73713d7	nvmem_add_cell_lookups	vmlinux	EXPORT_SYMBOL_GPL	
++0x110db9f6	extcon_set_property	vmlinux	EXPORT_SYMBOL_GPL	
++0x7e747168	extcon_get_property	vmlinux	EXPORT_SYMBOL_GPL	
++0x6ab81af5	dev_pm_qos_flags	vmlinux	EXPORT_SYMBOL_GPL	
++0x5da7a137	__devm_alloc_percpu	vmlinux	EXPORT_SYMBOL_GPL	
++0x7be0d9b6	devm_kstrdup	vmlinux	EXPORT_SYMBOL_GPL	
++0xccbbaa24	uart_suspend_port	vmlinux	EXPORT_SYMBOL	
++0xbae512b4	of_dma_xlate_by_chan_id	vmlinux	EXPORT_SYMBOL_GPL	
++0xbc171517	__blkdev_driver_ioctl	vmlinux	EXPORT_SYMBOL_GPL	
++0x4afedab1	xprtiod_workqueue	vmlinux	EXPORT_SYMBOL_GPL	
++0x509950d8	hid_field_extract	vmlinux	EXPORT_SYMBOL_GPL	
++0xeb9938b6	__sdhci_add_host	vmlinux	EXPORT_SYMBOL_GPL	
++0x2a836e82	scsi_device_resume	vmlinux	EXPORT_SYMBOL	
++0x9cfa65df	platform_get_irq_byname_optional	vmlinux	EXPORT_SYMBOL_GPL	
++0x23d830f3	sbitmap_show	vmlinux	EXPORT_SYMBOL_GPL	
++0x03000e3c	kernel_read_file_from_path	vmlinux	EXPORT_SYMBOL_GPL	
++0x91a1ea0c	ipv6_find_tlv	vmlinux	EXPORT_SYMBOL_GPL	
++0xe7fa0c71	neigh_changeaddr	vmlinux	EXPORT_SYMBOL	
++0x459833cd	sdhci_request	vmlinux	EXPORT_SYMBOL_GPL	
++0xfba67a58	devm_free_percpu	vmlinux	EXPORT_SYMBOL_GPL	
++0x20a09c43	do_unregister_con_driver	vmlinux	EXPORT_SYMBOL_GPL	
++0xa120d33c	tty_unregister_ldisc	vmlinux	EXPORT_SYMBOL	
++0x1894cd62	tty_standard_install	vmlinux	EXPORT_SYMBOL_GPL	
++0xb3971a04	amba_apb_device_add_res	vmlinux	EXPORT_SYMBOL_GPL	
++0x7612ea76	gpiochip_populate_parent_fwspec_fourcell	vmlinux	EXPORT_SYMBOL_GPL	
++0x710c73b6	crypto_unregister_notifier	vmlinux	EXPORT_SYMBOL_GPL	
++0x91579731	invalidate_inode_pages2	vmlinux	EXPORT_SYMBOL_GPL	
++0x97e7f902	trace_vbprintk	vmlinux	EXPORT_SYMBOL_GPL	
++0x216de4e1	rcu_get_gp_kthreads_prio	vmlinux	EXPORT_SYMBOL_GPL	
++0xf1798337	__hw_addr_ref_sync_dev	vmlinux	EXPORT_SYMBOL	
++0x56bc3482	mmc_retune_pause	vmlinux	EXPORT_SYMBOL	
++0x17edb82e	dma_resv_get_fences_rcu	vmlinux	EXPORT_SYMBOL_GPL	
++0x01f3897b	kmem_cache_destroy	vmlinux	EXPORT_SYMBOL	
++0x002463ba	add_to_page_cache_locked	vmlinux	EXPORT_SYMBOL	
++0xea38036f	ring_buffer_entries	vmlinux	EXPORT_SYMBOL_GPL	
++0x8fc64662	alloc_skb_for_msg	vmlinux	EXPORT_SYMBOL_GPL	
++0x8ff60436	mpi_ec_add_points	vmlinux	EXPORT_SYMBOL_GPL	
++0x5943a316	blkcg_root_css	vmlinux	EXPORT_SYMBOL_GPL	
++0x16f409f5	nfs_request_remove_commit_list	vmlinux	EXPORT_SYMBOL_GPL	
++0x36243d40	proc_create_net_data	vmlinux	EXPORT_SYMBOL_GPL	
++0x4bf48f71	d_instantiate_anon	vmlinux	EXPORT_SYMBOL	
++0xc84314e2	rpc_proc_register	vmlinux	EXPORT_SYMBOL_GPL	
++0x38b9c5c1	svc_set_num_threads_sync	vmlinux	EXPORT_SYMBOL_GPL	
++0x094e792c	nf_ct_get_tuple_skb	vmlinux	EXPORT_SYMBOL	
++0xcb2bfe2b	nvmem_register_notifier	vmlinux	EXPORT_SYMBOL_GPL	
++0x1d346dbc	mmc_of_parse_voltage	vmlinux	EXPORT_SYMBOL	
++0x3017ca89	phy_mii_ioctl	vmlinux	EXPORT_SYMBOL	
++0xa8caa845	clk_bulk_put_all	vmlinux	EXPORT_SYMBOL	
++0xd2e2a9d0	hdmi_spd_infoframe_pack_only	vmlinux	EXPORT_SYMBOL	
++0xb7b7d89d	gpiochip_irq_domain_activate	vmlinux	EXPORT_SYMBOL_GPL	
++0x6e7a17a7	sprint_OID	vmlinux	EXPORT_SYMBOL_GPL	
++0xfc201b66	sprint_oid	vmlinux	EXPORT_SYMBOL_GPL	
++0xe826e05a	acomp_request_free	vmlinux	EXPORT_SYMBOL_GPL	
++0x27b47c97	vm_event_states	vmlinux	EXPORT_SYMBOL	
++0x8f1974b4	__module_get	vmlinux	EXPORT_SYMBOL	
++0x93d6dd8c	complete_all	vmlinux	EXPORT_SYMBOL	
++0x987d4bec	__release_region	vmlinux	EXPORT_SYMBOL	
++0x5ed040b0	pm_set_vt_switch	vmlinux	EXPORT_SYMBOL	
++0xbcb6048f	amba_device_alloc	vmlinux	EXPORT_SYMBOL_GPL	
++0xb4ec6a41	bdi_register	vmlinux	EXPORT_SYMBOL	
++0xcf54ea93	async_unregister_domain	vmlinux	EXPORT_SYMBOL_GPL	
++0x1ed0d1d9	xprt_alloc_slot	vmlinux	EXPORT_SYMBOL_GPL	
++0x8e896760	__iptunnel_pull_header	vmlinux	EXPORT_SYMBOL_GPL	
++0xeb3b1c05	inet_csk_clear_xmit_timers	vmlinux	EXPORT_SYMBOL	
++0xe29b0919	reuseport_alloc	vmlinux	EXPORT_SYMBOL	
++0xc8172f4a	mmc_regulator_get_supply	vmlinux	EXPORT_SYMBOL_GPL	
++0xe556dd2b	__device_reset	vmlinux	EXPORT_SYMBOL_GPL	
++0xbf805f3a	regulator_unregister_supply_alias	vmlinux	EXPORT_SYMBOL_GPL	
++0x7129e5f8	hex_asc	vmlinux	EXPORT_SYMBOL	
++0x65cc2ad8	nfs_pgheader_init	vmlinux	EXPORT_SYMBOL_GPL	
++0x2f27caa2	fat_time_unix2fat	vmlinux	EXPORT_SYMBOL_GPL	
++0xc2cebfaa	fs_param_is_u64	vmlinux	EXPORT_SYMBOL	
++0xb734851b	fs_param_is_s32	vmlinux	EXPORT_SYMBOL	
++0x925fdac7	fs_param_is_u32	vmlinux	EXPORT_SYMBOL	
++0x1085c25f	d_tmpfile	vmlinux	EXPORT_SYMBOL	
++0x52c35e83	call_rcu_tasks_trace	vmlinux	EXPORT_SYMBOL_GPL	
++0x989074ff	kmsg_dump_reason_str	vmlinux	EXPORT_SYMBOL_GPL	
++0xd4b5868c	nvme_init_identify	vmlinux	EXPORT_SYMBOL_GPL	
++0xeb19986d	tty_get_pgrp	vmlinux	EXPORT_SYMBOL_GPL	
++0xd6ef9913	of_clk_get_parent_count	vmlinux	EXPORT_SYMBOL_GPL	
++0x96b29254	strncasecmp	vmlinux	EXPORT_SYMBOL	
++0x8caf9305	uuid_is_valid	vmlinux	EXPORT_SYMBOL	
++0xe779c34e	unregister_asymmetric_key_parser	vmlinux	EXPORT_SYMBOL_GPL	
++0xe91655cc	default_llseek	vmlinux	EXPORT_SYMBOL	
++0xd31a2ac5	ring_buffer_oldest_event_ts	vmlinux	EXPORT_SYMBOL_GPL	
++0xc05cee80	ipi_get_hwirq	vmlinux	EXPORT_SYMBOL_GPL	
++0xcd3a5fab	svc_bind	vmlinux	EXPORT_SYMBOL_GPL	
++0xd4753838	tcp_read_sock	vmlinux	EXPORT_SYMBOL	
++0x758d326e	of_find_net_device_by_node	vmlinux	EXPORT_SYMBOL	
++0x22ad5df6	sdhci_pltfm_free	vmlinux	EXPORT_SYMBOL_GPL	
++0x7be89624	usb_gadget_giveback_request	vmlinux	EXPORT_SYMBOL_GPL	
++0xbbb95910	__traceiter_iscsi_dbg_eh	vmlinux	EXPORT_SYMBOL_GPL	
++0xa4358390	scsi_host_busy	vmlinux	EXPORT_SYMBOL	
++0xa412e54c	dma_fence_wait_any_timeout	vmlinux	EXPORT_SYMBOL	
++0x9c5fb966	pinconf_generic_dt_subnode_to_map	vmlinux	EXPORT_SYMBOL_GPL	
++0xb89b6e6b	guid_parse	vmlinux	EXPORT_SYMBOL	
++0x7de6cc23	io_cgrp_subsys_on_dfl_key	vmlinux	EXPORT_SYMBOL_GPL	
++0x950703aa	rpc_peeraddr	vmlinux	EXPORT_SYMBOL_GPL	
++0x5c1b0558	cpuidle_register_driver	vmlinux	EXPORT_SYMBOL_GPL	
++0x8a80e97f	scsi_eh_prep_cmnd	vmlinux	EXPORT_SYMBOL	
++0x6f2f1e9a	firmware_request_platform	vmlinux	EXPORT_SYMBOL_GPL	
++0x42ab5787	tty_port_register_device_attr	vmlinux	EXPORT_SYMBOL_GPL	
++0x01c6f17a	devm_regulator_unregister_supply_alias	vmlinux	EXPORT_SYMBOL_GPL	
++0x736683d9	pci_set_cacheline_size	vmlinux	EXPORT_SYMBOL_GPL	
++0xa870fca7	copy_page_from_iter	vmlinux	EXPORT_SYMBOL	
++0x815b5dd4	match_octal	vmlinux	EXPORT_SYMBOL	
++0xaefc832e	nfs_put_lock_context	vmlinux	EXPORT_SYMBOL_GPL	
++0xa6be0adc	cdev_device_del	vmlinux	EXPORT_SYMBOL	
++0xc949d98f	cdev_device_add	vmlinux	EXPORT_SYMBOL	
++0xba6d5c2d	walk_page_range	vmlinux	EXPORT_SYMBOL_GPL	
++0x3f6e80ae	i2c_smbus_write_byte	vmlinux	EXPORT_SYMBOL	
++0x1f91d372	scsi_register_driver	vmlinux	EXPORT_SYMBOL	
++0xc3cfa61c	dma_fence_match_context	vmlinux	EXPORT_SYMBOL	
++0x25e58a09	hdmi_avi_infoframe_init	vmlinux	EXPORT_SYMBOL	
++0xb15b4109	crc32c	vmlinux	EXPORT_SYMBOL	
++0x0d06c977	iomap_dio_rw	vmlinux	EXPORT_SYMBOL_GPL	
++0x987447cc	vfs_fsync	vmlinux	EXPORT_SYMBOL	
++0xb6a1130e	poll_freewait	vmlinux	EXPORT_SYMBOL	
++0x40c7247c	si_meminfo	vmlinux	EXPORT_SYMBOL	
++0x775fb5c3	kthread_create_on_node	vmlinux	EXPORT_SYMBOL	
++0x0f53766d	component_add	vmlinux	EXPORT_SYMBOL_GPL	
++0x6f369114	radix_tree_delete_item	vmlinux	EXPORT_SYMBOL	
++0x324098dd	_copy_from_iter_full_nocache	vmlinux	EXPORT_SYMBOL	
++0x142a7988	__traceiter_pnfs_mds_fallback_pg_get_mirror_count	vmlinux	EXPORT_SYMBOL_GPL	
++0x5e95b1cd	current_umask	vmlinux	EXPORT_SYMBOL	
++0x44a0d70a	get_fs_type	vmlinux	EXPORT_SYMBOL	
++0x40d59096	unregister_restart_handler	vmlinux	EXPORT_SYMBOL	
++0x51a08d27	usb_hub_claim_port	vmlinux	EXPORT_SYMBOL_GPL	
++0xa6df7390	tty_driver_kref_put	vmlinux	EXPORT_SYMBOL	
++0x4cddf84c	regulator_bulk_free	vmlinux	EXPORT_SYMBOL_GPL	
++0x80d5e57a	mpi_free	vmlinux	EXPORT_SYMBOL_GPL	
++0xc00f92ff	dquot_acquire	vmlinux	EXPORT_SYMBOL	
++0x3c3fce39	__local_bh_enable_ip	vmlinux	EXPORT_SYMBOL	
++0xada1579a	xfrm_local_error	vmlinux	EXPORT_SYMBOL_GPL	
++0xb01905fa	sock_prot_inuse_get	vmlinux	EXPORT_SYMBOL_GPL	
++0xda82d8d8	devm_register_netdev	vmlinux	EXPORT_SYMBOL	
++0xe940e7cf	usb_wakeup_notification	vmlinux	EXPORT_SYMBOL_GPL	
++0x7f5c9234	phy_support_asym_pause	vmlinux	EXPORT_SYMBOL	
++0xf765b45e	gpiod_put	vmlinux	EXPORT_SYMBOL_GPL	
++0x998d79d6	x509_decode_time	vmlinux	EXPORT_SYMBOL_GPL	
++0xf38db67d	iomap_readahead	vmlinux	EXPORT_SYMBOL_GPL	
++0xc1c0e2da	generic_write_end	vmlinux	EXPORT_SYMBOL	
++0xa750e90f	seq_file_path	vmlinux	EXPORT_SYMBOL	
++0xafa947ce	pin_user_pages	vmlinux	EXPORT_SYMBOL	
++0x67955ce6	profile_hits	vmlinux	EXPORT_SYMBOL_GPL	
++0x63b98d47	devm_request_threaded_irq	vmlinux	EXPORT_SYMBOL	
++0x435e0877	mini_qdisc_pair_init	vmlinux	EXPORT_SYMBOL	
++0xe61e341e	bpf_prog_create	vmlinux	EXPORT_SYMBOL_GPL	
++0xcd083b10	unregister_sound_dsp	vmlinux	EXPORT_SYMBOL	
++0x03112f13	dwc_cc_if_alloc	vmlinux	EXPORT_SYMBOL	
++0x01a0cb78	property_entries_free	vmlinux	EXPORT_SYMBOL_GPL	
++0x7d9f0606	gpio_to_desc	vmlinux	EXPORT_SYMBOL_GPL	
++0x1e19370e	security_inode_copy_up	vmlinux	EXPORT_SYMBOL	
++0x352ec68b	bpf_offload_dev_destroy	vmlinux	EXPORT_SYMBOL_GPL	
++0xa4016134	__traceiter_module_get	vmlinux	EXPORT_SYMBOL	
++0x89d983db	tcp_ca_openreq_child	vmlinux	EXPORT_SYMBOL_GPL	
++0xc233aa01	bpf_prog_destroy	vmlinux	EXPORT_SYMBOL_GPL	
++0xf49ccf06	spi_mem_exec_op	vmlinux	EXPORT_SYMBOL_GPL	
++0x624a94da	spi_mem_supports_op	vmlinux	EXPORT_SYMBOL_GPL	
++0x2f2f5065	devm_remove_action	vmlinux	EXPORT_SYMBOL_GPL	
++0x5025dec6	devm_clk_put	vmlinux	EXPORT_SYMBOL	
++0x21be37e1	hdmi_avi_infoframe_check	vmlinux	EXPORT_SYMBOL	
++0x8c14b9a3	pci_enable_atomic_ops_to_root	vmlinux	EXPORT_SYMBOL	
++0xa84ce9e0	crypto_aes_inv_sbox	vmlinux	EXPORT_SYMBOL	
++0x145ece85	bio_copy_data_iter	vmlinux	EXPORT_SYMBOL	
++0xa6b5e528	inode_insert5	vmlinux	EXPORT_SYMBOL	
++0xcdba6104	deactivate_super	vmlinux	EXPORT_SYMBOL	
++0x099f0531	vmap	vmlinux	EXPORT_SYMBOL	
++0x456f9140	ww_mutex_lock_interruptible	vmlinux	EXPORT_SYMBOL_GPL	
++0xcfa1f0f1	ipv6_chk_custom_prefix	net/ipv6/ipv6	EXPORT_SYMBOL	
++0xef119b6d	snd_compr_free_pages	sound/core/snd-compress	EXPORT_SYMBOL	
++0x1e2d3ae9	sata_pmp_error_handler	drivers/ata/libata	EXPORT_SYMBOL_GPL	
++0x55be34c1	media_entity_pads_init	drivers/media/mc/mc	EXPORT_SYMBOL_GPL	
++0xefbba056	tm6000_set_reg_mask	drivers/media/usb/tm6000/tm6000	EXPORT_SYMBOL_GPL	
++0x4144b951	mt76x02_mac_cc_reset	drivers/net/wireless/mediatek/mt76/mt76x02-lib	EXPORT_SYMBOL_GPL	
++0x38646c62	iscsi_host_add	drivers/scsi/libiscsi	EXPORT_SYMBOL_GPL	
++0x4f7b6d2b	drm_dp_send_real_edid_checksum	drivers/gpu/drm/drm_kms_helper	EXPORT_SYMBOL	
++0x5208b919	ieee80211_wake_queues	net/mac80211/mac80211	EXPORT_SYMBOL	
++0x49006f5d	bcma_host_pci_down	drivers/bcma/bcma	EXPORT_SYMBOL_GPL	
++0x10d246ca	v4l2_m2m_ioctl_dqbuf	drivers/media/v4l2-core/v4l2-mem2mem	EXPORT_SYMBOL_GPL	
++0x4b414100	drm_atomic_set_crtc_for_connector	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0xf1bdea4b	__hci_cmd_sync	net/bluetooth/bluetooth	EXPORT_SYMBOL	
++0xe72ed2fa	arizona_simple_dai_ops	sound/soc/codecs/snd-soc-arizona	EXPORT_SYMBOL_GPL	
++0x7ce48d3a	__iio_trigger_register	drivers/iio/industrialio	EXPORT_SYMBOL	
++0xe58ef8f9	v4l2_m2m_last_buf	drivers/media/v4l2-core/v4l2-mem2mem	EXPORT_SYMBOL_GPL	
++0xe2822320	__v4l2_find_nearest_size	drivers/media/v4l2-core/videodev	EXPORT_SYMBOL_GPL	
++0x430ecc96	ZSTD_initCStream_usingCDict	lib/zstd/zstd_compress	EXPORT_SYMBOL	
++0x3a49f0ec	wpan_phy_find	net/ieee802154/ieee802154	EXPORT_SYMBOL	
++0x98c64c84	ieee80211_queue_stopped	net/mac80211/mac80211	EXPORT_SYMBOL	
++0xb49fa7db	ieee80211_unreserve_tid	net/mac80211/mac80211	EXPORT_SYMBOL	
++0xb50ac6d7	cfg80211_external_auth_request	net/wireless/cfg80211	EXPORT_SYMBOL	
++0xfb3e76ff	mt76x02_mac_setaddr	drivers/net/wireless/mediatek/mt76/mt76x02-lib	EXPORT_SYMBOL_GPL	
++0x77faa053	mipi_dbi_command_stackbuf	drivers/gpu/drm/drm_mipi_dbi	EXPORT_SYMBOL	
++0x13d4d936	__drm_atomic_helper_crtc_duplicate_state	drivers/gpu/drm/drm_kms_helper	EXPORT_SYMBOL	
++0x88638552	simd_skcipher_create_compat	crypto/crypto_simd	EXPORT_SYMBOL_GPL	
++0x66a1552f	o2hb_setup_callback	fs/ocfs2/cluster/ocfs2_nodemanager	EXPORT_SYMBOL_GPL	
++0x3b312316	vchiq_mmal_port_disable	drivers/staging/vc04_services/vchiq-mmal/bcm2835-mmal-vchiq	EXPORT_SYMBOL_GPL	
++0x7f9e7fc1	videobuf_queue_cancel	drivers/media/v4l2-core/videobuf-core	EXPORT_SYMBOL_GPL	
++0xfb4bfa18	usbip_dump_urb	drivers/usb/usbip/usbip-core	EXPORT_SYMBOL_GPL	
++0x7fae8ebb	rtl_cam_empty_entry	drivers/net/wireless/realtek/rtlwifi/rtlwifi	EXPORT_SYMBOL	
++0x98aa95e0	mt76x2_configure_tx_delay	drivers/net/wireless/mediatek/mt76/mt76x2/mt76x2-common	EXPORT_SYMBOL_GPL	
++0x960781ed	iscsi_tcp_r2tpool_free	drivers/scsi/libiscsi_tcp	EXPORT_SYMBOL_GPL	
++0xa24512e5	cryptd_skcipher_queued	crypto/cryptd	EXPORT_SYMBOL_GPL	
++0x44469a76	crc_ccitt_false_table	lib/crc-ccitt	EXPORT_SYMBOL	
++0x133ade75	snd_soc_of_parse_audio_routing	sound/soc/snd-soc-core	EXPORT_SYMBOL_GPL	
++0x527aebc4	btbcm_setup_patchram	drivers/bluetooth/btbcm	EXPORT_SYMBOL_GPL	
++0x92340566	drm_fb_xrgb8888_to_rgb565	drivers/gpu/drm/drm_kms_helper	EXPORT_SYMBOL	
++0x0087edde	drm_dp_dpcd_read	drivers/gpu/drm/drm_kms_helper	EXPORT_SYMBOL	
++0x4d7e82ea	snd_soc_component_update_bits	sound/soc/snd-soc-core	EXPORT_SYMBOL_GPL	
++0xa710c8c9	v4l2_m2m_buf_remove_by_buf	drivers/media/v4l2-core/v4l2-mem2mem	EXPORT_SYMBOL_GPL	
++0x76e86174	drm_fb_memcpy_dstclip	drivers/gpu/drm/drm_kms_helper	EXPORT_SYMBOL	
++0x1cec31e7	pcm186x_regmap	sound/soc/codecs/snd-soc-pcm186x	EXPORT_SYMBOL_GPL	
++0xd8a7b36e	arizona_in_hpf_cut_enum	sound/soc/codecs/snd-soc-arizona	EXPORT_SYMBOL_GPL	
++0x7e22a316	snd_soc_dapm_put_pin_switch	sound/soc/snd-soc-core	EXPORT_SYMBOL_GPL	
++0xe436fd95	snd_soc_dapm_get_pin_switch	sound/soc/snd-soc-core	EXPORT_SYMBOL_GPL	
++0x50eb684d	ata_sff_tf_read	drivers/ata/libata	EXPORT_SYMBOL_GPL	
++0xfb49bb86	media_request_object_init	drivers/media/mc/mc	EXPORT_SYMBOL_GPL	
++0x2373d345	dvb_usbv2_resume	drivers/media/usb/dvb-usb-v2/dvb_usb_v2	EXPORT_SYMBOL	
++0x375c639c	usb_serial_generic_write_bulk_callback	drivers/usb/serial/usbserial	EXPORT_SYMBOL_GPL	
++0x6004858d	LZ4_compress_fast	lib/lz4/lz4_compress	EXPORT_SYMBOL	
++0x65d77173	nfc_target_lost	net/nfc/nfc	EXPORT_SYMBOL	
++0xc76f0a2a	ax25_find_cb	net/ax25/ax25	EXPORT_SYMBOL	
++0x9e2d74fb	wm_adsp2_component_remove	sound/soc/codecs/snd-soc-wm-adsp	EXPORT_SYMBOL_GPL	
++0xeb584b03	em28xx_write_reg	drivers/media/usb/em28xx/em28xx	EXPORT_SYMBOL_GPL	
++0x4f970cff	__traceiter_vb2_buf_done	drivers/media/common/videobuf2/videobuf2-common	EXPORT_SYMBOL_GPL	
++0xe0a17b66	mt76x02_init_debugfs	drivers/net/wireless/mediatek/mt76/mt76x02-lib	EXPORT_SYMBOL_GPL	
++0xd8fa57a6	dlm_unregister_eviction_cb	fs/ocfs2/dlm/ocfs2_dlm	EXPORT_SYMBOL_GPL	
++0x4aae2237	nf_ct_delete	net/netfilter/nf_conntrack	EXPORT_SYMBOL_GPL	
++0xcf26ed92	md_finish_reshape	drivers/md/md-mod	EXPORT_SYMBOL	
++0x0aa42d5e	__traceiter_vb2_v4l2_dqbuf	drivers/media/v4l2-core/videodev	EXPORT_SYMBOL_GPL	
++0xca3f100a	cma3000_suspend	drivers/input/misc/cma3000_d0x	EXPORT_SYMBOL	
++0x9a4d1932	rt2x00lib_set_mac_address	drivers/net/wireless/ralink/rt2x00/rt2x00lib	EXPORT_SYMBOL_GPL	
++0x0bd728a8	mt76_unregister_phy	drivers/net/wireless/mediatek/mt76/mt76	EXPORT_SYMBOL_GPL	
++0xa5692703	hostap_handle_sta_tx_exc	drivers/net/wireless/intersil/hostap/hostap	EXPORT_SYMBOL	
++0x965a9480	drm_gem_fb_get_obj	drivers/gpu/drm/drm_kms_helper	EXPORT_SYMBOL_GPL	
++0x0fabbdd0	dm_put_device	drivers/md/dm-mod	EXPORT_SYMBOL	
++0x740df1a0	dm_get_device	drivers/md/dm-mod	EXPORT_SYMBOL	
++0xe886e9ab	vb2_core_poll	drivers/media/common/videobuf2/videobuf2-common	EXPORT_SYMBOL_GPL	
++0x9aab8bc9	can_rx_offload_add_timestamp	drivers/net/can/dev/can-dev	EXPORT_SYMBOL_GPL	
++0xe4c31804	iscsi_conn_setup	drivers/scsi/libiscsi	EXPORT_SYMBOL_GPL	
++0x248f3329	p9_client_statfs	net/9p/9pnet	EXPORT_SYMBOL	
++0xec19daea	wdev_to_ieee80211_vif	net/mac80211/mac80211	EXPORT_SYMBOL_GPL	
++0x90e3ed31	__snd_seq_driver_register	sound/core/snd-seq-device	EXPORT_SYMBOL_GPL	
++0xcd98c66b	__devm_uio_register_device	drivers/uio/uio	EXPORT_SYMBOL_GPL	
++0xbc3c08ff	dev_attr_link_power_management_policy	drivers/ata/libata	EXPORT_SYMBOL_GPL	
++0x7d053fc5	dm_rh_start_recovery	drivers/md/dm-region-hash	EXPORT_SYMBOL_GPL	
++0x2839ae89	cec_queue_pin_hpd_event	drivers/media/cec/core/cec	EXPORT_SYMBOL_GPL	
++0xb7b2d224	mt76_mcu_rx_event	drivers/net/wireless/mediatek/mt76/mt76	EXPORT_SYMBOL_GPL	
++0x91fec1cc	drm_rect_calc_vscale	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0x2d50570f	drm_rect_calc_hscale	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0x5bc92e85	LZ4_compress_destSize	lib/lz4/lz4_compress	EXPORT_SYMBOL	
++0x0c96e4ca	virtio_transport_notify_send_pre_block	net/vmw_vsock/vmw_vsock_virtio_transport_common	EXPORT_SYMBOL_GPL	
++0x398778e1	fsg_ss_function	drivers/usb/gadget/function/usb_f_mass_storage	EXPORT_SYMBOL_GPL	
++0x857b6dc2	fsg_hs_function	drivers/usb/gadget/function/usb_f_mass_storage	EXPORT_SYMBOL_GPL	
++0xa5f99b69	fsg_fs_function	drivers/usb/gadget/function/usb_f_mass_storage	EXPORT_SYMBOL_GPL	
++0x91f828ab	hostap_info_process	drivers/net/wireless/intersil/hostap/hostap	EXPORT_SYMBOL	
++0xa6c996b4	nfc_tm_activated	net/nfc/nfc	EXPORT_SYMBOL	
++0xf3a188a2	rt2800_rfkill_poll	drivers/net/wireless/ralink/rt2x00/rt2800lib	EXPORT_SYMBOL_GPL	
++0xae5abfc4	drm_vma_node_allow	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0xa9e24134	l2cap_chan_set_defaults	net/bluetooth/bluetooth	EXPORT_SYMBOL_GPL	
++0x18d958f9	wm_adsp2_preloader_get	sound/soc/codecs/snd-soc-wm-adsp	EXPORT_SYMBOL_GPL	
++0x895827aa	snd_power_wait	sound/core/snd	EXPORT_SYMBOL	
++0x48d0e67b	iio_kfifo_free	drivers/iio/buffer/kfifo_buf	EXPORT_SYMBOL	
++0x84a5b41e	w1_unregister_family	drivers/w1/wire	EXPORT_SYMBOL	
++0x43831446	mwifiex_add_virtual_intf	drivers/net/wireless/marvell/mwifiex/mwifiex	EXPORT_SYMBOL_GPL	
++0xcc67670d	usb_otg_descriptor_init	drivers/usb/gadget/libcomposite	EXPORT_SYMBOL_GPL	
++0xc4f33b44	i2400m_error_recovery	drivers/net/wimax/i2400m/i2400m	EXPORT_SYMBOL_GPL	
++0x48267681	stv0288_attach	drivers/media/dvb-frontends/stv0288	EXPORT_SYMBOL	
++0xb8821e54	dibusb_i2c_algo	drivers/media/usb/dvb-usb/dvb-usb-dibusb-common	EXPORT_SYMBOL	
++0xffaa8e1d	rtl92c_phy_ap_calibrate	drivers/net/wireless/realtek/rtlwifi/rtl8192c/rtl8192c-common	EXPORT_SYMBOL	
++0xff6477bc	rtl92c_phy_iq_calibrate	drivers/net/wireless/realtek/rtlwifi/rtl8192c/rtl8192c-common	EXPORT_SYMBOL	
++0x31b8a5e3	__drm_set_edid_firmware_path	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0x6d24a21d	tpm_pm_resume	drivers/char/tpm/tpm	EXPORT_SYMBOL_GPL	
++0x231e0516	vsock_remove_pending	net/vmw_vsock/vsock	EXPORT_SYMBOL_GPL	
++0x242852b9	ax25_uid_policy	net/ax25/ax25	EXPORT_SYMBOL	
++0x3a26b941	ip_tunnel_delete_nets	net/ipv4/ip_tunnel	EXPORT_SYMBOL_GPL	
++0x19e31b95	snd_soc_jack_add_pins	sound/soc/snd-soc-core	EXPORT_SYMBOL_GPL	
++0x82122a3e	synth_current	drivers/accessibility/speakup/speakup	EXPORT_SYMBOL_GPL	
++0x5d8b3507	v4l2_m2m_buf_done_and_job_finish	drivers/media/v4l2-core/v4l2-mem2mem	EXPORT_SYMBOL	
++0x4fde36e9	usbnet_cdc_unbind	drivers/net/usb/cdc_ether	EXPORT_SYMBOL_GPL	
++0x5fc51771	drm_gem_prime_mmap	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0x50be749e	vhost_discard_vq_desc	drivers/vhost/vhost	EXPORT_SYMBOL_GPL	
++0x34ad83f1	btintel_enter_mfg	drivers/bluetooth/btintel	EXPORT_SYMBOL_GPL	
++0x93822ecb	rc_map_dibusb_table	drivers/media/usb/dvb-usb/dvb-usb-dibusb-common	EXPORT_SYMBOL	
++0xe0452c50	hostap_set_multicast_list_queue	drivers/net/wireless/intersil/hostap/hostap	EXPORT_SYMBOL	
++0xa97a5f54	drm_client_modeset_commit	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0xad4e902b	drm_color_ctm_s31_32_to_qm_n	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0x0d38db82	hci_cmd_sync	net/bluetooth/bluetooth	EXPORT_SYMBOL	
++0x2a803b2a	can_rx_unregister	net/can/can	EXPORT_SYMBOL	
++0xabc53717	hci_uart_register_device	drivers/bluetooth/hci_uart	EXPORT_SYMBOL_GPL	
++0x7b34ba1c	uhid_hid_driver	drivers/hid/uhid	EXPORT_SYMBOL_GPL	
++0x07729fd4	__SCK__tp_func_vb2_buf_queue	drivers/media/common/videobuf2/videobuf2-common	EXPORT_SYMBOL_GPL	
++0x65aaf037	crc7_be_syndrome_table	lib/crc7	EXPORT_SYMBOL	
++0xf36a2658	__ip_tunnel_change_mtu	net/ipv4/ip_tunnel	EXPORT_SYMBOL_GPL	
++0xd46dd659	ata_pci_bmdma_init_one	drivers/ata/libata	EXPORT_SYMBOL_GPL	
++0xc480dcf7	v4l2_async_register_subdev_sensor_common	drivers/media/v4l2-core/v4l2-fwnode	EXPORT_SYMBOL_GPL	
++0x65102584	mt76x02_ampdu_action	drivers/net/wireless/mediatek/mt76/mt76x02-lib	EXPORT_SYMBOL_GPL	
++0x0b5704b7	drm_property_create_signed_range	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0x9e83d044	drm_framebuffer_plane_height	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0x47293ea2	ovs_vport_alloc	net/openvswitch/openvswitch	EXPORT_SYMBOL_GPL	
++0x7837611a	arpt_do_table	net/ipv4/netfilter/arp_tables	EXPORT_SYMBOL	
++0x2010897c	async_tx_submit	crypto/async_tx/async_tx	EXPORT_SYMBOL_GPL	
++0xcfb6a3da	unregister_atmdevice_notifier	net/atm/atm	EXPORT_SYMBOL_GPL	
++0xd3e27fef	drm_atomic_add_affected_connectors	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0x2914ea2d	ZSTD_compressBlock	lib/zstd/zstd_compress	EXPORT_SYMBOL	
++0x60ea48a0	gs_free_req	drivers/usb/gadget/function/u_serial	EXPORT_SYMBOL_GPL	
++0x3694ca5d	hostap_check_sta_fw_version	drivers/net/wireless/intersil/hostap/hostap	EXPORT_SYMBOL	
++0x9cdba594	drm_atomic_bridge_chain_pre_enable	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0xe46d43db	drm_dp_mst_topology_mgr_set_mst	drivers/gpu/drm/drm_kms_helper	EXPORT_SYMBOL	
++0x8977d4f5	xt_proto_fini	net/netfilter/x_tables	EXPORT_SYMBOL_GPL	
++0x22daefe6	sata_scr_write_flush	drivers/ata/libata	EXPORT_SYMBOL_GPL	
++0x6de20e6d	synth_remove	drivers/accessibility/speakup/speakup	EXPORT_SYMBOL_GPL	
++0x4cf5f5a8	lc_is_used	lib/lru_cache	EXPORT_SYMBOL	
++0xf18c0117	snd_card_free	sound/core/snd	EXPORT_SYMBOL	
++0x3646e38f	dm_tm_issue_prefetches	drivers/md/persistent-data/dm-persistent-data	EXPORT_SYMBOL_GPL	
++0xb6632d26	v4l2_m2m_decoder_cmd	drivers/media/v4l2-core/v4l2-mem2mem	EXPORT_SYMBOL_GPL	
++0x6aaba135	mt76u_resume_rx	drivers/net/wireless/mediatek/mt76/mt76-usb	EXPORT_SYMBOL_GPL	
++0x7d8f33fa	ath9k_hw_disable_interrupts	drivers/net/wireless/ath/ath9k/ath9k_hw	EXPORT_SYMBOL	
++0x97999817	rfkill_set_hw_state	net/rfkill/rfkill	EXPORT_SYMBOL	
++0xbaf28431	wm_adsp_compr_get_caps	sound/soc/codecs/snd-soc-wm-adsp	EXPORT_SYMBOL_GPL	
++0x23fb0de5	ata_host_suspend	drivers/ata/libata	EXPORT_SYMBOL_GPL	
++0x6f412ca8	ata_link_offline	drivers/ata/libata	EXPORT_SYMBOL_GPL	
++0x916d7885	fbtft_write_reg8_bus9	drivers/staging/fbtft/fbtft	EXPORT_SYMBOL	
++0x3eeb6fc9	dm_exception_store_destroy	drivers/md/dm-snapshot	EXPORT_SYMBOL	
++0x9692e9e0	rt2x00lib_txdone_noinfo	drivers/net/wireless/ralink/rt2x00/rt2x00lib	EXPORT_SYMBOL_GPL	
++0x9d8d4412	ath_hw_keysetmac	drivers/net/wireless/ath/ath	EXPORT_SYMBOL	
++0x47c569a3	ath6kl_core_create	drivers/net/wireless/ath/ath6kl/ath6kl_core	EXPORT_SYMBOL	
++0xc29f5dcf	drm_fb_helper_cfb_copyarea	drivers/gpu/drm/drm_kms_helper	EXPORT_SYMBOL	
++0xe4c59ae1	nf_conntrack_eventmask_report	net/netfilter/nf_conntrack	EXPORT_SYMBOL_GPL	
++0x545e22e6	snd_compress_deregister	sound/core/snd-compress	EXPORT_SYMBOL_GPL	
++0x1eda630e	usb_wwan_open	drivers/usb/serial/usb_wwan	EXPORT_SYMBOL	
++0xa709e9dd	register_pppox_proto	drivers/net/ppp/pppox	EXPORT_SYMBOL	
++0x01e07eee	mt76x02_mcu_cleanup	drivers/net/wireless/mediatek/mt76/mt76x02-lib	EXPORT_SYMBOL_GPL	
++0x884deb9d	eeprom_93cx6_read	drivers/misc/eeprom/eeprom_93cx6	EXPORT_SYMBOL_GPL	
++0x5e7e40e6	snd_pcm_new_internal	sound/core/snd-pcm	EXPORT_SYMBOL	
++0x4b960a8c	md_check_no_bitmap	drivers/md/md-mod	EXPORT_SYMBOL	
++0x55be56a1	v4l2_i2c_new_subdev	drivers/media/v4l2-core/videodev	EXPORT_SYMBOL_GPL	
++0xc4f451f7	cx24123_attach	drivers/media/dvb-frontends/cx24123	EXPORT_SYMBOL	
++0xd819c6fe	cx231xx_dev_uninit	drivers/media/usb/cx231xx/cx231xx	EXPORT_SYMBOL_GPL	
++0x2fb3d76e	drm_plane_create_color_properties	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0xe344b954	vsock_enqueue_accept	net/vmw_vsock/vsock	EXPORT_SYMBOL_GPL	
++0x8fb3eb3f	ipt_unregister_table_exit	net/ipv4/netfilter/ip_tables	EXPORT_SYMBOL	
++0xff5a8cfe	cn_del_callback	drivers/connector/cn	EXPORT_SYMBOL_GPL	
++0x552e3b97	videobuf_mmap_free	drivers/media/v4l2-core/videobuf-core	EXPORT_SYMBOL_GPL	
++0x7771a146	v4l2_ctrl_notify	drivers/media/v4l2-core/videodev	EXPORT_SYMBOL	
++0x4c2118c8	ar9003_mci_send_wlan_channels	drivers/net/wireless/ath/ath9k/ath9k_hw	EXPORT_SYMBOL	
++0xa7e8d0ac	p9_client_lock_dotl	net/9p/9pnet	EXPORT_SYMBOL	
++0x3800192b	dvb_register_device	drivers/media/dvb-core/dvb-core	EXPORT_SYMBOL	
++0x5e57c25f	usb_serial_deregister_drivers	drivers/usb/serial/usbserial	EXPORT_SYMBOL_GPL	
++0xef39a59b	ssb_commit_settings	drivers/ssb/ssb	EXPORT_SYMBOL	
++0x5b1b1f4b	vb2_core_queue_release	drivers/media/common/videobuf2/videobuf2-common	EXPORT_SYMBOL_GPL	
++0x8f796f5b	rt2x00usb_vendor_request	drivers/net/wireless/ralink/rt2x00/rt2x00usb	EXPORT_SYMBOL_GPL	
++0xa6c3cf8a	nfc_get_local_general_bytes	net/nfc/nfc	EXPORT_SYMBOL	
++0x6f1f7ace	md_bitmap_resize	drivers/md/md-mod	EXPORT_SYMBOL_GPL	
++0xc7f0f027	drm_format_info_min_pitch	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0xf9610a0c	fib6_new_table	net/ipv6/ipv6	EXPORT_SYMBOL_GPL	
++0xc4f6fd6e	dev_attr_ncq_prio_enable	drivers/ata/libata	EXPORT_SYMBOL_GPL	
++0xe87f4fcf	synth_add	drivers/accessibility/speakup/speakup	EXPORT_SYMBOL_GPL	
++0xccd197c7	vb2_destroy_framevec	drivers/media/common/videobuf2/videobuf2-memops	EXPORT_SYMBOL	
++0xd559abf4	rt2x00lib_dmastart	drivers/net/wireless/ralink/rt2x00/rt2x00lib	EXPORT_SYMBOL_GPL	
++0x577bec47	drm_kms_helper_hotplug_event	drivers/gpu/drm/drm_kms_helper	EXPORT_SYMBOL	
++0x7ea76d28	qtree_release_dquot	fs/quota/quota_tree	EXPORT_SYMBOL	
++0x507b9d69	p9_client_fsync	net/9p/9pnet	EXPORT_SYMBOL	
++0x81fff2d1	ip_set_netmask_map	net/netfilter/ipset/ip_set	EXPORT_SYMBOL_GPL	
++0x68ae4b71	ip_set_put_byindex	net/netfilter/ipset/ip_set	EXPORT_SYMBOL_GPL	
++0x7c5e0683	v4l2_m2m_ioctl_try_encoder_cmd	drivers/media/v4l2-core/v4l2-mem2mem	EXPORT_SYMBOL_GPL	
++0x34d18966	rt2x00usb_disable_radio	drivers/net/wireless/ralink/rt2x00/rt2x00usb	EXPORT_SYMBOL_GPL	
++0xb472d488	drm_get_format_info	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0xf487844a	nf_conntrack_expect_lock	net/netfilter/nf_conntrack	EXPORT_SYMBOL_GPL	
++0xd05fda43	drm_prime_get_contiguous_size	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0x4c83de5a	drm_dp_atomic_release_vcpi_slots	drivers/gpu/drm/drm_kms_helper	EXPORT_SYMBOL	
++0x12627f15	curve25519_generic	lib/crypto/libcurve25519-generic	EXPORT_SYMBOL	
++0x38a50774	snd_pcm_lib_default_mmap	sound/core/snd-pcm	EXPORT_SYMBOL_GPL	
++0x237de236	iio_buffer_get	drivers/iio/industrialio	EXPORT_SYMBOL_GPL	
++0x7a711aef	iio_channel_start_all_cb	drivers/iio/buffer/industrialio-buffer-cb	EXPORT_SYMBOL_GPL	
++0x8b4706d1	vhost_chr_read_iter	drivers/vhost/vhost	EXPORT_SYMBOL_GPL	
++0xbf1a2968	btracker_create	drivers/md/dm-cache	EXPORT_SYMBOL_GPL	
++0x9a0a5d58	ar9003_mci_cleanup	drivers/net/wireless/ath/ath9k/ath9k_hw	EXPORT_SYMBOL	
++0x18a0d9c8	drm_atomic_helper_prepare_planes	drivers/gpu/drm/drm_kms_helper	EXPORT_SYMBOL	
++0x7573cdb9	drm_dp_aux_init	drivers/gpu/drm/drm_kms_helper	EXPORT_SYMBOL	
++0x37917fb8	wiphy_to_ieee80211_hw	net/mac80211/mac80211	EXPORT_SYMBOL	
++0x08ec3d79	ipv6_getsockopt	net/ipv6/ipv6	EXPORT_SYMBOL	
++0x26b32ddd	asoc_simple_parse_pin_switches	sound/soc/generic/snd-soc-simple-card-utils	EXPORT_SYMBOL_GPL	
++0x6ce599c4	roccat_connect	drivers/hid/hid-roccat	EXPORT_SYMBOL_GPL	
++0x5adc2807	btracker_destroy	drivers/md/dm-cache	EXPORT_SYMBOL_GPL	
++0x9104eb0f	v4l2_clk_put	drivers/media/v4l2-core/videodev	EXPORT_SYMBOL	
++0x0da7d59b	v4l2_subdev_get_fwnode_pad_1_to_1	drivers/media/v4l2-core/videodev	EXPORT_SYMBOL_GPL	
++0x64cdc827	usb_ftdi_elan_edset_setup	drivers/usb/misc/ftdi-elan	EXPORT_SYMBOL_GPL	
++0x03580127	ath9k_hw_setmcastfilter	drivers/net/wireless/ath/ath9k/ath9k_hw	EXPORT_SYMBOL	
++0x53aedc8d	cfg80211_ch_switch_notify	net/wireless/cfg80211	EXPORT_SYMBOL	
++0x85cabffb	snd_ctl_sync_vmaster	sound/core/snd	EXPORT_SYMBOL_GPL	
++0x3aa37eb1	vhost_set_backend_features	drivers/vhost/vhost	EXPORT_SYMBOL_GPL	
++0x5824bc8b	vhost_dev_cleanup	drivers/vhost/vhost	EXPORT_SYMBOL_GPL	
++0x7267af1e	mtd_table_mutex_lock	drivers/mtd/mtd	EXPORT_SYMBOL_GPL	
++0x76dc1186	ata_sff_queue_work	drivers/ata/libata	EXPORT_SYMBOL_GPL	
++0x15d097c4	v4l2_i2c_new_subdev_board	drivers/media/v4l2-core/videodev	EXPORT_SYMBOL_GPL	
++0x014a88db	mt76x2_phy_set_txpower	drivers/net/wireless/mediatek/mt76/mt76x2/mt76x2-common	EXPORT_SYMBOL_GPL	
++0x60ef3d30	cfg80211_notify_new_peer_candidate	net/wireless/cfg80211	EXPORT_SYMBOL	
++0x1eafc473	ata_host_activate	drivers/ata/libata	EXPORT_SYMBOL_GPL	
++0x34be7baa	o2nm_node_get	fs/ocfs2/cluster/ocfs2_nodemanager	EXPORT_SYMBOL_GPL	
++0x85b5e625	rfkill_set_states	net/rfkill/rfkill	EXPORT_SYMBOL	
++0x66d0b798	dibusb_rc_query	drivers/media/usb/dvb-usb/dvb-usb-dibusb-common	EXPORT_SYMBOL	
++0xcf8cfb8e	can_put_echo_skb	drivers/net/can/dev/can-dev	EXPORT_SYMBOL_GPL	
++0x6e598245	vcc_process_recv_queue	net/atm/atm	EXPORT_SYMBOL	
++0x2cc2d52d	vcc_hash	net/atm/atm	EXPORT_SYMBOL	
++0xb75d28d9	__hci_cmd_sync_ev	net/bluetooth/bluetooth	EXPORT_SYMBOL	
++0xdf2bd58a	nft_meta_set_destroy	net/netfilter/nf_tables	EXPORT_SYMBOL_GPL	
++0x15e0761d	nf_nat_alloc_null_binding	net/netfilter/nf_nat	EXPORT_SYMBOL_GPL	
++0xcbc3192b	cx2341x_handler_setup	drivers/media/common/cx2341x	EXPORT_SYMBOL	
++0x32d288cd	mipi_dbi_spi_cmd_max_speed	drivers/gpu/drm/drm_mipi_dbi	EXPORT_SYMBOL	
++0xdfc7c6ef	ssb_admatch_size	drivers/ssb/ssb	EXPORT_SYMBOL	
++0xcb17f1cb	ssb_admatch_base	drivers/ssb/ssb	EXPORT_SYMBOL	
++0xcda43b2d	w1_ds2781_io	drivers/w1/slaves/w1_ds2781	EXPORT_SYMBOL	
++0xc31118f4	w1_ds2780_io	drivers/w1/slaves/w1_ds2780	EXPORT_SYMBOL	
++0x127ab037	can_rx_offload_get_echo_skb	drivers/net/can/dev/can-dev	EXPORT_SYMBOL_GPL	
++0xa5510c5c	drm_atomic_set_fence_for_plane	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0x57698a50	drm_mm_takedown	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0xf5596d89	cfg80211_get_p2p_attr	net/wireless/cfg80211	EXPORT_SYMBOL	
++0x1d0c54c0	nf_reject_ip6_tcphdr_get	net/ipv6/netfilter/nf_reject_ipv6	EXPORT_SYMBOL_GPL	
++0x21692e08	synproxy_send_client_synack_ipv6	net/netfilter/nf_synproxy_core	EXPORT_SYMBOL_GPL	
++0xe436bef7	get_mtd_device_nm	drivers/mtd/mtd	EXPORT_SYMBOL_GPL	
++0x66535a18	adxl34x_suspend	drivers/input/misc/adxl34x	EXPORT_SYMBOL_GPL	
++0x1906648e	brcmu_boardrev_str	drivers/net/wireless/broadcom/brcm80211/brcmutil/brcmutil	EXPORT_SYMBOL	
++0xe08b7781	drm_crtc_vblank_on	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0xdda31ec1	drm_dp_mst_hpd_irq	drivers/gpu/drm/drm_kms_helper	EXPORT_SYMBOL	
++0x9b80dea7	fuse_do_open	fs/fuse/fuse	EXPORT_SYMBOL_GPL	
++0xa03cafe2	snd_soc_dapm_force_enable_pin	sound/soc/snd-soc-core	EXPORT_SYMBOL_GPL	
++0xfd24c2af	rtl_cam_reset_all_entry	drivers/net/wireless/realtek/rtlwifi/rtlwifi	EXPORT_SYMBOL	
++0x87b85772	vhost_exceeds_weight	drivers/vhost/vhost	EXPORT_SYMBOL_GPL	
++0xa41c7c3a	ath_is_mybeacon	drivers/net/wireless/ath/ath	EXPORT_SYMBOL	
++0x52d67a4e	neon_aes_cbc_encrypt	arch/arm64/crypto/aes-neon-blk	EXPORT_SYMBOL	
++0x69cd9fba	arpt_alloc_initial_table	net/ipv4/netfilter/arp_tables	EXPORT_SYMBOL_GPL	
++0x1eb88e07	nf_nat_ipv6_register_fn	net/netfilter/nf_nat	EXPORT_SYMBOL_GPL	
++0x7beff8d8	usb_wwan_set_serial_info	drivers/usb/serial/usb_wwan	EXPORT_SYMBOL	
++0xe365ff8b	usb_wwan_get_serial_info	drivers/usb/serial/usb_wwan	EXPORT_SYMBOL	
++0x805fc13a	__SCK__tp_func_dev_irq	drivers/net/wireless/mediatek/mt76/mt76	EXPORT_SYMBOL_GPL	
++0xd96b425a	__drm_printfn_coredump	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0xf3e2b9c2	ip6_datagram_recv_ctl	net/ipv6/ipv6	EXPORT_SYMBOL_GPL	
++0x7da96965	ip6_dst_alloc	net/ipv6/ipv6	EXPORT_SYMBOL	
++0x17dd39d6	dm_deferred_set_create	drivers/md/dm-bio-prison	EXPORT_SYMBOL_GPL	
++0x9e1d6098	au8522_led_ctrl	drivers/media/dvb-frontends/au8522_common	EXPORT_SYMBOL	
++0xd44fab86	drm_gem_cma_prime_vunmap	drivers/gpu/drm/drm	EXPORT_SYMBOL_GPL	
++0xab0cf9fa	drm_event_reserve_init	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0x264fd564	drm_helper_move_panel_connectors_to_head	drivers/gpu/drm/drm_kms_helper	EXPORT_SYMBOL	
++0x8b197a91	fuse_send_init	fs/fuse/fuse	EXPORT_SYMBOL_GPL	
++0x5dd8c69d	ieee802154_unregister_hw	net/mac802154/mac802154	EXPORT_SYMBOL	
++0xf75c5526	ax25_listen_register	net/ax25/ax25	EXPORT_SYMBOL	
++0x117aca91	cfg80211_merge_profile	net/wireless/cfg80211	EXPORT_SYMBOL	
++0x501356df	mtd_concat_destroy	drivers/mtd/mtd	EXPORT_SYMBOL	
++0x36cb72c1	vb2_ioctl_dqbuf	drivers/media/common/videobuf2/videobuf2-v4l2	EXPORT_SYMBOL_GPL	
++0x2f8015cf	drm_vblank_init	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0xb78e29f8	drm_dp_dual_mode_detect	drivers/gpu/drm/drm_kms_helper	EXPORT_SYMBOL	
++0x9e13f6f6	gf128mul_lle	crypto/gf128mul	EXPORT_SYMBOL	
++0x49377e42	ieee80211_rx_list	net/mac80211/mac80211	EXPORT_SYMBOL	
++0x3d0dff2e	snd_soc_bytes_get	sound/soc/snd-soc-core	EXPORT_SYMBOL_GPL	
++0xd55a8d38	inv_mpu_pmops	drivers/iio/imu/inv_mpu6050/inv-mpu6050	EXPORT_SYMBOL_GPL	
++0xfccd91a8	dib0070_wbd_offset	drivers/media/dvb-frontends/dib0070	EXPORT_SYMBOL	
++0x27d8e8bd	flexcop_pass_dmx_packets	drivers/media/common/b2c2/b2c2-flexcop	EXPORT_SYMBOL	
++0xd1ad5cb8	adxl34x_probe	drivers/input/misc/adxl34x	EXPORT_SYMBOL_GPL	
++0x58e846e5	drm_hdcp_update_content_protection	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0xfba231ce	drm_atomic_helper_commit_duplicated_state	drivers/gpu/drm/drm_kms_helper	EXPORT_SYMBOL	
++0xe025182f	__async_tx_find_channel	crypto/async_tx/async_tx	EXPORT_SYMBOL_GPL	
++0x9e4f7457	ieee80211_stop_tx_ba_cb_irqsafe	net/mac80211/mac80211	EXPORT_SYMBOL	
++0x8347de7c	snd_soc_card_add_dai_link	sound/soc/snd-soc-core	EXPORT_SYMBOL_GPL	
++0xaf3f9bb5	snd_dmaengine_pcm_open_request_chan	sound/core/snd-pcm-dmaengine	EXPORT_SYMBOL_GPL	
++0x2d6bcdcb	iio_trigger_generic_data_rdy_poll	drivers/iio/industrialio	EXPORT_SYMBOL	
++0x77c72673	rt2x00lib_remove_dev	drivers/net/wireless/ralink/rt2x00/rt2x00lib	EXPORT_SYMBOL_GPL	
++0xeb8891ed	backlight_force_update	drivers/video/backlight/backlight	EXPORT_SYMBOL	
++0x6fb25b88	ieee80211_sched_scan_stopped	net/mac80211/mac80211	EXPORT_SYMBOL	
++0x17d5f550	ata_scsi_slave_destroy	drivers/ata/libata	EXPORT_SYMBOL_GPL	
++0xb92a3d49	gp8psk_fe_attach	drivers/media/dvb-frontends/gp8psk-fe	EXPORT_SYMBOL_GPL	
++0xb089e083	mt76x2_mcu_init_gain	drivers/net/wireless/mediatek/mt76/mt76x2/mt76x2-common	EXPORT_SYMBOL_GPL	
++0x828fa1fb	p54_free_common	drivers/net/wireless/intersil/p54/p54common	EXPORT_SYMBOL_GPL	
++0x4eb25d06	ath9k_hw_addrxbuf_edma	drivers/net/wireless/ath/ath9k/ath9k_hw	EXPORT_SYMBOL	
++0xdd3e30b6	drm_sched_entity_fini	drivers/gpu/drm/scheduler/gpu-sched	EXPORT_SYMBOL	
++0x1f41d975	drm_crtc_vblank_restore	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0x4856fd1f	__drm_atomic_helper_connector_reset	drivers/gpu/drm/drm_kms_helper	EXPORT_SYMBOL	
++0x5c00d810	ZSTD_CDictWorkspaceBound	lib/zstd/zstd_compress	EXPORT_SYMBOL	
++0x9e0ddaae	llc_add_pack	net/llc/llc	EXPORT_SYMBOL	
++0x4cecba61	xfrm6_tunnel_alloc_spi	net/ipv6/xfrm6_tunnel	EXPORT_SYMBOL	
++0x9f347acf	btintel_download_firmware	drivers/bluetooth/btintel	EXPORT_SYMBOL_GPL	
++0xd8f1144f	ath9k_hw_deinit	drivers/net/wireless/ath/ath9k/ath9k_hw	EXPORT_SYMBOL	
++0x0718b8b7	bt_info	net/bluetooth/bluetooth	EXPORT_SYMBOL	
++0xef2254b8	stv0910_attach	drivers/media/dvb-frontends/stv0910	EXPORT_SYMBOL_GPL	
++0xa3fc5dc7	stv6110_attach	drivers/media/dvb-frontends/stv6110	EXPORT_SYMBOL	
++0x7d984b18	lnbp22_attach	drivers/media/dvb-frontends/lnbp22	EXPORT_SYMBOL	
++0x341530cb	rc_map_af9005_table	drivers/media/usb/dvb-usb/dvb-usb-af9005-remote	EXPORT_SYMBOL	
++0x2b22fd0b	mwifiex_add_card	drivers/net/wireless/marvell/mwifiex/mwifiex	EXPORT_SYMBOL_GPL	
++0x7c53216a	drm_atomic_get_new_connector_for_encoder	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0xc1f0a894	ieee80211_nan_func_terminated	net/mac80211/mac80211	EXPORT_SYMBOL	
++0x761692f3	l2tp_tunnel_delete	net/l2tp/l2tp_core	EXPORT_SYMBOL_GPL	
++0x32641418	inet_diag_bc_sk	net/ipv4/inet_diag	EXPORT_SYMBOL_GPL	
++0xc65456a3	nf_osf_match	net/netfilter/nfnetlink_osf	EXPORT_SYMBOL_GPL	
++0xd8992f1b	bmp280_regmap_config	drivers/iio/pressure/bmp280	EXPORT_SYMBOL	
++0x321ff279	bmp180_regmap_config	drivers/iio/pressure/bmp280	EXPORT_SYMBOL	
++0xeb9ec52e	bme680_regmap_config	drivers/iio/chemical/bme680_core	EXPORT_SYMBOL	
++0x8528d343	s921_attach	drivers/media/dvb-frontends/s921	EXPORT_SYMBOL	
++0x90fe4331	rtlwifi_rate_mapping	drivers/net/wireless/realtek/rtlwifi/rtlwifi	EXPORT_SYMBOL	
++0xb8256aa9	rt2800_read_eeprom_efuse	drivers/net/wireless/ralink/rt2x00/rt2800lib	EXPORT_SYMBOL_GPL	
++0x97b93264	mt76_has_tx_pending	drivers/net/wireless/mediatek/mt76/mt76	EXPORT_SYMBOL_GPL	
++0x8c1f6cbb	ath9k_hw_abortpcurecv	drivers/net/wireless/ath/ath9k/ath9k_hw	EXPORT_SYMBOL	
++0x6bedf402	ieee80211_freq_khz_to_channel	net/wireless/cfg80211	EXPORT_SYMBOL	
++0x2f622ea1	roccat_disconnect	drivers/hid/hid-roccat	EXPORT_SYMBOL_GPL	
++0x924c46f8	zs_unmap_object	mm/zsmalloc	EXPORT_SYMBOL_GPL	
++0x7e606130	snd_soc_calc_bclk	sound/soc/snd-soc-core	EXPORT_SYMBOL_GPL	
++0x503bd137	snd_interval_ranges	sound/core/snd-pcm	EXPORT_SYMBOL	
++0x5bd84fd5	mt76x02_rates	drivers/net/wireless/mediatek/mt76/mt76x02-lib	EXPORT_SYMBOL_GPL	
++0xf0457dde	drm_atomic_helper_connector_tv_reset	drivers/gpu/drm/drm_kms_helper	EXPORT_SYMBOL	
++0x0e90cbc3	nf_nat_pptp_hook_expectfn	net/netfilter/nf_conntrack_pptp	EXPORT_SYMBOL_GPL	
++0x03e93312	arizona_lhpf4_mode	sound/soc/codecs/snd-soc-arizona	EXPORT_SYMBOL_GPL	
++0xc64e0d9c	arizona_lhpf3_mode	sound/soc/codecs/snd-soc-arizona	EXPORT_SYMBOL_GPL	
++0x60390628	arizona_lhpf2_mode	sound/soc/codecs/snd-soc-arizona	EXPORT_SYMBOL_GPL	
++0x51d11cb5	arizona_lhpf1_mode	sound/soc/codecs/snd-soc-arizona	EXPORT_SYMBOL_GPL	
++0xd6c5d18e	iio_trigger_validate_own_device	drivers/iio/industrialio	EXPORT_SYMBOL	
++0xdd9722f8	w1_add_master_device	drivers/w1/wire	EXPORT_SYMBOL	
++0x9256c501	virtio_transport_stream_has_data	net/vmw_vsock/vmw_vsock_virtio_transport_common	EXPORT_SYMBOL_GPL	
++0x146b8cb9	deregister_atm_ioctl	net/atm/atm	EXPORT_SYMBOL	
++0x2ab11208	hci_register_dev	net/bluetooth/bluetooth	EXPORT_SYMBOL	
++0x1e2f6546	ffs_single_dev	drivers/usb/gadget/function/usb_f_fs	EXPORT_SYMBOL_GPL	
++0x55b902b1	snd_rawmidi_drain_output	sound/core/snd-rawmidi	EXPORT_SYMBOL	
++0x1a1ed61b	ata_sff_dev_classify	drivers/ata/libata	EXPORT_SYMBOL_GPL	
++0x3db7d765	rpisense_reg_read	drivers/mfd/rpisense-core	EXPORT_SYMBOL_GPL	
++0x61267ca1	drm_gem_shmem_pin	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0xc5affa75	snd_soc_dai_compr_startup	sound/soc/snd-soc-core	EXPORT_SYMBOL_GPL	
++0x3745034b	snd_pcm_hw_constraint_mask64	sound/core/snd-pcm	EXPORT_SYMBOL	
++0x7fe51b75	g_audio_setup	drivers/usb/gadget/function/u_audio	EXPORT_SYMBOL_GPL	
++0x941fbd8c	drm_atomic_get_crtc_state	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0x7c3ac925	ieee80211_get_vht_max_nss	net/wireless/cfg80211	EXPORT_SYMBOL	
++0x07b4eb90	__nf_conntrack_confirm	net/netfilter/nf_conntrack	EXPORT_SYMBOL_GPL	
++0x9b168b62	vchiq_mmal_port_set_format	drivers/staging/vc04_services/vchiq-mmal/bcm2835-mmal-vchiq	EXPORT_SYMBOL_GPL	
++0x5781554b	config_ep_by_speed	drivers/usb/gadget/libcomposite	EXPORT_SYMBOL_GPL	
++0x33bfdca2	gserial_alloc_line	drivers/usb/gadget/function/u_serial	EXPORT_SYMBOL_GPL	
++0x93a6c92f	rtl92c_phy_set_bb_reg	drivers/net/wireless/realtek/rtlwifi/rtl8192c/rtl8192c-common	EXPORT_SYMBOL	
++0xaf969565	ocfs2_dlm_lock	fs/ocfs2/ocfs2_stackglue	EXPORT_SYMBOL_GPL	
++0x15637820	ip_set_name_byindex	net/netfilter/ipset/ip_set	EXPORT_SYMBOL_GPL	
++0xa82b2066	dm_bufio_write_dirty_buffers	drivers/md/dm-bufio	EXPORT_SYMBOL_GPL	
++0xbf06dfc4	matrix_keypad_parse_properties	drivers/input/matrix-keymap	EXPORT_SYMBOL_GPL	
++0xd7b9d87a	drm_panel_enable	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0x25d04f92	drm_gem_fb_create_handle	drivers/gpu/drm/drm_kms_helper	EXPORT_SYMBOL	
++0xf13914b3	gue_encap_hlen	net/ipv4/fou	EXPORT_SYMBOL	
++0x87c4fb47	cdc_ncm_rx_fixup	drivers/net/usb/cdc_ncm	EXPORT_SYMBOL_GPL	
++0x28f4abe2	cdc_ncm_tx_fixup	drivers/net/usb/cdc_ncm	EXPORT_SYMBOL_GPL	
++0xdce5c9f6	mt76x02_phy_set_band	drivers/net/wireless/mediatek/mt76/mt76x02-lib	EXPORT_SYMBOL_GPL	
++0x38120322	lbtf_send_tx_feedback	drivers/net/wireless/marvell/libertas_tf/libertas_tf	EXPORT_SYMBOL_GPL	
++0xc9c6bb25	eeprom_93cx6_readb	drivers/misc/eeprom/eeprom_93cx6	EXPORT_SYMBOL_GPL	
++0xe2c84666	nft_reject_icmp_code	net/netfilter/nft_reject	EXPORT_SYMBOL_GPL	
++0x02866519	snd_jack_add_new_kctl	sound/core/snd	EXPORT_SYMBOL	
++0x62daa7fd	__serio_register_port	drivers/input/serio/serio	EXPORT_SYMBOL	
++0x72f0b8cd	md_integrity_register	drivers/md/md-mod	EXPORT_SYMBOL	
++0xa76326f7	mt76_skb_adjust_pad	drivers/net/wireless/mediatek/mt76/mt76	EXPORT_SYMBOL_GPL	
++0xbe20e6a7	l2cap_register_user	net/bluetooth/bluetooth	EXPORT_SYMBOL	
++0x81f46687	arizona_anc_ev	sound/soc/codecs/snd-soc-arizona	EXPORT_SYMBOL_GPL	
++0x706c0516	snd_ctl_unregister_ioctl	sound/core/snd	EXPORT_SYMBOL	
++0x6a889e20	ssb_bus_resume	drivers/ssb/ssb	EXPORT_SYMBOL	
++0x031dfba4	v4l2_async_notifier_register	drivers/media/v4l2-core/videodev	EXPORT_SYMBOL	
++0xe023a9d5	media_devnode_remove	drivers/media/mc/mc	EXPORT_SYMBOL_GPL	
++0x8e45bc1f	fsg_lun_fsync_sub	drivers/usb/gadget/function/usb_f_mass_storage	EXPORT_SYMBOL_GPL	
++0x76675517	drm_connector_attach_hdr_output_metadata_property	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0xf88505ba	arizona_voice_trigger_switch	sound/soc/codecs/snd-soc-arizona	EXPORT_SYMBOL_GPL	
++0x6af8a872	dm_array_info_init	drivers/md/persistent-data/dm-persistent-data	EXPORT_SYMBOL_GPL	
++0x393cc8ba	dm_bio_get_target_bio_nr	drivers/md/dm-mod	EXPORT_SYMBOL_GPL	
++0xd6015a2a	cec_queue_pin_cec_event	drivers/media/cec/core/cec	EXPORT_SYMBOL_GPL	
++0x16ac2597	drm_printf	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0xaac615ee	dlm_posix_unlock	fs/dlm/dlm	EXPORT_SYMBOL_GPL	
++0xb0aed408	ZSTD_compressStream	lib/zstd/zstd_compress	EXPORT_SYMBOL	
++0x36d82f56	dm_get_cell	drivers/md/dm-bio-prison	EXPORT_SYMBOL_GPL	
++0x869505ac	vxlan_fdb_clear_offload	drivers/net/vxlan	EXPORT_SYMBOL_GPL	
++0x5377588f	w5100_remove	drivers/net/ethernet/wiznet/w5100	EXPORT_SYMBOL_GPL	
++0x15c62f07	__nfc_alloc_vendor_cmd_reply_skb	net/nfc/nfc	EXPORT_SYMBOL	
++0x7e979078	ssb_device_is_enabled	drivers/ssb/ssb	EXPORT_SYMBOL	
++0xd7f75d3a	usb_composite_probe	drivers/usb/gadget/libcomposite	EXPORT_SYMBOL_GPL	
++0xec12af74	__drm_dbg	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0xaaed8e80	v4l2_ctrl_new_fwnode_properties	drivers/media/v4l2-core/videodev	EXPORT_SYMBOL	
++0x2f71f804	usb_wwan_suspend	drivers/usb/serial/usb_wwan	EXPORT_SYMBOL	
++0x14d09101	rtl_set_tx_report	drivers/net/wireless/realtek/rtlwifi/rtlwifi	EXPORT_SYMBOL_GPL	
++0x92c85d2d	mt76x2_phy_update_channel_gain	drivers/net/wireless/mediatek/mt76/mt76x2/mt76x2-common	EXPORT_SYMBOL_GPL	
++0xa713782e	mt76_eeprom_override	drivers/net/wireless/mediatek/mt76/mt76	EXPORT_SYMBOL_GPL	
++0xe2c6adfb	drm_mode_create_from_cmdline_mode	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0x188a1647	ecc_is_pubkey_valid_full	crypto/ecc	EXPORT_SYMBOL	
++0xe261ded2	dlm_register_domain	fs/ocfs2/dlm/ocfs2_dlm	EXPORT_SYMBOL_GPL	
++0x559a32b8	dlm_unregister_domain	fs/ocfs2/dlm/ocfs2_dlm	EXPORT_SYMBOL_GPL	
++0xb987563a	ip_vs_conn_in_get	net/netfilter/ipvs/ip_vs	EXPORT_SYMBOL	
++0x779fbaba	virtio_transport_dgram_dequeue	net/vmw_vsock/vmw_vsock_virtio_transport_common	EXPORT_SYMBOL_GPL	
++0x7e7db9cc	ieee80211_tx_dequeue	net/mac80211/mac80211	EXPORT_SYMBOL	
++0xd4dd3560	snd_timer_global_new	sound/core/snd-timer	EXPORT_SYMBOL	
++0x983a4c94	ata_std_prereset	drivers/ata/libata	EXPORT_SYMBOL_GPL	
++0x0d146126	usb_ftdi_elan_edset_empty	drivers/usb/misc/ftdi-elan	EXPORT_SYMBOL_GPL	
++0x9373fb53	i2400m_tx_msg_sent	drivers/net/wimax/i2400m/i2400m	EXPORT_SYMBOL_GPL	
++0x9680f264	drm_mode_create_tile_group	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0x2ed6fa2e	ieee80211_queue_delayed_work	net/mac80211/mac80211	EXPORT_SYMBOL	
++0x28080d56	sctp_do_peeloff	net/sctp/sctp	EXPORT_SYMBOL	
++0x0fafbe31	arizona_init_dvfs	sound/soc/codecs/snd-soc-arizona	EXPORT_SYMBOL_GPL	
++0xcc9e5fea	snd_ctl_add	sound/core/snd	EXPORT_SYMBOL	
++0xaca51e9c	sata_scr_read	drivers/ata/libata	EXPORT_SYMBOL_GPL	
++0xece5e188	dvb_ca_en50221_release	drivers/media/dvb-core/dvb-core	EXPORT_SYMBOL	
++0xe1d0d369	tm6000_set_audio_bitrate	drivers/media/usb/tm6000/tm6000	EXPORT_SYMBOL_GPL	
++0x6487bb56	drm_fb_helper_pan_display	drivers/gpu/drm/drm_kms_helper	EXPORT_SYMBOL	
++0x44ba3a1c	drm_atomic_helper_wait_for_dependencies	drivers/gpu/drm/drm_kms_helper	EXPORT_SYMBOL	
++0x2978a34f	drm_dp_downstream_id	drivers/gpu/drm/drm_kms_helper	EXPORT_SYMBOL	
++0x392a838b	drm_dp_downstream_max_dotclock	drivers/gpu/drm/drm_kms_helper	EXPORT_SYMBOL	
++0xbc54f296	arizona_set_sysclk	sound/soc/codecs/snd-soc-arizona	EXPORT_SYMBOL_GPL	
++0x668abc72	mt76x02_phy_set_rxpath	drivers/net/wireless/mediatek/mt76/mt76x02-lib	EXPORT_SYMBOL_GPL	
++0x19e89544	ath9k_hw_check_alive	drivers/net/wireless/ath/ath9k/ath9k_hw	EXPORT_SYMBOL	
++0x4a5a8811	curve25519_null_point	lib/crypto/libcurve25519-generic	EXPORT_SYMBOL	
++0xcfc58f28	bt_procfs_init	net/bluetooth/bluetooth	EXPORT_SYMBOL	
++0x154c6338	dm_kcopyd_client_destroy	drivers/md/dm-mod	EXPORT_SYMBOL	
++0x8147ebc1	v4l2_device_set_name	drivers/media/v4l2-core/videodev	EXPORT_SYMBOL_GPL	
++0xbec67838	devm_backlight_device_unregister	drivers/video/backlight/backlight	EXPORT_SYMBOL	
++0xbcf1f0e6	zs_create_pool	mm/zsmalloc	EXPORT_SYMBOL_GPL	
++0x7160e46d	ieee80211_sta_pspoll	net/mac80211/mac80211	EXPORT_SYMBOL	
++0xa9aba55f	snd_soc_component_nc_pin_unlocked	sound/soc/snd-soc-core	EXPORT_SYMBOL_GPL	
++0x02b7b682	get_bitmap_from_slot	drivers/md/md-mod	EXPORT_SYMBOL	
++0xf85ef103	rtl92c_dm_init_rate_adaptive_mask	drivers/net/wireless/realtek/rtlwifi/rtl8192c/rtl8192c-common	EXPORT_SYMBOL	
++0x13eed240	ath9k_hw_setopmode	drivers/net/wireless/ath/ath9k/ath9k_hw	EXPORT_SYMBOL	
++0x3752dc10	drm_client_init	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0x687549e3	drm_atomic_helper_check	drivers/gpu/drm/drm_kms_helper	EXPORT_SYMBOL	
++0xdafc6044	cfg80211_vendor_cmd_get_sender	net/wireless/cfg80211	EXPORT_SYMBOL_GPL	
++0xf4efc0c8	fsg_ss_bulk_out_desc	drivers/usb/gadget/function/usb_f_mass_storage	EXPORT_SYMBOL_GPL	
++0x56344daf	fsg_hs_bulk_out_desc	drivers/usb/gadget/function/usb_f_mass_storage	EXPORT_SYMBOL_GPL	
++0x1710b539	fsg_fs_bulk_out_desc	drivers/usb/gadget/function/usb_f_mass_storage	EXPORT_SYMBOL_GPL	
++0x6c941c9b	cdc_ncm_fill_tx_frame	drivers/net/usb/cdc_ncm	EXPORT_SYMBOL_GPL	
++0x7fa332bc	wm_adsp_compr_open	sound/soc/codecs/snd-soc-wm-adsp	EXPORT_SYMBOL_GPL	
++0x367faeda	drm_atomic_helper_plane_duplicate_state	drivers/gpu/drm/drm_kms_helper	EXPORT_SYMBOL	
++0xfe731af8	nf_ct_invert_tuple	net/netfilter/nf_conntrack	EXPORT_SYMBOL_GPL	
++0xa61aa028	snd_pcm_format_unsigned	sound/core/snd-pcm	EXPORT_SYMBOL	
++0x4a4cb558	dm_btree_insert_notify	drivers/md/persistent-data/dm-persistent-data	EXPORT_SYMBOL_GPL	
++0x4b6a557c	zl10036_attach	drivers/media/dvb-frontends/zl10036	EXPORT_SYMBOL	
++0x25eb7c7f	rt2800_config_shared_key	drivers/net/wireless/ralink/rt2x00/rt2800lib	EXPORT_SYMBOL_GPL	
++0x16b2a7cc	rt2800_link_tuner	drivers/net/wireless/ralink/rt2x00/rt2800lib	EXPORT_SYMBOL_GPL	
++0x023d2853	drm_crtc_vblank_off	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0xf18ad8d4	drm_crtc_vblank_get	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0x28a29803	ip6_route_me_harder	net/ipv6/ipv6	EXPORT_SYMBOL	
++0x74341872	mux_chip_free	drivers/mux/mux-core	EXPORT_SYMBOL_GPL	
++0x045688dd	ms_sensors_read_prom_word	drivers/iio/common/ms_sensors/ms_sensors_i2c	EXPORT_SYMBOL	
++0xad7c4c6e	vhost_poll_queue	drivers/vhost/vhost	EXPORT_SYMBOL_GPL	
++0x630b24d3	__tracepoint_vb2_qbuf	drivers/media/common/videobuf2/videobuf2-common	EXPORT_SYMBOL_GPL	
++0x5c9145d3	usb_ftdi_elan_write_pcimem	drivers/usb/misc/ftdi-elan	EXPORT_SYMBOL_GPL	
++0x69cd9a8a	drm_property_create_bool	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0xd9a8455b	ieee80211_tdls_oper_request	net/mac80211/mac80211	EXPORT_SYMBOL	
++0x0c5ee9e3	snd_soc_dai_active	sound/soc/snd-soc-core	EXPORT_SYMBOL_GPL	
++0x753a1578	snd_device_new	sound/core/snd	EXPORT_SYMBOL	
++0xca6f1f61	dm_savepowerindex	drivers/net/wireless/realtek/rtlwifi/rtl8192c/rtl8192c-common	EXPORT_SYMBOL_GPL	
++0x6d32eb3a	drm_gem_cma_dumb_create	drivers/gpu/drm/drm	EXPORT_SYMBOL_GPL	
++0x38ce0af7	drm_crtc_enable_color_mgmt	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0xc35220f4	p9_client_disconnect	net/9p/9pnet	EXPORT_SYMBOL	
++0x20a78063	snd_pcm_hw_constraint_list	sound/core/snd-pcm	EXPORT_SYMBOL	
++0x8d5dc902	v4l2_pipeline_pm_put	drivers/media/v4l2-core/videodev	EXPORT_SYMBOL_GPL	
++0x656226fe	v4l2_pipeline_pm_get	drivers/media/v4l2-core/videodev	EXPORT_SYMBOL_GPL	
++0xd4a0a1b1	vb2_ops_wait_prepare	drivers/media/common/videobuf2/videobuf2-v4l2	EXPORT_SYMBOL_GPL	
++0x172d35aa	smscore_putbuffer	drivers/media/common/siano/smsmdtv	EXPORT_SYMBOL_GPL	
++0xda907d38	smscore_getbuffer	drivers/media/common/siano/smsmdtv	EXPORT_SYMBOL_GPL	
++0x42a04b8a	rndis_register	drivers/usb/gadget/function/usb_f_rndis	EXPORT_SYMBOL_GPL	
++0x3ea3693f	cdc_ncm_rx_verify_nth32	drivers/net/usb/cdc_ncm	EXPORT_SYMBOL_GPL	
++0x9085b6dd	cdc_ncm_rx_verify_nth16	drivers/net/usb/cdc_ncm	EXPORT_SYMBOL_GPL	
++0x72714749	iscsi_boot_create_ethernet	drivers/scsi/iscsi_boot_sysfs	EXPORT_SYMBOL_GPL	
++0x73879664	vsock_addr_init	net/vmw_vsock/vsock	EXPORT_SYMBOL_GPL	
++0x5e1ce5cb	nf_ct_bridge_unregister	net/netfilter/nf_conntrack	EXPORT_SYMBOL_GPL	
++0x8f8a65f7	mux_control_select	drivers/mux/mux-core	EXPORT_SYMBOL_GPL	
++0x9a5669ef	iio_read_avail_channel_attribute	drivers/iio/industrialio	EXPORT_SYMBOL_GPL	
++0xccfe6409	btracker_nr_demotions_queued	drivers/md/dm-cache	EXPORT_SYMBOL_GPL	
++0x0ed816fb	usb_serial_generic_get_icount	drivers/usb/serial/usbserial	EXPORT_SYMBOL_GPL	
++0x9c77b653	ieee80211_iterate_active_interfaces_rtnl	net/mac80211/mac80211	EXPORT_SYMBOL_GPL	
++0xda721255	ata_host_detach	drivers/ata/libata	EXPORT_SYMBOL_GPL	
++0x59b167b6	dvb_frontend_reinitialise	drivers/media/dvb-core/dvb-core	EXPORT_SYMBOL	
++0x0c589aba	usb_validate_langid	drivers/usb/gadget/libcomposite	EXPORT_SYMBOL_GPL	
++0xd4e9e57f	drm_connector_attach_vrr_capable_property	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0x5731f054	drm_dp_mst_reset_vcpi_slots	drivers/gpu/drm/drm_kms_helper	EXPORT_SYMBOL	
++0xbcd8e548	snd_soc_info_volsw	sound/soc/snd-soc-core	EXPORT_SYMBOL_GPL	
++0x277749fe	s5h1411_attach	drivers/media/dvb-frontends/s5h1411	EXPORT_SYMBOL	
++0xdd9cc624	fsg_show_ro	drivers/usb/gadget/function/usb_f_mass_storage	EXPORT_SYMBOL_GPL	
++0x546a2f89	mt76x02_edcca_init	drivers/net/wireless/mediatek/mt76/mt76x02-lib	EXPORT_SYMBOL_GPL	
++0x114c11c3	p9_is_proto_dotl	net/9p/9pnet	EXPORT_SYMBOL	
++0xa75fb66c	nft_unregister_chain_type	net/netfilter/nf_tables	EXPORT_SYMBOL_GPL	
++0x67563ecf	fbtft_write_vmem8_bus8	drivers/staging/fbtft/fbtft	EXPORT_SYMBOL	
++0xd6421247	dm_exception_store_create	drivers/md/dm-snapshot	EXPORT_SYMBOL	
++0xa60f5c3e	drm_bridge_chain_post_disable	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0x9e6fb068	ip6_tnl_xmit	net/ipv6/ip6_tunnel	EXPORT_SYMBOL	
++0x0b443e59	dvb_frontend_detach	drivers/media/dvb-core/dvb-core	EXPORT_SYMBOL	
++0x44d724ec	mt76_tx_status_check	drivers/net/wireless/mediatek/mt76/mt76	EXPORT_SYMBOL_GPL	
++0x6c6735aa	drm_gem_shmem_free_object	drivers/gpu/drm/drm	EXPORT_SYMBOL_GPL	
++0xbd0f699d	vsock_addr_bound	net/vmw_vsock/vsock	EXPORT_SYMBOL_GPL	
++0x6cb002e7	p9_client_renameat	net/9p/9pnet	EXPORT_SYMBOL	
++0x058827be	nf_confirm	net/netfilter/nf_conntrack	EXPORT_SYMBOL_GPL	
++0x46bf60b9	ath9k_hw_stop_dma_queue	drivers/net/wireless/ath/ath9k/ath9k_hw	EXPORT_SYMBOL	
++0xd5f41819	neon_aes_ecb_encrypt	arch/arm64/crypto/aes-neon-blk	EXPORT_SYMBOL	
++0xf447b658	ip_vs_conn_out_get_proto	net/netfilter/ipvs/ip_vs	EXPORT_SYMBOL_GPL	
++0x9e6d79f8	snd_info_get_str	sound/core/snd	EXPORT_SYMBOL	
++0xaab0ef04	dm_bitset_cursor_skip	drivers/md/persistent-data/dm-persistent-data	EXPORT_SYMBOL_GPL	
++0x9477afe7	cdrom_get_last_written	drivers/cdrom/cdrom	EXPORT_SYMBOL	
++0x97e05663	rtl_tid_to_ac	drivers/net/wireless/realtek/rtlwifi/rtlwifi	EXPORT_SYMBOL_GPL	
++0xec94ef8c	drm_crtc_vblank_count	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0xadb4187a	drm_crtc_init	drivers/gpu/drm/drm_kms_helper	EXPORT_SYMBOL	
++0x045faebf	drm_dp_mst_connector_early_unregister	drivers/gpu/drm/drm_kms_helper	EXPORT_SYMBOL	
++0xd35a6a53	simd_unregister_skciphers	crypto/crypto_simd	EXPORT_SYMBOL_GPL	
++0xfabfba91	ip_set_match_extensions	net/netfilter/ipset/ip_set	EXPORT_SYMBOL_GPL	
++0x95c1024f	ubi_leb_erase	drivers/mtd/ubi/ubi	EXPORT_SYMBOL_GPL	
++0x7d5e1815	dm_rh_get_region_key	drivers/md/dm-region-hash	EXPORT_SYMBOL_GPL	
++0x69f11a25	mt76x02_phy_dfs_adjust_agc	drivers/net/wireless/mediatek/mt76/mt76x02-lib	EXPORT_SYMBOL_GPL	
++0x3bff1885	drm_dp_dual_mode_write	drivers/gpu/drm/drm_kms_helper	EXPORT_SYMBOL	
++0x968053a0	drm_dp_find_vcpi_slots	drivers/gpu/drm/drm_kms_helper	EXPORT_SYMBOL	
++0x4737738d	xfrm6_rcv_tnl	net/ipv6/ipv6	EXPORT_SYMBOL	
++0x4a0505ec	nf_conncount_init	net/netfilter/nf_conncount	EXPORT_SYMBOL_GPL	
++0x58e77f26	snd_soc_limit_volume	sound/soc/snd-soc-core	EXPORT_SYMBOL_GPL	
++0xc7d094b5	dm_read_arg_group	drivers/md/dm-mod	EXPORT_SYMBOL	
++0x8b456349	zd1301_demod_get_dvb_frontend	drivers/media/dvb-frontends/zd1301_demod	EXPORT_SYMBOL	
++0xa8f714ee	dib3000mc_pid_parse	drivers/media/dvb-frontends/dib3000mc	EXPORT_SYMBOL	
++0x42f0075f	rt2x00queue_unmap_skb	drivers/net/wireless/ralink/rt2x00/rt2x00lib	EXPORT_SYMBOL_GPL	
++0x5bfe2f67	drm_gem_handle_create	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0x286ef4c2	cfg80211_sched_scan_results	net/wireless/cfg80211	EXPORT_SYMBOL	
++0x892f948a	esp_output_head	net/ipv4/esp4	EXPORT_SYMBOL_GPL	
++0x2f778426	register_ip_vs_app_inc	net/netfilter/ipvs/ip_vs	EXPORT_SYMBOL	
++0x32801f50	video_device_release	drivers/media/v4l2-core/videodev	EXPORT_SYMBOL	
++0x61fa0ff4	mt76x02u_mcu_fw_reset	drivers/net/wireless/mediatek/mt76/mt76x02-usb	EXPORT_SYMBOL_GPL	
++0x900a3029	drm_mode_set_config_internal	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0xc3a98c1d	lc_try_lock	lib/lru_cache	EXPORT_SYMBOL	
++0xcd3794c9	cs42448_data	sound/soc/codecs/snd-soc-cs42xx8	EXPORT_SYMBOL_GPL	
++0x390716be	snd_pcm_hw_rule_noresample	sound/core/snd-pcm	EXPORT_SYMBOL	
++0x7c8aa02a	iio_device_attach_buffer	drivers/iio/industrialio	EXPORT_SYMBOL_GPL	
++0x1512a0fb	usbip_recv_xbuff	drivers/usb/usbip/usbip-core	EXPORT_SYMBOL_GPL	
++0xa5dee7d6	rt2x00mac_sw_scan_start	drivers/net/wireless/ralink/rt2x00/rt2x00lib	EXPORT_SYMBOL_GPL	
++0xf146916d	mt76x2_phy_tssi_compensate	drivers/net/wireless/mediatek/mt76/mt76x2/mt76x2-common	EXPORT_SYMBOL_GPL	
++0x7aafeb81	ath9k_hw_btcoex_init_2wire	drivers/net/wireless/ath/ath9k/ath9k_hw	EXPORT_SYMBOL	
++0xf6720336	bcm2835_smi_get_settings_from_regs	drivers/misc/bcm2835_smi	EXPORT_SYMBOL	
++0x94e58293	drm_connector_list_iter_begin	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0x37bfc6ad	drm_helper_mode_fill_fb_struct	drivers/gpu/drm/drm_kms_helper	EXPORT_SYMBOL	
++0xdf8ece83	fuse_conn_put	fs/fuse/fuse	EXPORT_SYMBOL_GPL	
++0x50e45060	ahci_start_fis_rx	drivers/ata/libahci	EXPORT_SYMBOL_GPL	
++0xbb5d6579	em28xx_set_mode	drivers/media/usb/em28xx/em28xx	EXPORT_SYMBOL_GPL	
++0xdd8ec6bd	hchacha_block_arch	arch/arm64/crypto/chacha-neon	EXPORT_SYMBOL	
++0xce3864eb	ZSTD_compress_usingDict	lib/zstd/zstd_compress	EXPORT_SYMBOL	
++0x413eb32a	ieee80211_get_hdrlen_from_skb	net/wireless/cfg80211	EXPORT_SYMBOL	
++0xa400d07d	asoc_simple_set_dailink_name	sound/soc/generic/snd-soc-simple-card-utils	EXPORT_SYMBOL_GPL	
++0xbfc0fe5c	snd_soc_component_initialize	sound/soc/snd-soc-core	EXPORT_SYMBOL_GPL	
++0x1e5252ed	videobuf_querybuf	drivers/media/v4l2-core/videobuf-core	EXPORT_SYMBOL_GPL	
++0x688d2a65	v4l2_clk_enable	drivers/media/v4l2-core/videodev	EXPORT_SYMBOL	
++0x7609b3dc	rt2x00mac_bss_info_changed	drivers/net/wireless/ralink/rt2x00/rt2x00lib	EXPORT_SYMBOL_GPL	
++0xfec7316a	mt76_register_device	drivers/net/wireless/mediatek/mt76/mt76	EXPORT_SYMBOL_GPL	
++0x8b4a379d	cfg80211_update_owe_info_event	net/wireless/cfg80211	EXPORT_SYMBOL	
++0x46511079	gameport_stop_polling	drivers/input/gameport/gameport	EXPORT_SYMBOL	
++0xbf19894c	ipvlan_link_setup	drivers/net/ipvlan/ipvlan	EXPORT_SYMBOL_GPL	
++0xe6ad8b96	ar9003_mci_set_bt_version	drivers/net/wireless/ath/ath9k/ath9k_hw	EXPORT_SYMBOL	
++0x5cdcab0e	ar9003_is_paprd_enabled	drivers/net/wireless/ath/ath9k/ath9k_hw	EXPORT_SYMBOL	
++0x13349f06	drm_i2c_encoder_init	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0x1e208338	nft_fib6_eval	net/ipv6/netfilter/nft_fib_ipv6	EXPORT_SYMBOL_GPL	
++0xb9a6ad29	nft_fib4_eval	net/ipv4/netfilter/nft_fib_ipv4	EXPORT_SYMBOL_GPL	
++0x2e2d360d	__snd_rawmidi_transmit_peek	sound/core/snd-rawmidi	EXPORT_SYMBOL	
++0x8f2f1463	snd_pcm_hw_constraint_msbits	sound/core/snd-pcm	EXPORT_SYMBOL	
++0xc5e0403f	mt76_eeprom_init	drivers/net/wireless/mediatek/mt76/mt76	EXPORT_SYMBOL_GPL	
++0x2b34b4c8	mt76_insert_ccmp_hdr	drivers/net/wireless/mediatek/mt76/mt76	EXPORT_SYMBOL_GPL	
++0x0d294fc1	ath9k_hw_btcoex_set_concur_txprio	drivers/net/wireless/ath/ath9k/ath9k_hw	EXPORT_SYMBOL	
++0x4f765e2e	mipi_dbi_display_is_on	drivers/gpu/drm/drm_mipi_dbi	EXPORT_SYMBOL	
++0xc3cd034d	crc8_populate_lsb	lib/crc8	EXPORT_SYMBOL	
++0xaa8106bc	crc8_populate_msb	lib/crc8	EXPORT_SYMBOL	
++0xadbc6841	asoc_simple_parse_convert	sound/soc/generic/snd-soc-simple-card-utils	EXPORT_SYMBOL_GPL	
++0x73076315	snd_pci_quirk_lookup_id	sound/core/snd	EXPORT_SYMBOL	
++0x3fe39aeb	cec_s_phys_addr	drivers/media/cec/core/cec	EXPORT_SYMBOL_GPL	
++0x409f9708	drm_print_regset32	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0xcc8e8c36	drm_fb_helper_fini	drivers/gpu/drm/drm_kms_helper	EXPORT_SYMBOL	
++0xccb19691	nf_ct_remove_expect	net/netfilter/nf_conntrack	EXPORT_SYMBOL_GPL	
++0x2720fec5	pcm179x_regmap_config	sound/soc/codecs/snd-soc-pcm179x-codec	EXPORT_SYMBOL_GPL	
++0xec1914c6	snd_midi_event_reset_encode	sound/core/seq/snd-seq-midi-event	EXPORT_SYMBOL	
++0xdebe249f	ata_sff_qc_issue	drivers/ata/libata	EXPORT_SYMBOL_GPL	
++0x2ca04a99	drm_send_event_locked	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0x5bebff45	nf_ct_get_id	net/netfilter/nf_conntrack	EXPORT_SYMBOL_GPL	
++0xf45ce9f7	dev_attr_usbip_debug	drivers/usb/usbip/usbip-core	EXPORT_SYMBOL_GPL	
++0x8c4cdec1	drm_syncobj_get_fd	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0xd7098ba5	drm_connector_attach_edid_property	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0xcb5d88ff	virtio_transport_notify_send_pre_enqueue	net/vmw_vsock/vmw_vsock_virtio_transport_common	EXPORT_SYMBOL_GPL	
++0x591abcf9	atm_dev_register	net/atm/atm	EXPORT_SYMBOL	
++0xf7f90f2b	m88ds3103_attach	drivers/media/dvb-frontends/m88ds3103	EXPORT_SYMBOL	
++0x799b7d87	sata_async_notification	drivers/ata/libata	EXPORT_SYMBOL_GPL	
++0xc77c000a	v4l2_event_subdev_unsubscribe	drivers/media/v4l2-core/videodev	EXPORT_SYMBOL_GPL	
++0x3fe97196	p9stat_read	net/9p/9pnet	EXPORT_SYMBOL	
++0x75ff02b7	xt_register_table	net/netfilter/x_tables	EXPORT_SYMBOL_GPL	
++0xd255dbf8	set_h225_addr_hook	net/netfilter/nf_conntrack_h323	EXPORT_SYMBOL_GPL	
++0xa6684bc2	snd_soc_poweroff	sound/soc/snd-soc-core	EXPORT_SYMBOL_GPL	
++0x30ee906b	md_unregister_thread	drivers/md/md-mod	EXPORT_SYMBOL	
++0x8f8d4341	v4l2_get_edid_phys_addr	drivers/media/v4l2-core/v4l2-dv-timings	EXPORT_SYMBOL_GPL	
++0xf8298a54	usb_serial_generic_unthrottle	drivers/usb/serial/usbserial	EXPORT_SYMBOL_GPL	
++0xe0ff7a18	unregister_pppox_proto	drivers/net/ppp/pppox	EXPORT_SYMBOL	
++0x8c52a7de	drm_panel_add	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0x34366c9b	ieee80211_alloc_hw_nm	net/mac80211/mac80211	EXPORT_SYMBOL	
++0x30775250	snd_pcm_hw_constraint_eld	sound/core/snd-pcm	EXPORT_SYMBOL_GPL	
++0x0b9fc807	snd_ctl_activate_id	sound/core/snd	EXPORT_SYMBOL_GPL	
++0xcf8c2590	dm_cache_policy_get_hint_size	drivers/md/dm-cache	EXPORT_SYMBOL_GPL	
++0x922ecd29	v4l2_enum_dv_timings_cap	drivers/media/v4l2-core/v4l2-dv-timings	EXPORT_SYMBOL_GPL	
++0x86cf6e65	usb_serial_generic_submit_read_urbs	drivers/usb/serial/usbserial	EXPORT_SYMBOL_GPL	
++0x2d17ec41	rt2x00mac_sw_scan_complete	drivers/net/wireless/ralink/rt2x00/rt2x00lib	EXPORT_SYMBOL_GPL	
++0xad6d64d7	nf_br_ops	net/bridge/bridge	EXPORT_SYMBOL_GPL	
++0xbecf5d14	nfnl_acct_put	net/netfilter/nfnetlink_acct	EXPORT_SYMBOL_GPL	
++0x7931caa5	dm_exception_store_type_unregister	drivers/md/dm-snapshot	EXPORT_SYMBOL	
++0xbb073f34	usb_serial_generic_close	drivers/usb/serial/usbserial	EXPORT_SYMBOL_GPL	
++0xaa7268ed	mt76x2_mcu_load_cr	drivers/net/wireless/mediatek/mt76/mt76x2/mt76x2-common	EXPORT_SYMBOL_GPL	
++0x8d91b0e6	unregister_ip_vs_scheduler	net/netfilter/ipvs/ip_vs	EXPORT_SYMBOL	
++0xbe3b93f9	asoc_simple_canonicalize_cpu	sound/soc/generic/snd-soc-simple-card-utils	EXPORT_SYMBOL_GPL	
++0x834dc955	snd_pcm_format_size	sound/core/snd-pcm	EXPORT_SYMBOL	
++0x5422febb	dm_cache_policy_register	drivers/md/dm-cache	EXPORT_SYMBOL_GPL	
++0x86098a53	v4l2_ctrl_activate	drivers/media/v4l2-core/videodev	EXPORT_SYMBOL	
++0xd9e310df	dm_cache_policy_unregister	drivers/md/dm-cache	EXPORT_SYMBOL_GPL	
++0x1cda8446	rt2800_config_erp	drivers/net/wireless/ralink/rt2x00/rt2800lib	EXPORT_SYMBOL_GPL	
++0xdc2ba5f7	drm_property_create_object	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0x06c49551	drm_dp_dsc_sink_line_buf_depth	drivers/gpu/drm/drm_kms_helper	EXPORT_SYMBOL	
++0xcfd5c5d8	snd_soc_card_get_kcontrol	sound/soc/snd-soc-core	EXPORT_SYMBOL_GPL	
++0x28dd3631	snd_soc_rtdcom_lookup	sound/soc/snd-soc-core	EXPORT_SYMBOL_GPL	
++0x522c6281	iio_enum_read	drivers/iio/industrialio	EXPORT_SYMBOL_GPL	
++0x890723f7	dm_cache_policy_get_version	drivers/md/dm-cache	EXPORT_SYMBOL_GPL	
++0xaafbe88a	v4l_disable_media_source	drivers/media/v4l2-core/videodev	EXPORT_SYMBOL_GPL	
++0xe2222983	dib9000_set_gpio	drivers/media/dvb-frontends/dib9000	EXPORT_SYMBOL	
++0x3a03fd9d	vb2_wait_for_all_buffers	drivers/media/common/videobuf2/videobuf2-common	EXPORT_SYMBOL_GPL	
++0x7ec13389	flexcop_pid_feed_control	drivers/media/common/b2c2/b2c2-flexcop	EXPORT_SYMBOL	
++0xf47a39c8	ath9k_hw_rxprocdesc	drivers/net/wireless/ath/ath9k/ath9k_hw	EXPORT_SYMBOL	
++0xf49bc67a	atm_pcr_goal	net/atm/atm	EXPORT_SYMBOL	
++0x6da385e5	regulatory_set_wiphy_regd_sync_rtnl	net/wireless/cfg80211	EXPORT_SYMBOL	
++0x59ab8b6e	snd_soc_bytes_info	sound/soc/snd-soc-core	EXPORT_SYMBOL_GPL	
++0x13af024a	v4l2_fwnode_endpoint_parse	drivers/media/v4l2-core/v4l2-fwnode	EXPORT_SYMBOL_GPL	
++0x44341f3a	xc4000_attach	drivers/media/tuners/xc4000	EXPORT_SYMBOL	
++0xb2359f44	xc5000_attach	drivers/media/tuners/xc5000	EXPORT_SYMBOL	
++0x707a2bb4	cdc_ncm_select_altsetting	drivers/net/usb/cdc_ncm	EXPORT_SYMBOL_GPL	
++0xe183c883	rt2800_watchdog	drivers/net/wireless/ralink/rt2x00/rt2800lib	EXPORT_SYMBOL_GPL	
++0xd06d5ef8	drm_gem_dmabuf_vmap	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0x94e481cf	ZSTD_adjustCParams	lib/zstd/zstd_compress	EXPORT_SYMBOL	
++0x3fb4d161	snd_seq_kernel_client_dispatch	sound/core/seq/snd-seq	EXPORT_SYMBOL	
++0x09356f1a	__dm_get_device	drivers/md/dm-mod	EXPORT_SYMBOL	
++0xde906ac9	tap_destroy_cdev	drivers/net/tap	EXPORT_SYMBOL_GPL	
++0xc58fbc11	drm_gem_cma_mmap	drivers/gpu/drm/drm	EXPORT_SYMBOL_GPL	
++0xa99bea75	vsock_core_register	net/vmw_vsock/vsock	EXPORT_SYMBOL_GPL	
++0xc92505c3	drm_object_property_get_value	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0x1dff7b53	vsock_find_connected_socket	net/vmw_vsock/vsock	EXPORT_SYMBOL_GPL	
++0x07ca79b3	lowpan_header_decompress	net/6lowpan/6lowpan	EXPORT_SYMBOL_GPL	
++0xbcf8bf9e	drm_client_buffer_vunmap	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0x48a0175b	snd_soc_dapm_put_volsw	sound/soc/snd-soc-core	EXPORT_SYMBOL_GPL	
++0xd188df55	snd_soc_dapm_get_volsw	sound/soc/snd-soc-core	EXPORT_SYMBOL_GPL	
++0x8c4622d2	v4l2_m2m_querybuf	drivers/media/v4l2-core/v4l2-mem2mem	EXPORT_SYMBOL_GPL	
++0x609f3599	rtl92c_set_p2p_ps_offload_cmd	drivers/net/wireless/realtek/rtlwifi/rtl8192c/rtl8192c-common	EXPORT_SYMBOL_GPL	
++0xd0774304	drm_lspcon_get_mode	drivers/gpu/drm/drm_kms_helper	EXPORT_SYMBOL	
++0x3dfb431f	async_tx_quiesce	crypto/async_tx/async_tx	EXPORT_SYMBOL_GPL	
++0x88a143b6	arizona_in_dmic_osr	sound/soc/codecs/snd-soc-arizona	EXPORT_SYMBOL_GPL	
++0x16756dc0	snd_usbmidi_input_start	sound/usb/snd-usbmidi-lib	EXPORT_SYMBOL	
++0x57609b05	fbtft_probe_common	drivers/staging/fbtft/fbtft	EXPORT_SYMBOL	
++0x2f40da68	dm_bm_set_read_write	drivers/md/persistent-data/dm-persistent-data	EXPORT_SYMBOL_GPL	
++0x72f07bf4	dm_bufio_set_minimum_buffers	drivers/md/dm-bufio	EXPORT_SYMBOL_GPL	
++0x32d43420	v4l2_ctrl_get_name	drivers/media/v4l2-core/videodev	EXPORT_SYMBOL	
++0x80fcb420	v4l2_m2m_expbuf	drivers/media/v4l2-core/v4l2-mem2mem	EXPORT_SYMBOL_GPL	
++0x2d16b626	rt2x00lib_dmadone	drivers/net/wireless/ralink/rt2x00/rt2x00lib	EXPORT_SYMBOL_GPL	
++0x5118378d	p9_show_client_options	net/9p/9pnet	EXPORT_SYMBOL	
++0x474310a6	hci_free_dev	net/bluetooth/bluetooth	EXPORT_SYMBOL	
++0x61d80af5	iio_validate_scan_mask_onehot	drivers/iio/industrialio	EXPORT_SYMBOL_GPL	
++0x6960e899	tpg_s_crop_compose	drivers/media/common/v4l2-tpg/v4l2-tpg	EXPORT_SYMBOL_GPL	
++0x4fa22345	mt76x02_phy_set_txdac	drivers/net/wireless/mediatek/mt76/mt76x02-lib	EXPORT_SYMBOL_GPL	
++0x9a6768f3	virtio_transport_recv_pkt	net/vmw_vsock/vmw_vsock_virtio_transport_common	EXPORT_SYMBOL_GPL	
++0xfe189ffb	snd_soc_set_runtime_hwparams	sound/soc/snd-soc-core	EXPORT_SYMBOL_GPL	
++0x5ea5ec4e	snd_pcm_open_substream	sound/core/snd-pcm	EXPORT_SYMBOL	
++0x5f72340c	ssb_device_disable	drivers/ssb/ssb	EXPORT_SYMBOL	
++0x7c6ec265	mwifiex_handle_rx_packet	drivers/net/wireless/marvell/mwifiex/mwifiex	EXPORT_SYMBOL_GPL	
++0x6fe19547	snd_device_free	sound/core/snd	EXPORT_SYMBOL	
++0x3afbdd45	drm_of_component_probe	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0x849acf0b	drm_connector_set_link_status_property	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0xb36cae4b	sctp_transport_lookup_process	net/sctp/sctp	EXPORT_SYMBOL_GPL	
++0xd30baade	nf_tables_deactivate_flowtable	net/netfilter/nf_tables	EXPORT_SYMBOL_GPL	
++0xd50b606d	snd_soc_debugfs_root	sound/soc/snd-soc-core	EXPORT_SYMBOL_GPL	
++0xf39dd4f2	dm_cell_release_no_holder	drivers/md/dm-bio-prison	EXPORT_SYMBOL_GPL	
++0xe966f71a	au8522_release_state	drivers/media/dvb-frontends/au8522_common	EXPORT_SYMBOL	
++0x1167a051	em28xx_stop_urbs	drivers/media/usb/em28xx/em28xx	EXPORT_SYMBOL_GPL	
++0xdfc0fee3	nf_ct_seq_adjust	net/netfilter/nf_conntrack	EXPORT_SYMBOL_GPL	
++0x261321dc	v4l2_i2c_subdev_addr	drivers/media/v4l2-core/videodev	EXPORT_SYMBOL_GPL	
++0x6c287af6	v4l2_i2c_subdev_init	drivers/media/v4l2-core/videodev	EXPORT_SYMBOL_GPL	
++0xdcbddad2	snd_pcm_period_elapsed	sound/core/snd-pcm	EXPORT_SYMBOL	
++0x10e4e8a9	usbatm_usb_probe	drivers/usb/atm/usbatm	EXPORT_SYMBOL_GPL	
++0x0b88e093	i2400m_dev_bootstrap	drivers/net/wimax/i2400m/i2400m	EXPORT_SYMBOL_GPL	
++0xa59db8fb	drm_av_sync_delay	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0xca9fc082	synproxy_net_id	net/netfilter/nf_synproxy_core	EXPORT_SYMBOL_GPL	
++0xfc3cc85d	iio_convert_raw_to_processed	drivers/iio/industrialio	EXPORT_SYMBOL_GPL	
++0x7541dfde	dm_cell_quiesce_v2	drivers/md/dm-bio-prison	EXPORT_SYMBOL_GPL	
++0xfd44a34e	media_request_pin	drivers/media/mc/mc	EXPORT_SYMBOL_GPL	
++0xc9988e39	lgs8gl5_attach	drivers/media/dvb-frontends/lgs8gl5	EXPORT_SYMBOL	
++0x5950f4a8	drm_panel_remove	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0x5629fcbd	drm_object_attach_property	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0x18dd19c3	mux_control_states	drivers/mux/mux-core	EXPORT_SYMBOL_GPL	
++0x4b4f47b4	iio_read_channel_ext_info	drivers/iio/industrialio	EXPORT_SYMBOL_GPL	
++0x727ea304	charlcd_poke	drivers/auxdisplay/charlcd	EXPORT_SYMBOL_GPL	
++0xb6c18690	setup_udp_tunnel_sock	net/ipv4/udp_tunnel	EXPORT_SYMBOL_GPL	
++0x5729327a	iscsi_tcp_segment_unmap	drivers/scsi/libiscsi_tcp	EXPORT_SYMBOL_GPL	
++0x0801a108	drm_fb_helper_debug_leave	drivers/gpu/drm/drm_kms_helper	EXPORT_SYMBOL	
++0xa76b31a2	crypto_ecdh_shared_secret	crypto/ecc	EXPORT_SYMBOL	
++0x1c3e6e5b	poly1305_init_arch	arch/arm64/crypto/poly1305-neon	EXPORT_SYMBOL	
++0xde58aa85	ieee80211_next_txq	net/mac80211/mac80211	EXPORT_SYMBOL	
++0x4fd317ef	nf_flow_table_cleanup	net/netfilter/nf_flow_table	EXPORT_SYMBOL_GPL	
++0x3e26b6bd	snd_soc_component_read	sound/soc/snd-soc-core	EXPORT_SYMBOL_GPL	
++0x595bdc27	v4l2_ctrl_cluster	drivers/media/v4l2-core/videodev	EXPORT_SYMBOL	
++0x49a4fcbd	adxl34x_remove	drivers/input/misc/adxl34x	EXPORT_SYMBOL_GPL	
++0xce574271	drm_bridge_chain_mode_set	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0x03181fce	nf_ct_frag6_gather	net/ipv6/netfilter/nf_defrag_ipv6	EXPORT_SYMBOL_GPL	
++0x01a73807	ip_tunnel_setup	net/ipv4/ip_tunnel	EXPORT_SYMBOL_GPL	
++0xa0f59194	wm_adsp2_remove	sound/soc/codecs/snd-soc-wm-adsp	EXPORT_SYMBOL_GPL	
++0x2541a979	snd_soc_calc_frame_size	sound/soc/snd-soc-core	EXPORT_SYMBOL_GPL	
++0x356b988c	mtd_kmalloc_up_to	drivers/mtd/mtd	EXPORT_SYMBOL_GPL	
++0x13725912	ahci_start_engine	drivers/ata/libahci	EXPORT_SYMBOL_GPL	
++0x04355e48	ata_platform_remove_one	drivers/ata/libata	EXPORT_SYMBOL_GPL	
++0xa9249908	md_find_rdev_nr_rcu	drivers/md/md-mod	EXPORT_SYMBOL_GPL	
++0x2f34939f	v4l2_event_pending	drivers/media/v4l2-core/videodev	EXPORT_SYMBOL_GPL	
++0x902938cc	rtl92c_dm_check_txpower_tracking	drivers/net/wireless/realtek/rtlwifi/rtl8192c/rtl8192c-common	EXPORT_SYMBOL	
++0x727468a7	mt76x02_phy_set_txpower	drivers/net/wireless/mediatek/mt76/mt76x02-lib	EXPORT_SYMBOL_GPL	
++0x80c84652	iscsi_tcp_dgst_header	drivers/scsi/libiscsi_tcp	EXPORT_SYMBOL_GPL	
++0x747a69b6	iscsi_conn_unbind	drivers/scsi/libiscsi	EXPORT_SYMBOL_GPL	
++0xb827d419	mcp23x17_regmap	drivers/pinctrl/pinctrl-mcp23s08	EXPORT_SYMBOL_GPL	
++0x889c0d0d	snd_soc_dai_link_set_capabilities	sound/soc/snd-soc-core	EXPORT_SYMBOL_GPL	
++0x7ada1b7c	snd_card_rw_proc_new	sound/core/snd	EXPORT_SYMBOL_GPL	
++0x328c02f9	dib0090_update_rframp_7090	drivers/media/dvb-frontends/dib0090	EXPORT_SYMBOL	
++0x0b2c64a3	raid6_vgfmul	lib/raid6/raid6_pq	EXPORT_SYMBOL	
++0x93c5e70d	snd_soc_dapm_free	sound/soc/snd-soc-core	EXPORT_SYMBOL_GPL	
++0x4c8401a1	cxd2820r_attach	drivers/media/dvb-frontends/cxd2820r	EXPORT_SYMBOL	
++0x9a694b28	usb_wwan_write_room	drivers/usb/serial/usb_wwan	EXPORT_SYMBOL	
++0x90e4e6e9	drm_crtc_vblank_count_and_time	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0x978adbe2	drm_bridge_get_modes	drivers/gpu/drm/drm	EXPORT_SYMBOL_GPL	
++0xc2f7ba73	drm_send_event	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0xb681a7e7	register_md_cluster_operations	drivers/md/md-mod	EXPORT_SYMBOL	
++0xa394466e	vb2_fop_write	drivers/media/common/videobuf2/videobuf2-v4l2	EXPORT_SYMBOL_GPL	
++0x41730e00	unregister_cdrom	drivers/cdrom/cdrom	EXPORT_SYMBOL	
++0xf1432ea8	v4l2_m2m_request_queue	drivers/media/v4l2-core/v4l2-mem2mem	EXPORT_SYMBOL_GPL	
++0xb6f4b031	__SCK__tp_func_vb2_qbuf	drivers/media/common/videobuf2/videobuf2-common	EXPORT_SYMBOL_GPL	
++0x2118af9d	rt2x00usb_register_read_async	drivers/net/wireless/ralink/rt2x00/rt2x00usb	EXPORT_SYMBOL_GPL	
++0xade00c87	mt76_mcu_get_response	drivers/net/wireless/mediatek/mt76/mt76	EXPORT_SYMBOL_GPL	
++0xd859ac8c	o2net_fill_node_map	fs/ocfs2/cluster/ocfs2_nodemanager	EXPORT_SYMBOL_GPL	
++0x8c874435	poly1305_init_generic	lib/crypto/libpoly1305	EXPORT_SYMBOL_GPL	
++0xfc94a73f	usbip_recv_iso	drivers/usb/usbip/usbip-core	EXPORT_SYMBOL_GPL	
++0x4ca7d6c6	__lbtf_cmd	drivers/net/wireless/marvell/libertas_tf/libertas_tf	EXPORT_SYMBOL_GPL	
++0xa8ead3c7	ath9k_hw_reset_tsf	drivers/net/wireless/ath/ath9k/ath9k_hw	EXPORT_SYMBOL	
++0xa7e5b31f	inet6_csk_route_req	net/ipv6/ipv6	EXPORT_SYMBOL	
++0xd62e1c07	ip_tunnel_dellink	net/ipv4/ip_tunnel	EXPORT_SYMBOL_GPL	
++0x59aa10cf	rtl_cam_delete_one_entry	drivers/net/wireless/realtek/rtlwifi/rtlwifi	EXPORT_SYMBOL	
++0x297f455b	af_alg_poll	crypto/af_alg	EXPORT_SYMBOL_GPL	
++0xb71827ad	ip_tunnel_init_net	net/ipv4/ip_tunnel	EXPORT_SYMBOL_GPL	
++0x812db06b	synproxy_recv_client_ack_ipv6	net/netfilter/nf_synproxy_core	EXPORT_SYMBOL_GPL	
++0x6f3c0c56	ata_sff_wait_ready	drivers/ata/libata	EXPORT_SYMBOL_GPL	
++0x11837aac	dev_attr_unload_heads	drivers/ata/libata	EXPORT_SYMBOL_GPL	
++0x1c65d1fd	__traceiter_vb2_v4l2_buf_done	drivers/media/v4l2-core/videodev	EXPORT_SYMBOL_GPL	
++0xf833f6ba	dvb_usb_device_init	drivers/media/usb/dvb-usb/dvb-usb	EXPORT_SYMBOL	
++0xb775db55	alloc_ep_req	drivers/usb/gadget/libcomposite	EXPORT_SYMBOL_GPL	
++0x7f081ae7	mt76x02u_mac_start	drivers/net/wireless/mediatek/mt76/mt76x02-usb	EXPORT_SYMBOL_GPL	
++0x39e32b0e	ath9k_hw_setrxfilter	drivers/net/wireless/ath/ath9k/ath9k_hw	EXPORT_SYMBOL	
++0x0185c41e	ath9k_hw_getrxfilter	drivers/net/wireless/ath/ath9k/ath9k_hw	EXPORT_SYMBOL	
++0x90303f9e	drm_modeset_backoff	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0x4522d82a	lc_reset	lib/lru_cache	EXPORT_SYMBOL	
++0x749849d8	LZ4_loadDict	lib/lz4/lz4_compress	EXPORT_SYMBOL	
++0xd1d71e1a	snd_soc_dapm_del_routes	sound/soc/snd-soc-core	EXPORT_SYMBOL_GPL	
++0xca54be54	mtd_ooblayout_set_eccbytes	drivers/mtd/mtd	EXPORT_SYMBOL_GPL	
++0xa1286965	mtd_ooblayout_get_eccbytes	drivers/mtd/mtd	EXPORT_SYMBOL_GPL	
++0x0dc805eb	fbtft_unregister_framebuffer	drivers/staging/fbtft/fbtft	EXPORT_SYMBOL	
++0x0529be72	vb2_core_dqbuf	drivers/media/common/videobuf2/videobuf2-common	EXPORT_SYMBOL_GPL	
++0xd1a3e8e0	fsg_common_create_luns	drivers/usb/gadget/function/usb_f_mass_storage	EXPORT_SYMBOL_GPL	
++0x0c262c6b	i2400m_rx	drivers/net/wimax/i2400m/i2400m	EXPORT_SYMBOL_GPL	
++0x6352dc20	i2400m_tx	drivers/net/wimax/i2400m/i2400m	EXPORT_SYMBOL_GPL	
++0xd112fbe4	snd_soc_dapm_disable_pin_unlocked	sound/soc/snd-soc-core	EXPORT_SYMBOL_GPL	
++0xbd556cbf	ata_bmdma_dumb_qc_prep	drivers/ata/libata	EXPORT_SYMBOL_GPL	
++0x2c3be707	sata_set_spd	drivers/ata/libata	EXPORT_SYMBOL_GPL	
++0xd6f0dbdb	rtl92c_phy_set_txpower_level	drivers/net/wireless/realtek/rtlwifi/rtl8192c/rtl8192c-common	EXPORT_SYMBOL	
++0xb7b38639	mt76_unregister_device	drivers/net/wireless/mediatek/mt76/mt76	EXPORT_SYMBOL_GPL	
++0x958df3ac	zs_free	mm/zsmalloc	EXPORT_SYMBOL_GPL	
++0x2aefa737	register_atm_ioctl	net/atm/atm	EXPORT_SYMBOL	
++0xc101dd07	cfg80211_chandef_usable	net/wireless/cfg80211	EXPORT_SYMBOL	
++0x9ceb8380	ssb_pmu_set_ldo_paref	drivers/ssb/ssb	EXPORT_SYMBOL	
++0x756f9b10	flexcop_device_initialize	drivers/media/common/b2c2/b2c2-flexcop	EXPORT_SYMBOL	
++0xc79ecffb	drm_dp_downstream_is_type	drivers/gpu/drm/drm_kms_helper	EXPORT_SYMBOL	
++0x922bd5e8	fuse_free_conn	fs/fuse/fuse	EXPORT_SYMBOL_GPL	
++0x85b28d5a	cfg80211_iter_combinations	net/wireless/cfg80211	EXPORT_SYMBOL	
++0x7f604125	vhost_dev_check_owner	drivers/vhost/vhost	EXPORT_SYMBOL_GPL	
++0x0a4a0a22	pps_register_source	drivers/pps/pps_core	EXPORT_SYMBOL	
++0x5a7622b9	v4l2_ctrl_new_std	drivers/media/v4l2-core/videodev	EXPORT_SYMBOL	
++0xacb38f48	usb_serial_generic_write	drivers/usb/serial/usbserial	EXPORT_SYMBOL_GPL	
++0x5f88f0b1	ar9003_paprd_is_done	drivers/net/wireless/ath/ath9k/ath9k_hw	EXPORT_SYMBOL	
++0x6000b27a	ar9003_get_pll_sqsum_dvc	drivers/net/wireless/ath/ath9k/ath9k_hw	EXPORT_SYMBOL	
++0xa1df82e4	drm_gem_shmem_prime_import_sg_table	drivers/gpu/drm/drm	EXPORT_SYMBOL_GPL	
++0x62d6e353	drm_gem_shmem_get_pages	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0xde41fdf6	dlmlock	fs/ocfs2/dlm/ocfs2_dlm	EXPORT_SYMBOL_GPL	
++0x8c3b285b	ip6_tnl_encap_setup	net/ipv6/ip6_tunnel	EXPORT_SYMBOL_GPL	
++0x0e4752a2	snd_timer_interrupt	sound/core/snd-timer	EXPORT_SYMBOL	
++0xc451b1b8	dm_bio_from_per_bio_data	drivers/md/dm-mod	EXPORT_SYMBOL_GPL	
++0x504cdb0b	ppp_register_net_channel	drivers/net/ppp/ppp_generic	EXPORT_SYMBOL	
++0x9c1ff941	adau1977_regmap_config	sound/soc/codecs/snd-soc-adau1977	EXPORT_SYMBOL_GPL	
++0x8c82dfca	synth_request_region	drivers/accessibility/speakup/speakup	EXPORT_SYMBOL_GPL	
++0xdf1d3d3c	md_register_thread	drivers/md/md-mod	EXPORT_SYMBOL	
++0x87f39b70	mwifiex_process_hs_config	drivers/net/wireless/marvell/mwifiex/mwifiex	EXPORT_SYMBOL_GPL	
++0xda77bef5	ieee80211_stop_tx_ba_session	net/mac80211/mac80211	EXPORT_SYMBOL	
++0xc6fca5ad	v4l2_m2m_release	drivers/media/v4l2-core/v4l2-mem2mem	EXPORT_SYMBOL_GPL	
++0x0614dd5a	v4l2_video_std_frame_period	drivers/media/v4l2-core/videodev	EXPORT_SYMBOL	
++0xe817eb01	__drm_printfn_err	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0x052452ce	p9_client_wstat	net/9p/9pnet	EXPORT_SYMBOL	
++0xe75030ce	bt_accept_dequeue	net/bluetooth/bluetooth	EXPORT_SYMBOL	
++0xf3d5d22f	w1_triplet	drivers/w1/wire	EXPORT_SYMBOL_GPL	
++0xc248bde2	dm_disk_bitset_init	drivers/md/persistent-data/dm-persistent-data	EXPORT_SYMBOL_GPL	
++0x5acc6c8c	generic_rndis_bind	drivers/net/usb/rndis_host	EXPORT_SYMBOL_GPL	
++0x7b7bc636	drm_atomic_get_old_connector_for_encoder	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0xce9f9e1b	vq_meta_prefetch	drivers/vhost/vhost	EXPORT_SYMBOL_GPL	
++0x87aadb1b	videobuf_mmap_mapper	drivers/media/v4l2-core/videobuf-core	EXPORT_SYMBOL_GPL	
++0xa0de6e50	zl10039_attach	drivers/media/dvb-frontends/zl10039	EXPORT_SYMBOL	
++0xeff26be9	gserial_connect	drivers/usb/gadget/function/u_serial	EXPORT_SYMBOL_GPL	
++0xa0c0de03	hdlcdrv_unregister	drivers/net/hamradio/hdlcdrv	EXPORT_SYMBOL	
++0x7e2df9c1	p9_client_xattrcreate	net/9p/9pnet	EXPORT_SYMBOL_GPL	
++0xb1ed5cb1	__ieee80211_get_radio_led_name	net/mac80211/mac80211	EXPORT_SYMBOL	
++0x8084addf	si470x_viddev_template	drivers/media/radio/si470x/radio-si470x-common	EXPORT_SYMBOL_GPL	
++0x78a7a6e0	usb_wwan_close	drivers/usb/serial/usb_wwan	EXPORT_SYMBOL	
++0xb7869e2f	rtl92c_phy_lc_calibrate	drivers/net/wireless/realtek/rtlwifi/rtl8192c/rtl8192c-common	EXPORT_SYMBOL	
++0xb3f5c776	rtl_lps_enter	drivers/net/wireless/realtek/rtlwifi/rtlwifi	EXPORT_SYMBOL_GPL	
++0xf2d4cc6b	mt76x0_phy_calibrate	drivers/net/wireless/mediatek/mt76/mt76x0/mt76x0-common	EXPORT_SYMBOL_GPL	
++0x6b7003df	mt76x02_mcu_msg_send	drivers/net/wireless/mediatek/mt76/mt76x02-lib	EXPORT_SYMBOL_GPL	
++0xec1764ad	ath9k_hw_getnf	drivers/net/wireless/ath/ath9k/ath9k_hw	EXPORT_SYMBOL	
++0x7342606a	drm_modeset_lock_init	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0x4406c6af	drm_gem_put_pages	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0x9815d4dc	drm_gem_get_pages	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0x33247226	drm_fbdev_generic_setup	drivers/gpu/drm/drm_kms_helper	EXPORT_SYMBOL	
++0xcf9f3328	dlm_release_lockspace	fs/dlm/dlm	EXPORT_SYMBOL_GPL	
++0x4d1d285c	tpg_init	drivers/media/common/v4l2-tpg/v4l2-tpg	EXPORT_SYMBOL_GPL	
++0x21374eec	rt2x00mac_tx_frames_pending	drivers/net/wireless/ralink/rt2x00/rt2x00lib	EXPORT_SYMBOL_GPL	
++0xf6332a01	mt76x02_mac_start	drivers/net/wireless/mediatek/mt76/mt76x02-lib	EXPORT_SYMBOL_GPL	
++0x58570207	drm_master_internal_release	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0xe504d4ef	drm_gem_fb_destroy	drivers/gpu/drm/drm_kms_helper	EXPORT_SYMBOL	
++0x784928c2	snd_soc_component_update_bits_async	sound/soc/snd-soc-core	EXPORT_SYMBOL_GPL	
++0x8d63474d	snd_soc_dapm_ignore_suspend	sound/soc/snd-soc-core	EXPORT_SYMBOL_GPL	
++0x7d39a4f6	cdrom_check_events	drivers/cdrom/cdrom	EXPORT_SYMBOL	
++0xf0fe7047	i2400m_setup	drivers/net/wimax/i2400m/i2400m	EXPORT_SYMBOL_GPL	
++0xe652932b	rt2x00mac_get_stats	drivers/net/wireless/ralink/rt2x00/rt2x00lib	EXPORT_SYMBOL_GPL	
++0x49e0b65e	drm_hdmi_avi_infoframe_colorimetry	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0x27efff25	ieee80211_s1g_channel_width	net/wireless/cfg80211	EXPORT_SYMBOL	
++0x1ab0e295	snd_soc_dai_compr_trigger	sound/soc/snd-soc-core	EXPORT_SYMBOL_GPL	
++0x83bf7f4c	drm_atomic_private_obj_fini	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0x5bd38ab3	drm_release_noglobal	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0x853a28d1	qtree_get_next_id	fs/quota/quota_tree	EXPORT_SYMBOL	
++0x9145507e	p9dirent_read	net/9p/9pnet	EXPORT_SYMBOL	
++0xb08e250f	p9_client_readdir	net/9p/9pnet	EXPORT_SYMBOL	
++0x02e9a0a0	ieee80211_queue_work	net/mac80211/mac80211	EXPORT_SYMBOL	
++0x32d7bd54	l2cap_unregister_user	net/bluetooth/bluetooth	EXPORT_SYMBOL	
++0xa5a09b35	snd_soc_dapm_weak_routes	sound/soc/snd-soc-core	EXPORT_SYMBOL_GPL	
++0x357ab9fd	v4l2_s_ctrl	drivers/media/v4l2-core/videodev	EXPORT_SYMBOL	
++0x71e01530	tpm_chip_unregister	drivers/char/tpm/tpm	EXPORT_SYMBOL_GPL	
++0x6f381e91	l2tp_ioctl	net/l2tp/l2tp_ip	EXPORT_SYMBOL_GPL	
++0x3b822545	__cfg80211_alloc_event_skb	net/wireless/cfg80211	EXPORT_SYMBOL	
++0x19788c06	v4l2_ctrl_subdev_subscribe_event	drivers/media/v4l2-core/videodev	EXPORT_SYMBOL	
++0x1b419e98	__media_pipeline_stop	drivers/media/mc/mc	EXPORT_SYMBOL_GPL	
++0x743b4ada	cx2341x_ext_ctrls	drivers/media/common/cx2341x	EXPORT_SYMBOL	
++0xd6a29164	p54_free_skb	drivers/net/wireless/intersil/p54/p54common	EXPORT_SYMBOL_GPL	
++0x736c35fc	drm_modeset_unlock_all	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0xcb67e188	synproxy_parse_options	net/netfilter/nf_synproxy_core	EXPORT_SYMBOL_GPL	
++0x16406fa7	snd_soc_jack_add_zones	sound/soc/snd-soc-core	EXPORT_SYMBOL_GPL	
++0x043ea81c	snd_pcm_hw_param_first	sound/core/snd-pcm	EXPORT_SYMBOL	
++0x7b6b38f3	bcma_core_disable	drivers/bcma/bcma	EXPORT_SYMBOL_GPL	
++0xe6da8162	vb2_request_queue	drivers/media/common/videobuf2/videobuf2-v4l2	EXPORT_SYMBOL_GPL	
++0xd6fc1921	usb_put_function	drivers/usb/gadget/libcomposite	EXPORT_SYMBOL_GPL	
++0x7994ee38	ip6t_unregister_table	net/ipv6/netfilter/ip6_tables	EXPORT_SYMBOL	
++0xfaca40c0	snd_pcm_new	sound/core/snd-pcm	EXPORT_SYMBOL	
++0x7ebf2f08	__ata_ehi_push_desc	drivers/ata/libata	EXPORT_SYMBOL_GPL	
++0xa54c283d	dvb_usbv2_generic_rw	drivers/media/usb/dvb-usb-v2/dvb_usb_v2	EXPORT_SYMBOL	
++0x4260b534	mt76u_alloc_mcu_queue	drivers/net/wireless/mediatek/mt76/mt76-usb	EXPORT_SYMBOL_GPL	
++0xcefd67e9	qtree_write_dquot	fs/quota/quota_tree	EXPORT_SYMBOL	
++0x53cab07e	_snd_pcm_lib_alloc_vmalloc_buffer	sound/core/snd-pcm	EXPORT_SYMBOL	
++0x59fa3c55	fsg_show_file	drivers/usb/gadget/function/usb_f_mass_storage	EXPORT_SYMBOL_GPL	
++0x9660352e	ath9k_hw_computetxtime	drivers/net/wireless/ath/ath9k/ath9k_hw	EXPORT_SYMBOL	
++0xaa8b7264	drm_sched_dependency_optimized	drivers/gpu/drm/scheduler/gpu-sched	EXPORT_SYMBOL	
++0x372d26b1	mipi_dbi_command_buf	drivers/gpu/drm/drm_mipi_dbi	EXPORT_SYMBOL	
++0x8a41c696	snd_soc_dapm_sync	sound/soc/snd-soc-core	EXPORT_SYMBOL_GPL	
++0x6e0c0bb2	cec_s_phys_addr_from_edid	drivers/media/cec/core/cec	EXPORT_SYMBOL_GPL	
++0xe6426374	v4l2_s_ext_ctrls	drivers/media/v4l2-core/videodev	EXPORT_SYMBOL	
++0xd227d1ef	ath9k_hw_init_btcoex_hw	drivers/net/wireless/ath/ath9k/ath9k_hw	EXPORT_SYMBOL	
++0x8a490c90	rfkill_set_sw_state	net/rfkill/rfkill	EXPORT_SYMBOL	
++0x26e3c6d7	snd_dmaengine_pcm_open	sound/core/snd-pcm-dmaengine	EXPORT_SYMBOL_GPL	
++0xc428068d	sata_deb_timing_long	drivers/ata/libata	EXPORT_SYMBOL_GPL	
++0x673b94a9	ar9003_paprd_create_curve	drivers/net/wireless/ath/ath9k/ath9k_hw	EXPORT_SYMBOL	
++0xb709f241	ip6_route_output_flags_noref	net/ipv6/ipv6	EXPORT_SYMBOL_GPL	
++0x1e6b75a3	nft_parse_register	net/netfilter/nf_tables	EXPORT_SYMBOL_GPL	
++0xcb2bfb94	asoc_simple_init_jack	sound/soc/generic/snd-soc-simple-card-utils	EXPORT_SYMBOL_GPL	
++0x8167ddc7	btintel_set_event_mask	drivers/bluetooth/btintel	EXPORT_SYMBOL_GPL	
++0xc71d73ec	ath9k_hw_gpio_get	drivers/net/wireless/ath/ath9k/ath9k_hw	EXPORT_SYMBOL	
++0x8dba2f8a	drm_connector_atomic_hdr_metadata_equal	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0x87c187e9	drm_atomic_get_mst_topology_state	drivers/gpu/drm/drm_kms_helper	EXPORT_SYMBOL	
++0xf8e81a72	drm_dp_downstream_min_tmds_clock	drivers/gpu/drm/drm_kms_helper	EXPORT_SYMBOL	
++0x5832568a	ieee80211_stop_queue	net/mac80211/mac80211	EXPORT_SYMBOL	
++0xf8a4dd92	ieee80211_csa_finish	net/mac80211/mac80211	EXPORT_SYMBOL	
++0x7ef39823	ieee80211_hdrlen	net/wireless/cfg80211	EXPORT_SYMBOL	
++0xf3251e7b	v4l2_norm_to_name	drivers/media/v4l2-core/videodev	EXPORT_SYMBOL	
++0xe0a8121c	mt76_update_survey	drivers/net/wireless/mediatek/mt76/mt76	EXPORT_SYMBOL_GPL	
++0x6db57803	drm_bridge_get_edid	drivers/gpu/drm/drm	EXPORT_SYMBOL_GPL	
++0x011a7894	sigmadsp_attach	sound/soc/codecs/snd-soc-sigmadsp	EXPORT_SYMBOL_GPL	
++0x47263b05	snd_soc_component_set_sysclk	sound/soc/snd-soc-core	EXPORT_SYMBOL_GPL	
++0xfa05fd87	iio_write_channel_raw	drivers/iio/industrialio	EXPORT_SYMBOL_GPL	
++0x77861680	ata_link_online	drivers/ata/libata	EXPORT_SYMBOL_GPL	
++0x81e91880	smscore_register_device	drivers/media/common/siano/smsmdtv	EXPORT_SYMBOL_GPL	
++0x01241404	gether_get_dev_addr	drivers/usb/gadget/function/u_ether	EXPORT_SYMBOL_GPL	
++0x9bdcb723	gether_set_dev_addr	drivers/usb/gadget/function/u_ether	EXPORT_SYMBOL_GPL	
++0x7dae2c9a	drm_plane_create_rotation_property	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0xd65dfb2b	p9_client_clunk	net/9p/9pnet	EXPORT_SYMBOL	
++0x32a3b22d	cfg80211_chandef_dfs_required	net/wireless/cfg80211	EXPORT_SYMBOL	
++0x003bb2c3	dm_io	drivers/md/dm-mod	EXPORT_SYMBOL	
++0xfd1294c8	__traceiter_mac_txdone	drivers/net/wireless/mediatek/mt76/mt76	EXPORT_SYMBOL_GPL	
++0x5f9c868d	devm_drm_panel_bridge_add_typed	drivers/gpu/drm/drm_kms_helper	EXPORT_SYMBOL	
++0x0d62ae3b	dm_suspended	drivers/md/dm-mod	EXPORT_SYMBOL_GPL	
++0xb6aa87d4	vb2_request_object_is_buffer	drivers/media/common/videobuf2/videobuf2-common	EXPORT_SYMBOL_GPL	
++0x4f85040e	rt2x00lib_get_bssidx	drivers/net/wireless/ralink/rt2x00/rt2x00lib	EXPORT_SYMBOL_GPL	
++0xefcc5fce	tpm2_flush_context	drivers/char/tpm/tpm	EXPORT_SYMBOL_GPL	
++0x365db370	virtio_transport_put_credit	net/vmw_vsock/vmw_vsock_virtio_transport_common	EXPORT_SYMBOL_GPL	
++0x7b291de1	virtio_transport_get_credit	net/vmw_vsock/vmw_vsock_virtio_transport_common	EXPORT_SYMBOL_GPL	
++0x5128137d	ip_vs_conn_put	net/netfilter/ipvs/ip_vs	EXPORT_SYMBOL	
++0x2e0774dc	dm_bufio_get_block_number	drivers/md/dm-bufio	EXPORT_SYMBOL_GPL	
++0x34a173a8	md_update_sb	drivers/md/md-mod	EXPORT_SYMBOL	
++0xc8113db2	__media_remove_intf_link	drivers/media/mc/mc	EXPORT_SYMBOL_GPL	
++0x28707e32	dib7000p_attach	drivers/media/dvb-frontends/dib7000p	EXPORT_SYMBOL	
++0x3255493a	dib7000m_attach	drivers/media/dvb-frontends/dib7000m	EXPORT_SYMBOL	
++0xbc906e5d	tap_create_cdev	drivers/net/tap	EXPORT_SYMBOL_GPL	
++0xbc308af2	mt76x02_eeprom_parse_hw_cap	drivers/net/wireless/mediatek/mt76/mt76x02-lib	EXPORT_SYMBOL_GPL	
++0x737a285c	drm_gem_dmabuf_export	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0x51038602	l2cap_chan_del	net/bluetooth/bluetooth	EXPORT_SYMBOL_GPL	
++0xf4510b06	mtd_write	drivers/mtd/mtd	EXPORT_SYMBOL_GPL	
++0x721b9786	media_get_pad_index	drivers/media/mc/mc	EXPORT_SYMBOL_GPL	
++0xf23db080	vb2_read	drivers/media/common/videobuf2/videobuf2-common	EXPORT_SYMBOL_GPL	
++0x25498113	rndis_status	drivers/net/usb/rndis_host	EXPORT_SYMBOL_GPL	
++0x786d37e1	drm_client_modeset_check	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0xbb5336d5	drm_atomic_helper_commit_modeset_disables	drivers/gpu/drm/drm_kms_helper	EXPORT_SYMBOL	
++0x582f248e	drm_dp_get_adjust_request_pre_emphasis	drivers/gpu/drm/drm_kms_helper	EXPORT_SYMBOL	
++0xa0f51276	wiphy_read_of_freq_limits	net/wireless/cfg80211	EXPORT_SYMBOL	
++0x4dce7dd4	iio_format_value	drivers/iio/industrialio	EXPORT_SYMBOL_GPL	
++0x1b13cf90	ahci_save_initial_config	drivers/ata/libahci	EXPORT_SYMBOL_GPL	
++0x83dbc98d	media_graph_walk_cleanup	drivers/media/mc/mc	EXPORT_SYMBOL_GPL	
++0x05672c12	drm_bridge_attach	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0x5752f31b	lc_del	lib/lru_cache	EXPORT_SYMBOL	
++0xd116cbd8	ieee80211_iter_keys_rcu	net/mac80211/mac80211	EXPORT_SYMBOL	
++0xfd931e04	snd_soc_component_set_jack	sound/soc/snd-soc-core	EXPORT_SYMBOL_GPL	
++0xbac412d7	i2c_hid_ll_driver	drivers/hid/i2c-hid/i2c-hid	EXPORT_SYMBOL_GPL	
++0x187ec1ed	cec_s_conn_info	drivers/media/cec/core/cec	EXPORT_SYMBOL_GPL	
++0x26a9af8c	dvb_dmx_swfilter_packets	drivers/media/dvb-core/dvb-core	EXPORT_SYMBOL	
++0x5d1b4e42	__tracepoint_mac_txdone	drivers/net/wireless/mediatek/mt76/mt76	EXPORT_SYMBOL_GPL	
++0xd5b86c94	ocfs2_plock	fs/ocfs2/ocfs2_stackglue	EXPORT_SYMBOL_GPL	
++0x3cbecf08	snd_jack_set_key	sound/core/snd	EXPORT_SYMBOL	
++0xf14e5829	ata_cable_sata	drivers/ata/libata	EXPORT_SYMBOL_GPL	
++0xc4e55b1f	drm_dev_alloc	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0xf7f78fbc	drm_fb_helper_cfb_fillrect	drivers/gpu/drm/drm_kms_helper	EXPORT_SYMBOL	
++0xa155c071	ZSTD_compressBegin_usingDict	lib/zstd/zstd_compress	EXPORT_SYMBOL	
++0x61ce5abf	snd_soc_dapm_enable_pin_unlocked	sound/soc/snd-soc-core	EXPORT_SYMBOL_GPL	
++0xcb90a5fc	btintel_version_info_tlv	drivers/bluetooth/btintel	EXPORT_SYMBOL_GPL	
++0x135bdfa6	ubi_leb_map	drivers/mtd/ubi/ubi	EXPORT_SYMBOL_GPL	
++0x62becf0b	drm_hdcp_check_ksvs_revoked	drivers/gpu/drm/drm	EXPORT_SYMBOL_GPL	
++0x3cb97384	drm_gem_map_detach	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0x8b605282	drm_gem_map_attach	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0x2c7e5f84	dlm_posix_lock	fs/dlm/dlm	EXPORT_SYMBOL_GPL	
++0x5bad0966	print_tuple	net/netfilter/nf_conntrack	EXPORT_SYMBOL_GPL	
++0xda51e9a5	wm_halo_init	sound/soc/codecs/snd-soc-wm-adsp	EXPORT_SYMBOL_GPL	
++0xd1940ea8	snd_soc_dai_set_clkdiv	sound/soc/snd-soc-core	EXPORT_SYMBOL_GPL	
++0x60695425	iio_device_release_direct_mode	drivers/iio/industrialio	EXPORT_SYMBOL_GPL	
++0x3312795a	ata_sas_queuecmd	drivers/ata/libata	EXPORT_SYMBOL_GPL	
++0xdacb2a56	dib0090_set_vga	drivers/media/dvb-frontends/dib0090	EXPORT_SYMBOL	
++0x73175c08	rtl92c_set_fw_rsvdpagepkt	drivers/net/wireless/realtek/rtlwifi/rtl8192c/rtl8192c-common	EXPORT_SYMBOL	
++0xfe355980	drm_gem_shmem_purge	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0x8c1d0f70	snd_soc_dapm_force_enable_pin_unlocked	sound/soc/snd-soc-core	EXPORT_SYMBOL_GPL	
++0xb796c672	em28xx_audio_analog_set	drivers/media/usb/em28xx/em28xx	EXPORT_SYMBOL_GPL	
++0x3e877464	usb_add_config_only	drivers/usb/gadget/libcomposite	EXPORT_SYMBOL_GPL	
++0xcd2ba798	dm_bufio_forget	drivers/md/dm-bufio	EXPORT_SYMBOL_GPL	
++0xd89e4ec0	drm_class_device_register	drivers/gpu/drm/drm	EXPORT_SYMBOL_GPL	
++0x674a6bcb	drm_sched_job_init	drivers/gpu/drm/scheduler/gpu-sched	EXPORT_SYMBOL	
++0xf5a54af8	mipi_dbi_dev_init	drivers/gpu/drm/drm_mipi_dbi	EXPORT_SYMBOL	
++0x80282484	drm_gtf_mode	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0x9f65c857	ZSTD_checkCParams	lib/zstd/zstd_compress	EXPORT_SYMBOL	
++0x7bb319a0	virtio_transport_stream_has_space	net/vmw_vsock/vmw_vsock_virtio_transport_common	EXPORT_SYMBOL_GPL	
++0x72df0a45	snd_rawmidi_transmit_empty	sound/core/snd-rawmidi	EXPORT_SYMBOL	
++0x6b455fd4	snd_timer_open	sound/core/snd-timer	EXPORT_SYMBOL	
++0x0311a148	iio_device_set_clock	drivers/iio/industrialio	EXPORT_SYMBOL	
++0x56009b09	__v4l2_ctrl_grab	drivers/media/v4l2-core/videodev	EXPORT_SYMBOL	
++0xa724a262	vb2_ioctl_create_bufs	drivers/media/common/videobuf2/videobuf2-v4l2	EXPORT_SYMBOL_GPL	
++0x52975aeb	rt2800_wait_wpdma_ready	drivers/net/wireless/ralink/rt2x00/rt2800lib	EXPORT_SYMBOL_GPL	
++0x68ba921d	drm_bridge_remove	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0x7b0c7794	drm_atomic_helper_crtc_destroy_state	drivers/gpu/drm/drm_kms_helper	EXPORT_SYMBOL	
++0x17d52b01	drm_dp_dpcd_write	drivers/gpu/drm/drm_kms_helper	EXPORT_SYMBOL	
++0xeafb02d2	v9fs_get_trans_by_name	net/9p/9pnet	EXPORT_SYMBOL	
++0x3e2ecee9	ax25_listen_release	net/ax25/ax25	EXPORT_SYMBOL	
++0x9a55465f	devm_snd_dmaengine_pcm_register	sound/soc/snd-soc-core	EXPORT_SYMBOL_GPL	
++0x861a49ea	snd_jack_set_parent	sound/core/snd	EXPORT_SYMBOL	
++0x0fc1f38b	serio_unregister_driver	drivers/input/serio/serio	EXPORT_SYMBOL	
++0x8f846687	dvb_dmx_init	drivers/media/dvb-core/dvb-core	EXPORT_SYMBOL	
++0xe1ea0586	usbip_dump_header	drivers/usb/usbip/usbip-core	EXPORT_SYMBOL_GPL	
++0x1d78fae3	drm_modeset_lock_all	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0xe94a4dec	ebt_unregister_table	net/bridge/netfilter/ebtables	EXPORT_SYMBOL	
++0x6a5e2bde	__cookie_v6_init_sequence	net/ipv6/ipv6	EXPORT_SYMBOL_GPL	
++0x72d6dd86	ip_set_type_register	net/netfilter/ipset/ip_set	EXPORT_SYMBOL_GPL	
++0x31341550	nat_rtp_rtcp_hook	net/netfilter/nf_conntrack_h323	EXPORT_SYMBOL_GPL	
++0xdac78357	w1_touch_bit	drivers/w1/wire	EXPORT_SYMBOL_GPL	
++0x9720d758	ata_bmdma_stop	drivers/ata/libata	EXPORT_SYMBOL_GPL	
++0x08db00e0	fbtft_framebuffer_alloc	drivers/staging/fbtft/fbtft	EXPORT_SYMBOL	
++0x5e7ba8b8	efuse_power_switch	drivers/net/wireless/realtek/rtlwifi/rtlwifi	EXPORT_SYMBOL	
++0x50674de7	drm_timeout_abs_to_jiffies	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0xbf983525	ip6t_do_table	net/ipv6/netfilter/ip6_tables	EXPORT_SYMBOL	
++0x92ad7a50	ata_std_postreset	drivers/ata/libata	EXPORT_SYMBOL_GPL	
++0xfc14bb2e	dm_get_dev_t	drivers/md/dm-mod	EXPORT_SYMBOL_GPL	
++0xc7db129d	v4l2_i2c_subdev_set_name	drivers/media/v4l2-core/videodev	EXPORT_SYMBOL_GPL	
++0xc80cd70a	drm_dp_read_desc	drivers/gpu/drm/drm_kms_helper	EXPORT_SYMBOL	
++0x68ccae5c	simd_register_skciphers_compat	crypto/crypto_simd	EXPORT_SYMBOL_GPL	
++0x0627ea9a	ieee80211_mark_rx_ba_filtered_frames	net/mac80211/mac80211	EXPORT_SYMBOL	
++0x0628ad7a	nf_ct_expect_init	net/netfilter/nf_conntrack	EXPORT_SYMBOL_GPL	
++0xfb68e74f	asoc_simple_dai_init	sound/soc/generic/snd-soc-simple-card-utils	EXPORT_SYMBOL_GPL	
++0x079731b8	arizona_out_ev	sound/soc/codecs/snd-soc-arizona	EXPORT_SYMBOL_GPL	
++0x04e1b99f	snd_pcm_std_chmaps	sound/core/snd-pcm	EXPORT_SYMBOL_GPL	
++0x2d912492	snd_unregister_oss_device	sound/core/snd	EXPORT_SYMBOL	
++0x9590abf0	btbcm_setup_apple	drivers/bluetooth/btbcm	EXPORT_SYMBOL_GPL	
++0xef13e96f	gameport_start_polling	drivers/input/gameport/gameport	EXPORT_SYMBOL	
++0x6d4c9467	pcm512x_regmap	sound/soc/codecs/snd-soc-pcm512x	EXPORT_SYMBOL_GPL	
++0x656dcd64	dapm_pinctrl_event	sound/soc/snd-soc-core	EXPORT_SYMBOL_GPL	
++0x858df655	btbcm_finalize	drivers/bluetooth/btbcm	EXPORT_SYMBOL_GPL	
++0x754685fa	put_mtd_device	drivers/mtd/mtd	EXPORT_SYMBOL_GPL	
++0x4f6c8b6b	mddev_suspend	drivers/md/md-mod	EXPORT_SYMBOL_GPL	
++0x11affa63	usb_ep_autoconfig_reset	drivers/usb/gadget/libcomposite	EXPORT_SYMBOL_GPL	
++0x91cfb0bd	rndis_set_param_vendor	drivers/usb/gadget/function/usb_f_rndis	EXPORT_SYMBOL_GPL	
++0x7a1bcd59	gf128mul_x8_ble	crypto/gf128mul	EXPORT_SYMBOL	
++0x818867dd	ip_tunnel_changelink	net/ipv4/ip_tunnel	EXPORT_SYMBOL_GPL	
++0x1890a098	mtd_get_fact_prot_info	drivers/mtd/mtd	EXPORT_SYMBOL_GPL	
++0x8a24eb7d	spk_var_show	drivers/accessibility/speakup/speakup	EXPORT_SYMBOL_GPL	
++0xf59dab95	dib9000_set_i2c_adapter	drivers/media/dvb-frontends/dib9000	EXPORT_SYMBOL	
++0xe5013c58	dibx000_get_i2c_adapter	drivers/media/dvb-frontends/dibx000_common	EXPORT_SYMBOL	
++0x1624bdf3	drm_object_property_set_value	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0x868463bf	line6_send_raw_message	sound/usb/line6/snd-usb-line6	EXPORT_SYMBOL_GPL	
++0x68f5bfb5	bcma_chipco_pll_read	drivers/bcma/bcma	EXPORT_SYMBOL_GPL	
++0xe4ac339d	v4l2_m2m_last_buffer_done	drivers/media/v4l2-core/v4l2-mem2mem	EXPORT_SYMBOL_GPL	
++0xc6ebcd8b	mt76x2_get_power_info	drivers/net/wireless/mediatek/mt76/mt76x2/mt76x2-common	EXPORT_SYMBOL_GPL	
++0xb043b653	__snd_pcm_lib_xfer	sound/core/snd-pcm	EXPORT_SYMBOL	
++0x35cf89a1	devm_iio_triggered_buffer_setup	drivers/iio/buffer/industrialio-triggered-buffer	EXPORT_SYMBOL_GPL	
++0x0953e228	mt352_attach	drivers/media/dvb-frontends/mt352	EXPORT_SYMBOL	
++0x5598d318	mt312_attach	drivers/media/dvb-frontends/mt312	EXPORT_SYMBOL	
++0x24d124ac	drm_mode_equal_no_clocks_no_stereo	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0xad2843f3	fuse_sync_release	fs/fuse/fuse	EXPORT_SYMBOL_GPL	
++0xfbc50c0f	ip6t_unregister_table_exit	net/ipv6/netfilter/ip6_tables	EXPORT_SYMBOL	
++0x3829c00b	nf_conntrack_alter_reply	net/netfilter/nf_conntrack	EXPORT_SYMBOL_GPL	
++0x48e31891	arizona_anc_ng_enum	sound/soc/codecs/snd-soc-arizona	EXPORT_SYMBOL_GPL	
++0x4f6c9aaf	snd_rawmidi_proceed	sound/core/snd-rawmidi	EXPORT_SYMBOL	
++0xc165e08c	iio_read_channel_processed	drivers/iio/industrialio	EXPORT_SYMBOL_GPL	
++0x577e3459	cx231xx_send_gpio_cmd	drivers/media/usb/cx231xx/cx231xx	EXPORT_SYMBOL_GPL	
++0xf0b84d54	drm_crtc_handle_vblank	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0x1b503288	drm_framebuffer_lookup	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0x2c3c221b	ata_scsi_unlock_native_capacity	drivers/ata/libata	EXPORT_SYMBOL_GPL	
++0x4d5be10d	v4l2_ctrl_subdev_log_status	drivers/media/v4l2-core/videodev	EXPORT_SYMBOL	
++0xb47b1490	mt76x2_mcu_tssi_comp	drivers/net/wireless/mediatek/mt76/mt76x2/mt76x2-common	EXPORT_SYMBOL_GPL	
++0x5a495a57	mt76x2_get_temp_comp	drivers/net/wireless/mediatek/mt76/mt76x2/mt76x2-common	EXPORT_SYMBOL_GPL	
++0xe3e6ba3b	iscsi_queuecommand	drivers/scsi/libiscsi	EXPORT_SYMBOL_GPL	
++0x3b083bb1	drm_gem_handle_delete	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0xb54ae948	drm_panel_bridge_add_typed	drivers/gpu/drm/drm_kms_helper	EXPORT_SYMBOL	
++0x1a5faa3a	vli_mod_inv	crypto/ecc	EXPORT_SYMBOL	
++0xcd224e1d	dlm_new_lockspace	fs/dlm/dlm	EXPORT_SYMBOL_GPL	
++0x3bbc16eb	cfg80211_unlink_bss	net/wireless/cfg80211	EXPORT_SYMBOL	
++0x661bb969	nf_conncount_list_init	net/netfilter/nf_conncount	EXPORT_SYMBOL_GPL	
++0x47b9f8fa	mt76_seq_puts_array	drivers/net/wireless/mediatek/mt76/mt76	EXPORT_SYMBOL_GPL	
++0xef11daad	p9_client_xattrwalk	net/9p/9pnet	EXPORT_SYMBOL_GPL	
++0xcb0b9d27	ip_tunnel_xmit	net/ipv4/ip_tunnel	EXPORT_SYMBOL_GPL	
++0x11eba48e	snd_pcm_create_iec958_consumer_hw_params	sound/core/snd-pcm	EXPORT_SYMBOL	
++0xb20f811c	tpm_chip_stop	drivers/char/tpm/tpm	EXPORT_SYMBOL_GPL	
++0x58cd5b1e	nf_ct_helper_expectfn_unregister	net/netfilter/nf_conntrack	EXPORT_SYMBOL_GPL	
++0xfcb3925f	mtd_blktrans_cease_background	drivers/mtd/mtd_blkdevs	EXPORT_SYMBOL_GPL	
++0x8b9570ae	videobuf_read_stream	drivers/media/v4l2-core/videobuf-core	EXPORT_SYMBOL_GPL	
++0xa5cae92f	fsg_ss_bulk_out_comp_desc	drivers/usb/gadget/function/usb_f_mass_storage	EXPORT_SYMBOL_GPL	
++0x57fe0412	hostap_set_roaming	drivers/net/wireless/intersil/hostap/hostap	EXPORT_SYMBOL	
++0xbd946d9c	ath9k_hw_setpower	drivers/net/wireless/ath/ath9k/ath9k_hw	EXPORT_SYMBOL	
++0xbd13ee5d	o2hb_check_node_heartbeating_no_sem	fs/ocfs2/cluster/ocfs2_nodemanager	EXPORT_SYMBOL_GPL	
++0x647d6170	dlm_lock	fs/dlm/dlm	EXPORT_SYMBOL_GPL	
++0x58efad9a	xfrm6_tunnel_register	net/ipv6/tunnel6	EXPORT_SYMBOL	
++0xca600305	xfrm4_tunnel_register	net/ipv4/tunnel4	EXPORT_SYMBOL	
++0xa141c876	ssb_clockspeed	drivers/ssb/ssb	EXPORT_SYMBOL	
++0xcb67b1a4	mt76_mmio_init	drivers/net/wireless/mediatek/mt76/mt76	EXPORT_SYMBOL_GPL	
++0xbf2ac349	drm_crtc_from_index	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0xb26d1fe8	drm_atomic_helper_shutdown	drivers/gpu/drm/drm_kms_helper	EXPORT_SYMBOL	
++0xc51d0641	drm_dp_mst_topology_mgr_init	drivers/gpu/drm/drm_kms_helper	EXPORT_SYMBOL	
++0xbd5e37b8	p9_client_readlink	net/9p/9pnet	EXPORT_SYMBOL	
++0xe4ddea37	nf_nat_icmpv6_reply_translation	net/netfilter/nf_nat	EXPORT_SYMBOL_GPL	
++0xc8269f94	snd_soc_params_to_frame_size	sound/soc/snd-soc-core	EXPORT_SYMBOL_GPL	
++0xd4dacf06	snd_pcm_lib_ioctl	sound/core/snd-pcm	EXPORT_SYMBOL	
++0x044a52ae	w1_read_8	drivers/w1/wire	EXPORT_SYMBOL_GPL	
++0xc319c604	synth_putws_s	drivers/accessibility/speakup/speakup	EXPORT_SYMBOL_GPL	
++0x6e3567fa	rtl_rx_ampdu_apply	drivers/net/wireless/realtek/rtlwifi/rtlwifi	EXPORT_SYMBOL	
++0xa52067cf	rt2x00queue_stop_queue	drivers/net/wireless/ralink/rt2x00/rt2x00lib	EXPORT_SYMBOL_GPL	
++0xd944152f	brcmu_pktq_peek_tail	drivers/net/wireless/broadcom/brcm80211/brcmutil/brcmutil	EXPORT_SYMBOL	
++0xe582170b	brcmu_pktq_pdeq_tail	drivers/net/wireless/broadcom/brcm80211/brcmutil/brcmutil	EXPORT_SYMBOL	
++0xff94397f	brcmu_pktq_penq_head	drivers/net/wireless/broadcom/brcm80211/brcmutil/brcmutil	EXPORT_SYMBOL	
++0x39efcedb	lc_seq_printf_stats	lib/lru_cache	EXPORT_SYMBOL	
++0x6709a2cc	mt76_rx_aggr_start	drivers/net/wireless/mediatek/mt76/mt76	EXPORT_SYMBOL_GPL	
++0x1396d3d1	of_find_backlight_by_node	drivers/video/backlight/backlight	EXPORT_SYMBOL	
++0xe9091e30	ip6_append_data	net/ipv6/ipv6	EXPORT_SYMBOL_GPL	
++0xd0ddd5b4	v4l2_device_register	drivers/media/v4l2-core/videodev	EXPORT_SYMBOL_GPL	
++0x115b7dfa	mt76_dma_attach	drivers/net/wireless/mediatek/mt76/mt76	EXPORT_SYMBOL_GPL	
++0xb8bdb3f5	drm_puts	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0x9c995c69	xt_percpu_counter_alloc	net/netfilter/x_tables	EXPORT_SYMBOL_GPL	
++0x750e0f6f	snd_pcm_create_iec958_consumer	sound/core/snd-pcm	EXPORT_SYMBOL	
++0xf13ff84d	v4l2_m2m_unregister_media_controller	drivers/media/v4l2-core/v4l2-mem2mem	EXPORT_SYMBOL_GPL	
++0x4bc55f22	drm_dp_read_mst_cap	drivers/gpu/drm/drm_kms_helper	EXPORT_SYMBOL	
++0x41a3fd08	cast5_setkey	crypto/cast5_generic	EXPORT_SYMBOL_GPL	
++0x0ffcfd24	ata_sff_softreset	drivers/ata/libata	EXPORT_SYMBOL_GPL	
++0x35be3fea	ata_scsi_dma_need_drain	drivers/ata/libata	EXPORT_SYMBOL_GPL	
++0x4847f59d	drm_atomic_helper_cleanup_planes	drivers/gpu/drm/drm_kms_helper	EXPORT_SYMBOL	
++0xbbd15a51	speakup_start_ttys	drivers/accessibility/speakup/speakup	EXPORT_SYMBOL_GPL	
++0x693e74ba	ttpci_eeprom_decode_mac	drivers/media/pci/ttpci/ttpci-eeprom	EXPORT_SYMBOL	
++0xf0e22068	drm_mode_config_cleanup	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0xbea04443	drm_bridge_connector_enable_hpd	drivers/gpu/drm/drm_kms_helper	EXPORT_SYMBOL_GPL	
++0xac131fe4	dib9000_get_component_bus_interface	drivers/media/dvb-frontends/dib9000	EXPORT_SYMBOL	
++0x461c2f49	drm_of_encoder_active_endpoint	drivers/gpu/drm/drm	EXPORT_SYMBOL_GPL	
++0xd151bd2b	drm_ioctl_permit	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0x17f54263	raid6_gfexp	lib/raid6/raid6_pq	EXPORT_SYMBOL	
++0xaa024146	sonet_copy_stats	net/atm/atm	EXPORT_SYMBOL	
++0x2420386f	arizona_isrc_fsl	sound/soc/codecs/snd-soc-arizona	EXPORT_SYMBOL_GPL	
++0xe194d0ef	synth_printf	drivers/accessibility/speakup/speakup	EXPORT_SYMBOL_GPL	
++0x359fc0aa	dvb_register_frontend	drivers/media/dvb-core/dvb-core	EXPORT_SYMBOL	
++0xbecace28	can_rx_register	net/can/can	EXPORT_SYMBOL	
++0x4d5718b3	ipcomp_init_state	net/xfrm/xfrm_ipcomp	EXPORT_SYMBOL_GPL	
++0x139f79c6	xt_check_match	net/netfilter/x_tables	EXPORT_SYMBOL_GPL	
++0xce267ca5	nf_nat_helper_register	net/netfilter/nf_conntrack	EXPORT_SYMBOL_GPL	
++0xac85123b	iio_show_mount_matrix	drivers/iio/industrialio	EXPORT_SYMBOL_GPL	
++0x6bd29619	btintel_version_info	drivers/bluetooth/btintel	EXPORT_SYMBOL_GPL	
++0x53bcccbe	dib3000mc_attach	drivers/media/dvb-frontends/dib3000mc	EXPORT_SYMBOL	
++0xa97e54da	dib3000mb_attach	drivers/media/dvb-frontends/dib3000mb	EXPORT_SYMBOL	
++0xe5dd2b27	usb_ep_autoconfig	drivers/usb/gadget/libcomposite	EXPORT_SYMBOL_GPL	
++0x769e9e34	rtl_global_var	drivers/net/wireless/realtek/rtlwifi/rtlwifi	EXPORT_SYMBOL_GPL	
++0x0a661edb	drm_syncobj_find_fence	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0x9b95c885	drm_mode_match	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0xb05e3544	drm_atomic_helper_check_planes	drivers/gpu/drm/drm_kms_helper	EXPORT_SYMBOL	
++0xf5cd2d67	nf_reject_iphdr_put	net/ipv4/netfilter/nf_reject_ipv4	EXPORT_SYMBOL_GPL	
++0x6b41db80	pcm186x_probe	sound/soc/codecs/snd-soc-pcm186x	EXPORT_SYMBOL_GPL	
++0x35e7e409	snd_soc_unregister_component	sound/soc/snd-soc-core	EXPORT_SYMBOL_GPL	
++0x190d2145	iio_channel_cb_get_channels	drivers/iio/buffer/industrialio-buffer-cb	EXPORT_SYMBOL_GPL	
++0xd7b07952	pps_unregister_source	drivers/pps/pps_core	EXPORT_SYMBOL	
++0x4449e1dd	synth_buffer_clear	drivers/accessibility/speakup/speakup	EXPORT_SYMBOL_GPL	
++0x2212481d	ts2020_attach	drivers/media/dvb-frontends/ts2020	EXPORT_SYMBOL	
++0x9cb05efb	s5h1432_attach	drivers/media/dvb-frontends/s5h1432	EXPORT_SYMBOL	
++0x67cff061	mipi_dbi_poweron_reset	drivers/gpu/drm/drm_mipi_dbi	EXPORT_SYMBOL	
++0x59056243	drm_mm_replace_node	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0x6dbc7d22	l2tp_session_get	net/l2tp/l2tp_core	EXPORT_SYMBOL_GPL	
++0xe6949e6b	em28xx_setup_xc3028	drivers/media/usb/em28xx/em28xx	EXPORT_SYMBOL_GPL	
++0xd284df8b	mxl5005s_attach	drivers/media/tuners/mxl5005s	EXPORT_SYMBOL	
++0x22b0d483	dm_restorepowerindex	drivers/net/wireless/realtek/rtlwifi/rtl8192c/rtl8192c-common	EXPORT_SYMBOL_GPL	
++0x4f18a150	__drm_debug	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0x70a8ff01	drm_mode_config_helper_resume	drivers/gpu/drm/drm_kms_helper	EXPORT_SYMBOL	
++0xd7ba575e	dlm_errmsg	fs/ocfs2/dlm/ocfs2_dlm	EXPORT_SYMBOL_GPL	
++0x76e9c5f9	ata_host_start	drivers/ata/libata	EXPORT_SYMBOL_GPL	
++0x8c72fb47	rndis_free_response	drivers/usb/gadget/function/usb_f_rndis	EXPORT_SYMBOL_GPL	
++0x35d2834d	mt76x02_limit_rate_power	drivers/net/wireless/mediatek/mt76/mt76x02-lib	EXPORT_SYMBOL_GPL	
++0x7bc3d667	mt76_free_device	drivers/net/wireless/mediatek/mt76/mt76	EXPORT_SYMBOL_GPL	
++0xa5e6d325	drm_scdc_read	drivers/gpu/drm/drm_kms_helper	EXPORT_SYMBOL	
++0xb6ebf62a	o2nm_this_node	fs/ocfs2/cluster/ocfs2_nodemanager	EXPORT_SYMBOL_GPL	
++0x4443d399	atm_proc_root	net/atm/atm	EXPORT_SYMBOL	
++0x047a9162	snd_component_add	sound/core/snd	EXPORT_SYMBOL	
++0x84dad068	synth_buffer_getc	drivers/accessibility/speakup/speakup	EXPORT_SYMBOL_GPL	
++0x744798e9	l2cap_chan_list	net/bluetooth/bluetooth	EXPORT_SYMBOL_GPL	
++0x58b7c658	ip6t_alloc_initial_table	net/ipv6/netfilter/ip6_tables	EXPORT_SYMBOL_GPL	
++0x68770047	wm_adsp1_event	sound/soc/codecs/snd-soc-wm-adsp	EXPORT_SYMBOL_GPL	
++0x46e28f2f	mtd_writev	drivers/mtd/mtd	EXPORT_SYMBOL_GPL	
++0x13f4ede1	mtd_read_oob	drivers/mtd/mtd	EXPORT_SYMBOL_GPL	
++0x5ec62549	ata_dev_classify	drivers/ata/libata	EXPORT_SYMBOL_GPL	
++0xf703a3f9	__tracepoint_vb2_dqbuf	drivers/media/common/videobuf2/videobuf2-common	EXPORT_SYMBOL_GPL	
++0xc2821775	tuner_count	drivers/media/tuners/tuner-types	EXPORT_SYMBOL	
++0x2e6e8ae2	hostap_set_encryption	drivers/net/wireless/intersil/hostap/hostap	EXPORT_SYMBOL	
++0x559b2f35	drm_of_crtc_port_mask	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0x55e367f8	drm_gem_shmem_create_object_cached	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0x7c28f551	wimax_reset	net/wimax/wimax	EXPORT_SYMBOL	
++0x397f6231	ip_set_free	net/netfilter/ipset/ip_set	EXPORT_SYMBOL_GPL	
++0x5b38f65c	nf_nat_mangle_udp_packet	net/netfilter/nf_nat	EXPORT_SYMBOL	
++0xff538f90	snd_soc_dapm_get_pin_status	sound/soc/snd-soc-core	EXPORT_SYMBOL_GPL	
++0xecae70ce	snd_soc_dapm_update_dai	sound/soc/snd-soc-core	EXPORT_SYMBOL_GPL	
++0x7902637c	si21xx_attach	drivers/media/dvb-frontends/si21xx	EXPORT_SYMBOL	
++0x37d8e032	smscore_unregister_hotplug	drivers/media/common/siano/smsmdtv	EXPORT_SYMBOL_GPL	
++0x0f50fbe9	mt76_sw_scan_complete	drivers/net/wireless/mediatek/mt76/mt76	EXPORT_SYMBOL_GPL	
++0x1912a757	nfc_class	net/nfc/nfc	EXPORT_SYMBOL	
++0xc0cdc0ed	ieee80211_restart_hw	net/mac80211/mac80211	EXPORT_SYMBOL	
++0x7c576277	smsendian_handle_message_header	drivers/media/common/siano/smsmdtv	EXPORT_SYMBOL_GPL	
++0xba5fb7e6	mt76x02_enqueue_buffered_bc	drivers/net/wireless/mediatek/mt76/mt76x02-lib	EXPORT_SYMBOL_GPL	
++0xd60afcef	hostap_80211_rx	drivers/net/wireless/intersil/hostap/hostap	EXPORT_SYMBOL	
++0xf8c3c2d1	iscsi_tcp_recv_segment_is_hdr	drivers/scsi/libiscsi_tcp	EXPORT_SYMBOL_GPL	
++0xceee0664	iscsi_itt_to_ctask	drivers/scsi/libiscsi	EXPORT_SYMBOL_GPL	
++0x32f2b87f	vhost_vq_init_access	drivers/vhost/vhost	EXPORT_SYMBOL_GPL	
++0x7228d3d7	nxt6000_attach	drivers/media/dvb-frontends/nxt6000	EXPORT_SYMBOL	
++0x2e63a6cf	input_ff_create_memless	drivers/input/ff-memless	EXPORT_SYMBOL_GPL	
++0x59fd9076	mt76x02_add_interface	drivers/net/wireless/mediatek/mt76/mt76x02-lib	EXPORT_SYMBOL_GPL	
++0x1468d11e	ip6_redirect	net/ipv6/ipv6	EXPORT_SYMBOL_GPL	
++0xc436b0ff	ata_sas_tport_delete	drivers/ata/libata	EXPORT_SYMBOL_GPL	
++0x8cc74293	cec_transmit_msg	drivers/media/cec/core/cec	EXPORT_SYMBOL_GPL	
++0x07e83afc	i2c_bit_add_numbered_bus	drivers/i2c/algos/i2c-algo-bit	EXPORT_SYMBOL	
++0x2e09263f	usb_copy_descriptors	drivers/usb/gadget/libcomposite	EXPORT_SYMBOL_GPL	
++0x37a29003	rtl_fw_page_write	drivers/net/wireless/realtek/rtlwifi/rtlwifi	EXPORT_SYMBOL_GPL	
++0x77a4187d	mt76x02_mac_write_txwi	drivers/net/wireless/mediatek/mt76/mt76x02-lib	EXPORT_SYMBOL_GPL	
++0xf789aaea	drm_dp_aux_unregister	drivers/gpu/drm/drm_kms_helper	EXPORT_SYMBOL	
++0x9ba3753a	ieee80211_sched_scan_results	net/mac80211/mac80211	EXPORT_SYMBOL	
++0xc231a3e5	__mt76_sta_remove	drivers/net/wireless/mediatek/mt76/mt76	EXPORT_SYMBOL_GPL	
++0xa274f3e8	drm_gem_shmem_vunmap	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0x0a72f765	drm_clflush_virt_range	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0x281df593	ieee80211_sta_uapsd_trigger	net/mac80211/mac80211	EXPORT_SYMBOL	
++0xc2b49ab4	nf_nat_setup_info	net/netfilter/nf_nat	EXPORT_SYMBOL	
++0x98235f59	ata_sff_hsm_move	drivers/ata/libata	EXPORT_SYMBOL_GPL	
++0x80091d15	sata_link_debounce	drivers/ata/libata	EXPORT_SYMBOL_GPL	
++0xe7d1c6d0	helene_attach	drivers/media/dvb-frontends/helene	EXPORT_SYMBOL	
++0xf44217c7	ath9k_hw_setup_statusring	drivers/net/wireless/ath/ath9k/ath9k_hw	EXPORT_SYMBOL	
++0x8397fb4b	wimax_dev_add	net/wimax/wimax	EXPORT_SYMBOL_GPL	
++0x7c8ea901	wimax_msg	net/wimax/wimax	EXPORT_SYMBOL_GPL	
++0xdda7fb4e	nf_ct_unlink_expect_report	net/netfilter/nf_conntrack	EXPORT_SYMBOL_GPL	
++0x4afd2101	__iio_device_register	drivers/iio/industrialio	EXPORT_SYMBOL	
++0xb2ab241d	ata_do_set_mode	drivers/ata/libata	EXPORT_SYMBOL_GPL	
++0xe6024e59	dm_bufio_release	drivers/md/dm-bufio	EXPORT_SYMBOL_GPL	
++0x8ad5c651	xt_unregister_matches	net/netfilter/x_tables	EXPORT_SYMBOL	
++0x4b51f74c	ata_xfer_mode2mask	drivers/ata/libata	EXPORT_SYMBOL_GPL	
++0x8a6e8150	btmrvl_register_hdev	drivers/bluetooth/btmrvl	EXPORT_SYMBOL_GPL	
++0x88295b96	dm_tm_unlock	drivers/md/persistent-data/dm-persistent-data	EXPORT_SYMBOL_GPL	
++0x48e323be	dm_bm_unlock	drivers/md/persistent-data/dm-persistent-data	EXPORT_SYMBOL_GPL	
++0x8a8c1a0b	drm_gem_shmem_get_pages_sgt	drivers/gpu/drm/drm	EXPORT_SYMBOL_GPL	
++0x520d7ff2	drm_modeset_acquire_fini	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0x649892e8	snd_pcm_create_iec958_consumer_default	sound/core/snd-pcm	EXPORT_SYMBOL	
++0x1e276b20	m88rs2000_attach	drivers/media/dvb-frontends/m88rs2000	EXPORT_SYMBOL	
++0x4cc23445	usb_cdc_wdm_register	drivers/usb/class/cdc-wdm	EXPORT_SYMBOL	
++0x2d90d210	ath9k_hw_set_tx_filter	drivers/net/wireless/ath/ath9k/ath9k_hw	EXPORT_SYMBOL	
++0xc13ae5f3	iscsi_update_cmdsn	drivers/scsi/libiscsi	EXPORT_SYMBOL_GPL	
++0x01b53815	drm_atomic_helper_wait_for_vblanks	drivers/gpu/drm/drm_kms_helper	EXPORT_SYMBOL	
++0x9782be94	__gameport_register_driver	drivers/input/gameport/gameport	EXPORT_SYMBOL	
++0xd43cafae	ata_bmdma_start	drivers/ata/libata	EXPORT_SYMBOL_GPL	
++0xb881d38a	ata_port_freeze	drivers/ata/libata	EXPORT_SYMBOL_GPL	
++0xa302be82	gether_get_host_addr_u8	drivers/usb/gadget/function/u_ether	EXPORT_SYMBOL_GPL	
++0x60207244	rtl_efuse_shadow_map_update	drivers/net/wireless/realtek/rtlwifi/rtlwifi	EXPORT_SYMBOL	
++0xfe57cc75	rtl_c2hcmd_enqueue	drivers/net/wireless/realtek/rtlwifi/rtlwifi	EXPORT_SYMBOL	
++0xb4f71798	bcm2835_smi_user_dma	drivers/misc/bcm2835_smi	EXPORT_SYMBOL	
++0x9bb6fd09	vsock_connected_table	net/vmw_vsock/vsock	EXPORT_SYMBOL_GPL	
++0xa9b4bca3	__ieee80211_get_tx_led_name	net/mac80211/mac80211	EXPORT_SYMBOL	
++0xf4857612	l2tp_xmit_skb	net/l2tp/l2tp_core	EXPORT_SYMBOL_GPL	
++0xeadd333d	snd_pcm_new_stream	sound/core/snd-pcm	EXPORT_SYMBOL	
++0x37a8a4ea	sata_link_resume	drivers/ata/libata	EXPORT_SYMBOL_GPL	
++0x829e5cc6	sync_page_io	drivers/md/md-mod	EXPORT_SYMBOL_GPL	
++0x504ded51	mt76x02_tx_prepare_skb	drivers/net/wireless/mediatek/mt76/mt76x02-lib	EXPORT_SYMBOL_GPL	
++0xedb2d56c	brcmu_pkt_buf_get_skb	drivers/net/wireless/broadcom/brcm80211/brcmutil/brcmutil	EXPORT_SYMBOL	
++0x2b63c0a8	inet6_csk_update_pmtu	net/ipv6/ipv6	EXPORT_SYMBOL_GPL	
++0x4ac39282	arizona_set_fll	sound/soc/codecs/snd-soc-arizona	EXPORT_SYMBOL_GPL	
++0xf76e9e28	snd_soc_jack_free_gpios	sound/soc/snd-soc-core	EXPORT_SYMBOL_GPL	
++0x6a2de036	__tracepoint_vb2_v4l2_buf_queue	drivers/media/v4l2-core/videodev	EXPORT_SYMBOL_GPL	
++0x315de2cf	v4l2_ctrl_get_menu	drivers/media/v4l2-core/videodev	EXPORT_SYMBOL	
++0x80e132e2	au8522_analog_i2c_gate_ctrl	drivers/media/dvb-frontends/au8522_common	EXPORT_SYMBOL	
++0xdcd82c4b	mc44s803_attach	drivers/media/tuners/mc44s803	EXPORT_SYMBOL	
++0x28f9b5c9	iscsi_itt_to_task	drivers/scsi/libiscsi	EXPORT_SYMBOL_GPL	
++0xdb12a9f4	st_register	drivers/misc/ti-st/st_drv	EXPORT_SYMBOL_GPL	
++0xa64100e1	videobuf_queue_vmalloc_init	drivers/media/v4l2-core/videobuf-vmalloc	EXPORT_SYMBOL_GPL	
++0xfb3029e1	usb_serial_suspend	drivers/usb/serial/usbserial	EXPORT_SYMBOL	
++0x72b114a2	usb_otg_descriptor_alloc	drivers/usb/gadget/libcomposite	EXPORT_SYMBOL_GPL	
++0x840f2761	rtl92c_phy_set_rfpath_switch	drivers/net/wireless/realtek/rtlwifi/rtl8192c/rtl8192c-common	EXPORT_SYMBOL	
++0x72c5aee9	drm_vma_offset_manager_init	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0x0f1a2a18	bcma_driver_unregister	drivers/bcma/bcma	EXPORT_SYMBOL_GPL	
++0x95a52abd	dm_bm_is_read_only	drivers/md/persistent-data/dm-persistent-data	EXPORT_SYMBOL_GPL	
++0x3f7dde0b	drm_cvt_mode	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0xcdaf3b10	nf_nat_ipv4_register_fn	net/netfilter/nf_nat	EXPORT_SYMBOL_GPL	
++0x7053777e	btintel_read_debug_features	drivers/bluetooth/btintel	EXPORT_SYMBOL_GPL	
++0xfac09965	mt76x2_eeprom_init	drivers/net/wireless/mediatek/mt76/mt76x2/mt76x2-common	EXPORT_SYMBOL_GPL	
++0x05fa4a77	snd_rawmidi_info_select	sound/core/snd-rawmidi	EXPORT_SYMBOL	
++0x3ac507ba	snd_timer_global_register	sound/core/snd-timer	EXPORT_SYMBOL	
++0x61cdb088	iio_read_avail_channel_raw	drivers/iio/industrialio	EXPORT_SYMBOL_GPL	
++0x2e6edb4d	vhost_add_used	drivers/vhost/vhost	EXPORT_SYMBOL_GPL	
++0x13596792	ata_host_register	drivers/ata/libata	EXPORT_SYMBOL_GPL	
++0xa4931a21	gspca_frame_add	drivers/media/usb/gspca/gspca_main	EXPORT_SYMBOL	
++0x97fee399	ath6kl_cfg80211_suspend	drivers/net/wireless/ath/ath6kl/ath6kl_core	EXPORT_SYMBOL	
++0xdd87c803	drm_vblank_work_cancel_sync	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0x4bb7ed32	drm_connector_unregister	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0xd2fcfe61	ieee80211_get_num_supported_channels	net/wireless/cfg80211	EXPORT_SYMBOL	
++0x07f9f10c	xfrm6_rcv	net/ipv6/ipv6	EXPORT_SYMBOL	
++0xf3bb04b2	snd_soc_component_exit_regmap	sound/soc/snd-soc-core	EXPORT_SYMBOL_GPL	
++0x97fa7e82	snd_soc_component_init_regmap	sound/soc/snd-soc-core	EXPORT_SYMBOL_GPL	
++0x911e455c	bcma_core_set_clockmode	drivers/bcma/bcma	EXPORT_SYMBOL_GPL	
++0xab1abfba	ata_msleep	drivers/ata/libata	EXPORT_SYMBOL_GPL	
++0x1690b503	usb_role_switch_get_drvdata	drivers/usb/roles/roles	EXPORT_SYMBOL_GPL	
++0x51a348cc	usb_role_switch_set_drvdata	drivers/usb/roles/roles	EXPORT_SYMBOL_GPL	
++0x2057eb10	ppp_output_wakeup	drivers/net/ppp/ppp_generic	EXPORT_SYMBOL	
++0x7b8c32f1	bt_err	net/bluetooth/bluetooth	EXPORT_SYMBOL	
++0x53766efc	nf_tables_bind_set	net/netfilter/nf_tables	EXPORT_SYMBOL_GPL	
++0xd83d109d	snd_soc_dpcm_can_be_params	sound/soc/snd-soc-core	EXPORT_SYMBOL_GPL	
++0xcde09bd0	hci_uart_tx_wakeup	drivers/bluetooth/hci_uart	EXPORT_SYMBOL_GPL	
++0x82c518a5	vchiq_mmal_submit_buffer	drivers/staging/vc04_services/vchiq-mmal/bcm2835-mmal-vchiq	EXPORT_SYMBOL_GPL	
++0xc8b19fba	rtl8192_phy_check_is_legal_rfpath	drivers/net/wireless/realtek/rtlwifi/rtl8192c/rtl8192c-common	EXPORT_SYMBOL	
++0x2327d91c	_rtl92c_phy_calculate_bit_shift	drivers/net/wireless/realtek/rtlwifi/rtl8192c/rtl8192c-common	EXPORT_SYMBOL	
++0xbc747990	lbs_host_sleep_cfg	drivers/net/wireless/marvell/libertas/libertas	EXPORT_SYMBOL_GPL	
++0xa2e5ccf6	mipi_dbi_enable_flush	drivers/gpu/drm/drm_mipi_dbi	EXPORT_SYMBOL	
++0x1c5f904f	drm_legacy_ioremap	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0x7f1e2c38	drm_master_internal_acquire	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0x768e7fa5	async_raid6_2data_recov	crypto/async_tx/async_raid6_recov	EXPORT_SYMBOL_GPL	
++0xa3e5db6a	cfg80211_put_bss	net/wireless/cfg80211	EXPORT_SYMBOL	
++0x19551755	nf_nat_inet_unregister_fn	net/netfilter/nf_nat	EXPORT_SYMBOL_GPL	
++0xf25ac6e6	btmrvl_check_evtpkt	drivers/bluetooth/btmrvl	EXPORT_SYMBOL_GPL	
++0x74ee9098	sms_board_load_modules	drivers/media/common/siano/smsmdtv	EXPORT_SYMBOL_GPL	
++0xa459469a	usb_put_function_instance	drivers/usb/gadget/libcomposite	EXPORT_SYMBOL_GPL	
++0xf8cbff91	vsock_insert_connected	net/vmw_vsock/vsock	EXPORT_SYMBOL_GPL	
++0x9a7063d7	v4l2_ctrl_find	drivers/media/v4l2-core/videodev	EXPORT_SYMBOL	
++0x8280534c	v4l2_ctrl_fill	drivers/media/v4l2-core/videodev	EXPORT_SYMBOL	
++0xbc5671dc	v4l_printk_ioctl	drivers/media/v4l2-core/videodev	EXPORT_SYMBOL	
++0x550588e4	stv6110x_attach	drivers/media/dvb-frontends/stv6110x	EXPORT_SYMBOL	
++0x2aaeff25	ath9k_cmn_init_crypto	drivers/net/wireless/ath/ath9k/ath9k_common	EXPORT_SYMBOL	
++0x076fd50f	drm_i2c_encoder_commit	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0x93814933	hifiberry_pll_regmap	drivers/clk/clk-hifiberry-dachd	EXPORT_SYMBOL_GPL	
++0x7654247f	cfg80211_send_layer2_update	net/wireless/cfg80211	EXPORT_SYMBOL	
++0xb4841c31	nf_synproxy_ipv4_init	net/netfilter/nf_synproxy_core	EXPORT_SYMBOL_GPL	
++0xc984adf4	speakup_info	drivers/accessibility/speakup/speakup	EXPORT_SYMBOL_GPL	
++0x9dca766a	em28xx_init_usb_xfer	drivers/media/usb/em28xx/em28xx	EXPORT_SYMBOL_GPL	
++0xd9c7a4a2	tda18218_attach	drivers/media/tuners/tda18218	EXPORT_SYMBOL	
++0xd2ea2134	usb_descriptor_fillbuf	drivers/usb/gadget/libcomposite	EXPORT_SYMBOL_GPL	
++0x31b400c3	drm_sysfs_connector_status_event	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0xbdfcf579	can_sock_destruct	net/can/can	EXPORT_SYMBOL	
++0x426a261f	nf_l4proto_log_invalid	net/netfilter/nf_conntrack	EXPORT_SYMBOL_GPL	
++0x00aa7eed	mmal_vchi_buffer_init	drivers/staging/vc04_services/vchiq-mmal/bcm2835-mmal-vchiq	EXPORT_SYMBOL_GPL	
++0xd991e3b9	dm_bufio_get_device_size	drivers/md/dm-bufio	EXPORT_SYMBOL_GPL	
++0xae2f101d	rtl_beacon_statistic	drivers/net/wireless/realtek/rtlwifi/rtlwifi	EXPORT_SYMBOL_GPL	
++0xceb1be5e	__drmm_add_action	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0x2a4c0876	wimax_report_rfkill_sw	net/wimax/wimax	EXPORT_SYMBOL_GPL	
++0x6fbdb8d9	snd_soc_info_xr_sx	sound/soc/snd-soc-core	EXPORT_SYMBOL_GPL	
++0xa2b7c97f	rt2x00queue_stop_queues	drivers/net/wireless/ralink/rt2x00/rt2x00lib	EXPORT_SYMBOL_GPL	
++0x2b38951e	af_alg_pull_tsgl	crypto/af_alg	EXPORT_SYMBOL_GPL	
++0xd657c10f	nft_register_flowtable_type	net/netfilter/nf_tables	EXPORT_SYMBOL_GPL	
++0x5af762f1	snd_fasync_free	sound/core/snd	EXPORT_SYMBOL_GPL	
++0x73848f32	dvb_ringbuffer_write	drivers/media/dvb-core/dvb-core	EXPORT_SYMBOL	
++0x248d64bc	cx231xx_unregister_extension	drivers/media/usb/cx231xx/cx231xx	EXPORT_SYMBOL	
++0x38b7efa8	dibusb_dib3000mc_frontend_attach	drivers/media/usb/dvb-usb/dvb-usb-dibusb-mc-common	EXPORT_SYMBOL	
++0xd356adbe	ipvlan_link_new	drivers/net/ipvlan/ipvlan	EXPORT_SYMBOL_GPL	
++0x3ba22ee6	lbs_start_card	drivers/net/wireless/marvell/libertas/libertas	EXPORT_SYMBOL_GPL	
++0x5efc6fd0	drm_mode_is_420_also	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0x6261ed0e	drm_gem_unlock_reservations	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0xb0ae0731	tpm_pcr_read	drivers/char/tpm/tpm	EXPORT_SYMBOL_GPL	
++0xbd3e7542	cast_s1	crypto/cast_common	EXPORT_SYMBOL_GPL	
++0x4c5788de	xt_table_unlock	net/netfilter/x_tables	EXPORT_SYMBOL_GPL	
++0x2d4532e9	nft_reject_init	net/netfilter/nft_reject	EXPORT_SYMBOL_GPL	
++0x97db034f	snd_soc_link_compr_shutdown	sound/soc/snd-soc-core	EXPORT_SYMBOL_GPL	
++0x0d95aaf5	v4l2_async_notifier_add_subdev	drivers/media/v4l2-core/videodev	EXPORT_SYMBOL_GPL	
++0x903fcca1	cxd2880_attach	drivers/media/dvb-frontends/cxd2880/cxd2880	EXPORT_SYMBOL	
++0x26e6b8c4	brcmu_prpkt	drivers/net/wireless/broadcom/brcm80211/brcmutil/brcmutil	EXPORT_SYMBOL	
++0x56ed7eeb	iscsi_tcp_recv_skb	drivers/scsi/libiscsi_tcp	EXPORT_SYMBOL_GPL	
++0x1a5fca54	ata_sff_error_handler	drivers/ata/libata	EXPORT_SYMBOL_GPL	
++0xc8998d98	v4l2_clk_disable	drivers/media/v4l2-core/videodev	EXPORT_SYMBOL	
++0x4c5a79cb	usbip_in_eh	drivers/usb/usbip/usbip-core	EXPORT_SYMBOL_GPL	
++0x3a0ba670	fsg_lun_open	drivers/usb/gadget/function/usb_f_mass_storage	EXPORT_SYMBOL_GPL	
++0xac6761f9	p9_client_begin_disconnect	net/9p/9pnet	EXPORT_SYMBOL	
++0xb6db8ff1	xfrm6_tunnel_spi_lookup	net/ipv6/xfrm6_tunnel	EXPORT_SYMBOL	
++0xe88754a4	ms_sensors_ht_read_temperature	drivers/iio/common/ms_sensors/ms_sensors_i2c	EXPORT_SYMBOL	
++0x8d4b5fb1	cx231xx_dev_init	drivers/media/usb/cx231xx/cx231xx	EXPORT_SYMBOL_GPL	
++0x89d9444e	cma3000_exit	drivers/input/misc/cma3000_d0x	EXPORT_SYMBOL	
++0x7233efba	cma3000_init	drivers/input/misc/cma3000_d0x	EXPORT_SYMBOL	
++0x131cee7d	fsg_store_cdrom	drivers/usb/gadget/function/usb_f_mass_storage	EXPORT_SYMBOL_GPL	
++0x4d5a28b7	drm_connector_set_panel_orientation_with_quirk	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0xea31c3cd	drm_fb_helper_set_suspend	drivers/gpu/drm/drm_kms_helper	EXPORT_SYMBOL	
++0xedf0e4fd	qtree_read_dquot	fs/quota/quota_tree	EXPORT_SYMBOL	
++0x53b52981	vc_sm_cma_free	drivers/staging/vc04_services/vc-sm-cma/vc-sm-cma	EXPORT_SYMBOL_GPL	
++0x9e4faeef	dm_io_client_destroy	drivers/md/dm-mod	EXPORT_SYMBOL	
++0xc6f112d6	drm_dp_downstream_max_bpc	drivers/gpu/drm/drm_kms_helper	EXPORT_SYMBOL	
++0xdc89c0f5	tpm_default_chip	drivers/char/tpm/tpm	EXPORT_SYMBOL_GPL	
++0x250f1c9b	mt76u_init	drivers/net/wireless/mediatek/mt76/mt76-usb	EXPORT_SYMBOL_GPL	
++0xa5266b14	dfs_pattern_detector_init	drivers/net/wireless/ath/ath	EXPORT_SYMBOL	
++0x81ca304e	__drm_atomic_helper_connector_destroy_state	drivers/gpu/drm/drm_kms_helper	EXPORT_SYMBOL	
++0x56448557	mcp23s08_probe_one	drivers/pinctrl/pinctrl-mcp23s08	EXPORT_SYMBOL_GPL	
++0x10b3d548	ip6_frag_next	net/ipv6/ipv6	EXPORT_SYMBOL	
++0x4f527fa9	snd_seq_kernel_client_write_poll	sound/core/seq/snd-seq	EXPORT_SYMBOL	
++0x8688d322	v4l2_subdev_init	drivers/media/v4l2-core/videodev	EXPORT_SYMBOL	
++0x8515f78d	cx231xx_uninit_bulk	drivers/media/usb/cx231xx/cx231xx	EXPORT_SYMBOL_GPL	
++0x6db569bb	usb_role_switch_get	drivers/usb/roles/roles	EXPORT_SYMBOL_GPL	
++0x31ed4f4f	vhost_vq_is_setup	drivers/vhost/vhost	EXPORT_SYMBOL_GPL	
++0x73577c19	bcma_core_pll_ctl	drivers/bcma/bcma	EXPORT_SYMBOL_GPL	
++0x79dc36a1	macvlan_common_setup	drivers/net/macvlan	EXPORT_SYMBOL_GPL	
++0xce38fbcc	_rtl92c_phy_set_rf_sleep	drivers/net/wireless/realtek/rtlwifi/rtl8192c/rtl8192c-common	EXPORT_SYMBOL	
++0xd6b65e2f	of_drm_find_bridge	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0x5c215352	ieee80211_report_wowlan_wakeup	net/mac80211/mac80211	EXPORT_SYMBOL	
++0xe334e6df	cfg80211_sinfo_alloc_tid_stats	net/wireless/cfg80211	EXPORT_SYMBOL	
++0xa5f58e5f	ip_set_get_ip6_port	net/netfilter/ipset/ip_set	EXPORT_SYMBOL_GPL	
++0x90ae4c8b	ip_set_get_ip4_port	net/netfilter/ipset/ip_set	EXPORT_SYMBOL_GPL	
++0xa308e493	snd_soc_jack_notifier_register	sound/soc/snd-soc-core	EXPORT_SYMBOL_GPL	
++0x84811715	ssb_bus_suspend	drivers/ssb/ssb	EXPORT_SYMBOL	
++0xcca8debb	btmrvl_enable_hs	drivers/bluetooth/btmrvl	EXPORT_SYMBOL_GPL	
++0x46f3cf7a	btmrvl_enable_ps	drivers/bluetooth/btmrvl	EXPORT_SYMBOL_GPL	
++0x194fb331	dib0090_set_dc_servo	drivers/media/dvb-frontends/dib0090	EXPORT_SYMBOL	
++0x9bb31b1c	drm_dev_register	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0x066dc948	ata_link_abort	drivers/ata/libata	EXPORT_SYMBOL_GPL	
++0xf241a6eb	dm_bufio_forget_buffers	drivers/md/dm-bufio	EXPORT_SYMBOL_GPL	
++0x2726a294	rt2x00usb_flush_queue	drivers/net/wireless/ralink/rt2x00/rt2x00usb	EXPORT_SYMBOL_GPL	
++0x4ba7b970	aic32x4_probe	sound/soc/codecs/snd-soc-tlv320aic32x4	EXPORT_SYMBOL	
++0xfcf2eddf	v4l2_ctrl_request_hdl_find	drivers/media/v4l2-core/videodev	EXPORT_SYMBOL_GPL	
++0xc6110b6e	tpg_free	drivers/media/common/v4l2-tpg/v4l2-tpg	EXPORT_SYMBOL_GPL	
++0xf56c2017	mlog_not_bits	fs/ocfs2/cluster/ocfs2_nodemanager	EXPORT_SYMBOL_GPL	
++0x4faa0f0d	snd_seq_device_new	sound/core/snd-seq-device	EXPORT_SYMBOL	
++0x05963ea8	v4l_vb2q_enable_media_source	drivers/media/v4l2-core/videodev	EXPORT_SYMBOL_GPL	
++0x6a70b3f6	lg2160_attach	drivers/media/dvb-frontends/lg2160	EXPORT_SYMBOL	
++0x9f98cd97	vb2_buffer_in_use	drivers/media/common/videobuf2/videobuf2-common	EXPORT_SYMBOL	
++0x0775e65d	cfg80211_remain_on_channel_expired	net/wireless/cfg80211	EXPORT_SYMBOL	
++0x321bb765	line6_disconnect	sound/usb/line6/snd-usb-line6	EXPORT_SYMBOL_GPL	
++0x8f834a1c	snd_seq_create_kernel_client	sound/core/seq/snd-seq	EXPORT_SYMBOL	
++0xbf0fe6db	bcma_chipco_gpio_outen	drivers/bcma/bcma	EXPORT_SYMBOL_GPL	
++0x9b29f5d8	mtd_del_partition	drivers/mtd/mtd	EXPORT_SYMBOL_GPL	
++0x71317b5a	dvb_dmx_swfilter	drivers/media/dvb-core/dvb-core	EXPORT_SYMBOL	
++0x9f103032	drm_dp_dual_mode_max_tmds_clock	drivers/gpu/drm/drm_kms_helper	EXPORT_SYMBOL	
++0xb2c2e6f8	drm_dp_read_sink_count	drivers/gpu/drm/drm_kms_helper	EXPORT_SYMBOL	
++0xb5bfd8c9	fuse_dev_install	fs/fuse/fuse	EXPORT_SYMBOL_GPL	
++0x4b62826c	dlm_unlock	fs/dlm/dlm	EXPORT_SYMBOL_GPL	
++0x2b7d6bb8	get_mtd_device	drivers/mtd/mtd	EXPORT_SYMBOL_GPL	
++0xb77d1482	ata_sas_port_alloc	drivers/ata/libata	EXPORT_SYMBOL_GPL	
++0xdad1420c	ata_port_abort	drivers/ata/libata	EXPORT_SYMBOL_GPL	
++0xa85cfae5	mt76x02_bss_info_changed	drivers/net/wireless/mediatek/mt76/mt76x02-lib	EXPORT_SYMBOL_GPL	
++0x6ce1c95c	__SCK__tp_func_vb2_v4l2_dqbuf	drivers/media/v4l2-core/videodev	EXPORT_SYMBOL_GPL	
++0x8d980389	ath9k_hw_loadnf	drivers/net/wireless/ath/ath9k/ath9k_hw	EXPORT_SYMBOL	
++0x7e715850	drm_panel_init	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0x26815dbc	drm_dp_link_rate_to_bw_code	drivers/gpu/drm/drm_kms_helper	EXPORT_SYMBOL	
++0x213cf7b4	cryptd_ahash_queued	crypto/cryptd	EXPORT_SYMBOL_GPL	
++0xe2aae5cc	crc8	lib/crc8	EXPORT_SYMBOL	
++0x645ef974	p9_client_read_once	net/9p/9pnet	EXPORT_SYMBOL	
++0xc46c5ed2	lib80211_register_crypto_ops	net/wireless/lib80211	EXPORT_SYMBOL	
++0xcfa9e186	mux_chip_alloc	drivers/mux/mux-core	EXPORT_SYMBOL_GPL	
++0x601f665f	dm_io_client_create	drivers/md/dm-mod	EXPORT_SYMBOL	
++0x1832755f	vb2_ioctl_prepare_buf	drivers/media/common/videobuf2/videobuf2-v4l2	EXPORT_SYMBOL_GPL	
++0x671c3b1a	mt76x02_mcu_set_radio_state	drivers/net/wireless/mediatek/mt76/mt76x02-lib	EXPORT_SYMBOL_GPL	
++0x90aa8549	vsock_find_cid	net/vmw_vsock/vsock	EXPORT_SYMBOL_GPL	
++0xa4a420a7	inet_diag_dump_one_icsk	net/ipv4/inet_diag	EXPORT_SYMBOL_GPL	
++0x01bea8b7	mtd_is_locked	drivers/mtd/mtd	EXPORT_SYMBOL_GPL	
++0x6e227d75	tea5761_attach	drivers/media/tuners/tea5761	EXPORT_SYMBOL_GPL	
++0xfc503417	drm_dp_send_query_stream_enc_status	drivers/gpu/drm/drm_kms_helper	EXPORT_SYMBOL	
++0xc3116e6c	nf_nat_packet	net/netfilter/nf_nat	EXPORT_SYMBOL_GPL	
++0x73a8f206	bme680_core_probe	drivers/iio/chemical/bme680_core	EXPORT_SYMBOL_GPL	
++0x5b93a256	btrtl_get_uart_settings	drivers/bluetooth/btrtl	EXPORT_SYMBOL_GPL	
++0xebcc64a4	dm_bufio_get_block_data	drivers/md/dm-bufio	EXPORT_SYMBOL_GPL	
++0x1bab2cf9	go7007_alloc	drivers/media/usb/go7007/go7007	EXPORT_SYMBOL	
++0xbcb90cb3	poly1305_core_emit	lib/crypto/libpoly1305	EXPORT_SYMBOL	
++0x7484357f	snd_midi_event_decode	sound/core/seq/snd-seq-midi-event	EXPORT_SYMBOL	
++0x2bf3cc4e	vhost_add_used_n	drivers/vhost/vhost	EXPORT_SYMBOL_GPL	
++0xa159c192	dm_set_target_max_io_len	drivers/md/dm-mod	EXPORT_SYMBOL_GPL	
++0xa715a6c5	v4l2_ctrl_g_ctrl	drivers/media/v4l2-core/videodev	EXPORT_SYMBOL	
++0x6026aaf0	tpg_log_status	drivers/media/common/v4l2-tpg/v4l2-tpg	EXPORT_SYMBOL_GPL	
++0xa017cdc7	usb_ftdi_elan_edset_input	drivers/usb/misc/ftdi-elan	EXPORT_SYMBOL_GPL	
++0x747f17a7	cdrom_get_media_event	drivers/cdrom/cdrom	EXPORT_SYMBOL	
++0x20ef725f	iscsi_tcp_hdr_recv_prep	drivers/scsi/libiscsi_tcp	EXPORT_SYMBOL_GPL	
++0xd63d569e	af_alg_async_cb	crypto/af_alg	EXPORT_SYMBOL_GPL	
++0x0bff8337	xfrm6_protocol_deregister	net/ipv6/ipv6	EXPORT_SYMBOL	
++0xfe6592bb	nft_register_expr	net/netfilter/nf_tables	EXPORT_SYMBOL_GPL	
++0x730f2eae	v4l2_m2m_init	drivers/media/v4l2-core/v4l2-mem2mem	EXPORT_SYMBOL_GPL	
++0xb4e32b94	drm_irq_uninstall	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0x2d47ac83	lc_committed	lib/lru_cache	EXPORT_SYMBOL	
++0x7c7fb20f	fbtft_unregister_backlight	drivers/staging/fbtft/fbtft	EXPORT_SYMBOL	
++0x15c0f54e	dib0090_get_current_gain	drivers/media/dvb-frontends/dib0090	EXPORT_SYMBOL	
++0x56648e44	usb_function_register	drivers/usb/gadget/libcomposite	EXPORT_SYMBOL_GPL	
++0x7ec1919e	fuse_mount_put	fs/fuse/fuse	EXPORT_SYMBOL_GPL	
++0xa6ba44d0	xt_proto_init	net/netfilter/x_tables	EXPORT_SYMBOL_GPL	
++0xa5ad1ea5	snd_soc_card_remove_dai_link	sound/soc/snd-soc-core	EXPORT_SYMBOL_GPL	
++0x12f69e6e	__v4l2_ctrl_s_ctrl_string	drivers/media/v4l2-core/videodev	EXPORT_SYMBOL	
++0x19df9672	drm_gem_cma_create_object_default_funcs	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0x0379eb19	sata_pmp_qc_defer_cmd_switch	drivers/ata/libata	EXPORT_SYMBOL_GPL	
++0x3aa4a9e4	ata_sff_port_intr	drivers/ata/libata	EXPORT_SYMBOL_GPL	
++0x8408182f	ata_scsi_change_queue_depth	drivers/ata/libata	EXPORT_SYMBOL_GPL	
++0x46d5da2d	media_device_delete	drivers/media/mc/mc	EXPORT_SYMBOL_GPL	
++0x99a81ab3	smsclient_sendrequest	drivers/media/common/siano/smsmdtv	EXPORT_SYMBOL_GPL	
++0x86b437d8	drm_master_put	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0x14f3b12a	iio_trigger_unregister	drivers/iio/industrialio	EXPORT_SYMBOL	
++0xe9bd2e40	iio_read_max_channel_raw	drivers/iio/industrialio	EXPORT_SYMBOL_GPL	
++0x74283359	gether_get_host_addr_cdc	drivers/usb/gadget/function/u_ether	EXPORT_SYMBOL_GPL	
++0xf940212b	drm_dp_read_downstream_info	drivers/gpu/drm/drm_kms_helper	EXPORT_SYMBOL	
++0x81dad070	virtio_transport_dgram_bind	net/vmw_vsock/vmw_vsock_virtio_transport_common	EXPORT_SYMBOL_GPL	
++0x1e284dd3	mroute6_is_socket	net/ipv6/ipv6	EXPORT_SYMBOL	
++0x020e970c	pci_test_config_bits	drivers/ata/libata	EXPORT_SYMBOL_GPL	
++0xd8cdb683	radio_tea5777_exit	drivers/media/radio/shark2	EXPORT_SYMBOL_GPL	
++0xb6f92c18	media_device_pci_init	drivers/media/mc/mc	EXPORT_SYMBOL_GPL	
++0x41af8633	hostap_set_hostapd	drivers/net/wireless/intersil/hostap/hostap	EXPORT_SYMBOL	
++0x3502feef	ath6kl_info	drivers/net/wireless/ath/ath6kl/ath6kl_core	EXPORT_SYMBOL	
++0x914a6670	ath9k_hw_putrxbuf	drivers/net/wireless/ath/ath9k/ath9k_hw	EXPORT_SYMBOL	
++0xd860d4de	ath9k_hw_puttxbuf	drivers/net/wireless/ath/ath9k/ath9k_hw	EXPORT_SYMBOL	
++0x63a9a7f2	drm_atomic_add_encoder_bridges	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0x6615069e	drm_dp_dsc_sink_max_slice_count	drivers/gpu/drm/drm_kms_helper	EXPORT_SYMBOL	
++0xe661d576	fuse_dev_fiq_ops	fs/fuse/fuse	EXPORT_SYMBOL_GPL	
++0x0229cf1d	udp_tunnel_notify_del_rx_port	net/ipv4/udp_tunnel	EXPORT_SYMBOL_GPL	
++0x67138e03	snd_ctl_notify	sound/core/snd	EXPORT_SYMBOL	
++0x6d003626	media_request_object_unbind	drivers/media/mc/mc	EXPORT_SYMBOL_GPL	
++0x038a4e2f	cx2341x_handler_set_busy	drivers/media/common/cx2341x	EXPORT_SYMBOL	
++0x454693d5	snd_pcm_hw_constraint_step	sound/core/snd-pcm	EXPORT_SYMBOL	
++0x4f477261	dm_bm_checksum	drivers/md/persistent-data/dm-persistent-data	EXPORT_SYMBOL_GPL	
++0xedc8d18f	media_device_unregister_entity	drivers/media/mc/mc	EXPORT_SYMBOL_GPL	
++0x63080596	__traceiter_vb2_dqbuf	drivers/media/common/videobuf2/videobuf2-common	EXPORT_SYMBOL_GPL	
++0x5fb98956	hostap_init_proc	drivers/net/wireless/intersil/hostap/hostap	EXPORT_SYMBOL	
++0xf243a4f2	drm_framebuffer_init	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0x58221ba3	esp6_output_tail	net/ipv6/esp6	EXPORT_SYMBOL_GPL	
++0x8d864069	snd_pcm_rate_range_to_bits	sound/core/snd-pcm	EXPORT_SYMBOL_GPL	
++0xd8d42cfd	w1_register_family	drivers/w1/wire	EXPORT_SYMBOL	
++0xbe4de675	cec_get_edid_phys_addr	drivers/media/cec/core/cec	EXPORT_SYMBOL_GPL	
++0x76edfcb2	dibx000_i2c_set_speed	drivers/media/dvb-frontends/dibx000_common	EXPORT_SYMBOL	
++0xb05116ef	drm_atomic_set_crtc_for_plane	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0x898f91b9	br_fdb_find_port	net/bridge/bridge	EXPORT_SYMBOL_GPL	
++0x43a7c255	ip_set_init_comment	net/netfilter/ipset/ip_set	EXPORT_SYMBOL_GPL	
++0xa85db1b6	nf_nat_pptp_hook_inbound	net/netfilter/nf_conntrack_pptp	EXPORT_SYMBOL_GPL	
++0xe9b5574d	drm_dp_mst_deallocate_vcpi	drivers/gpu/drm/drm_kms_helper	EXPORT_SYMBOL	
++0x13f1d4a1	flow_offload_route_init	net/netfilter/nf_flow_table	EXPORT_SYMBOL_GPL	
++0xb6655612	vhost_dev_has_owner	drivers/vhost/vhost	EXPORT_SYMBOL_GPL	
++0xa18f224e	ath_regd_find_country_by_name	drivers/net/wireless/ath/ath	EXPORT_SYMBOL	
++0x0fadbdd9	__devm_drm_dev_alloc	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0x61735ee7	ieee80211_remain_on_channel_expired	net/mac80211/mac80211	EXPORT_SYMBOL_GPL	
++0x78c53d0f	set_sig_addr_hook	net/netfilter/nf_conntrack_h323	EXPORT_SYMBOL_GPL	
++0x2720d49c	vb2_fop_mmap	drivers/media/common/videobuf2/videobuf2-v4l2	EXPORT_SYMBOL_GPL	
++0xb31d59f3	usb_wwan_port_probe	drivers/usb/serial/usb_wwan	EXPORT_SYMBOL_GPL	
++0x01a595d4	drm_crtc_helper_set_mode	drivers/gpu/drm/drm_kms_helper	EXPORT_SYMBOL	
++0x63ed6a8a	virtio_transport_notify_recv_init	net/vmw_vsock/vmw_vsock_virtio_transport_common	EXPORT_SYMBOL_GPL	
++0x86cfa1e8	nf_reject_ip_tcphdr_get	net/ipv4/netfilter/nf_reject_ipv4	EXPORT_SYMBOL_GPL	
++0x01612c0b	v4l2_detect_gtf	drivers/media/v4l2-core/v4l2-dv-timings	EXPORT_SYMBOL_GPL	
++0xa97e00eb	v4l2_detect_cvt	drivers/media/v4l2-core/v4l2-dv-timings	EXPORT_SYMBOL_GPL	
++0x97e3184c	v4l2_clk_set_rate	drivers/media/v4l2-core/videodev	EXPORT_SYMBOL	
++0x461a1a6d	v4l2_clk_get_rate	drivers/media/v4l2-core/videodev	EXPORT_SYMBOL	
++0x46c77c85	smscore_start_device	drivers/media/common/siano/smsmdtv	EXPORT_SYMBOL_GPL	
++0x476ab8f8	flexcop_wan_set_speed	drivers/media/common/b2c2/b2c2-flexcop	EXPORT_SYMBOL	
++0x0526cde1	drm_plane_cleanup	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0x9708bf0f	iio_triggered_buffer_cleanup	drivers/iio/buffer/industrialio-triggered-buffer	EXPORT_SYMBOL	
++0xb5b999d8	vb2_video_unregister_device	drivers/media/common/videobuf2/videobuf2-v4l2	EXPORT_SYMBOL_GPL	
++0x7cf6267b	rt2800_disable_radio	drivers/net/wireless/ralink/rt2x00/rt2800lib	EXPORT_SYMBOL_GPL	
++0x9e0d2eca	ip_set_put_flags	net/netfilter/ipset/ip_set	EXPORT_SYMBOL_GPL	
++0x96d08bf7	nf_tables_destroy_set	net/netfilter/nf_tables	EXPORT_SYMBOL_GPL	
++0xd267237c	iio_map_array_register	drivers/iio/industrialio	EXPORT_SYMBOL_GPL	
++0xeb77f84e	ubi_leb_change	drivers/mtd/ubi/ubi	EXPORT_SYMBOL_GPL	
++0x36e59758	dvb_frontend_resume	drivers/media/dvb-core/dvb-core	EXPORT_SYMBOL	
++0xb7fb2698	rtl92c_phy_query_bb_reg	drivers/net/wireless/realtek/rtlwifi/rtl8192c/rtl8192c-common	EXPORT_SYMBOL	
++0xd52d2167	vsock_core_get_transport	net/vmw_vsock/vsock	EXPORT_SYMBOL_GPL	
++0x145a43e6	serio_unregister_port	drivers/input/serio/serio	EXPORT_SYMBOL	
++0x16081ffb	can_dlc2len	drivers/net/can/dev/can-dev	EXPORT_SYMBOL_GPL	
++0xb24dbfba	rtl_debug_remove_one	drivers/net/wireless/realtek/rtlwifi/rtlwifi	EXPORT_SYMBOL_GPL	
++0x7da36fdf	mt76_csa_finish	drivers/net/wireless/mediatek/mt76/mt76	EXPORT_SYMBOL_GPL	
++0x811d2a35	ath9k_hw_setantenna	drivers/net/wireless/ath/ath9k/ath9k_hw	EXPORT_SYMBOL	
++0x0d9b4753	drm_mode_equal	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0xab8bc1a2	snd_pcm_rate_mask_intersect	sound/core/snd-pcm	EXPORT_SYMBOL_GPL	
++0x68a24153	snd_pcm_format_physical_width	sound/core/snd-pcm	EXPORT_SYMBOL	
++0x0042523f	devm_mux_chip_alloc	drivers/mux/mux-core	EXPORT_SYMBOL_GPL	
++0x0156b021	__bcma_driver_register	drivers/bcma/bcma	EXPORT_SYMBOL_GPL	
++0xf4ad9a15	dvb_ringbuffer_read	drivers/media/dvb-core/dvb-core	EXPORT_SYMBOL	
++0x277feeff	dib9000_fw_set_component_bus_speed	drivers/media/dvb-frontends/dib9000	EXPORT_SYMBOL	
++0x2db02d58	tun_get_tx_ring	drivers/net/tun	EXPORT_SYMBOL_GPL	
++0xf9cc7080	drm_atomic_get_connector_state	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0x518b633f	ata_sas_tport_add	drivers/ata/libata	EXPORT_SYMBOL_GPL	
++0x87bee547	btracker_queue	drivers/md/dm-cache	EXPORT_SYMBOL_GPL	
++0x01d2f9ac	dm_rh_recovery_start	drivers/md/dm-region-hash	EXPORT_SYMBOL_GPL	
++0xe37beaf8	v4l2_querymenu	drivers/media/v4l2-core/videodev	EXPORT_SYMBOL	
++0xe87a3799	dvb_pll_attach	drivers/media/dvb-frontends/dvb-pll	EXPORT_SYMBOL	
++0xeb051bca	af_alg_release_parent	crypto/af_alg	EXPORT_SYMBOL_GPL	
++0xbc36ee06	ieee80211_calc_rx_airtime	net/mac80211/mac80211	EXPORT_SYMBOL_GPL	
++0x7aad008b	bt_to_errno	net/bluetooth/bluetooth	EXPORT_SYMBOL	
++0x7314dd69	ebt_register_table	net/bridge/netfilter/ebtables	EXPORT_SYMBOL	
++0xbe5b6d39	cs4271_probe	sound/soc/codecs/snd-soc-cs4271	EXPORT_SYMBOL_GPL	
++0x8ee61f12	vhost_add_used_and_signal_n	drivers/vhost/vhost	EXPORT_SYMBOL_GPL	
++0xdfa535af	cx2341x_handler_init	drivers/media/common/cx2341x	EXPORT_SYMBOL	
++0xf1421d13	drm_mode_sort	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0xb2ad1d6a	atm_init_aal5	net/atm/atm	EXPORT_SYMBOL	
++0x49428055	v4l2_ctrl_sub_ev_ops	drivers/media/v4l2-core/videodev	EXPORT_SYMBOL	
++0xb790fbd0	usbip_event_add	drivers/usb/usbip/usbip-core	EXPORT_SYMBOL_GPL	
++0x858e88ec	rt2800_reset_tuner	drivers/net/wireless/ralink/rt2x00/rt2800lib	EXPORT_SYMBOL_GPL	
++0x292cd3d9	ath9k_hw_releasetxqueue	drivers/net/wireless/ath/ath9k/ath9k_hw	EXPORT_SYMBOL	
++0xe4b051cf	raid6_datap_recov	lib/raid6/raid6_pq	EXPORT_SYMBOL_GPL	
++0xcac3040e	iio_bus_type	drivers/iio/industrialio	EXPORT_SYMBOL	
++0xe8e818c0	md_start	drivers/md/md-mod	EXPORT_SYMBOL_GPL	
++0x4f09322d	ad714x_disable	drivers/input/misc/ad714x	EXPORT_SYMBOL	
++0x94575d83	cfg80211_tx_mlme_mgmt	net/wireless/cfg80211	EXPORT_SYMBOL	
++0xc552fa9c	cfg80211_rx_mlme_mgmt	net/wireless/cfg80211	EXPORT_SYMBOL	
++0xd04ec867	snd_soc_dai_set_pll	sound/soc/snd-soc-core	EXPORT_SYMBOL_GPL	
++0x9399f3bb	mtd_block_isbad	drivers/mtd/mtd	EXPORT_SYMBOL_GPL	
++0x8b4f9be3	alloc_can_err_skb	drivers/net/can/dev/can-dev	EXPORT_SYMBOL_GPL	
++0x4084af89	rt2x00usb_initialize	drivers/net/wireless/ralink/rt2x00/rt2x00usb	EXPORT_SYMBOL_GPL	
++0xcb04f2f2	mwifiex_upload_device_dump	drivers/net/wireless/marvell/mwifiex/mwifiex	EXPORT_SYMBOL_GPL	
++0x76b491d9	drm_of_component_match_add	drivers/gpu/drm/drm	EXPORT_SYMBOL_GPL	
++0xd50af19d	p9_tag_lookup	net/9p/9pnet	EXPORT_SYMBOL	
++0xaeb7451e	ax25_defaddr	net/ax25/ax25	EXPORT_SYMBOL_GPL	
++0xe5025ebb	ip6_fraglist_prepare	net/ipv6/ipv6	EXPORT_SYMBOL	
++0x5aa0d78f	devm_iio_device_alloc	drivers/iio/industrialio	EXPORT_SYMBOL_GPL	
++0x0e74d42c	mtd_read_user_prot_reg	drivers/mtd/mtd	EXPORT_SYMBOL_GPL	
++0x64eef2ae	mtd_get_user_prot_info	drivers/mtd/mtd	EXPORT_SYMBOL_GPL	
++0x9ebb154b	drm_framebuffer_cleanup	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0xd39e52fc	drm_get_unmapped_area	drivers/gpu/drm/drm	EXPORT_SYMBOL_GPL	
++0xc4223549	drm_bridge_connector_disable_hpd	drivers/gpu/drm/drm_kms_helper	EXPORT_SYMBOL_GPL	
++0xba55d23e	crc7_be	lib/crc7	EXPORT_SYMBOL	
++0xcc1a7c48	cfg80211_is_element_inherited	net/wireless/cfg80211	EXPORT_SYMBOL	
++0xf65c5e46	tpg_fillbuffer	drivers/media/common/v4l2-tpg/v4l2-tpg	EXPORT_SYMBOL_GPL	
++0x0d4023ec	mt76x02_get_max_rate_power	drivers/net/wireless/mediatek/mt76/mt76x02-lib	EXPORT_SYMBOL_GPL	
++0x882f2ef0	lbs_add_card	drivers/net/wireless/marvell/libertas/libertas	EXPORT_SYMBOL_GPL	
++0x8a51eb57	lc_seq_dump_details	lib/lru_cache	EXPORT_SYMBOL	
++0xce8159bb	tpg_pattern_strings	drivers/media/common/v4l2-tpg/v4l2-tpg	EXPORT_SYMBOL_GPL	
++0x54fb0d28	ip_vs_nfct_expect_related	net/netfilter/ipvs/ip_vs	EXPORT_SYMBOL	
++0x298958c7	snd_pcm_lib_preallocate_pages_for_all	sound/core/snd-pcm	EXPORT_SYMBOL	
++0xed25c8fd	cx231xx_init_bulk	drivers/media/usb/cx231xx/cx231xx	EXPORT_SYMBOL_GPL	
++0x070b28aa	drm_ht_remove_item	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0xcc4ee841	raid6_gfexi	lib/raid6/raid6_pq	EXPORT_SYMBOL	
++0x71747f18	snd_soc_lookup_component_nolocked	sound/soc/snd-soc-core	EXPORT_SYMBOL_GPL	
++0xc6315d8e	__SCK__tp_func_mac_txdone	drivers/net/wireless/mediatek/mt76/mt76	EXPORT_SYMBOL_GPL	
++0x141069ed	fuse_dev_free	fs/fuse/fuse	EXPORT_SYMBOL_GPL	
++0x05865a2e	qtree_entry_unused	fs/quota/quota_tree	EXPORT_SYMBOL	
++0x7b5ce5c3	baswap	net/bluetooth/bluetooth	EXPORT_SYMBOL	
++0x53564435	cfg80211_cqm_txe_notify	net/wireless/cfg80211	EXPORT_SYMBOL	
++0x379d2ebb	udp_tunnel_push_rx_port	net/ipv4/udp_tunnel	EXPORT_SYMBOL_GPL	
++0x27580356	iio_channel_cb_get_iio_dev	drivers/iio/buffer/industrialio-buffer-cb	EXPORT_SYMBOL_GPL	
++0x73a48b4a	ata_sff_std_ports	drivers/ata/libata	EXPORT_SYMBOL_GPL	
++0x78c5ccde	dm_snap_origin	drivers/md/dm-snapshot	EXPORT_SYMBOL	
++0xdbdccb0f	tun_get_socket	drivers/net/tun	EXPORT_SYMBOL_GPL	
++0x6a03ede9	dm_noflush_suspending	drivers/md/dm-mod	EXPORT_SYMBOL_GPL	
++0x9b00ddc0	md_bitmap_end_sync	drivers/md/md-mod	EXPORT_SYMBOL	
++0xbbcb55e1	rt2800_ampdu_action	drivers/net/wireless/ralink/rt2x00/rt2800lib	EXPORT_SYMBOL_GPL	
++0xbd9f5893	drm_sched_entity_push_job	drivers/gpu/drm/scheduler/gpu-sched	EXPORT_SYMBOL	
++0xf4b7418b	drm_dp_mst_add_affected_dsc_crtcs	drivers/gpu/drm/drm_kms_helper	EXPORT_SYMBOL	
++0xbfd26f15	simd_aead_free	crypto/crypto_simd	EXPORT_SYMBOL_GPL	
++0x9a908ad7	p9_client_rename	net/9p/9pnet	EXPORT_SYMBOL	
++0xc1f4ff4a	p9_client_remove	net/9p/9pnet	EXPORT_SYMBOL	
++0x129ba6b3	snd_rawmidi_kernel_open	sound/core/snd-rawmidi	EXPORT_SYMBOL	
++0x8624bfa3	bcma_pmu_spuravoid_pllupdate	drivers/bcma/bcma	EXPORT_SYMBOL_GPL	
++0xf102033e	slhc_remember	drivers/net/slip/slhc	EXPORT_SYMBOL	
++0xfa6ef130	drm_property_replace_global_blob	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0x77eeada9	hci_reset_dev	net/bluetooth/bluetooth	EXPORT_SYMBOL	
++0xc3e94dad	can_send	net/can/can	EXPORT_SYMBOL	
++0xe7979883	snd_soc_component_enable_pin_unlocked	sound/soc/snd-soc-core	EXPORT_SYMBOL_GPL	
++0x5983533c	snd_ctl_boolean_mono_info	sound/core/snd	EXPORT_SYMBOL	
++0xa9cb99f9	rt2800_wait_csr_ready	drivers/net/wireless/ralink/rt2x00/rt2800lib	EXPORT_SYMBOL_GPL	
++0x9367e22f	iscsi_complete_pdu	drivers/scsi/libiscsi	EXPORT_SYMBOL_GPL	
++0xde78a278	ieee802154_stop_queue	net/mac802154/mac802154	EXPORT_SYMBOL	
++0xd1a1e43c	lib80211_crypt_info_free	net/wireless/lib80211	EXPORT_SYMBOL	
++0x09b2561c	asoc_simple_startup	sound/soc/generic/snd-soc-simple-card-utils	EXPORT_SYMBOL_GPL	
++0x60016af2	snd_soc_component_enable_pin	sound/soc/snd-soc-core	EXPORT_SYMBOL_GPL	
++0x007b0fb4	snd_soc_of_parse_card_name	sound/soc/snd-soc-core	EXPORT_SYMBOL_GPL	
++0x48987e0d	si470x_stop	drivers/media/radio/si470x/radio-si470x-common	EXPORT_SYMBOL_GPL	
++0x397558b5	drm_atomic_helper_check_modeset	drivers/gpu/drm/drm_kms_helper	EXPORT_SYMBOL	
++0x7c7ca16d	snd_soc_add_card_controls	sound/soc/snd-soc-core	EXPORT_SYMBOL_GPL	
++0x77d624db	dibusb_power_ctrl	drivers/media/usb/dvb-usb/dvb-usb-dibusb-common	EXPORT_SYMBOL	
++0xdf142325	drm_prime_pages_to_sg	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0xcffd69c0	crypto_nhpoly1305_final_helper	crypto/nhpoly1305	EXPORT_SYMBOL	
++0x2823f923	nf_ct_remove_expectations	net/netfilter/nf_conntrack	EXPORT_SYMBOL_GPL	
++0x459e133f	v4l2_m2m_get_curr_priv	drivers/media/v4l2-core/v4l2-mem2mem	EXPORT_SYMBOL	
++0xfdbc3f5f	rtl_get_hal_edca_param	drivers/net/wireless/realtek/rtlwifi/rtlwifi	EXPORT_SYMBOL_GPL	
++0x4571aea8	ath_is_world_regd	drivers/net/wireless/ath/ath	EXPORT_SYMBOL	
++0x195d14ed	nfnetlink_unicast	net/netfilter/nfnetlink	EXPORT_SYMBOL_GPL	
++0x08c2b447	vhost_log_write	drivers/vhost/vhost	EXPORT_SYMBOL_GPL	
++0xc9e381d5	rt2x00lib_pretbtt	drivers/net/wireless/ralink/rt2x00/rt2x00lib	EXPORT_SYMBOL_GPL	
++0x937a7dbe	drm_of_find_possible_crtcs	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0x10cadcda	drm_primary_helper_destroy	drivers/gpu/drm/drm_kms_helper	EXPORT_SYMBOL	
++0xce50e5de	ZSTD_compress_usingCDict	lib/zstd/zstd_compress	EXPORT_SYMBOL	
++0x0efbca4c	btracker_promotion_already_present	drivers/md/dm-cache	EXPORT_SYMBOL_GPL	
++0xe840e832	dibusb2_0_streaming_ctrl	drivers/media/usb/dvb-usb/dvb-usb-dibusb-common	EXPORT_SYMBOL	
++0xd14b4153	usb_serial_generic_throttle	drivers/usb/serial/usbserial	EXPORT_SYMBOL_GPL	
++0x78e264c5	cdrom_mode_select	drivers/cdrom/cdrom	EXPORT_SYMBOL	
++0x56a89d26	ar9003_paprd_enable	drivers/net/wireless/ath/ath9k/ath9k_hw	EXPORT_SYMBOL	
++0x0eb06fde	iscsi_tcp_task_xmit	drivers/scsi/libiscsi_tcp	EXPORT_SYMBOL_GPL	
++0x05c8bc1e	drm_syncobj_create	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0xcf45b1f5	virtio_transport_destruct	net/vmw_vsock/vmw_vsock_virtio_transport_common	EXPORT_SYMBOL_GPL	
++0x9ebc2f7e	nf_conntrack_in	net/netfilter/nf_conntrack	EXPORT_SYMBOL_GPL	
++0xc3f2fae8	snd_pcm_lib_preallocate_free_for_all	sound/core/snd-pcm	EXPORT_SYMBOL	
++0x485fa2fb	iio_device_alloc	drivers/iio/industrialio	EXPORT_SYMBOL	
++0x813bb0f4	ata_port_schedule_eh	drivers/ata/libata	EXPORT_SYMBOL_GPL	
++0xd688716b	dm_kcopyd_client_create	drivers/md/dm-mod	EXPORT_SYMBOL	
++0x758aff39	v4l2_fh_add	drivers/media/v4l2-core/videodev	EXPORT_SYMBOL_GPL	
++0x9be6d42b	helene_attach_s	drivers/media/dvb-frontends/helene	EXPORT_SYMBOL	
++0xfad8cf0b	i2c_root_adapter	drivers/i2c/i2c-mux	EXPORT_SYMBOL_GPL	
++0x78b72f44	usbip_debug_flag	drivers/usb/usbip/usbip-core	EXPORT_SYMBOL_GPL	
++0x8b3718e7	iscsi_tcp_conn_setup	drivers/scsi/libiscsi_tcp	EXPORT_SYMBOL_GPL	
++0x98502cbf	drm_scdc_set_scrambling	drivers/gpu/drm/drm_kms_helper	EXPORT_SYMBOL	
++0x8f5a7d34	aarp_send_ddp	net/appletalk/appletalk	EXPORT_SYMBOL	
++0x2478036f	serio_interrupt	drivers/input/serio/serio	EXPORT_SYMBOL	
++0x8ca765ee	p54_rx	drivers/net/wireless/intersil/p54/p54common	EXPORT_SYMBOL_GPL	
++0xa02d3d05	ath9k_hw_set_gpio	drivers/net/wireless/ath/ath9k/ath9k_hw	EXPORT_SYMBOL	
++0xd78e159f	drm_hdmi_avi_infoframe_bars	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0x2fa94ef2	drm_dp_downstream_444_to_420_conversion	drivers/gpu/drm/drm_kms_helper	EXPORT_SYMBOL	
++0xf1c367a8	__ovs_vport_ops_register	net/openvswitch/openvswitch	EXPORT_SYMBOL_GPL	
++0x30bcfa9d	can_proto_register	net/can/can	EXPORT_SYMBOL	
++0x8a55cd79	__ndisc_fill_addr_option	net/ipv6/ipv6	EXPORT_SYMBOL_GPL	
++0xd4ebf171	nf_nat_helper_put	net/netfilter/nf_conntrack	EXPORT_SYMBOL_GPL	
++0x4024751f	asoc_simple_parse_widgets	sound/soc/generic/snd-soc-simple-card-utils	EXPORT_SYMBOL_GPL	
++0x5a997af8	md_set_array_sectors	drivers/md/md-mod	EXPORT_SYMBOL	
++0x0e799108	null_dailink_component	sound/soc/snd-soc-core	EXPORT_SYMBOL_GPL	
++0x7225667d	vhost_work_flush	drivers/vhost/vhost	EXPORT_SYMBOL_GPL	
++0x666f30bf	ahci_handle_port_intr	drivers/ata/libahci	EXPORT_SYMBOL_GPL	
++0x09cc81fa	dm_btree_cursor_skip	drivers/md/persistent-data/dm-persistent-data	EXPORT_SYMBOL_GPL	
++0x33fc1e3e	em28xx_alloc_urbs	drivers/media/usb/em28xx/em28xx	EXPORT_SYMBOL_GPL	
++0xb9784f7b	flexcop_dump_reg	drivers/media/common/b2c2/b2c2-flexcop	EXPORT_SYMBOL	
++0xc199772c	dm_writepowerindex	drivers/net/wireless/realtek/rtlwifi/rtl8192c/rtl8192c-common	EXPORT_SYMBOL_GPL	
++0x938a3b2e	__mt76_poll	drivers/net/wireless/mediatek/mt76/mt76	EXPORT_SYMBOL_GPL	
++0x03746954	drm_add_modes_noedid	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0xf6b85ec5	cfg80211_ref_bss	net/wireless/cfg80211	EXPORT_SYMBOL	
++0x62e54853	w1_ds2781_eeprom_cmd	drivers/w1/slaves/w1_ds2781	EXPORT_SYMBOL	
++0x2702ac23	w1_ds2780_eeprom_cmd	drivers/w1/slaves/w1_ds2780	EXPORT_SYMBOL	
++0x13abdd5a	hostap_dump_tx_header	drivers/net/wireless/intersil/hostap/hostap	EXPORT_SYMBOL	
++0x7fb75891	hostap_dump_rx_header	drivers/net/wireless/intersil/hostap/hostap	EXPORT_SYMBOL	
++0x4be205da	drm_warn_on_modeset_not_all_locked	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0xc50921c0	snd_unregister_device	sound/core/snd	EXPORT_SYMBOL	
++0x61ab8de0	ata_scsi_cmd_error_handler	drivers/ata/libata	EXPORT_SYMBOL	
++0xb75386fd	_rtl92c_phy_rf_serial_read	drivers/net/wireless/realtek/rtlwifi/rtl8192c/rtl8192c-common	EXPORT_SYMBOL	
++0x27cf77d4	af_alg_accept	crypto/af_alg	EXPORT_SYMBOL_GPL	
++0xde63ef1e	xt_request_find_match	net/netfilter/x_tables	EXPORT_SYMBOL_GPL	
++0xcfc4d9cb	microtune_attach	drivers/media/tuners/mt20xx	EXPORT_SYMBOL_GPL	
++0x28c5b4b7	iforce_send_packet	drivers/input/joystick/iforce/iforce	EXPORT_SYMBOL	
++0x4a733b61	iscsi_put_task	drivers/scsi/libiscsi	EXPORT_SYMBOL_GPL	
++0x2e439142	drm_get_panel_orientation_quirk	drivers/gpu/drm/drm_panel_orientation_quirks	EXPORT_SYMBOL	
++0xe70a5f0c	drm_ioctl	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0xcf17859f	cx231xx_demod_reset	drivers/media/usb/cx231xx/cx231xx	EXPORT_SYMBOL_GPL	
++0x319aaabd	dibusb2_0_power_ctrl	drivers/media/usb/dvb-usb/dvb-usb-dibusb-common	EXPORT_SYMBOL	
++0x918dfecd	drm_mode_duplicate	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0x745a9c62	can_proto_unregister	net/can/can	EXPORT_SYMBOL	
++0x7949cc43	snd_soc_of_parse_aux_devs	sound/soc/snd-soc-core	EXPORT_SYMBOL_GPL	
++0x1bf45436	vhost_dev_reset_owner	drivers/vhost/vhost	EXPORT_SYMBOL_GPL	
++0x63757e92	w1_calc_crc8	drivers/w1/wire	EXPORT_SYMBOL_GPL	
++0x15d9d680	ata_sff_busy_sleep	drivers/ata/libata	EXPORT_SYMBOL_GPL	
++0x00612a7c	drm_vma_node_is_allowed	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0x8ca2497b	fuse_dequeue_forget	fs/fuse/fuse	EXPORT_SYMBOL	
++0x2496a6fd	v4l2_mc_create_media_graph	drivers/media/v4l2-core/videodev	EXPORT_SYMBOL_GPL	
++0x19f37a4c	vb2_qbuf	drivers/media/common/videobuf2/videobuf2-v4l2	EXPORT_SYMBOL_GPL	
++0x3b7066d3	usbip_stop_eh	drivers/usb/usbip/usbip-core	EXPORT_SYMBOL_GPL	
++0xb3adf38d	store_cdrom_address	drivers/usb/gadget/function/usb_f_mass_storage	EXPORT_SYMBOL_GPL	
++0x5b17be06	cast_s4	crypto/cast_common	EXPORT_SYMBOL_GPL	
++0x5c01a983	md_done_sync	drivers/md/md-mod	EXPORT_SYMBOL	
++0xac4624a5	flexcop_i2c_request	drivers/media/common/b2c2/b2c2-flexcop	EXPORT_SYMBOL	
++0xb33fab69	ieee80211_iterate_stations_atomic	net/mac80211/mac80211	EXPORT_SYMBOL_GPL	
++0xcb9da044	l2cap_conn_get	net/bluetooth/bluetooth	EXPORT_SYMBOL	
++0x608e3367	lib80211_crypt_info_init	net/wireless/lib80211	EXPORT_SYMBOL	
++0xf45c55ab	ipv6_chk_prefix	net/ipv6/ipv6	EXPORT_SYMBOL	
++0x24f816c6	ip6_dst_lookup_flow	net/ipv6/ipv6	EXPORT_SYMBOL_GPL	
++0x452b8376	usb_ftdi_elan_edset_output	drivers/usb/misc/ftdi-elan	EXPORT_SYMBOL_GPL	
++0xd05a394c	virtio_transport_deliver_tap_pkt	net/vmw_vsock/vmw_vsock_virtio_transport_common	EXPORT_SYMBOL_GPL	
++0xe5d815a9	ip6_xmit	net/ipv6/ipv6	EXPORT_SYMBOL	
++0xf8a6fa62	ip_tunnel_init	net/ipv4/ip_tunnel	EXPORT_SYMBOL_GPL	
++0x88fb83b0	iio_channel_get_all_cb	drivers/iio/buffer/industrialio-buffer-cb	EXPORT_SYMBOL_GPL	
++0x1d919606	ata_sff_dev_select	drivers/ata/libata	EXPORT_SYMBOL_GPL	
++0xeab93c3c	ata_noop_qc_prep	drivers/ata/libata	EXPORT_SYMBOL_GPL	
++0x429c47e4	dm_cell_visit_release	drivers/md/dm-bio-prison	EXPORT_SYMBOL_GPL	
++0x8afd18d0	drm_bridge_detect	drivers/gpu/drm/drm	EXPORT_SYMBOL_GPL	
++0x4fbd55fb	drm_hdmi_avi_infoframe_quant_range	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0x1fa4962d	l2cap_chan_close	net/bluetooth/bluetooth	EXPORT_SYMBOL	
++0x7fdd85e2	udp6_lib_lookup_skb	net/ipv6/ipv6	EXPORT_SYMBOL_GPL	
++0xf78280d0	w1_remove_master_device	drivers/w1/wire	EXPORT_SYMBOL	
++0x8b4541cc	mtd_ooblayout_ecc	drivers/mtd/mtd	EXPORT_SYMBOL_GPL	
++0xef94204e	o2nm_get_node_by_ip	fs/ocfs2/cluster/ocfs2_nodemanager	EXPORT_SYMBOL_GPL	
++0xcecfcca4	line6_suspend	sound/usb/line6/snd-usb-line6	EXPORT_SYMBOL_GPL	
++0xb4cca37a	ata_sas_port_start	drivers/ata/libata	EXPORT_SYMBOL_GPL	
++0x2616d971	md_account_bio	drivers/md/md-mod	EXPORT_SYMBOL_GPL	
++0x81ebf8b1	ath9k_hw_btcoex_deinit	drivers/net/wireless/ath/ath9k/ath9k_hw	EXPORT_SYMBOL	
++0x06a0723a	drm_property_replace_blob	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0xd914b822	drm_atomic_bridge_chain_enable	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0xf0a6e9a2	dlm_posix_get	fs/dlm/dlm	EXPORT_SYMBOL_GPL	
++0x34d7841c	__media_entity_remove_links	drivers/media/mc/mc	EXPORT_SYMBOL_GPL	
++0x161b9640	mt76x02_init_agc_gain	drivers/net/wireless/mediatek/mt76/mt76x02-lib	EXPORT_SYMBOL_GPL	
++0x3755f990	gf128mul_init_64k_bbe	crypto/gf128mul	EXPORT_SYMBOL	
++0x79b82a71	cfg80211_find_vendor_elem	net/wireless/cfg80211	EXPORT_SYMBOL	
++0x275269b3	ieee80211_ie_split_ric	net/wireless/cfg80211	EXPORT_SYMBOL	
++0x88715995	xt_find_match	net/netfilter/x_tables	EXPORT_SYMBOL	
++0x3af89f92	cec_queue_pin_5v_event	drivers/media/cec/core/cec	EXPORT_SYMBOL_GPL	
++0xfba63fcd	v4l2_m2m_ctx_init	drivers/media/v4l2-core/v4l2-mem2mem	EXPORT_SYMBOL_GPL	
++0x8535693f	dvb_usb_device_exit	drivers/media/usb/dvb-usb/dvb-usb	EXPORT_SYMBOL	
++0xdfb3c229	rtl_ps_enable_nic	drivers/net/wireless/realtek/rtlwifi/rtlwifi	EXPORT_SYMBOL	
++0xff9c4b56	ZSTD_compressBound	lib/zstd/zstd_compress	EXPORT_SYMBOL	
++0xa707c90a	nf_ct_helper_expectfn_find_by_name	net/netfilter/nf_conntrack	EXPORT_SYMBOL_GPL	
++0xfd1525f2	snd_card_set_id	sound/core/snd	EXPORT_SYMBOL	
++0xe15b842b	serio_reconnect	drivers/input/serio/serio	EXPORT_SYMBOL	
++0xefc08bba	cec_unregister_adapter	drivers/media/cec/core/cec	EXPORT_SYMBOL_GPL	
++0x20b310fb	ar9003_hw_disable_phy_restart	drivers/net/wireless/ath/ath9k/ath9k_hw	EXPORT_SYMBOL	
++0x72db83c4	bcm2835_smi_set_address	drivers/misc/bcm2835_smi	EXPORT_SYMBOL	
++0x07ac0d07	drm_encoder_cleanup	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0x52ecbc75	crc_ccitt	lib/crc-ccitt	EXPORT_SYMBOL	
++0x9bcd68ec	ieee80211_rx_napi	net/mac80211/mac80211	EXPORT_SYMBOL	
++0x177a7c26	udp_tunnel_xmit_skb	net/ipv4/udp_tunnel	EXPORT_SYMBOL_GPL	
++0xc48b7ccf	ata_mode_string	drivers/ata/libata	EXPORT_SYMBOL_GPL	
++0x34d45c77	dm_btree_cursor_get_value	drivers/md/persistent-data/dm-persistent-data	EXPORT_SYMBOL_GPL	
++0x20c9cf27	lbs_get_firmware_async	drivers/net/wireless/marvell/libertas/libertas	EXPORT_SYMBOL_GPL	
++0x13803097	drm_crtc_send_vblank_event	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0xeef35421	xfrm6_tunnel_deregister	net/ipv6/tunnel6	EXPORT_SYMBOL	
++0xad5664c1	xfrm4_tunnel_deregister	net/ipv4/tunnel4	EXPORT_SYMBOL	
++0xcedfc878	dm_bitset_cursor_get_value	drivers/md/persistent-data/dm-persistent-data	EXPORT_SYMBOL_GPL	
++0x74a81ec6	vxlan_fdb_find_uc	drivers/net/vxlan	EXPORT_SYMBOL_GPL	
++0x0b28a9ad	qcafrm_create_footer	drivers/net/ethernet/qualcomm/qca_7k_common	EXPORT_SYMBOL_GPL	
++0x05a6dc59	p9_client_attach	net/9p/9pnet	EXPORT_SYMBOL	
++0xfe93e215	ieee80211_disable_rssi_reports	net/mac80211/mac80211	EXPORT_SYMBOL	
++0x557faf50	nf_ct_unexpect_related	net/netfilter/nf_conntrack	EXPORT_SYMBOL_GPL	
++0xd5b9b778	dvb_create_media_graph	drivers/media/dvb-core/dvb-core	EXPORT_SYMBOL_GPL	
++0xa3e1febb	v4l2_ctrl_radio_filter	drivers/media/v4l2-core/videodev	EXPORT_SYMBOL	
++0xc09d16b3	v4l2_fwnode_device_parse	drivers/media/v4l2-core/v4l2-fwnode	EXPORT_SYMBOL_GPL	
++0x6bd3ba6f	can_rx_offload_irq_offload_timestamp	drivers/net/can/dev/can-dev	EXPORT_SYMBOL_GPL	
++0x550835d1	drm_bridge_add	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0xfdf70093	ZSTD_CStreamOutSize	lib/zstd/zstd_compress	EXPORT_SYMBOL	
++0x186e2a7c	arizona_init_dai	sound/soc/codecs/snd-soc-arizona	EXPORT_SYMBOL_GPL	
++0xf71354ac	dibx000_exit_i2c_master	drivers/media/dvb-frontends/dibx000_common	EXPORT_SYMBOL	
++0x63f544aa	dibx000_init_i2c_master	drivers/media/dvb-frontends/dibx000_common	EXPORT_SYMBOL	
++0xddd1e814	virtio_transport_stream_is_active	net/vmw_vsock/vmw_vsock_virtio_transport_common	EXPORT_SYMBOL_GPL	
++0x48bc400e	snd_pcm_hw_constraint_ratdens	sound/core/snd-pcm	EXPORT_SYMBOL	
++0x441dd47b	release_and_free_resource	sound/core/snd	EXPORT_SYMBOL	
++0x2d665fbd	mux_control_put	drivers/mux/mux-core	EXPORT_SYMBOL_GPL	
++0x2b8be8aa	mux_control_get	drivers/mux/mux-core	EXPORT_SYMBOL_GPL	
++0xc96d6746	fbtft_framebuffer_release	drivers/staging/fbtft/fbtft	EXPORT_SYMBOL	
++0xc9f0e83c	em28xx_write_regs	drivers/media/usb/em28xx/em28xx	EXPORT_SYMBOL_GPL	
++0xe92cfd5d	mt76u_single_wr	drivers/net/wireless/mediatek/mt76/mt76-usb	EXPORT_SYMBOL_GPL	
++0x5eb6d40a	mt76_txq_schedule_all	drivers/net/wireless/mediatek/mt76/mt76	EXPORT_SYMBOL_GPL	
++0xb7b7df52	iscsi_tcp_conn_teardown	drivers/scsi/libiscsi_tcp	EXPORT_SYMBOL_GPL	
++0x0ae8ba02	drm_dp_mst_dsc_aux_for_port	drivers/gpu/drm/drm_kms_helper	EXPORT_SYMBOL	
++0x6fb41b9a	ieee80211_get_tx_rates	net/mac80211/mac80211	EXPORT_SYMBOL	
++0x0db1d489	raw_v6_hashinfo	net/ipv6/ipv6	EXPORT_SYMBOL_GPL	
++0x156d8209	__traceiter_fib6_table_lookup	net/ipv6/ipv6	EXPORT_SYMBOL_GPL	
++0xb1861500	nf_reject_ip_tcphdr_put	net/ipv4/netfilter/nf_reject_ipv4	EXPORT_SYMBOL_GPL	
++0x6bec0e66	vhost_iotlb_del_range	drivers/vhost/vhost_iotlb	EXPORT_SYMBOL_GPL	
++0x38ff875f	vhost_iotlb_add_range	drivers/vhost/vhost_iotlb	EXPORT_SYMBOL_GPL	
++0x05c20fa1	ssb_pmu_spuravoid_pllupdate	drivers/ssb/ssb	EXPORT_SYMBOL_GPL	
++0x2fb9a3ba	drm_mode_get_tile_group	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0x7cceaf92	zs_pool_stats	mm/zsmalloc	EXPORT_SYMBOL_GPL	
++0xc654115f	vsock_remove_bound	net/vmw_vsock/vsock	EXPORT_SYMBOL_GPL	
++0xddd5bf50	p9_client_cb	net/9p/9pnet	EXPORT_SYMBOL	
++0x57080ed4	_rtl92c_phy_txpwr_idx_to_dbm	drivers/net/wireless/realtek/rtlwifi/rtl8192c/rtl8192c-common	EXPORT_SYMBOL	
++0xb3bcaf45	mt76_get_rate	drivers/net/wireless/mediatek/mt76/mt76	EXPORT_SYMBOL_GPL	
++0x083eb21c	rfkill_unregister	net/rfkill/rfkill	EXPORT_SYMBOL	
++0x512dbd0f	bcma_chipco_pll_maskset	drivers/bcma/bcma	EXPORT_SYMBOL_GPL	
++0x5352d022	v4l2_m2m_resume	drivers/media/v4l2-core/v4l2-mem2mem	EXPORT_SYMBOL	
++0xddda5cd3	go7007_parse_video_stream	drivers/media/usb/go7007/go7007	EXPORT_SYMBOL	
++0xb12040d2	usb_ep_autoconfig_ss	drivers/usb/gadget/libcomposite	EXPORT_SYMBOL_GPL	
++0xc0777ee1	drm_writeback_cleanup_job	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0xc0187c1e	drm_plane_force_disable	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0xd0fad08f	bcma_chipco_gpio_out	drivers/bcma/bcma	EXPORT_SYMBOL_GPL	
++0xf699bc7b	cypress_load_firmware	drivers/media/common/cypress_firmware	EXPORT_SYMBOL	
++0xc92017c8	__drmm_add_action_or_reset	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0xb002460e	drm_atomic_add_affected_planes	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0x6016e258	ip6_tnl_get_iflink	net/ipv6/ip6_tunnel	EXPORT_SYMBOL	
++0x54486c0e	nf_dup_ipv6	net/ipv6/netfilter/nf_dup_ipv6	EXPORT_SYMBOL_GPL	
++0x17b35628	nf_nat_ipv6_unregister_fn	net/netfilter/nf_nat	EXPORT_SYMBOL_GPL	
++0x76d40046	synth_buffer_skip_nonlatin1	drivers/accessibility/speakup/speakup	EXPORT_SYMBOL_GPL	
++0x975a1e29	tpg_g_interleaved_plane	drivers/media/common/v4l2-tpg/v4l2-tpg	EXPORT_SYMBOL_GPL	
++0x3560ca43	rtl_collect_scan_list	drivers/net/wireless/realtek/rtlwifi/rtlwifi	EXPORT_SYMBOL	
++0x8a0afc37	ath6kl_cfg80211_resume	drivers/net/wireless/ath/ath6kl/ath6kl_core	EXPORT_SYMBOL	
++0xb053adda	drm_rect_rotate	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0x854c0f24	vsock_create_connected	net/vmw_vsock/vsock	EXPORT_SYMBOL_GPL	
++0x1de558c1	nft_reject_icmpv6_code	net/netfilter/nft_reject	EXPORT_SYMBOL_GPL	
++0xdfa23e14	ata_slave_link_init	drivers/ata/libata	EXPORT_SYMBOL_GPL	
++0x2417c5c4	dm_btree_empty	drivers/md/persistent-data/dm-persistent-data	EXPORT_SYMBOL_GPL	
++0xc1b99792	ieee80211_channel_to_freq_khz	net/wireless/cfg80211	EXPORT_SYMBOL	
++0xaad5e38a	uio_event_notify	drivers/uio/uio	EXPORT_SYMBOL_GPL	
++0x1f45b62f	rt2800_txdone	drivers/net/wireless/ralink/rt2x00/rt2800lib	EXPORT_SYMBOL_GPL	
++0x7498ce98	alloc_mdio_bitbang	drivers/net/mdio/mdio-bitbang	EXPORT_SYMBOL	
++0x1a344738	__cfg80211_alloc_reply_skb	net/wireless/cfg80211	EXPORT_SYMBOL	
++0xa210f40a	w1_reset_select_slave	drivers/w1/wire	EXPORT_SYMBOL_GPL	
++0x856eb2b5	ubi_get_volume_info	drivers/mtd/ubi/ubi	EXPORT_SYMBOL_GPL	
++0x13ed18f4	mtd_device_parse_register	drivers/mtd/mtd	EXPORT_SYMBOL_GPL	
++0x10025aa1	mt2060_attach	drivers/media/tuners/mt2060	EXPORT_SYMBOL	
++0xf0b72887	lbtf_remove_card	drivers/net/wireless/marvell/libertas_tf/libertas_tf	EXPORT_SYMBOL_GPL	
++0xcbb11945	hostap_free_data	drivers/net/wireless/intersil/hostap/hostap	EXPORT_SYMBOL	
++0x07eefb14	drm_connector_attach_max_bpc_property	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0x8ca2d9e4	drm_dp_calc_pbn_mode	drivers/gpu/drm/drm_kms_helper	EXPORT_SYMBOL	
++0x670ca4f1	backlight_device_get_by_type	drivers/video/backlight/backlight	EXPORT_SYMBOL	
++0x2b02aa61	cfg80211_conn_failed	net/wireless/cfg80211	EXPORT_SYMBOL	
++0x2275f4fe	aic32x4_remove	sound/soc/codecs/snd-soc-tlv320aic32x4	EXPORT_SYMBOL	
++0x8b6f5395	dvb_usb_get_hexline	drivers/media/usb/dvb-usb/dvb-usb	EXPORT_SYMBOL	
++0x8d019d4f	drm_vblank_work_flush	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0xefe73979	simd_skcipher_free	crypto/crypto_simd	EXPORT_SYMBOL_GPL	
++0x1abb88e7	cfg80211_rx_spurious_frame	net/wireless/cfg80211	EXPORT_SYMBOL	
++0x62700561	ocfs2_stack_glue_unregister	fs/ocfs2/ocfs2_stackglue	EXPORT_SYMBOL_GPL	
++0xcd47fcc4	arc4_crypt	lib/crypto/libarc4	EXPORT_SYMBOL	
++0x32e032e6	cfg80211_control_port_tx_status	net/wireless/cfg80211	EXPORT_SYMBOL	
++0x07a81635	snd_card_new	sound/core/snd	EXPORT_SYMBOL	
++0x6543f2c2	bmp280_dev_pm_ops	drivers/iio/pressure/bmp280	EXPORT_SYMBOL	
++0x0c690e68	ubi_close_volume	drivers/mtd/ubi/ubi	EXPORT_SYMBOL_GPL	
++0xb3ff1f94	videobuf_read_one	drivers/media/v4l2-core/videobuf-core	EXPORT_SYMBOL_GPL	
++0x1622004d	o2hb_unregister_callback	fs/ocfs2/cluster/ocfs2_nodemanager	EXPORT_SYMBOL_GPL	
++0xd4fd925a	ieee80211_manage_rx_ba_offl	net/mac80211/mac80211	EXPORT_SYMBOL	
++0x3bc17c49	nf_nat_masquerade_inet_register_notifiers	net/netfilter/nf_nat	EXPORT_SYMBOL_GPL	
++0x86f1c20c	v4l2_event_subscribe	drivers/media/v4l2-core/videodev	EXPORT_SYMBOL_GPL	
++0x9b8a53f5	drm_ht_just_insert_please	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0x9d6cba30	cfg80211_find_elem_match	net/wireless/cfg80211	EXPORT_SYMBOL	
++0xcee5b7e6	drm_mode_create_hdmi_colorspace_property	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0xb9b311d3	ip_set_elem_len	net/netfilter/ipset/ip_set	EXPORT_SYMBOL_GPL	
++0xfe9beb32	unregister_mtd_chip_driver	drivers/mtd/chips/chipreg	EXPORT_SYMBOL	
++0x47f25086	cec_s_log_addrs	drivers/media/cec/core/cec	EXPORT_SYMBOL_GPL	
++0xd9d1f356	mxl111sf_demod_attach	drivers/media/usb/dvb-usb-v2/mxl111sf-demod	EXPORT_SYMBOL_GPL	
++0x1ceaa6f6	rndis_set_host_mac	drivers/usb/gadget/function/usb_f_rndis	EXPORT_SYMBOL_GPL	
++0xb301f4c1	ath_regd_init	drivers/net/wireless/ath/ath	EXPORT_SYMBOL	
++0x1e22228f	ath9k_hw_wait	drivers/net/wireless/ath/ath9k/ath9k_hw	EXPORT_SYMBOL	
++0x6cd022e7	drm_fb_cma_get_gem_obj	drivers/gpu/drm/drm_kms_helper	EXPORT_SYMBOL_GPL	
++0x133bcd9b	line6_pcm_release	sound/usb/line6/snd-usb-line6	EXPORT_SYMBOL_GPL	
++0x9954a627	drm_mode_create_suggested_offset_properties	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0x4350f8d9	ip_tunnel_newlink	net/ipv4/ip_tunnel	EXPORT_SYMBOL_GPL	
++0xdf5a3841	ct_sip_parse_numerical_param	net/netfilter/nf_conntrack_sip	EXPORT_SYMBOL_GPL	
++0xebedfe5f	rtl_wowlan_fw_cb	drivers/net/wireless/realtek/rtlwifi/rtlwifi	EXPORT_SYMBOL	
++0xf4060ce3	drm_connector_list_iter_next	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0xe58a3360	p9_error_init	net/9p/9pnet	EXPORT_SYMBOL	
++0x817e337a	fsg_lun_close	drivers/usb/gadget/function/usb_f_mass_storage	EXPORT_SYMBOL_GPL	
++0x0577f4fd	rt2x00mac_add_interface	drivers/net/wireless/ralink/rt2x00/rt2x00lib	EXPORT_SYMBOL_GPL	
++0x8195dca5	cryptd_free_aead	crypto/cryptd	EXPORT_SYMBOL_GPL	
++0x23500e06	virtio_transport_notify_send_post_enqueue	net/vmw_vsock/vmw_vsock_virtio_transport_common	EXPORT_SYMBOL_GPL	
++0xeaee8855	nf_tproxy_laddr4	net/ipv4/netfilter/nf_tproxy_ipv4	EXPORT_SYMBOL_GPL	
++0xf3bafb75	asoc_simple_convert_fixup	sound/soc/generic/snd-soc-simple-card-utils	EXPORT_SYMBOL_GPL	
++0x01205515	w1_reset_resume_command	drivers/w1/wire	EXPORT_SYMBOL_GPL	
++0xc5872d01	dm_table_run_md_queue_async	drivers/md/dm-mod	EXPORT_SYMBOL	
++0x970c85c2	mt76_set_irq_mask	drivers/net/wireless/mediatek/mt76/mt76	EXPORT_SYMBOL_GPL	
++0x5719b2ac	drm_sched_resume_timeout	drivers/gpu/drm/scheduler/gpu-sched	EXPORT_SYMBOL	
++0x75b7f18f	drm_atomic_get_plane_state	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0x6603b176	drm_gem_prime_import_dev	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0xa6ff9496	drm_dp_link_train_clock_recovery_delay	drivers/gpu/drm/drm_kms_helper	EXPORT_SYMBOL	
++0x222411dd	ahci_error_handler	drivers/ata/libahci	EXPORT_SYMBOL_GPL	
++0x1a95be31	cec_register_adapter	drivers/media/cec/core/cec	EXPORT_SYMBOL_GPL	
++0x63f4bd17	rndis_signal_disconnect	drivers/usb/gadget/function/usb_f_rndis	EXPORT_SYMBOL_GPL	
++0xe83b06bd	drm_client_rotation	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0x7b990276	drm_irq_install	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0x6bec3915	wm_adsp2_init	sound/soc/codecs/snd-soc-wm-adsp	EXPORT_SYMBOL_GPL	
++0xd11c8e91	wm_adsp1_init	sound/soc/codecs/snd-soc-wm-adsp	EXPORT_SYMBOL_GPL	
++0x5c407196	snd_pcm_fill_iec958_consumer_hw_params	sound/core/snd-pcm	EXPORT_SYMBOL	
++0xec29dfcd	ata_dev_set_feature	drivers/ata/libata	EXPORT_SYMBOL_GPL	
++0x44acb961	v4l2_fwnode_parse_link	drivers/media/v4l2-core/v4l2-fwnode	EXPORT_SYMBOL_GPL	
++0xcd674496	fsg_store_file	drivers/usb/gadget/function/usb_f_mass_storage	EXPORT_SYMBOL_GPL	
++0x269f0465	rtl92c_phy_rf_config	drivers/net/wireless/realtek/rtlwifi/rtl8192c/rtl8192c-common	EXPORT_SYMBOL	
++0x3351521d	dm_cell_unlock_v2	drivers/md/dm-bio-prison	EXPORT_SYMBOL_GPL	
++0xeeba4bd8	v4l2_ctrl_request_hdl_ctrl_find	drivers/media/v4l2-core/videodev	EXPORT_SYMBOL_GPL	
++0xc49c16e3	rtl92c_phy_set_io	drivers/net/wireless/realtek/rtlwifi/rtl8192c/rtl8192c-common	EXPORT_SYMBOL	
++0x8706854f	mt76x02_remove_hdr_pad	drivers/net/wireless/mediatek/mt76/mt76x02-lib	EXPORT_SYMBOL_GPL	
++0xd1da855f	iscsi_boot_create_host_kset	drivers/scsi/iscsi_boot_sysfs	EXPORT_SYMBOL_GPL	
++0x8fea24bd	bt_sock_unregister	net/bluetooth/bluetooth	EXPORT_SYMBOL	
++0xc14c60bf	ath9k_hw_setuptxqueue	drivers/net/wireless/ath/ath9k/ath9k_hw	EXPORT_SYMBOL	
++0x7f531f4b	snd_timer_resolution	sound/core/snd-timer	EXPORT_SYMBOL	
++0x5cba502d	ms_sensors_read_temp_and_pressure	drivers/iio/common/ms_sensors/ms_sensors_i2c	EXPORT_SYMBOL	
++0xe080716d	rtl_tx_report_handler	drivers/net/wireless/realtek/rtlwifi/rtlwifi	EXPORT_SYMBOL_GPL	
++0x6d7523c6	btintel_set_diag	drivers/bluetooth/btintel	EXPORT_SYMBOL_GPL	
++0x46ac032f	__tracepoint_vb2_v4l2_dqbuf	drivers/media/v4l2-core/videodev	EXPORT_SYMBOL_GPL	
++0x1356ab28	ieee80211_mandatory_rates	net/wireless/cfg80211	EXPORT_SYMBOL	
++0x7ad4e21a	inet_diag_register	net/ipv4/inet_diag	EXPORT_SYMBOL_GPL	
++0x08c02a41	nf_ct_helper_init	net/netfilter/nf_conntrack	EXPORT_SYMBOL_GPL	
++0x9e96e2ff	ata_pci_sff_prepare_host	drivers/ata/libata	EXPORT_SYMBOL_GPL	
++0x707b5c92	dm_rh_dirty_log	drivers/md/dm-region-hash	EXPORT_SYMBOL_GPL	
++0x4bbc7e46	vb2_ops_wait_finish	drivers/media/common/videobuf2/videobuf2-v4l2	EXPORT_SYMBOL_GPL	
++0x67133576	rtl_init_rfkill	drivers/net/wireless/realtek/rtlwifi/rtlwifi	EXPORT_SYMBOL	
++0x475536e7	ath9k_hw_set_sta_beacon_timers	drivers/net/wireless/ath/ath9k/ath9k_hw	EXPORT_SYMBOL	
++0xd537c06c	tpm_is_tpm2	drivers/char/tpm/tpm	EXPORT_SYMBOL_GPL	
++0xec956b90	snd_pcm_hw_rule_add	sound/core/snd-pcm	EXPORT_SYMBOL	
++0xfe53f308	mtd_ooblayout_find_eccregion	drivers/mtd/mtd	EXPORT_SYMBOL_GPL	
++0x2e5382f9	rtl_fill_dummy	drivers/net/wireless/realtek/rtlwifi/rtlwifi	EXPORT_SYMBOL_GPL	
++0x0d57752d	drm_gem_cma_prime_import_sg_table	drivers/gpu/drm/drm	EXPORT_SYMBOL_GPL	
++0xf19e2bff	drm_crtc_vblank_helper_get_vblank_timestamp	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0x1fe041f9	drm_dp_mst_get_vcpi_slots	drivers/gpu/drm/drm_kms_helper	EXPORT_SYMBOL	
++0xb6392668	snd_card_file_remove	sound/core/snd	EXPORT_SYMBOL	
++0x7ade1071	dm_tm_destroy	drivers/md/persistent-data/dm-persistent-data	EXPORT_SYMBOL_GPL	
++0x3371de87	v4l2_m2m_ioctl_querybuf	drivers/media/v4l2-core/v4l2-mem2mem	EXPORT_SYMBOL_GPL	
++0x2728923b	au8522_sleep	drivers/media/dvb-frontends/au8522_common	EXPORT_SYMBOL	
++0x986832d2	__iscsi_complete_pdu	drivers/scsi/libiscsi	EXPORT_SYMBOL_GPL	
++0xccbe6bbd	o2nm_get_node_by_num	fs/ocfs2/cluster/ocfs2_nodemanager	EXPORT_SYMBOL_GPL	
++0x2bb32ad1	arc4_setkey	lib/crypto/libarc4	EXPORT_SYMBOL	
++0x3dc7d218	snd_dmaengine_pcm_get_chan	sound/core/snd-pcm-dmaengine	EXPORT_SYMBOL_GPL	
++0xac437f7b	snd_interval_ratnum	sound/core/snd-pcm	EXPORT_SYMBOL	
++0xbb463303	btintel_read_boot_params	drivers/bluetooth/btintel	EXPORT_SYMBOL_GPL	
++0xedc3440d	mtd_write_oob	drivers/mtd/mtd	EXPORT_SYMBOL_GPL	
++0xcccfb2fa	sata_deb_timing_hotplug	drivers/ata/libata	EXPORT_SYMBOL_GPL	
++0xf4225b73	media_request_get_by_fd	drivers/media/mc/mc	EXPORT_SYMBOL_GPL	
++0x8311243f	drm_prime_sg_to_page_addr_arrays	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0xe67b36db	wimax_msg_send	net/wimax/wimax	EXPORT_SYMBOL_GPL	
++0x2310adee	ieee80211_bss_get_elem	net/wireless/cfg80211	EXPORT_SYMBOL	
++0x198af183	ipv6_dev_get_saddr	net/ipv6/ipv6	EXPORT_SYMBOL	
++0x370cfe6e	v4l2_dv_timings_presets	drivers/media/v4l2-core/v4l2-dv-timings	EXPORT_SYMBOL_GPL	
++0x7f1a1cda	tea5761_autodetection	drivers/media/tuners/tea5761	EXPORT_SYMBOL_GPL	
++0x0cc8ecf7	drm_connector_attach_colorspace_property	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0xbf0e51c7	ovs_netdev_link	net/openvswitch/openvswitch	EXPORT_SYMBOL_GPL	
++0xeb43cc80	dib0090_gain_control	drivers/media/dvb-frontends/dib0090	EXPORT_SYMBOL	
++0x10eb6d41	ovs_vport_free	net/openvswitch/openvswitch	EXPORT_SYMBOL_GPL	
++0x5c88219c	ieee80211_rate_control_register	net/mac80211/mac80211	EXPORT_SYMBOL	
++0xb4c1ac46	inet_diag_unregister	net/ipv4/inet_diag	EXPORT_SYMBOL_GPL	
++0xf8842cd4	nf_ct_netns_put	net/netfilter/nf_conntrack	EXPORT_SYMBOL_GPL	
++0x6410b1ca	nf_ct_netns_get	net/netfilter/nf_conntrack	EXPORT_SYMBOL_GPL	
++0xd8fc2c90	virtio_transport_stream_rcvhiwat	net/vmw_vsock/vmw_vsock_virtio_transport_common	EXPORT_SYMBOL_GPL	
++0xee9a49df	l2tp_recv_common	net/l2tp/l2tp_core	EXPORT_SYMBOL_GPL	
++0x2a596739	snd_pcm_stop_xrun	sound/core/snd-pcm	EXPORT_SYMBOL_GPL	
++0xf4e2b1d8	snd_hwdep_new	sound/core/snd-hwdep	EXPORT_SYMBOL	
++0x8d49370a	ffs_lock	drivers/usb/gadget/function/usb_f_fs	EXPORT_SYMBOL_GPL	
++0xa2a58bbe	charlcd_alloc	drivers/auxdisplay/charlcd	EXPORT_SYMBOL_GPL	
++0xca59561c	rt2x00usb_vendor_request_buff	drivers/net/wireless/ralink/rt2x00/rt2x00usb	EXPORT_SYMBOL_GPL	
++0x4840d472	ath9k_cmn_rx_accept	drivers/net/wireless/ath/ath9k/ath9k_common	EXPORT_SYMBOL	
++0x45b2b61b	ieee802154_hdr_peek_addrs	net/ieee802154/ieee802154	EXPORT_SYMBOL_GPL	
++0x1650e2f9	drm_do_get_edid	drivers/gpu/drm/drm	EXPORT_SYMBOL_GPL	
++0x7c3138f2	sctp_transport_traverse_process	net/sctp/sctp	EXPORT_SYMBOL_GPL	
++0x2b6ddf7a	nf_dup_netdev_egress	net/netfilter/nf_dup_netdev	EXPORT_SYMBOL_GPL	
++0xf79f4538	snd_ctl_boolean_stereo_info	sound/core/snd	EXPORT_SYMBOL	
++0x61d9c2f6	rt2x00lib_txdone_nomatch	drivers/net/wireless/ralink/rt2x00/rt2x00lib	EXPORT_SYMBOL_GPL	
++0xc20134e7	chacha20poly1305_decrypt	lib/crypto/libchacha20poly1305	EXPORT_SYMBOL	
++0x147c3f2e	chacha20poly1305_encrypt	lib/crypto/libchacha20poly1305	EXPORT_SYMBOL	
++0xa24d2611	__ieee80211_get_assoc_led_name	net/mac80211/mac80211	EXPORT_SYMBOL	
++0x3b64b73c	ieee80211_ctstoself_duration	net/mac80211/mac80211	EXPORT_SYMBOL	
++0x2ae0877b	__SCK__tp_func_vb2_v4l2_buf_done	drivers/media/v4l2-core/videodev	EXPORT_SYMBOL_GPL	
++0xa9ae892c	ath9k_hw_btcoex_set_weight	drivers/net/wireless/ath/ath9k/ath9k_hw	EXPORT_SYMBOL	
++0xebed52d3	nft_unregister_flowtable_type	net/netfilter/nf_tables	EXPORT_SYMBOL_GPL	
++0x86f6eb00	nf_ct_expect_put	net/netfilter/nf_conntrack	EXPORT_SYMBOL_GPL	
++0x5292293c	md_handle_request	drivers/md/md-mod	EXPORT_SYMBOL	
++0xaad94a9a	v4l2_ctrl_new_custom	drivers/media/v4l2-core/videodev	EXPORT_SYMBOL	
++0xddbbb588	go7007_read_interrupt	drivers/media/usb/go7007/go7007	EXPORT_SYMBOL	
++0x10125405	tda829x_attach	drivers/media/tuners/tda8290	EXPORT_SYMBOL_GPL	
++0x43a6269a	rtl_swlps_beacon	drivers/net/wireless/realtek/rtlwifi/rtlwifi	EXPORT_SYMBOL_GPL	
++0xe0069074	drm_plane_from_index	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0xe5701550	wimax_dev_init	net/wimax/wimax	EXPORT_SYMBOL_GPL	
++0xdd7c3219	synproxy_send_client_synack	net/netfilter/nf_synproxy_core	EXPORT_SYMBOL_GPL	
++0x320726fe	wm_adsp_fw_get	sound/soc/codecs/snd-soc-wm-adsp	EXPORT_SYMBOL_GPL	
++0x76c1918c	unregister_md_personality	drivers/md/md-mod	EXPORT_SYMBOL	
++0x008c02f6	mt76x02_resync_beacon_timer	drivers/net/wireless/mediatek/mt76/mt76x02-lib	EXPORT_SYMBOL_GPL	
++0x152502b9	iscsi_suspend_tx	drivers/scsi/libiscsi	EXPORT_SYMBOL_GPL	
++0x5e95a4b2	o2net_send_message_vec	fs/ocfs2/cluster/ocfs2_nodemanager	EXPORT_SYMBOL_GPL	
++0x1ecd9e39	fuse_conn_get	fs/fuse/fuse	EXPORT_SYMBOL_GPL	
++0x4f7c264c	ip_vs_tcp_conn_listen	net/netfilter/ipvs/ip_vs	EXPORT_SYMBOL	
++0x03dd411a	nf_flow_offload_ipv6_hook	net/netfilter/nf_flow_table	EXPORT_SYMBOL_GPL	
++0x1658a808	snd_rawmidi_set_ops	sound/core/snd-rawmidi	EXPORT_SYMBOL	
++0x1c2744fe	_snd_pcm_stream_lock_irqsave	sound/core/snd-pcm	EXPORT_SYMBOL_GPL	
++0x7ea4c481	fbtft_init_display	drivers/staging/fbtft/fbtft	EXPORT_SYMBOL	
++0x1a0623f7	tap_get_ptr_ring	drivers/net/tap	EXPORT_SYMBOL_GPL	
++0xaf743e40	rtl92c_phy_set_bw_mode	drivers/net/wireless/realtek/rtlwifi/rtl8192c/rtl8192c-common	EXPORT_SYMBOL	
++0x15f55be0	pingv6_prot	net/ipv6/ipv6	EXPORT_SYMBOL_GPL	
++0xb2040134	ipv6_synproxy_hook	net/netfilter/nf_synproxy_core	EXPORT_SYMBOL_GPL	
++0x82e6af51	ipv4_synproxy_hook	net/netfilter/nf_synproxy_core	EXPORT_SYMBOL_GPL	
++0x3546f6dd	nfnl_acct_overquota	net/netfilter/nfnetlink_acct	EXPORT_SYMBOL_GPL	
++0xeca7949e	dm_bufio_client_destroy	drivers/md/dm-bufio	EXPORT_SYMBOL_GPL	
++0x25288fe0	md_bitmap_unplug	drivers/md/md-mod	EXPORT_SYMBOL	
++0xb6754968	v4l2_s_parm_cap	drivers/media/v4l2-core/videodev	EXPORT_SYMBOL_GPL	
++0x02b2b68c	vb2_reqbufs	drivers/media/common/videobuf2/videobuf2-v4l2	EXPORT_SYMBOL_GPL	
++0x098d2ed9	lc_try_get	lib/lru_cache	EXPORT_SYMBOL	
++0xf5d4792a	ieee80211_ready_on_channel	net/mac80211/mac80211	EXPORT_SYMBOL_GPL	
++0x775eae4d	cfg80211_crit_proto_stopped	net/wireless/cfg80211	EXPORT_SYMBOL	
++0x8ec9e1c4	nft_obj_notify	net/netfilter/nf_tables	EXPORT_SYMBOL_GPL	
++0x739bbcfc	nf_nat_amanda_hook	net/netfilter/nf_conntrack_amanda	EXPORT_SYMBOL_GPL	
++0x779c8e39	spk_var_store	drivers/accessibility/speakup/speakup	EXPORT_SYMBOL_GPL	
++0x4c13ac66	ezusb_fx1_set_reset	drivers/usb/misc/ezusb	EXPORT_SYMBOL_GPL	
++0x54824f58	channel5g	drivers/net/wireless/realtek/rtlwifi/rtlwifi	EXPORT_SYMBOL	
++0x8e73818e	rt2x00mac_reconfig_complete	drivers/net/wireless/ralink/rt2x00/rt2x00lib	EXPORT_SYMBOL_GPL	
++0xbfbe53d5	lc_get_cumulative	lib/lru_cache	EXPORT_SYMBOL	
++0xf9c83a5b	v9fs_register_trans	net/9p/9pnet	EXPORT_SYMBOL	
++0x87094751	vb2_create_bufs	drivers/media/common/videobuf2/videobuf2-v4l2	EXPORT_SYMBOL_GPL	
++0xbe358a9a	mt76x02_sta_remove	drivers/net/wireless/mediatek/mt76/mt76x02-lib	EXPORT_SYMBOL_GPL	
++0x59dc4ec8	drm_fb_memcpy	drivers/gpu/drm/drm_kms_helper	EXPORT_SYMBOL	
++0xe06a7072	snd_soc_find_dai_with_mutex	sound/soc/snd-soc-core	EXPORT_SYMBOL_GPL	
++0x8ae60e82	dvb_generic_open	drivers/media/dvb-core/dvb-core	EXPORT_SYMBOL	
++0xe5ceecd6	media_entity_enum_cleanup	drivers/media/mc/mc	EXPORT_SYMBOL_GPL	
++0xfdc3797d	iforce_process_packet	drivers/input/joystick/iforce/iforce	EXPORT_SYMBOL	
++0x765efb12	dvb_free_device	drivers/media/dvb-core/dvb-core	EXPORT_SYMBOL	
++0xa820d718	drm_crtc_accurate_vblank_count	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0x52fe4652	ax25_send_frame	net/ax25/ax25	EXPORT_SYMBOL	
++0xdf76bbeb	iio_pollfunc_store_time	drivers/iio/industrialio	EXPORT_SYMBOL	
++0x7501fe02	mtd_block_markbad	drivers/mtd/mtd	EXPORT_SYMBOL_GPL	
++0xe40b66ef	mt76_wcid_alloc	drivers/net/wireless/mediatek/mt76/mt76	EXPORT_SYMBOL_GPL	
++0xdd963235	snd_timer_stop	sound/core/snd-timer	EXPORT_SYMBOL	
++0x63af2d80	ata_sff_lost_interrupt	drivers/ata/libata	EXPORT_SYMBOL_GPL	
++0x9d13125c	ath9k_hw_stopdmarecv	drivers/net/wireless/ath/ath9k/ath9k_hw	EXPORT_SYMBOL	
++0xb89f60a1	drm_crtc_vblank_reset	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0xaa014736	cfg80211_ready_on_channel	net/wireless/cfg80211	EXPORT_SYMBOL	
++0x524858c2	devm_mux_control_get	drivers/mux/mux-core	EXPORT_SYMBOL_GPL	
++0x9acf62ab	iio_channel_cb_set_buffer_watermark	drivers/iio/buffer/industrialio-buffer-cb	EXPORT_SYMBOL_GPL	
++0x96523c54	dm_bio_prison_alloc_cell	drivers/md/dm-bio-prison	EXPORT_SYMBOL_GPL	
++0xec3d35ac	rt2x00queue_for_each_entry	drivers/net/wireless/ralink/rt2x00/rt2x00lib	EXPORT_SYMBOL_GPL	
++0x227d0afb	drm_gem_prime_import	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0x9983c9e5	drm_helper_encoder_in_use	drivers/gpu/drm/drm_kms_helper	EXPORT_SYMBOL	
++0x10c152d3	ip_tunnel_uninit	net/ipv4/ip_tunnel	EXPORT_SYMBOL_GPL	
++0x4d7bc8e5	ata_sff_wait_after_reset	drivers/ata/libata	EXPORT_SYMBOL_GPL	
++0x87c934be	dm_tm_inc	drivers/md/persistent-data/dm-persistent-data	EXPORT_SYMBOL_GPL	
++0x5dae895b	v4l2_query_ext_ctrl	drivers/media/v4l2-core/videodev	EXPORT_SYMBOL	
++0x2491c8d0	tda18271_attach	drivers/media/tuners/tda18271	EXPORT_SYMBOL_GPL	
++0xc324efb9	drm_edid_to_sad	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0xde53c8df	tpm_try_get_ops	drivers/char/tpm/tpm	EXPORT_SYMBOL_GPL	
++0x3fa9bc07	lib80211_unregister_crypto_ops	net/wireless/lib80211	EXPORT_SYMBOL	
++0xa513cae6	ip6_input	net/ipv6/ipv6	EXPORT_SYMBOL_GPL	
++0x26325836	xt_replace_table	net/netfilter/x_tables	EXPORT_SYMBOL_GPL	
++0xc8c92dac	v4l2_m2m_prepare_buf	drivers/media/v4l2-core/v4l2-mem2mem	EXPORT_SYMBOL_GPL	
++0xfbdd8f58	drm_atomic_get_new_private_obj_state	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0xc8967905	drm_atomic_helper_commit_tail_rpm	drivers/gpu/drm/drm_kms_helper	EXPORT_SYMBOL	
++0xc2fd7ea2	snd_midi_event_encode_byte	sound/core/seq/snd-seq-midi-event	EXPORT_SYMBOL	
++0x8ef35eaa	v4l2_m2m_ioctl_decoder_cmd	drivers/media/v4l2-core/v4l2-mem2mem	EXPORT_SYMBOL_GPL	
++0xbe23989e	vb2_core_querybuf	drivers/media/common/videobuf2/videobuf2-common	EXPORT_SYMBOL_GPL	
++0xdf1ed950	iscsi_host_set_param	drivers/scsi/libiscsi	EXPORT_SYMBOL_GPL	
++0xe1242992	tpm_put_ops	drivers/char/tpm/tpm	EXPORT_SYMBOL_GPL	
++0x50b73ce2	rfkill_find_type	net/rfkill/rfkill	EXPORT_SYMBOL	
++0xc5601a24	__traceiter_vb2_v4l2_qbuf	drivers/media/v4l2-core/videodev	EXPORT_SYMBOL_GPL	
++0x5c3500bc	vb2_plane_cookie	drivers/media/common/videobuf2/videobuf2-common	EXPORT_SYMBOL_GPL	
++0xcaf6f4ee	rtl_get_hwinfo	drivers/net/wireless/realtek/rtlwifi/rtlwifi	EXPORT_SYMBOL_GPL	
++0x0321d428	rt2x00usb_kick_queue	drivers/net/wireless/ralink/rt2x00/rt2x00usb	EXPORT_SYMBOL_GPL	
++0x10c62b61	__drm_printfn_debug	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0xa2f5c65b	drm_dp_get_edid_quirks	drivers/gpu/drm/drm_kms_helper	EXPORT_SYMBOL	
++0x69417b86	vcc_insert_socket	net/atm/atm	EXPORT_SYMBOL	
++0x06e1d724	nft_reject_dump	net/netfilter/nft_reject	EXPORT_SYMBOL_GPL	
++0x38cb64cd	vhost_dev_set_owner	drivers/vhost/vhost	EXPORT_SYMBOL_GPL	
++0xc6696af4	ubi_open_volume_path	drivers/mtd/ubi/ubi	EXPORT_SYMBOL_GPL	
++0x236c178c	ata_scsi_ioctl	drivers/ata/libata	EXPORT_SYMBOL_GPL	
++0x39fe6acc	v4l2_async_notifier_parse_fwnode_sensor_common	drivers/media/v4l2-core/v4l2-fwnode	EXPORT_SYMBOL_GPL	
++0xd9f05a2b	ix2505v_attach	drivers/media/dvb-frontends/ix2505v	EXPORT_SYMBOL	
++0xc6ff9c3b	stv090x_attach	drivers/media/dvb-frontends/stv090x	EXPORT_SYMBOL	
++0x16892d3c	vb2_core_expbuf	drivers/media/common/videobuf2/videobuf2-common	EXPORT_SYMBOL_GPL	
++0x381b63d2	mtd_ooblayout_set_databytes	drivers/mtd/mtd	EXPORT_SYMBOL_GPL	
++0x4f3770b9	mtd_ooblayout_get_databytes	drivers/mtd/mtd	EXPORT_SYMBOL_GPL	
++0x4596bf81	vb2_fop_poll	drivers/media/common/videobuf2/videobuf2-v4l2	EXPORT_SYMBOL_GPL	
++0xef8211ef	fsg_show_cdrom	drivers/usb/gadget/function/usb_f_mass_storage	EXPORT_SYMBOL_GPL	
++0x391d0ce7	rtl_efuse_ops_init	drivers/net/wireless/realtek/rtlwifi/rtlwifi	EXPORT_SYMBOL_GPL	
++0x0794ac1f	drm_gem_cma_vm_ops	drivers/gpu/drm/drm	EXPORT_SYMBOL_GPL	
++0xb4eecee3	drm_i2c_encoder_dpms	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0xf24aee5d	xfrm6_protocol_register	net/ipv6/ipv6	EXPORT_SYMBOL	
++0xf50fecbc	v4l2_ctrl_replace	drivers/media/v4l2-core/videodev	EXPORT_SYMBOL	
++0x15367dbe	mt76x02_tx_status_data	drivers/net/wireless/mediatek/mt76/mt76x02-lib	EXPORT_SYMBOL_GPL	
++0x65e6cf8b	lbs_stop_card	drivers/net/wireless/marvell/libertas/libertas	EXPORT_SYMBOL_GPL	
++0xb3309d93	ip6_pol_route	net/ipv6/ipv6	EXPORT_SYMBOL_GPL	
++0xa47b9048	snd_register_device	sound/core/snd	EXPORT_SYMBOL	
++0x17509b6e	ipvlan_count_rx	drivers/net/ipvlan/ipvlan	EXPORT_SYMBOL_GPL	
++0xf5f76385	ieee80211_nan_func_match	net/mac80211/mac80211	EXPORT_SYMBOL	
++0x40c58fd5	cfg80211_cac_event	net/wireless/cfg80211	EXPORT_SYMBOL	
++0xca94881a	cfg80211_classify8021d	net/wireless/cfg80211	EXPORT_SYMBOL	
++0xa1d11262	ata_do_dev_read_id	drivers/ata/libata	EXPORT_SYMBOL_GPL	
++0x8bf8db4d	v4l2_clk_get	drivers/media/v4l2-core/videodev	EXPORT_SYMBOL	
++0x25c09a91	usb_function_unregister	drivers/usb/gadget/libcomposite	EXPORT_SYMBOL_GPL	
++0x47b78b5f	mt76x2_apply_gain_adj	drivers/net/wireless/mediatek/mt76/mt76x2/mt76x2-common	EXPORT_SYMBOL_GPL	
++0x9fc2c9b1	mt76_rx_aggr_stop	drivers/net/wireless/mediatek/mt76/mt76	EXPORT_SYMBOL_GPL	
++0x0ae047a5	ar9003_mci_send_message	drivers/net/wireless/ath/ath9k/ath9k_hw	EXPORT_SYMBOL	
++0xc6e33d6b	iscsi_conn_stop	drivers/scsi/libiscsi	EXPORT_SYMBOL_GPL	
++0x6b06bc17	__drm_atomic_helper_set_config	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0xeeb1cf25	atm_charge	net/atm/atm	EXPORT_SYMBOL	
++0xae62a3a0	arizona_dvfs_sysclk_ev	sound/soc/codecs/snd-soc-arizona	EXPORT_SYMBOL_GPL	
++0xafb0bf6a	media_request_object_put	drivers/media/mc/mc	EXPORT_SYMBOL_GPL	
++0x8ea60059	rtl_fw_cb	drivers/net/wireless/realtek/rtlwifi/rtlwifi	EXPORT_SYMBOL	
++0x404f03d3	ieee80211_beacon_set_cntdwn	net/mac80211/mac80211	EXPORT_SYMBOL	
++0x0d7f5fcd	xt_alloc_entry_offsets	net/netfilter/x_tables	EXPORT_SYMBOL	
++0x794def64	iio_channel_get	drivers/iio/industrialio	EXPORT_SYMBOL_GPL	
++0xf26b9812	video_device_release_empty	drivers/media/v4l2-core/videodev	EXPORT_SYMBOL	
++0xa11b9899	cdrom_read_tocentry	drivers/cdrom/cdrom	EXPORT_SYMBOL_GPL	
++0xf1e54587	nf_conntrack_lock	net/netfilter/nf_conntrack	EXPORT_SYMBOL_GPL	
++0x7a21c98e	btintel_secure_send	drivers/bluetooth/btintel	EXPORT_SYMBOL_GPL	
++0xb5006f98	dm_cell_release	drivers/md/dm-bio-prison	EXPORT_SYMBOL_GPL	
++0x5a9728cb	_mwifiex_dbg	drivers/net/wireless/marvell/mwifiex/mwifiex	EXPORT_SYMBOL_GPL	
++0xc1f40237	p9_client_walk	net/9p/9pnet	EXPORT_SYMBOL	
++0xef0a9727	iio_device_free	drivers/iio/industrialio	EXPORT_SYMBOL	
++0x5cdf2150	ata_dummy_port_info	drivers/ata/libata	EXPORT_SYMBOL_GPL	
++0x0cdac028	spi_bitbang_start	drivers/spi/spi-bitbang	EXPORT_SYMBOL_GPL	
++0xeb3470f1	drm_kms_helper_poll_enable	drivers/gpu/drm/drm_kms_helper	EXPORT_SYMBOL	
++0x4b732cf7	ieee80211_generic_frame_duration	net/mac80211/mac80211	EXPORT_SYMBOL	
++0x31e99fd5	nf_ct_port_nla_policy	net/netfilter/nf_conntrack	EXPORT_SYMBOL_GPL	
++0xeec415f8	pcm512x_probe	sound/soc/codecs/snd-soc-pcm512x	EXPORT_SYMBOL_GPL	
++0xa5ccddbd	snd_soc_unregister_dai	sound/soc/snd-soc-core	EXPORT_SYMBOL_GPL	
++0x52637dde	fbtft_write_reg8_bus8	drivers/staging/fbtft/fbtft	EXPORT_SYMBOL	
++0x1f23d883	iscsi_conn_start	drivers/scsi/libiscsi	EXPORT_SYMBOL_GPL	
++0xed4ae15e	ecc_make_pub_key	crypto/ecc	EXPORT_SYMBOL	
++0xc4d99852	o2hb_check_node_heartbeating_from_callback	fs/ocfs2/cluster/ocfs2_nodemanager	EXPORT_SYMBOL_GPL	
++0x73f9f144	ubi_leb_unmap	drivers/mtd/ubi/ubi	EXPORT_SYMBOL_GPL	
++0xbae1719f	drm_property_create_bitmask	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0x5ccdf244	addrconf_add_linklocal	net/ipv6/ipv6	EXPORT_SYMBOL_GPL	
++0xb4b61001	snd_soc_unregister_component_by_driver	sound/soc/snd-soc-core	EXPORT_SYMBOL_GPL	
++0x47234afc	spk_synth_is_alive_restart	drivers/accessibility/speakup/speakup	EXPORT_SYMBOL_GPL	
++0xdc77e0e9	rt2800_check_firmware	drivers/net/wireless/ralink/rt2x00/rt2800lib	EXPORT_SYMBOL_GPL	
++0x1f8ac718	__tracepoint_dev_irq	drivers/net/wireless/mediatek/mt76/mt76	EXPORT_SYMBOL_GPL	
++0x13d7a393	nft_data_release	net/netfilter/nf_tables	EXPORT_SYMBOL_GPL	
++0x99215724	bcma_chipco_chipctl_maskset	drivers/bcma/bcma	EXPORT_SYMBOL_GPL	
++0xea01c814	cn_add_callback	drivers/connector/cn	EXPORT_SYMBOL_GPL	
++0xe722e276	ath9k_hw_disable_mib_counters	drivers/net/wireless/ath/ath9k/ath9k_hw	EXPORT_SYMBOL	
++0xf21b8367	mipi_dbi_debugfs_init	drivers/gpu/drm/drm_mipi_dbi	EXPORT_SYMBOL	
++0x521c7102	xchacha20poly1305_decrypt	lib/crypto/libchacha20poly1305	EXPORT_SYMBOL	
++0xce15a526	xchacha20poly1305_encrypt	lib/crypto/libchacha20poly1305	EXPORT_SYMBOL	
++0xeb04fe61	nat_q931_hook	net/netfilter/nf_conntrack_h323	EXPORT_SYMBOL_GPL	
++0x6d629c59	snd_mpu401_uart_interrupt_tx	sound/drivers/mpu401/snd-mpu401-uart	EXPORT_SYMBOL	
++0x93b14ff3	mt76x02_tx_set_txpwr_auto	drivers/net/wireless/mediatek/mt76/mt76x02-lib	EXPORT_SYMBOL_GPL	
++0x3db7e478	mwifiex_del_virtual_intf	drivers/net/wireless/marvell/mwifiex/mwifiex	EXPORT_SYMBOL_GPL	
++0x3f4ab650	mwifiex_main_process	drivers/net/wireless/marvell/mwifiex/mwifiex	EXPORT_SYMBOL_GPL	
++0x64b88947	nf_reject_ip6hdr_put	net/ipv6/netfilter/nf_reject_ipv6	EXPORT_SYMBOL_GPL	
++0x2df878d7	xt_find_table_lock	net/netfilter/x_tables	EXPORT_SYMBOL_GPL	
++0x25e8931a	snd_dmaengine_pcm_trigger	sound/core/snd-pcm-dmaengine	EXPORT_SYMBOL_GPL	
++0x0d814f2d	vhost_has_work	drivers/vhost/vhost	EXPORT_SYMBOL_GPL	
++0x93de9ed9	tea5767_attach	drivers/media/tuners/tea5767	EXPORT_SYMBOL_GPL	
++0xc442f98b	ppp_dev_name	drivers/net/ppp/ppp_generic	EXPORT_SYMBOL	
++0xf1540cfa	lbs_send_tx_feedback	drivers/net/wireless/marvell/libertas/libertas	EXPORT_SYMBOL_GPL	
++0x498a296c	nf_connlabels_put	net/netfilter/nf_conntrack	EXPORT_SYMBOL_GPL	
++0xb1a33362	mtd_ooblayout_free	drivers/mtd/mtd	EXPORT_SYMBOL_GPL	
++0x284e07d8	vsock_bind_table	net/vmw_vsock/vsock	EXPORT_SYMBOL_GPL	
++0xcac68a47	wimax_msg_len	net/wimax/wimax	EXPORT_SYMBOL_GPL	
++0x850d23e7	ip6_frag_init	net/ipv6/ipv6	EXPORT_SYMBOL	
++0xb54e1dcb	snd_soc_of_put_dai_link_codecs	sound/soc/snd-soc-core	EXPORT_SYMBOL_GPL	
++0x4fad45f5	btintel_set_event_mask_mfg	drivers/bluetooth/btintel	EXPORT_SYMBOL_GPL	
++0x83dcbef7	l2tp_session_delete	net/l2tp/l2tp_core	EXPORT_SYMBOL_GPL	
++0x19d079b0	smscore_unregister_device	drivers/media/common/siano/smsmdtv	EXPORT_SYMBOL_GPL	
++0x8563a554	drm_ht_remove	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0xc113c71c	__udp6_lib_lookup	net/ipv6/ipv6	EXPORT_SYMBOL_GPL	
++0x93b3eda7	xt_rateest_put	net/netfilter/xt_RATEEST	EXPORT_SYMBOL_GPL	
++0x7579334f	vhost_iotlb_itree_next	drivers/vhost/vhost_iotlb	EXPORT_SYMBOL_GPL	
++0x6514584d	g_audio_cleanup	drivers/usb/gadget/function/u_audio	EXPORT_SYMBOL_GPL	
++0x91d5b9ee	mt76x02_irq_handler	drivers/net/wireless/mediatek/mt76/mt76x02-lib	EXPORT_SYMBOL_GPL	
++0xb575a884	mwifiex_cancel_hs	drivers/net/wireless/marvell/mwifiex/mwifiex	EXPORT_SYMBOL_GPL	
++0xfab11258	drm_atomic_set_fb_for_plane	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0xfaed7c61	cryptd_shash_desc	crypto/cryptd	EXPORT_SYMBOL_GPL	
++0xefec290a	lc_find	lib/lru_cache	EXPORT_SYMBOL	
++0xcd2da70a	xt_unregister_table	net/netfilter/x_tables	EXPORT_SYMBOL_GPL	
++0x2a82af1c	vhost_poll_stop	drivers/vhost/vhost	EXPORT_SYMBOL_GPL	
++0x0af3d134	v4l2_valid_dv_timings	drivers/media/v4l2-core/v4l2-dv-timings	EXPORT_SYMBOL_GPL	
++0x553c83c3	mb86a16_attach	drivers/media/dvb-frontends/mb86a16	EXPORT_SYMBOL	
++0xac3a006d	iscsi_requeue_task	drivers/scsi/libiscsi	EXPORT_SYMBOL_GPL	
++0x4722e864	drm_handle_vblank	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0x90a546c4	drm_mode_create_dp_colorspace_property	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0x8c704c8f	arizona_free_spk_irqs	sound/soc/codecs/snd-soc-arizona	EXPORT_SYMBOL_GPL	
++0x1d027e4b	snd_pcm_format_signed	sound/core/snd-pcm	EXPORT_SYMBOL	
++0x6e03e2b1	si470x_ctrl_ops	drivers/media/radio/si470x/radio-si470x-common	EXPORT_SYMBOL_GPL	
++0xdda00fc4	hostap_80211_ops	drivers/net/wireless/intersil/hostap/hostap	EXPORT_SYMBOL	
++0x11737553	hostap_info_init	drivers/net/wireless/intersil/hostap/hostap	EXPORT_SYMBOL	
++0xa0713087	drm_ht_find_item	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0x807aab35	flexcop_sram_ctrl	drivers/media/common/b2c2/b2c2-flexcop	EXPORT_SYMBOL	
++0x559de93a	drm_gem_cma_dumb_create_internal	drivers/gpu/drm/drm	EXPORT_SYMBOL_GPL	
++0x60ccaf25	drm_prime_gem_destroy	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0x1943e5ae	drm_i2c_encoder_mode_fixup	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0x7f03b6a9	crc_ccitt_table	lib/crc-ccitt	EXPORT_SYMBOL	
++0x7107f455	nf_nat_icmp_reply_translation	net/netfilter/nf_nat	EXPORT_SYMBOL_GPL	
++0xe965a5a5	ct_sip_get_sdp_header	net/netfilter/nf_conntrack_sip	EXPORT_SYMBOL_GPL	
++0xbed43a41	snd_usbmidi_suspend	sound/usb/snd-usbmidi-lib	EXPORT_SYMBOL	
++0xfe2e157f	roccat_common2_device_init_struct	drivers/hid/hid-roccat-common	EXPORT_SYMBOL_GPL	
++0xf5784b43	spk_ttyio_ops	drivers/accessibility/speakup/speakup	EXPORT_SYMBOL_GPL	
++0x2bf67def	v4l2_calc_aspect_ratio	drivers/media/v4l2-core/v4l2-dv-timings	EXPORT_SYMBOL_GPL	
++0x28b12cc9	v4l2_format_info	drivers/media/v4l2-core/videodev	EXPORT_SYMBOL	
++0xb57b35fa	v4l2_fwnode_put_link	drivers/media/v4l2-core/v4l2-fwnode	EXPORT_SYMBOL_GPL	
++0xc82bf157	drm_debugfs_create_files	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0xb10fc19e	ecc_get_curve	crypto/ecc	EXPORT_SYMBOL	
++0xa339ef51	mtd_block_isreserved	drivers/mtd/mtd	EXPORT_SYMBOL_GPL	
++0x0b25f6bc	dm_array_resize	drivers/md/persistent-data/dm-persistent-data	EXPORT_SYMBOL_GPL	
++0x1248075c	rt2800_link_stats	drivers/net/wireless/ralink/rt2x00/rt2800lib	EXPORT_SYMBOL_GPL	
++0xc6634315	mt76_ac_to_hwq	drivers/net/wireless/mediatek/mt76/mt76	EXPORT_SYMBOL_GPL	
++0x12b2ad06	iscsi_switch_str_param	drivers/scsi/libiscsi	EXPORT_SYMBOL_GPL	
++0x9b2560b9	gf128mul_init_4k_bbe	crypto/gf128mul	EXPORT_SYMBOL	
++0x83581089	gf128mul_init_4k_lle	crypto/gf128mul	EXPORT_SYMBOL	
++0xc69b7ee5	zs_destroy_pool	mm/zsmalloc	EXPORT_SYMBOL_GPL	
++0x1e7b5d8d	vhost_poll_start	drivers/vhost/vhost	EXPORT_SYMBOL_GPL	
++0x6f1fee61	ata_bmdma_error_handler	drivers/ata/libata	EXPORT_SYMBOL_GPL	
++0xf8b2c98a	raid5_set_cache_size	drivers/md/raid456	EXPORT_SYMBOL	
++0x14414460	v4l2_create_fwnode_links	drivers/media/v4l2-core/videodev	EXPORT_SYMBOL_GPL	
++0x0bebf2f4	macvlan_dellink	drivers/net/macvlan	EXPORT_SYMBOL_GPL	
++0xc910db28	usbnet_cdc_status	drivers/net/usb/cdc_ether	EXPORT_SYMBOL_GPL	
++0x5f558b67	mt76x02_set_rts_threshold	drivers/net/wireless/mediatek/mt76/mt76x02-lib	EXPORT_SYMBOL_GPL	
++0xead8aa7a	cfg80211_vendor_cmd_reply	net/wireless/cfg80211	EXPORT_SYMBOL_GPL	
++0x07c27aa8	udp_tunnel6_xmit_skb	net/ipv6/ip6_udp_tunnel	EXPORT_SYMBOL_GPL	
++0xa7b6ac84	ct_sip_parse_request	net/netfilter/nf_conntrack_sip	EXPORT_SYMBOL_GPL	
++0x29b429ba	mtd_lock	drivers/mtd/mtd	EXPORT_SYMBOL_GPL	
++0x0cf741c7	ata_sff_irq_on	drivers/ata/libata	EXPORT_SYMBOL_GPL	
++0x21c66831	flexcop_sram_set_dest	drivers/media/common/b2c2/b2c2-flexcop	EXPORT_SYMBOL	
++0xf5ca45f7	rt2800_txstatus_timeout	drivers/net/wireless/ralink/rt2x00/rt2800lib	EXPORT_SYMBOL_GPL	
++0xa0e25eae	ath9k_hw_phy_disable	drivers/net/wireless/ath/ath9k/ath9k_hw	EXPORT_SYMBOL	
++0xd680a377	drm_gem_object_free	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0x7e3fe205	ip6_dst_lookup_tunnel	net/ipv6/ipv6	EXPORT_SYMBOL_GPL	
++0x5c54e6f5	v4l2_ctrl_request_complete	drivers/media/v4l2-core/videodev	EXPORT_SYMBOL	
++0xb0da4adf	mxl111sf_tuner_attach	drivers/media/usb/dvb-usb-v2/mxl111sf-tuner	EXPORT_SYMBOL_GPL	
++0xdabbe486	usb_function_activate	drivers/usb/gadget/libcomposite	EXPORT_SYMBOL_GPL	
++0x1405cb56	drm_get_edid	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0xb79f25fd	p9_parse_header	net/9p/9pnet	EXPORT_SYMBOL	
++0x71321cad	gre_parse_header	net/ipv4/gre	EXPORT_SYMBOL	
++0xff9c7ecb	cs42xx8_pm	sound/soc/codecs/snd-soc-cs42xx8	EXPORT_SYMBOL_GPL	
++0x9f307b72	usb_role_switch_find_by_fwnode	drivers/usb/roles/roles	EXPORT_SYMBOL_GPL	
++0xfb99f455	ppp_unregister_compressor	drivers/net/ppp/ppp_generic	EXPORT_SYMBOL	
++0xe90575ef	drm_atomic_helper_bridge_reset	drivers/gpu/drm/drm_kms_helper	EXPORT_SYMBOL	
++0xb769d893	lowpan_unregister_netdev	net/6lowpan/6lowpan	EXPORT_SYMBOL	
++0x8594ba36	i2c_bit_add_bus	drivers/i2c/algos/i2c-algo-bit	EXPORT_SYMBOL	
++0xd83330a2	usb_function_deactivate	drivers/usb/gadget/libcomposite	EXPORT_SYMBOL_GPL	
++0xc7a5b4f2	mipi_dbi_command_read	drivers/gpu/drm/drm_mipi_dbi	EXPORT_SYMBOL	
++0x56f32f73	drm_gem_shmem_get_sg_table	drivers/gpu/drm/drm	EXPORT_SYMBOL_GPL	
++0x4eaa95e6	tpm_tis_remove	drivers/char/tpm/tpm_tis_core	EXPORT_SYMBOL_GPL	
++0x88fa3d54	vhost_vring_ioctl	drivers/vhost/vhost	EXPORT_SYMBOL_GPL	
++0xbcc13e95	ata_bmdma_status	drivers/ata/libata	EXPORT_SYMBOL_GPL	
++0xc90df7e5	dm_bufio_prefetch	drivers/md/dm-bufio	EXPORT_SYMBOL_GPL	
++0xaaa90ff4	md_rdev_init	drivers/md/md-mod	EXPORT_SYMBOL_GPL	
++0x7fe439c1	usb_ftdi_elan_edset_single	drivers/usb/misc/ftdi-elan	EXPORT_SYMBOL_GPL	
++0x4399308d	drm_dev_dbg	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0x89aa117f	atrtr_get_dev	net/appletalk/appletalk	EXPORT_SYMBOL	
++0xe5955c24	snd_soc_get_volsw_range	sound/soc/snd-soc-core	EXPORT_SYMBOL_GPL	
++0x3c146338	snd_soc_put_volsw_range	sound/soc/snd-soc-core	EXPORT_SYMBOL_GPL	
++0xf6022949	snd_timer_start	sound/core/snd-timer	EXPORT_SYMBOL	
++0xf7a9bc54	usb_serial_generic_read_bulk_callback	drivers/usb/serial/usbserial	EXPORT_SYMBOL_GPL	
++0xf0d6740e	drm_gem_shmem_create_with_handle	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0x6ef29b6a	l2tp_sk_to_tunnel	net/l2tp/l2tp_core	EXPORT_SYMBOL_GPL	
++0x52c16479	wm_halo_wdt_expire	sound/soc/codecs/snd-soc-wm-adsp	EXPORT_SYMBOL_GPL	
++0x924a7f7e	s5h1409_attach	drivers/media/dvb-frontends/s5h1409	EXPORT_SYMBOL	
++0x66983e96	simd_skcipher_create	crypto/crypto_simd	EXPORT_SYMBOL_GPL	
++0x4562f257	flow_offload_add	net/netfilter/nf_flow_table	EXPORT_SYMBOL_GPL	
++0x0ffd7eaa	vxlan_dev_create	drivers/net/vxlan	EXPORT_SYMBOL_GPL	
++0x45441a21	ath9k_hw_process_rxdesc_edma	drivers/net/wireless/ath/ath9k/ath9k_hw	EXPORT_SYMBOL	
++0x63560fbd	hdlcdrv_receiver	drivers/net/hamradio/hdlcdrv	EXPORT_SYMBOL	
++0x35cd9a6f	nf_ct_get_tuplepr	net/netfilter/nf_conntrack	EXPORT_SYMBOL_GPL	
++0xe50413d7	snd_seq_client_ioctl_lock	sound/core/seq/snd-seq	EXPORT_SYMBOL_GPL	
++0x0691b785	snd_pcm_add_chmap_ctls	sound/core/snd-pcm	EXPORT_SYMBOL_GPL	
++0xb2402c87	snd_pcm_notify	sound/core/snd-pcm	EXPORT_SYMBOL	
++0x0914d550	dm_table_get_mode	drivers/md/dm-mod	EXPORT_SYMBOL	
++0xff709c68	max2165_attach	drivers/media/tuners/max2165	EXPORT_SYMBOL	
++0xba9cb5c5	rt2x00mac_remove_interface	drivers/net/wireless/ralink/rt2x00/rt2x00lib	EXPORT_SYMBOL_GPL	
++0x066013b7	lowpan_register_netdev	net/6lowpan/6lowpan	EXPORT_SYMBOL	
++0xdac4908d	ieee80211_start_tx_ba_cb_irqsafe	net/mac80211/mac80211	EXPORT_SYMBOL	
++0x537ea772	garp_request_join	net/802/garp	EXPORT_SYMBOL_GPL	
++0x84917414	line6_send_sysex_message	sound/usb/line6/snd-usb-line6	EXPORT_SYMBOL_GPL	
++0x0054f69d	dm_tm_pre_commit	drivers/md/persistent-data/dm-persistent-data	EXPORT_SYMBOL_GPL	
++0x72289260	dm_block_manager_destroy	drivers/md/persistent-data/dm-persistent-data	EXPORT_SYMBOL_GPL	
++0xeb738659	ieee80211_sta_block_awake	net/mac80211/mac80211	EXPORT_SYMBOL	
++0x0d205dc6	nf_conntrack_find_get	net/netfilter/nf_conntrack	EXPORT_SYMBOL_GPL	
++0xe29c52f8	snd_rawmidi_transmit_ack	sound/core/snd-rawmidi	EXPORT_SYMBOL	
++0xb73c5cf3	snd_card_disconnect_sync	sound/core/snd	EXPORT_SYMBOL_GPL	
++0xbae3e41f	serio_unregister_child_port	drivers/input/serio/serio	EXPORT_SYMBOL	
++0xf1c0027a	fbtft_remove_common	drivers/staging/fbtft/fbtft	EXPORT_SYMBOL	
++0xb3e3038b	md_write_start	drivers/md/md-mod	EXPORT_SYMBOL	
++0x5b5be42c	dib9000_i2c_enumeration	drivers/media/dvb-frontends/dib9000	EXPORT_SYMBOL	
++0xe525166d	usbip_pack_pdu	drivers/usb/usbip/usbip-core	EXPORT_SYMBOL_GPL	
++0xa87bc9e7	o2nm_configured_node_map	fs/ocfs2/cluster/ocfs2_nodemanager	EXPORT_SYMBOL_GPL	
++0xa10800ca	nf_sk_lookup_slow_v6	net/ipv6/netfilter/nf_socket_ipv6	EXPORT_SYMBOL_GPL	
++0x266fa1a3	nf_sk_lookup_slow_v4	net/ipv4/netfilter/nf_socket_ipv4	EXPORT_SYMBOL_GPL	
++0xee828dbc	snd_dmaengine_pcm_register	sound/soc/snd-soc-core	EXPORT_SYMBOL_GPL	
++0x3cd0cee9	bcma_chipco_gpio_control	drivers/bcma/bcma	EXPORT_SYMBOL_GPL	
++0x587c964b	__lbs_cmd	drivers/net/wireless/marvell/libertas/libertas	EXPORT_SYMBOL_GPL	
++0x98455826	fuse_file_poll	fs/fuse/fuse	EXPORT_SYMBOL_GPL	
++0xe87b0e30	hci_register_cb	net/bluetooth/bluetooth	EXPORT_SYMBOL	
++0xaac8c87b	ahci_fill_cmd_slot	drivers/ata/libahci	EXPORT_SYMBOL_GPL	
++0x8532fc0c	dm_snap_cow	drivers/md/dm-snapshot	EXPORT_SYMBOL	
++0x50e5d7f5	usb_string_ids_tab	drivers/usb/gadget/libcomposite	EXPORT_SYMBOL_GPL	
++0x95b894e9	wimax_state_get	net/wimax/wimax	EXPORT_SYMBOL_GPL	
++0x53728fe7	snd_pcm_fill_iec958_consumer	sound/core/snd-pcm	EXPORT_SYMBOL	
++0x4a7f1352	vhost_dev_init	drivers/vhost/vhost	EXPORT_SYMBOL_GPL	
++0x3bc02aa1	tap_handle_frame	drivers/net/tap	EXPORT_SYMBOL_GPL	
++0xd10e0c49	ath9k_hw_gettsf32	drivers/net/wireless/ath/ath9k/ath9k_hw	EXPORT_SYMBOL	
++0xdc512134	backlight_register_notifier	drivers/video/backlight/backlight	EXPORT_SYMBOL	
++0xfcb86170	asoc_simple_canonicalize_platform	sound/soc/generic/snd-soc-simple-card-utils	EXPORT_SYMBOL_GPL	
++0xc70062ea	vb2_core_queue_init	drivers/media/common/videobuf2/videobuf2-common	EXPORT_SYMBOL_GPL	
++0x52b24e2a	rt2800_config_pairwise_key	drivers/net/wireless/ralink/rt2x00/rt2800lib	EXPORT_SYMBOL_GPL	
++0xeac70af4	ath_key_delete	drivers/net/wireless/ath/ath	EXPORT_SYMBOL	
++0x951dc613	vsock_table_lock	net/vmw_vsock/vsock	EXPORT_SYMBOL_GPL	
++0x07bf1c40	snd_soc_of_parse_tdm_slot	sound/soc/snd-soc-core	EXPORT_SYMBOL_GPL	
++0x99305058	_snd_ctl_add_follower	sound/core/snd	EXPORT_SYMBOL	
++0xccd86806	ata_id_string	drivers/ata/libata	EXPORT_SYMBOL_GPL	
++0x3a797d19	dm_btree_del	drivers/md/persistent-data/dm-persistent-data	EXPORT_SYMBOL_GPL	
++0x046257bf	drm_mode_create_tv_margin_properties	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0x23c1801b	wiphy_register	net/wireless/cfg80211	EXPORT_SYMBOL	
++0x632ac9a7	nft_dump_register	net/netfilter/nf_tables	EXPORT_SYMBOL_GPL	
++0xced24b7e	nf_conncount_cache_free	net/netfilter/nf_conncount	EXPORT_SYMBOL_GPL	
++0x986f2171	videobuf_to_vmalloc	drivers/media/v4l2-core/videobuf-vmalloc	EXPORT_SYMBOL_GPL	
++0xeda04cdb	usb_wwan_chars_in_buffer	drivers/usb/serial/usb_wwan	EXPORT_SYMBOL	
++0x108b188f	ath_is_49ghz_allowed	drivers/net/wireless/ath/ath	EXPORT_SYMBOL	
++0x82227280	lowpan_nhc_add	net/6lowpan/6lowpan	EXPORT_SYMBOL	
++0x14584c91	flow_offload_alloc	net/netfilter/nf_flow_table	EXPORT_SYMBOL_GPL	
++0xb808dff3	mtd_get_unmapped_area	drivers/mtd/mtd	EXPORT_SYMBOL_GPL	
++0x9ad6aa75	dm_start_time_ns_from_clone	drivers/md/dm-mod	EXPORT_SYMBOL_GPL	
++0xcac378ba	v4l2_event_unsubscribe	drivers/media/v4l2-core/videodev	EXPORT_SYMBOL_GPL	
++0x5657097c	iscsi_tcp_set_max_r2t	drivers/scsi/libiscsi_tcp	EXPORT_SYMBOL_GPL	
++0x9174a15d	iscsi_conn_queue_work	drivers/scsi/libiscsi	EXPORT_SYMBOL_GPL	
++0xb070511c	drm_connector_set_vrr_capable_property	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0x0f8434a5	wimax_rfkill	net/wimax/wimax	EXPORT_SYMBOL	
++0x78ffab0e	ieee80211_beacon_get_tim	net/mac80211/mac80211	EXPORT_SYMBOL	
++0x23e74542	ipv6_dup_options	net/ipv6/ipv6	EXPORT_SYMBOL_GPL	
++0xc7a37c73	add_mtd_blktrans_dev	drivers/mtd/mtd_blkdevs	EXPORT_SYMBOL_GPL	
++0xa4ce7826	dvb_generic_ioctl	drivers/media/dvb-core/dvb-core	EXPORT_SYMBOL	
++0xffbef7a1	sys_copyarea	drivers/video/fbdev/core/syscopyarea	EXPORT_SYMBOL	
++0x5250cf98	ieee80211_tkip_add_iv	net/mac80211/mac80211	EXPORT_SYMBOL_GPL	
++0x19e7a652	nf_conntrack_locks	net/netfilter/nf_conntrack	EXPORT_SYMBOL_GPL	
++0xc26320d3	iio_read_channel_offset	drivers/iio/industrialio	EXPORT_SYMBOL_GPL	
++0x5515aebc	ad714x_enable	drivers/input/misc/ad714x	EXPORT_SYMBOL	
++0x2f08e06d	tap_get_socket	drivers/net/tap	EXPORT_SYMBOL_GPL	
++0x0b91b524	ath_hw_setbssidmask	drivers/net/wireless/ath/ath	EXPORT_SYMBOL	
++0x4a402f86	btintel_set_debug_features	drivers/bluetooth/btintel	EXPORT_SYMBOL_GPL	
++0x14771ebd	ata_bmdma_port_start	drivers/ata/libata	EXPORT_SYMBOL_GPL	
++0x9e798e22	dm_bm_set_read_only	drivers/md/persistent-data/dm-persistent-data	EXPORT_SYMBOL_GPL	
++0x29cfbceb	md_bitmap_free	drivers/md/md-mod	EXPORT_SYMBOL	
++0x198bcbd6	md_bitmap_endwrite	drivers/md/md-mod	EXPORT_SYMBOL	
++0x452f53b1	__tracepoint_vb2_v4l2_buf_done	drivers/media/v4l2-core/videodev	EXPORT_SYMBOL_GPL	
++0x4a93f22b	vb2_dqbuf	drivers/media/common/videobuf2/videobuf2-v4l2	EXPORT_SYMBOL_GPL	
++0x6d8fac9a	drm_panel_bridge_remove	drivers/gpu/drm/drm_kms_helper	EXPORT_SYMBOL	
++0xe9af8216	drm_dp_send_power_updown_phy	drivers/gpu/drm/drm_kms_helper	EXPORT_SYMBOL	
++0x81e95439	wpan_phy_free	net/ieee802154/ieee802154	EXPORT_SYMBOL	
++0xc8a1f0e4	__traceiter_dev_irq	drivers/net/wireless/mediatek/mt76/mt76	EXPORT_SYMBOL_GPL	
++0x505ade6e	ath9k_hw_settsf64	drivers/net/wireless/ath/ath9k/ath9k_hw	EXPORT_SYMBOL	
++0xc3b21714	ath9k_hw_gettsf64	drivers/net/wireless/ath/ath9k/ath9k_hw	EXPORT_SYMBOL	
++0xe7b43d5e	fuse_simple_background	fs/fuse/fuse	EXPORT_SYMBOL_GPL	
++0xc4b25e3a	snd_soc_get_dai_name	sound/soc/snd-soc-core	EXPORT_SYMBOL_GPL	
++0x7294c352	snd_soc_set_dmi_name	sound/soc/snd-soc-core	EXPORT_SYMBOL_GPL	
++0xa35f18b6	mtd_table_assert_mutex_locked	drivers/mtd/mtd	EXPORT_SYMBOL_GPL	
++0x918ccb67	au8522_i2c_gate_ctrl	drivers/media/dvb-frontends/au8522_common	EXPORT_SYMBOL	
++0x2505b478	gspca_dev_probe2	drivers/media/usb/gspca/gspca_main	EXPORT_SYMBOL	
++0x9192a401	charlcd_register	drivers/auxdisplay/charlcd	EXPORT_SYMBOL_GPL	
++0x8662fea1	drm_dp_stop_crc	drivers/gpu/drm/drm_kms_helper	EXPORT_SYMBOL	
++0xd7613212	bt_err_ratelimited	net/bluetooth/bluetooth	EXPORT_SYMBOL	
++0x0730ab00	ip_set_put_extensions	net/netfilter/ipset/ip_set	EXPORT_SYMBOL_GPL	
++0xcce9ad4b	ip_set_get_extensions	net/netfilter/ipset/ip_set	EXPORT_SYMBOL_GPL	
++0xfb71ea17	gameport_open	drivers/input/gameport/gameport	EXPORT_SYMBOL	
++0x65f81f74	vb2_ioctl_expbuf	drivers/media/common/videobuf2/videobuf2-v4l2	EXPORT_SYMBOL_GPL	
++0x58c19a36	cfg80211_cqm_rssi_notify	net/wireless/cfg80211	EXPORT_SYMBOL	
++0x6c54df5f	videobuf_read_start	drivers/media/v4l2-core/videobuf-core	EXPORT_SYMBOL_GPL	
++0x1dfcfb32	smscore_register_hotplug	drivers/media/common/siano/smsmdtv	EXPORT_SYMBOL_GPL	
++0xd8905b95	drm_fb_helper_unregister_fbi	drivers/gpu/drm/drm_kms_helper	EXPORT_SYMBOL	
++0xf1a5611d	o2net_unregister_handler_list	fs/ocfs2/cluster/ocfs2_nodemanager	EXPORT_SYMBOL_GPL	
++0xad91e6ab	ip6_err_gen_icmpv6_unreach	net/ipv6/ipv6	EXPORT_SYMBOL	
++0x54a35032	alloc_can_skb	drivers/net/can/dev/can-dev	EXPORT_SYMBOL_GPL	
++0x29b89ac8	ath9k_hw_init_global_settings	drivers/net/wireless/ath/ath9k/ath9k_hw	EXPORT_SYMBOL	
++0x33a08525	drm_sched_increase_karma	drivers/gpu/drm/scheduler/gpu-sched	EXPORT_SYMBOL	
++0x23f9e147	wiphy_rfkill_set_hw_state	net/wireless/cfg80211	EXPORT_SYMBOL	
++0x2768284d	wm_adsp_read_ctl	sound/soc/codecs/snd-soc-wm-adsp	EXPORT_SYMBOL_GPL	
++0x729a5ef3	arizona_mixer_values	sound/soc/codecs/snd-soc-arizona	EXPORT_SYMBOL_GPL	
++0x98a265da	can_rx_offload_del	drivers/net/can/dev/can-dev	EXPORT_SYMBOL_GPL	
++0xe22a39fa	mt76x02_set_tx_ackto	drivers/net/wireless/mediatek/mt76/mt76x02-lib	EXPORT_SYMBOL_GPL	
++0xee53a738	drm_writeback_connector_init	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0xd090e1dc	ieee80211_beacon_get_template	net/mac80211/mac80211	EXPORT_SYMBOL	
++0x1757d1a4	fou_encap_hlen	net/ipv4/fou	EXPORT_SYMBOL	
++0x4e68cfe1	dvb_usbv2_generic_write_locked	drivers/media/usb/dvb-usb-v2/dvb_usb_v2	EXPORT_SYMBOL	
++0x040dc7cd	tpg_aspect_strings	drivers/media/common/v4l2-tpg/v4l2-tpg	EXPORT_SYMBOL_GPL	
++0x78adfcc5	mt76_register_debugfs	drivers/net/wireless/mediatek/mt76/mt76	EXPORT_SYMBOL_GPL	
++0xb881b1a9	ath6kl_printk	drivers/net/wireless/ath/ath6kl/ath6kl_core	EXPORT_SYMBOL	
++0xe88babd8	drm_sched_fini	drivers/gpu/drm/scheduler/gpu-sched	EXPORT_SYMBOL	
++0xadbefda4	dm_cache_policy_destroy	drivers/md/dm-cache	EXPORT_SYMBOL_GPL	
++0x3a18389a	dm_rh_update_states	drivers/md/dm-region-hash	EXPORT_SYMBOL_GPL	
++0xed3283a4	dm_bufio_set_sector_offset	drivers/md/dm-bufio	EXPORT_SYMBOL_GPL	
++0x8864d46a	_vb2_fop_release	drivers/media/common/videobuf2/videobuf2-v4l2	EXPORT_SYMBOL_GPL	
++0x56466e42	ZSTD_CStreamInSize	lib/zstd/zstd_compress	EXPORT_SYMBOL	
++0x71ec8642	arizona_out_vi_ramp	sound/soc/codecs/snd-soc-arizona	EXPORT_SYMBOL_GPL	
++0x103be782	arizona_out_vd_ramp	sound/soc/codecs/snd-soc-arizona	EXPORT_SYMBOL_GPL	
++0xd0993dd7	v4l2_m2m_buf_queue	drivers/media/v4l2-core/v4l2-mem2mem	EXPORT_SYMBOL_GPL	
++0x1952a007	mt76_tx_status_skb_done	drivers/net/wireless/mediatek/mt76/mt76	EXPORT_SYMBOL_GPL	
++0x1bb9ab77	mt76_rx	drivers/net/wireless/mediatek/mt76/mt76	EXPORT_SYMBOL_GPL	
++0xd1e35b23	ipt_unregister_table	net/ipv4/netfilter/ip_tables	EXPORT_SYMBOL	
++0xadb51cff	snd_seq_client_ioctl_unlock	sound/core/seq/snd-seq	EXPORT_SYMBOL_GPL	
++0x80f5568c	vb2_buffer_done	drivers/media/common/videobuf2/videobuf2-common	EXPORT_SYMBOL_GPL	
++0xd1ee02ab	usb_wwan_write	drivers/usb/serial/usb_wwan	EXPORT_SYMBOL	
++0x0397c88e	rt2x00mac_conf_tx	drivers/net/wireless/ralink/rt2x00/rt2x00lib	EXPORT_SYMBOL_GPL	
++0xf3542bb2	ath9k_hw_getchan_noise	drivers/net/wireless/ath/ath9k/ath9k_hw	EXPORT_SYMBOL	
++0xb441b3b6	p9_client_getlock_dotl	net/9p/9pnet	EXPORT_SYMBOL	
++0x48012e28	xt_check_proc_name	net/netfilter/x_tables	EXPORT_SYMBOL	
++0xf2a02321	xt_unregister_target	net/netfilter/x_tables	EXPORT_SYMBOL	
++0xad111707	vhost_iotlb_map_free	drivers/vhost/vhost_iotlb	EXPORT_SYMBOL_GPL	
++0x90e0a5db	flexcop_device_kfree	drivers/media/common/b2c2/b2c2-flexcop	EXPORT_SYMBOL	
++0xa91c8165	i2c_mux_add_adapter	drivers/i2c/i2c-mux	EXPORT_SYMBOL_GPL	
++0x241ee6db	hostap_add_interface	drivers/net/wireless/intersil/hostap/hostap	EXPORT_SYMBOL	
++0x4bd9918c	ieee80211_start_tx_ba_session	net/mac80211/mac80211	EXPORT_SYMBOL	
++0xee02e420	ax25_findbyuid	net/ax25/ax25	EXPORT_SYMBOL	
++0x89217d31	v4l2_fh_is_singular	drivers/media/v4l2-core/videodev	EXPORT_SYMBOL_GPL	
++0xb7176ab4	mt76x0_register_device	drivers/net/wireless/mediatek/mt76/mt76x0/mt76x0-common	EXPORT_SYMBOL_GPL	
++0x668a7fea	ct_sip_parse_address_param	net/netfilter/nf_conntrack_sip	EXPORT_SYMBOL_GPL	
++0x49b465a1	nf_conntrack_unregister_notifier	net/netfilter/nf_conntrack	EXPORT_SYMBOL_GPL	
++0xce62661e	nf_conntrack_helpers_unregister	net/netfilter/nf_conntrack	EXPORT_SYMBOL_GPL	
++0xe5897f19	asoc_simple_clean_reference	sound/soc/generic/snd-soc-simple-card-utils	EXPORT_SYMBOL_GPL	
++0xa019b03a	snd_soc_jack_add_gpiods	sound/soc/snd-soc-core	EXPORT_SYMBOL_GPL	
++0x9850e632	ssb_pcicore_dev_irqvecs_enable	drivers/ssb/ssb	EXPORT_SYMBOL	
++0x6aebce95	dm_bufio_issue_discard	drivers/md/dm-bufio	EXPORT_SYMBOL_GPL	
++0x840934ea	cx231xx_capture_start	drivers/media/usb/cx231xx/cx231xx	EXPORT_SYMBOL_GPL	
++0x683ad1a2	rndis_rx_fixup	drivers/net/usb/rndis_host	EXPORT_SYMBOL_GPL	
++0x611cbffe	mt76x02_set_ethtool_fwver	drivers/net/wireless/mediatek/mt76/mt76x02-lib	EXPORT_SYMBOL_GPL	
++0xf0ba2821	ad193x_regmap_config	sound/soc/codecs/snd-soc-ad193x	EXPORT_SYMBOL_GPL	
++0x6d3f57bd	dm_bufio_get_client	drivers/md/dm-bufio	EXPORT_SYMBOL_GPL	
++0x19722a6c	md_bitmap_copy_from_slot	drivers/md/md-mod	EXPORT_SYMBOL_GPL	
++0x45284ae9	smsendian_handle_rx_message	drivers/media/common/siano/smsmdtv	EXPORT_SYMBOL_GPL	
++0x37d91069	smsendian_handle_tx_message	drivers/media/common/siano/smsmdtv	EXPORT_SYMBOL_GPL	
++0x9dadf7c5	drm_dp_check_act_status	drivers/gpu/drm/drm_kms_helper	EXPORT_SYMBOL	
++0x4a833012	poly1305_final_generic	lib/crypto/libpoly1305	EXPORT_SYMBOL_GPL	
++0xbabd30f5	virtio_transport_dgram_allow	net/vmw_vsock/vmw_vsock_virtio_transport_common	EXPORT_SYMBOL_GPL	
++0xec7d8ff2	virtio_transport_notify_poll_in	net/vmw_vsock/vmw_vsock_virtio_transport_common	EXPORT_SYMBOL_GPL	
++0x75e6cc3d	iscsi_conn_get_param	drivers/scsi/libiscsi	EXPORT_SYMBOL_GPL	
++0x28a92820	snd_dmaengine_pcm_close	sound/core/snd-pcm-dmaengine	EXPORT_SYMBOL_GPL	
++0x743a165e	ata_pack_xfermask	drivers/ata/libata	EXPORT_SYMBOL_GPL	
++0xf8ed974f	dm_table_event	drivers/md/dm-mod	EXPORT_SYMBOL	
++0xe5cc45e6	ath9k_hw_abort_tx_dma	drivers/net/wireless/ath/ath9k/ath9k_hw	EXPORT_SYMBOL	
++0x61cff707	ip_vs_conn_new	net/netfilter/ipvs/ip_vs	EXPORT_SYMBOL	
++0x7ac2f329	snd_seq_expand_var_event	sound/core/seq/snd-seq	EXPORT_SYMBOL	
++0xdd4e8869	dm_region_hash_create	drivers/md/dm-region-hash	EXPORT_SYMBOL_GPL	
++0x57e9167f	mwifiex_process_sleep_confirm_resp	drivers/net/wireless/marvell/mwifiex/mwifiex	EXPORT_SYMBOL_GPL	
++0x5c5a24c8	drm_panel_disable	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0xe0eb0e92	drm_connector_attach_encoder	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0xd4671463	xor_block_inner_neon	arch/arm64/lib/xor-neon	EXPORT_SYMBOL	
++0x1ed4ad12	virtio_transport_notify_recv_pre_block	net/vmw_vsock/vmw_vsock_virtio_transport_common	EXPORT_SYMBOL_GPL	
++0x5c172eae	nfc_fw_download_done	net/nfc/nfc	EXPORT_SYMBOL	
++0x2db95610	nf_ct_expect_iterate_net	net/netfilter/nf_conntrack	EXPORT_SYMBOL_GPL	
++0x7c5a5ba8	cdrom_number_of_slots	drivers/cdrom/cdrom	EXPORT_SYMBOL	
++0x9fdb449e	efuse_one_byte_read	drivers/net/wireless/realtek/rtlwifi/rtlwifi	EXPORT_SYMBOL	
++0x9b285573	drm_match_cea_mode	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0x1cf7c965	drm_atomic_helper_disable_all	drivers/gpu/drm/drm_kms_helper	EXPORT_SYMBOL	
++0x9e98722b	ip_set_get_ipaddr6	net/netfilter/ipset/ip_set	EXPORT_SYMBOL_GPL	
++0xa293f8a6	ip_set_get_ipaddr4	net/netfilter/ipset/ip_set	EXPORT_SYMBOL_GPL	
++0xc7c9a745	arizona_clk_ev	sound/soc/codecs/snd-soc-arizona	EXPORT_SYMBOL_GPL	
++0xf8be1988	iio_get_channel_type	drivers/iio/industrialio	EXPORT_SYMBOL_GPL	
++0x3783e2d6	ata_ehi_clear_desc	drivers/ata/libata	EXPORT_SYMBOL_GPL	
++0x10053b99	dm_table_set_type	drivers/md/dm-mod	EXPORT_SYMBOL_GPL	
++0xbee1b44e	drm_bridge_chain_pre_enable	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0x5f8dc9fd	drm_vma_node_revoke	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0x3367b274	drm_atomic_helper_damage_iter_init	drivers/gpu/drm/drm_kms_helper	EXPORT_SYMBOL	
++0x894b1f57	drm_dp_get_adjust_request_post_cursor	drivers/gpu/drm/drm_kms_helper	EXPORT_SYMBOL	
++0xcf1820d9	ata_wait_register	drivers/ata/libata	EXPORT_SYMBOL_GPL	
++0x3eb89186	dm_cell_put_v2	drivers/md/dm-bio-prison	EXPORT_SYMBOL_GPL	
++0x73a2cb26	dm_cell_get_v2	drivers/md/dm-bio-prison	EXPORT_SYMBOL_GPL	
++0xfaab83b1	__video_register_device	drivers/media/v4l2-core/videodev	EXPORT_SYMBOL	
++0xf72ad5c9	sms_board_setup	drivers/media/common/siano/smsmdtv	EXPORT_SYMBOL_GPL	
++0xe788ce37	p54_parse_eeprom	drivers/net/wireless/intersil/p54/p54common	EXPORT_SYMBOL_GPL	
++0x216be43c	drm_mode_validate_ycbcr420	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0x3067c043	drm_ioctl_kernel	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0xfe12bcb9	drm_dsc_compute_rc_parameters	drivers/gpu/drm/drm_kms_helper	EXPORT_SYMBOL	
++0x6a059186	ieee80211_tx_rate_update	net/mac80211/mac80211	EXPORT_SYMBOL	
++0x8fa02936	cfg80211_free_nan_func	net/wireless/cfg80211	EXPORT_SYMBOL	
++0x5160cd43	nf_tproxy_get_sock_v4	net/ipv4/netfilter/nf_tproxy_ipv4	EXPORT_SYMBOL_GPL	
++0xe2b8cc13	nft_parse_register_load	net/netfilter/nf_tables	EXPORT_SYMBOL_GPL	
++0x02a30669	iio_buffer_put	drivers/iio/industrialio	EXPORT_SYMBOL_GPL	
++0xdf9ba1a2	mtd_pairing_groups	drivers/mtd/mtd	EXPORT_SYMBOL_GPL	
++0x011dcff0	md_stop_writes	drivers/md/md-mod	EXPORT_SYMBOL_GPL	
++0x41f7ee17	vb2_write	drivers/media/common/videobuf2/videobuf2-common	EXPORT_SYMBOL_GPL	
++0x517e7ccd	tpg_fill_plane_buffer	drivers/media/common/v4l2-tpg/v4l2-tpg	EXPORT_SYMBOL_GPL	
++0xb40fae23	tpg_g_color_order	drivers/media/common/v4l2-tpg/v4l2-tpg	EXPORT_SYMBOL_GPL	
++0x3a7694e1	rt2x00usb_clear_entry	drivers/net/wireless/ralink/rt2x00/rt2x00usb	EXPORT_SYMBOL_GPL	
++0xf20bfa42	drm_crtc_check_viewport	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0x784521dc	cfg80211_roamed	net/wireless/cfg80211	EXPORT_SYMBOL	
++0x82afa49e	snd_mpu401_uart_new	sound/drivers/mpu401/snd-mpu401-uart	EXPORT_SYMBOL	
++0x0bea4822	ssb_bus_may_powerdown	drivers/ssb/ssb	EXPORT_SYMBOL	
++0x4bc3817d	ata_sff_data_xfer	drivers/ata/libata	EXPORT_SYMBOL_GPL	
++0xbe38a431	dm_rh_recovery_prepare	drivers/md/dm-region-hash	EXPORT_SYMBOL_GPL	
++0x336c0189	cx231xx_register_extension	drivers/media/usb/cx231xx/cx231xx	EXPORT_SYMBOL	
++0x8d303b1b	iscsi_pool_free	drivers/scsi/libiscsi	EXPORT_SYMBOL_GPL	
++0x08bba0c3	ieee802154_register_hw	net/mac802154/mac802154	EXPORT_SYMBOL	
++0x660aca67	nft_set_lookup_global	net/netfilter/nf_tables	EXPORT_SYMBOL_GPL	
++0x5f287bdd	line6_read_data	sound/usb/line6/snd-usb-line6	EXPORT_SYMBOL_GPL	
++0x43f8ff3c	md_new_event	drivers/md/md-mod	EXPORT_SYMBOL_GPL	
++0x662f286b	videobuf_queue_to_vaddr	drivers/media/v4l2-core/videobuf-core	EXPORT_SYMBOL_GPL	
++0x1cd1e10e	v4l2_subdev_free_pad_config	drivers/media/v4l2-core/videodev	EXPORT_SYMBOL_GPL	
++0xa2fb1011	__devm_regmap_init_spi	drivers/base/regmap/regmap-spi	EXPORT_SYMBOL_GPL	
++0x7749031c	cfg80211_check_station_change	net/wireless/cfg80211	EXPORT_SYMBOL	
++0x250ae879	cx231xx_init_vbi_isoc	drivers/media/usb/cx231xx/cx231xx	EXPORT_SYMBOL_GPL	
++0x8d932cb4	mt76u_stop_tx	drivers/net/wireless/mediatek/mt76/mt76-usb	EXPORT_SYMBOL_GPL	
++0xafed67a1	ieee80211_cqm_rssi_notify	net/mac80211/mac80211	EXPORT_SYMBOL	
++0xe70bc699	cfg80211_assoc_timeout	net/wireless/cfg80211	EXPORT_SYMBOL	
++0x7872f9c6	btintel_regmap_init	drivers/bluetooth/btintel	EXPORT_SYMBOL_GPL	
++0x03de1c2f	ath_hw_get_listen_time	drivers/net/wireless/ath/ath	EXPORT_SYMBOL	
++0x740410fd	iscsi_session_teardown	drivers/scsi/libiscsi	EXPORT_SYMBOL_GPL	
++0x9c70ed9d	drm_bridge_chain_enable	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0x27c1ed3f	nft_set_elem_destroy	net/netfilter/nf_tables	EXPORT_SYMBOL_GPL	
++0x4f476eaf	snd_card_register	sound/core/snd	EXPORT_SYMBOL	
++0x07b086ef	fuse_fill_super_common	fs/fuse/fuse	EXPORT_SYMBOL_GPL	
++0x3f83524b	fuse_dev_alloc	fs/fuse/fuse	EXPORT_SYMBOL_GPL	
++0x326552d4	vsock_deliver_tap	net/vmw_vsock/vsock	EXPORT_SYMBOL_GPL	
++0xb1a3f207	ovs_vport_ops_unregister	net/openvswitch/openvswitch	EXPORT_SYMBOL_GPL	
++0x7fd901bc	nf_send_unreach	net/ipv4/netfilter/nf_reject_ipv4	EXPORT_SYMBOL_GPL	
++0xf44c24f6	nf_nat_irc_hook	net/netfilter/nf_conntrack_irc	EXPORT_SYMBOL_GPL	
++0x0c683df6	nf_nat_ftp_hook	net/netfilter/nf_conntrack_ftp	EXPORT_SYMBOL_GPL	
++0x716687e2	nf_ct_ext_add	net/netfilter/nf_conntrack	EXPORT_SYMBOL	
++0x52f61378	snd_soc_dapm_new_controls	sound/soc/snd-soc-core	EXPORT_SYMBOL_GPL	
++0xc577832d	vhost_iotlb_alloc	drivers/vhost/vhost_iotlb	EXPORT_SYMBOL_GPL	
++0x46f4a601	mddev_resume	drivers/md/md-mod	EXPORT_SYMBOL_GPL	
++0x808312ed	config_ep_by_speed_and_alt	drivers/usb/gadget/libcomposite	EXPORT_SYMBOL_GPL	
++0x7f10d763	rt2x00usb_probe	drivers/net/wireless/ralink/rt2x00/rt2x00usb	EXPORT_SYMBOL_GPL	
++0x3661111e	p54_register_common	drivers/net/wireless/intersil/p54/p54common	EXPORT_SYMBOL_GPL	
++0x1e4547a9	ar9003_mci_get_interrupt	drivers/net/wireless/ath/ath9k/ath9k_hw	EXPORT_SYMBOL	
++0xf57000c5	i2400m_is_boot_barker	drivers/net/wimax/i2400m/i2400m	EXPORT_SYMBOL_GPL	
++0x700c6601	mt76x2_init_txpower	drivers/net/wireless/mediatek/mt76/mt76x2/mt76x2-common	EXPORT_SYMBOL_GPL	
++0xefc8d68f	lbs_get_firmware	drivers/net/wireless/marvell/libertas/libertas	EXPORT_SYMBOL_GPL	
++0xd7da985c	ath9k_cmn_get_channel	drivers/net/wireless/ath/ath9k/ath9k_common	EXPORT_SYMBOL	
++0x47f985aa	drm_edid_duplicate	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0x25daad93	__drm_mm_interval_first	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0xc71a6bdc	__drm_atomic_helper_bridge_duplicate_state	drivers/gpu/drm/drm_kms_helper	EXPORT_SYMBOL	
++0xf65c8f02	vsock_find_bound_socket	net/vmw_vsock/vsock	EXPORT_SYMBOL_GPL	
++0xc0f04679	ata_std_sched_eh	drivers/ata/libata	EXPORT_SYMBOL_GPL	
++0x99510f1e	rt2x00queue_map_txskb	drivers/net/wireless/ralink/rt2x00/rt2x00lib	EXPORT_SYMBOL_GPL	
++0x959b9153	drm_fb_helper_lastclose	drivers/gpu/drm/drm_kms_helper	EXPORT_SYMBOL	
++0x7efb9b13	__cfg80211_send_event_skb	net/wireless/cfg80211	EXPORT_SYMBOL	
++0x6449fdfd	nf_log_dump_vlan	net/netfilter/nf_log_common	EXPORT_SYMBOL_GPL	
++0x08d04fd8	fbtft_write_gpio8_wr	drivers/staging/fbtft/fbtft	EXPORT_SYMBOL	
++0x54f42644	register_cdrom	drivers/cdrom/cdrom	EXPORT_SYMBOL	
++0x30b6b8cc	drm_hdmi_avi_infoframe_content_type	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0x2d83fa1e	of_get_drm_display_mode	drivers/gpu/drm/drm	EXPORT_SYMBOL_GPL	
++0x44815580	nf_ct_deliver_cached_events	net/netfilter/nf_conntrack	EXPORT_SYMBOL_GPL	
++0xc3964108	mtd_unlock	drivers/mtd/mtd	EXPORT_SYMBOL_GPL	
++0xa2ea5542	dm_bitset_del	drivers/md/persistent-data/dm-persistent-data	EXPORT_SYMBOL_GPL	
++0xff585440	v4l2_dv_timings_aspect_ratio	drivers/media/v4l2-core/v4l2-dv-timings	EXPORT_SYMBOL_GPL	
++0xdb6ed696	usb_composite_unregister	drivers/usb/gadget/libcomposite	EXPORT_SYMBOL_GPL	
++0x0f779593	fsg_show_inquiry_string	drivers/usb/gadget/function/usb_f_mass_storage	EXPORT_SYMBOL_GPL	
++0x12e7d0cb	rt2800_enable_radio	drivers/net/wireless/ralink/rt2x00/rt2800lib	EXPORT_SYMBOL_GPL	
++0xb92aea50	drm_file_get_master	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0x7c32ec15	ieee802154_hdr_peek	net/ieee802154/ieee802154	EXPORT_SYMBOL_GPL	
++0x9ba44884	ieee802154_hdr_pull	net/ieee802154/ieee802154	EXPORT_SYMBOL_GPL	
++0x9491f858	ieee802154_hdr_push	net/ieee802154/ieee802154	EXPORT_SYMBOL_GPL	
++0x26f6b499	iio_str_to_fixpoint	drivers/iio/industrialio	EXPORT_SYMBOL_GPL	
++0xbb461fb7	dm_bitset_cursor_begin	drivers/md/persistent-data/dm-persistent-data	EXPORT_SYMBOL_GPL	
++0x69058922	dvb_ringbuffer_empty	drivers/media/dvb-core/dvb-core	EXPORT_SYMBOL	
++0x8ead4bf0	xfrm6_rcv_spi	net/ipv6/ipv6	EXPORT_SYMBOL	
++0xcfb2c020	ip_tunnel_change_mtu	net/ipv4/ip_tunnel	EXPORT_SYMBOL_GPL	
++0x9529d482	snd_pcm_release_substream	sound/core/snd-pcm	EXPORT_SYMBOL	
++0x8ae64176	ipvlan_link_register	drivers/net/ipvlan/ipvlan	EXPORT_SYMBOL_GPL	
++0xf1052ddf	mt76_csa_check	drivers/net/wireless/mediatek/mt76/mt76	EXPORT_SYMBOL_GPL	
++0xca0ca0bf	drm_dp_mst_get_port_malloc	drivers/gpu/drm/drm_kms_helper	EXPORT_SYMBOL	
++0x548ffece	tcpv6_prot	net/ipv6/ipv6	EXPORT_SYMBOL_GPL	
++0xb8f5f1cc	snd_soc_bytes_put	sound/soc/snd-soc-core	EXPORT_SYMBOL_GPL	
++0x53f8c248	btbcm_set_bdaddr	drivers/bluetooth/btbcm	EXPORT_SYMBOL_GPL	
++0x97d0513a	ata_sas_slave_configure	drivers/ata/libata	EXPORT_SYMBOL_GPL	
++0x5704afa6	ata_qc_complete	drivers/ata/libata	EXPORT_SYMBOL_GPL	
++0x1b932697	dm_dirty_log_destroy	drivers/md/dm-log	EXPORT_SYMBOL	
++0xe0b552d6	dib9000_fw_pid_filter_ctrl	drivers/media/dvb-frontends/dib9000	EXPORT_SYMBOL	
++0x218f6591	drm_client_framebuffer_delete	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0xa6fbad13	wiphy_free	net/wireless/cfg80211	EXPORT_SYMBOL	
++0x1c534895	nft_reject_policy	net/netfilter/nft_reject	EXPORT_SYMBOL_GPL	
++0xad2c32e3	snd_ctl_new1	sound/core/snd	EXPORT_SYMBOL	
++0x7774620f	dm_rh_stop_recovery	drivers/md/dm-region-hash	EXPORT_SYMBOL_GPL	
++0x5576c845	dvb_ca_en50221_init	drivers/media/dvb-core/dvb-core	EXPORT_SYMBOL	
++0x9d3ee666	media_device_cleanup	drivers/media/mc/mc	EXPORT_SYMBOL_GPL	
++0xb757ca6d	rt2800_process_rxwi	drivers/net/wireless/ralink/rt2x00/rt2800lib	EXPORT_SYMBOL_GPL	
++0x3386bf54	devm_drm_panel_bridge_add	drivers/gpu/drm/drm_kms_helper	EXPORT_SYMBOL	
++0x7920f06d	nft_fib6_eval_type	net/ipv6/netfilter/nft_fib_ipv6	EXPORT_SYMBOL_GPL	
++0xed8c002a	nft_fib4_eval_type	net/ipv4/netfilter/nft_fib_ipv4	EXPORT_SYMBOL_GPL	
++0xed61d4dc	usb_wwan_tiocmset	drivers/usb/serial/usb_wwan	EXPORT_SYMBOL	
++0xc7421ba4	usb_wwan_tiocmget	drivers/usb/serial/usb_wwan	EXPORT_SYMBOL	
++0x9ede71be	tap_free_minor	drivers/net/tap	EXPORT_SYMBOL_GPL	
++0xbf925601	iscsi_eh_device_reset	drivers/scsi/libiscsi	EXPORT_SYMBOL_GPL	
++0xa930eafc	__drm_atomic_helper_bridge_reset	drivers/gpu/drm/drm_kms_helper	EXPORT_SYMBOL	
++0x3aee8b88	drm_dp_vsc_sdp_log	drivers/gpu/drm/drm_kms_helper	EXPORT_SYMBOL	
++0x0584e5a7	backlight_device_get_by_name	drivers/video/backlight/backlight	EXPORT_SYMBOL	
++0xc8e3332b	raid6_gflog	lib/raid6/raid6_pq	EXPORT_SYMBOL	
++0xa909cfc5	vhost_work_init	drivers/vhost/vhost	EXPORT_SYMBOL_GPL	
++0xbacc9624	__traceiter_vb2_qbuf	drivers/media/common/videobuf2/videobuf2-common	EXPORT_SYMBOL_GPL	
++0x3c62a91d	ieee80211_vif_to_wdev	net/mac80211/mac80211	EXPORT_SYMBOL_GPL	
++0x151d685c	wm_adsp_event	sound/soc/codecs/snd-soc-wm-adsp	EXPORT_SYMBOL_GPL	
++0x742f140d	snd_soc_dpcm_get_substream	sound/soc/snd-soc-core	EXPORT_SYMBOL_GPL	
++0xf57e8289	vhost_chr_write_iter	drivers/vhost/vhost	EXPORT_SYMBOL	
++0xc6d30556	md_reap_sync_thread	drivers/md/md-mod	EXPORT_SYMBOL	
++0xa17c0ccf	brcmu_dotrev_str	drivers/net/wireless/broadcom/brcm80211/brcmutil/brcmutil	EXPORT_SYMBOL	
++0xfcf56804	drm_atomic_get_old_private_obj_state	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0xda6e2b12	snd_soc_jack_notifier_unregister	sound/soc/snd-soc-core	EXPORT_SYMBOL_GPL	
++0xcdd2a9cd	ms_sensors_show_heater	drivers/iio/common/ms_sensors/ms_sensors_i2c	EXPORT_SYMBOL	
++0x8cacfd32	btmrvl_add_card	drivers/bluetooth/btmrvl	EXPORT_SYMBOL_GPL	
++0x76c5f2b2	ubi_leb_read	drivers/mtd/ubi/ubi	EXPORT_SYMBOL_GPL	
++0x24f63dcf	ata_xfer_mask2mode	drivers/ata/libata	EXPORT_SYMBOL_GPL	
++0xd7866b29	cec_delete_adapter	drivers/media/cec/core/cec	EXPORT_SYMBOL_GPL	
++0x4c892698	dib3000mc_pid_control	drivers/media/dvb-frontends/dib3000mc	EXPORT_SYMBOL	
++0x07043fce	drm_sched_pick_best	drivers/gpu/drm/scheduler/gpu-sched	EXPORT_SYMBOL	
++0xa4c8127c	ZSTD_maxCLevel	lib/zstd/zstd_compress	EXPORT_SYMBOL	
++0x0a5a9ef2	ieee802154_alloc_hw	net/mac802154/mac802154	EXPORT_SYMBOL	
++0x063f5308	ieee80211_get_tkip_p1k_iv	net/mac80211/mac80211	EXPORT_SYMBOL	
++0x58add6af	pcm512x_remove	sound/soc/codecs/snd-soc-pcm512x	EXPORT_SYMBOL_GPL	
++0xce9b8dd1	fbtft_write_reg16_bus8	drivers/staging/fbtft/fbtft	EXPORT_SYMBOL	
++0x3bdd0f94	v4l2_prio_change	drivers/media/v4l2-core/videodev	EXPORT_SYMBOL	
++0x141fce2a	fsg_common_remove_luns	drivers/usb/gadget/function/usb_f_mass_storage	EXPORT_SYMBOL_GPL	
++0xf204273f	drm_connector_attach_content_protection_property	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0x4f6d1c1f	drm_event_reserve_init_locked	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0x92e532a1	drm_poll	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0xd2037296	__drm_atomic_helper_crtc_reset	drivers/gpu/drm/drm_kms_helper	EXPORT_SYMBOL	
++0x20e64e76	synproxy_recv_client_ack	net/netfilter/nf_synproxy_core	EXPORT_SYMBOL_GPL	
++0x72fa4160	ath_gen_timer_free	drivers/net/wireless/ath/ath9k/ath9k_hw	EXPORT_SYMBOL	
++0x66ec6e78	drm_framebuffer_plane_width	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0xda3d3c9e	drm_gem_dmabuf_vunmap	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0x43481cdc	drm_atomic_helper_connector_reset	drivers/gpu/drm/drm_kms_helper	EXPORT_SYMBOL	
++0xa5eaa0cb	ieee80211_txq_may_transmit	net/mac80211/mac80211	EXPORT_SYMBOL	
++0xdfa7db68	map_destroy	drivers/mtd/chips/chipreg	EXPORT_SYMBOL	
++0x11f3044c	__SCK__tp_func_vb2_v4l2_buf_queue	drivers/media/v4l2-core/videodev	EXPORT_SYMBOL_GPL	
++0x53120006	vcc_release_async	net/atm/atm	EXPORT_SYMBOL	
++0x87d4467a	hci_suspend_dev	net/bluetooth/bluetooth	EXPORT_SYMBOL	
++0x065ccae6	nf_ct_expect_find_get	net/netfilter/nf_conntrack	EXPORT_SYMBOL_GPL	
++0xa08337f5	nf_ct_iterate_destroy	net/netfilter/nf_conntrack	EXPORT_SYMBOL_GPL	
++0xffb1009a	snd_pcm_lib_free_pages	sound/core/snd-pcm	EXPORT_SYMBOL	
++0x968090c8	roccat_common2_send	drivers/hid/hid-roccat-common	EXPORT_SYMBOL_GPL	
++0xe3c66a9f	em28xx_toggle_reg_bits	drivers/media/usb/em28xx/em28xx	EXPORT_SYMBOL_GPL	
++0x034e4180	smscore_get_board_id	drivers/media/common/siano/smsmdtv	EXPORT_SYMBOL_GPL	
++0xf99eb54f	smscore_set_board_id	drivers/media/common/siano/smsmdtv	EXPORT_SYMBOL_GPL	
++0x41da0375	qcafrm_create_header	drivers/net/ethernet/qualcomm/qca_7k_common	EXPORT_SYMBOL_GPL	
++0x71001eef	drm_sched_fault	drivers/gpu/drm/scheduler/gpu-sched	EXPORT_SYMBOL	
++0x4c500e16	drm_display_info_set_bus_formats	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0x785b89dd	drm_atomic_helper_bridge_propagate_bus_fmt	drivers/gpu/drm/drm_kms_helper	EXPORT_SYMBOL	
++0x4ef73291	ip6_update_pmtu	net/ipv6/ipv6	EXPORT_SYMBOL_GPL	
++0xcc51f05b	aic32x4_register_clocks	sound/soc/codecs/snd-soc-tlv320aic32x4	EXPORT_SYMBOL_GPL	
++0x4b894aa9	snd_soc_dapm_nc_pin	sound/soc/snd-soc-core	EXPORT_SYMBOL_GPL	
++0x6e9181a3	snd_card_disconnect	sound/core/snd	EXPORT_SYMBOL	
++0xf474795b	dm_internal_suspend_noflush	drivers/md/dm-mod	EXPORT_SYMBOL_GPL	
++0xba4c8fba	dm_put	drivers/md/dm-mod	EXPORT_SYMBOL_GPL	
++0x3adbd595	v4l2_field_names	drivers/media/v4l2-core/videodev	EXPORT_SYMBOL	
++0xa052c164	media_create_pad_link	drivers/media/mc/mc	EXPORT_SYMBOL_GPL	
++0x2b03408d	zl10353_attach	drivers/media/dvb-frontends/zl10353	EXPORT_SYMBOL	
++0x6ffa42b0	tda9887_attach	drivers/media/tuners/tda9887	EXPORT_SYMBOL_GPL	
++0x15050ab4	i2400m_unknown_barker	drivers/net/wimax/i2400m/i2400m	EXPORT_SYMBOL	
++0xf3ec93c5	ieee80211_txq_schedule_start	net/mac80211/mac80211	EXPORT_SYMBOL	
++0x0bc00f80	nf_nat_helper_try_module_get	net/netfilter/nf_conntrack	EXPORT_SYMBOL_GPL	
++0x3f55bfb9	dm_dirty_log_create	drivers/md/dm-log	EXPORT_SYMBOL	
++0xc749f679	rtl92c_dm_write_dig	drivers/net/wireless/realtek/rtlwifi/rtl8192c/rtl8192c-common	EXPORT_SYMBOL	
++0x53fbcb90	w5100_pm_ops	drivers/net/ethernet/wiznet/w5100	EXPORT_SYMBOL_GPL	
++0xddf68fc6	xt_find_revision	net/netfilter/x_tables	EXPORT_SYMBOL_GPL	
++0xdb747747	ahci_reset_controller	drivers/ata/libahci	EXPORT_SYMBOL_GPL	
++0x88a50e6b	ath9k_hw_set_interrupts	drivers/net/wireless/ath/ath9k/ath9k_hw	EXPORT_SYMBOL	
++0xcbe56bc2	zs_get_total_pages	mm/zsmalloc	EXPORT_SYMBOL_GPL	
++0xd6ea69eb	hci_set_fw_info	net/bluetooth/bluetooth	EXPORT_SYMBOL	
++0x4b4db94b	hci_set_hw_info	net/bluetooth/bluetooth	EXPORT_SYMBOL	
++0xcd543af5	nf_osf_find	net/netfilter/nfnetlink_osf	EXPORT_SYMBOL_GPL	
++0x1aca779c	arizona_set_fll_refclk	sound/soc/codecs/snd-soc-arizona	EXPORT_SYMBOL_GPL	
++0xd967f8ed	snd_soc_dai_get_channel_map	sound/soc/snd-soc-core	EXPORT_SYMBOL_GPL	
++0x6ce6b473	snd_soc_dai_set_channel_map	sound/soc/snd-soc-core	EXPORT_SYMBOL_GPL	
++0x251c0457	bcma_core_irq	drivers/bcma/bcma	EXPORT_SYMBOL	
++0xc6808be7	tpg_calc_text_basep	drivers/media/common/v4l2-tpg/v4l2-tpg	EXPORT_SYMBOL_GPL	
++0x7b547437	fc0011_attach	drivers/media/tuners/fc0011	EXPORT_SYMBOL	
++0x9767eccd	u_audio_stop_capture	drivers/usb/gadget/function/u_audio	EXPORT_SYMBOL_GPL	
++0x46e9cd45	drm_plane_create_blend_mode_property	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0xef91d7af	nf_flow_table_init	net/netfilter/nf_flow_table	EXPORT_SYMBOL_GPL	
++0xc9d13e22	snd_rawmidi_drop_output	sound/core/snd-rawmidi	EXPORT_SYMBOL	
++0xf8245b2d	ata_sas_port_init	drivers/ata/libata	EXPORT_SYMBOL_GPL	
++0x5fad7c89	dm_bio_prison_alloc_cell_v2	drivers/md/dm-bio-prison	EXPORT_SYMBOL_GPL	
++0xa0c6bcc8	v4l2_device_unregister_subdev	drivers/media/v4l2-core/videodev	EXPORT_SYMBOL_GPL	
++0x885c70f6	mcp23x08_regmap	drivers/pinctrl/pinctrl-mcp23s08	EXPORT_SYMBOL_GPL	
++0x9f04fed4	bcma_chipco_b_mii_write	drivers/bcma/bcma	EXPORT_SYMBOL_GPL	
++0x9fc4de02	dib0070_set_rf_output	drivers/media/dvb-frontends/dib0070	EXPORT_SYMBOL	
++0x50629b4f	dib0070_get_rf_output	drivers/media/dvb-frontends/dib0070	EXPORT_SYMBOL	
++0x3d94c92d	mipi_dbi_spi_transfer	drivers/gpu/drm/drm_mipi_dbi	EXPORT_SYMBOL	
++0x9acc8e9c	drm_property_lookup_blob	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0x8a51e8a1	drm_modeset_unlock	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0xddacccf6	bt_warn_ratelimited	net/bluetooth/bluetooth	EXPORT_SYMBOL	
++0x3b8fe3bb	dm_dirty_log_type_unregister	drivers/md/dm-log	EXPORT_SYMBOL	
++0x25166a12	nf_nat_helper_unregister	net/netfilter/nf_conntrack	EXPORT_SYMBOL_GPL	
++0x6369a185	cx231xx_enable656	drivers/media/usb/cx231xx/cx231xx	EXPORT_SYMBOL_GPL	
++0xc781bd9f	rfkill_resume_polling	net/rfkill/rfkill	EXPORT_SYMBOL	
++0xac97a207	ieee80211_radiotap_iterator_init	net/wireless/cfg80211	EXPORT_SYMBOL	
++0x76159800	wm_adsp_compr_set_params	sound/soc/codecs/snd-soc-wm-adsp	EXPORT_SYMBOL_GPL	
++0xed5b3325	snd_pcm_stream_unlock_irq	sound/core/snd-pcm	EXPORT_SYMBOL_GPL	
++0xfb6a7296	btintel_load_ddc_config	drivers/bluetooth/btintel	EXPORT_SYMBOL_GPL	
++0x3bbf580e	ata_dev_printk	drivers/ata/libata	EXPORT_SYMBOL	
++0x5f5908dd	dvb_remove_device	drivers/media/dvb-core/dvb-core	EXPORT_SYMBOL	
++0x8bbf3a8c	v4l2_async_notifier_unregister	drivers/media/v4l2-core/videodev	EXPORT_SYMBOL	
++0x18089ebc	iscsi_eh_abort	drivers/scsi/libiscsi	EXPORT_SYMBOL_GPL	
++0x4c5fed54	drm_sched_entity_init	drivers/gpu/drm/scheduler/gpu-sched	EXPORT_SYMBOL	
++0xfb86b96f	dlm_errname	fs/ocfs2/dlm/ocfs2_dlm	EXPORT_SYMBOL_GPL	
++0x7eb91e0e	ip_vs_proto_get	net/netfilter/ipvs/ip_vs	EXPORT_SYMBOL	
++0x89e3897d	v4l2_ctrl_query_fill	drivers/media/v4l2-core/videodev	EXPORT_SYMBOL	
++0xa3349831	dvb_usbv2_reset_resume	drivers/media/usb/dvb-usb-v2/dvb_usb_v2	EXPORT_SYMBOL	
++0x33c5f25a	fsg_show_nofua	drivers/usb/gadget/function/usb_f_mass_storage	EXPORT_SYMBOL_GPL	
++0x031b8177	rtl_lps_change_work_callback	drivers/net/wireless/realtek/rtlwifi/rtlwifi	EXPORT_SYMBOL_GPL	
++0x4afc7062	drm_atomic_set_mode_prop_for_crtc	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0xd0028f17	ieee80211_find_sta	net/mac80211/mac80211	EXPORT_SYMBOL	
++0x57efeb7d	ieee80211_tx_status_irqsafe	net/mac80211/mac80211	EXPORT_SYMBOL	
++0x3f11af8e	snd_dma_free_pages	sound/core/snd-pcm	EXPORT_SYMBOL	
++0x867e87eb	dm_bufio_get_dm_io_client	drivers/md/dm-bufio	EXPORT_SYMBOL_GPL	
++0x11e0ec41	dm_read_arg	drivers/md/dm-mod	EXPORT_SYMBOL	
++0xd4df2798	v4l2_clk_unregister_fixed	drivers/media/v4l2-core/videodev	EXPORT_SYMBOL	
++0x180ad273	w5100_ops_priv	drivers/net/ethernet/wiznet/w5100	EXPORT_SYMBOL_GPL	
++0x1f03912b	ZSTD_flushStream	lib/zstd/zstd_compress	EXPORT_SYMBOL	
++0xecba9ffa	vsock_stream_has_space	net/vmw_vsock/vsock	EXPORT_SYMBOL_GPL	
++0xf266c50d	bt_sock_unlink	net/bluetooth/bluetooth	EXPORT_SYMBOL	
++0xbfacb837	xt_percpu_counter_free	net/netfilter/x_tables	EXPORT_SYMBOL_GPL	
++0x1de9a163	snd_soc_runtime_calc_hw	sound/soc/snd-soc-core	EXPORT_SYMBOL_GPL	
++0xce944ece	snd_soc_dapm_add_routes	sound/soc/snd-soc-core	EXPORT_SYMBOL_GPL	
++0x64fde35a	snd_pcm_stream_lock_irq	sound/core/snd-pcm	EXPORT_SYMBOL_GPL	
++0x715f1002	ves1x93_attach	drivers/media/dvb-frontends/ves1x93	EXPORT_SYMBOL	
++0xaa5503d9	tpg_set_font	drivers/media/common/v4l2-tpg/v4l2-tpg	EXPORT_SYMBOL_GPL	
++0xece3830d	can_free_echo_skb	drivers/net/can/dev/can-dev	EXPORT_SYMBOL_GPL	
++0x9c8aec5d	ath6kl_core_destroy	drivers/net/wireless/ath/ath6kl/ath6kl_core	EXPORT_SYMBOL	
++0x9263b417	ecc_point_mult_shamir	crypto/ecc	EXPORT_SYMBOL	
++0xd95ac116	vsock_addr_validate	net/vmw_vsock/vsock	EXPORT_SYMBOL_GPL	
++0xb9d2d155	cfg80211_sta_opmode_change_notify	net/wireless/cfg80211	EXPORT_SYMBOL	
++0x16e4ecb4	snd_soc_lookup_component	sound/soc/snd-soc-core	EXPORT_SYMBOL_GPL	
++0x26ca237e	mddev_init_writes_pending	drivers/md/md-mod	EXPORT_SYMBOL_GPL	
++0x8106095a	v4l2_prio_max	drivers/media/v4l2-core/videodev	EXPORT_SYMBOL	
++0x5f0e1ed1	v4l2_fwnode_connector_parse	drivers/media/v4l2-core/v4l2-fwnode	EXPORT_SYMBOL_GPL	
++0x30af45a1	ZSTD_initCStream	lib/zstd/zstd_compress	EXPORT_SYMBOL	
++0x0e4dc960	rt2x00usb_uninitialize	drivers/net/wireless/ralink/rt2x00/rt2x00usb	EXPORT_SYMBOL_GPL	
++0x61b12ea6	ar9003_paprd_init_table	drivers/net/wireless/ath/ath9k/ath9k_hw	EXPORT_SYMBOL	
++0xc9fae756	ocfs2_cluster_connect	fs/ocfs2/ocfs2_stackglue	EXPORT_SYMBOL_GPL	
++0x8525e34f	cfg80211_ibss_joined	net/wireless/cfg80211	EXPORT_SYMBOL	
++0x9976089d	videobuf_mmap_setup	drivers/media/v4l2-core/videobuf-core	EXPORT_SYMBOL_GPL	
++0x5e79bb0d	tea5767_autodetection	drivers/media/tuners/tea5767	EXPORT_SYMBOL_GPL	
++0x5d78136f	lbs_remove_card	drivers/net/wireless/marvell/libertas/libertas	EXPORT_SYMBOL_GPL	
++0xa5d0546d	hostap_set_string	drivers/net/wireless/intersil/hostap/hostap	EXPORT_SYMBOL	
++0xf635b0da	drm_atomic_private_obj_init	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0x0105fd3c	tpm_calc_ordinal_duration	drivers/char/tpm/tpm	EXPORT_SYMBOL_GPL	
++0x820565a5	vsock_remove_connected	net/vmw_vsock/vsock	EXPORT_SYMBOL_GPL	
++0x33831a39	arizona_set_output_mode	sound/soc/codecs/snd-soc-arizona	EXPORT_SYMBOL_GPL	
++0xb501aa9b	snd_ctl_remove_id	sound/core/snd	EXPORT_SYMBOL	
++0xf10e93f7	drm_kms_helper_poll_fini	drivers/gpu/drm/drm_kms_helper	EXPORT_SYMBOL	
++0xf9f71742	hci_conn_security	net/bluetooth/bluetooth	EXPORT_SYMBOL	
++0x1ce2497f	reg_query_regdb_wmm	net/wireless/cfg80211	EXPORT_SYMBOL	
++0xb3d4c109	fbtft_write_spi	drivers/staging/fbtft/fbtft	EXPORT_SYMBOL	
++0xc7b45aa4	__SCK__tp_func_vb2_buf_done	drivers/media/common/videobuf2/videobuf2-common	EXPORT_SYMBOL_GPL	
++0xe01b149c	tap_get_minor	drivers/net/tap	EXPORT_SYMBOL_GPL	
++0x60dbfd71	bt_debugfs	net/bluetooth/bluetooth	EXPORT_SYMBOL_GPL	
++0x638701c2	wm_adsp_compr_trigger	sound/soc/codecs/snd-soc-wm-adsp	EXPORT_SYMBOL_GPL	
++0xe2509327	ata_bmdma_irq_clear	drivers/ata/libata	EXPORT_SYMBOL_GPL	
++0x214555a1	mmc_spi_put_pdata	drivers/mmc/host/of_mmc_spi	EXPORT_SYMBOL	
++0x12a53032	mmc_spi_get_pdata	drivers/mmc/host/of_mmc_spi	EXPORT_SYMBOL	
++0xf3522a54	atm_dev_release_vccs	net/atm/atm	EXPORT_SYMBOL	
++0x93005ab3	devm_iio_kfifo_allocate	drivers/iio/buffer/kfifo_buf	EXPORT_SYMBOL	
++0x24621ca3	dm_sm_disk_open	drivers/md/persistent-data/dm-persistent-data	EXPORT_SYMBOL_GPL	
++0x4d5532d9	mt76x02_get_efuse_data	drivers/net/wireless/mediatek/mt76/mt76x02-lib	EXPORT_SYMBOL_GPL	
++0x15af48f5	drm_mode_object_put	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0x58a79976	tpmm_chip_alloc	drivers/char/tpm/tpm	EXPORT_SYMBOL_GPL	
++0x3fed71b6	devm_iio_channel_get	drivers/iio/industrialio	EXPORT_SYMBOL_GPL	
++0xb06dfb6d	ata_sas_port_stop	drivers/ata/libata	EXPORT_SYMBOL_GPL	
++0x09d6811c	ppp_register_channel	drivers/net/ppp/ppp_generic	EXPORT_SYMBOL	
++0x885daed6	rtl92c_dm_watchdog	drivers/net/wireless/realtek/rtlwifi/rtl8192c/rtl8192c-common	EXPORT_SYMBOL	
++0x59967b23	mwifiex_drv_info_dump	drivers/net/wireless/marvell/mwifiex/mwifiex	EXPORT_SYMBOL_GPL	
++0xd197a671	rpisense_get_dev	drivers/mfd/rpisense-core	EXPORT_SYMBOL_GPL	
++0xd1bf09d3	drmm_kstrdup	drivers/gpu/drm/drm	EXPORT_SYMBOL_GPL	
++0xbb5911ac	drm_dp_remote_aux_init	drivers/gpu/drm/drm_kms_helper	EXPORT_SYMBOL	
++0x8d24833d	__gameport_register_port	drivers/input/gameport/gameport	EXPORT_SYMBOL	
++0xf58af566	md_bitmap_start_sync	drivers/md/md-mod	EXPORT_SYMBOL	
++0x135a0545	md_reload_sb	drivers/md/md-mod	EXPORT_SYMBOL	
++0xbc012669	dvb_unregister_frontend	drivers/media/dvb-core/dvb-core	EXPORT_SYMBOL	
++0x3a4448d8	v4l2_async_notifier_add_i2c_subdev	drivers/media/v4l2-core/videodev	EXPORT_SYMBOL_GPL	
++0xe95ab11a	drm_bridge_chain_mode_valid	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0x4339752f	async_syndrome_val	crypto/async_tx/async_pq	EXPORT_SYMBOL_GPL	
++0x8e3ffe7d	ieee80211_stop_queues	net/mac80211/mac80211	EXPORT_SYMBOL	
++0x51738247	nft_fib_validate	net/netfilter/nft_fib	EXPORT_SYMBOL_GPL	
++0x46717065	nf_ct_expect_unregister_notifier	net/netfilter/nf_conntrack	EXPORT_SYMBOL_GPL	
++0xe221b52f	snd_pcm_stream_unlock_irqrestore	sound/core/snd-pcm	EXPORT_SYMBOL_GPL	
++0x25f68a3d	iio_get_time_ns	drivers/iio/industrialio	EXPORT_SYMBOL	
++0xfa623e2d	__register_mtd_parser	drivers/mtd/mtd	EXPORT_SYMBOL_GPL	
++0x111ab12a	dm_bufio_mark_partial_buffer_dirty	drivers/md/dm-bufio	EXPORT_SYMBOL_GPL	
++0x49477f0b	mipi_dbi_buf_copy	drivers/gpu/drm/drm_mipi_dbi	EXPORT_SYMBOL	
++0x6c289cde	drm_flip_work_queue_task	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0xd60736ec	gf128mul_free_64k	crypto/gf128mul	EXPORT_SYMBOL	
++0x62e7179d	flow_offload_teardown	net/netfilter/nf_flow_table	EXPORT_SYMBOL_GPL	
++0xaf638544	nft_data_init	net/netfilter/nf_tables	EXPORT_SYMBOL_GPL	
++0x5ba91757	drm_atomic_state_init	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0x92668ad6	nfnl_acct_find_get	net/netfilter/nfnetlink_acct	EXPORT_SYMBOL_GPL	
++0x2e44b8d5	simple_tuner_attach	drivers/media/tuners/tuner-simple	EXPORT_SYMBOL_GPL	
++0x08179ef1	cdc_ncm_rx_verify_ndp32	drivers/net/usb/cdc_ncm	EXPORT_SYMBOL_GPL	
++0x1234f98d	cdc_ncm_rx_verify_ndp16	drivers/net/usb/cdc_ncm	EXPORT_SYMBOL_GPL	
++0xcf11a549	drm_flip_work_allocate_task	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0xfecb5dd0	drm_driver_legacy_fb_format	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0xf749debc	md5_zero_message_hash	crypto/md5	EXPORT_SYMBOL_GPL	
++0x74e5ff1a	udpv6_encap_enable	net/ipv6/ipv6	EXPORT_SYMBOL	
++0xd33bdba9	snd_pcm_set_sync	sound/core/snd-pcm	EXPORT_SYMBOL	
++0x6a4c7841	safe_candev_priv	drivers/net/can/dev/can-dev	EXPORT_SYMBOL_GPL	
++0xdf666902	drm_rotation_simplify	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0x396b71da	drm_gem_object_lookup	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0xdba126c1	reg_initiator_name	net/wireless/cfg80211	EXPORT_SYMBOL	
++0x8617b9f6	speakup_event	drivers/accessibility/speakup/speakup	EXPORT_SYMBOL_GPL	
++0xa245b67c	dvb_module_release	drivers/media/dvb-core/dvb-core	EXPORT_SYMBOL_GPL	
++0x348c030b	dib0070_attach	drivers/media/dvb-frontends/dib0070	EXPORT_SYMBOL	
++0xccb899c1	rtl92c_dm_bt_coexist	drivers/net/wireless/realtek/rtlwifi/rtl8192c/rtl8192c-common	EXPORT_SYMBOL	
++0xb0d904b7	raid6_empty_zero_page	lib/raid6/raid6_pq	EXPORT_SYMBOL	
++0x456b4e52	snd_info_create_card_entry	sound/core/snd	EXPORT_SYMBOL	
++0x0f3d9fc6	ata_qc_complete_multiple	drivers/ata/libata	EXPORT_SYMBOL_GPL	
++0x5dd4e6b7	wimax_msg_alloc	net/wimax/wimax	EXPORT_SYMBOL_GPL	
++0xa43b21e1	ipv6_sock_mc_drop	net/ipv6/ipv6	EXPORT_SYMBOL	
++0x537c5ed3	drm_crtc_add_crc_entry	drivers/gpu/drm/drm	EXPORT_SYMBOL_GPL	
++0xfa0e07ce	xfrm6_find_1stfragopt	net/ipv6/ipv6	EXPORT_SYMBOL	
++0x01749012	nft_register_chain_type	net/netfilter/nf_tables	EXPORT_SYMBOL_GPL	
++0x198788b4	snd_lookup_oss_minor_data	sound/core/snd	EXPORT_SYMBOL	
++0x4a3ea5c0	snd_request_card	sound/core/snd	EXPORT_SYMBOL	
++0x665ba4b0	brcmu_pktq_mdeq	drivers/net/wireless/broadcom/brcm80211/brcmutil/brcmutil	EXPORT_SYMBOL	
++0xf47dc51f	brcmu_pktq_mlen	drivers/net/wireless/broadcom/brcm80211/brcmutil/brcmutil	EXPORT_SYMBOL	
++0x131bd682	drm_helper_disable_unused_functions	drivers/gpu/drm/drm_kms_helper	EXPORT_SYMBOL	
++0x99965dae	l2tp_nl_register_ops	net/l2tp/l2tp_netlink	EXPORT_SYMBOL_GPL	
++0xef265f27	cfg80211_chandef_create	net/wireless/cfg80211	EXPORT_SYMBOL	
++0x02495653	cfg80211_tdls_oper_request	net/wireless/cfg80211	EXPORT_SYMBOL	
++0x98b1baa6	wm_adsp_write_ctl	sound/soc/codecs/snd-soc-wm-adsp	EXPORT_SYMBOL_GPL	
++0x1a724fcc	snd_seq_kernel_client_ctl	sound/core/seq/snd-seq	EXPORT_SYMBOL	
++0xa533b239	vhost_poll_flush	drivers/vhost/vhost	EXPORT_SYMBOL_GPL	
++0xec8a3584	gameport_unregister_driver	drivers/input/gameport/gameport	EXPORT_SYMBOL	
++0x0a2e0a65	dm_register_target	drivers/md/dm-mod	EXPORT_SYMBOL	
++0x04fc8bf2	rtl_deinit_deferred_work	drivers/net/wireless/realtek/rtlwifi/rtlwifi	EXPORT_SYMBOL_GPL	
++0x6d21cb34	drm_fb_helper_set_suspend_unlocked	drivers/gpu/drm/drm_kms_helper	EXPORT_SYMBOL	
++0xc794c9b0	ieee80211_nullfunc_get	net/mac80211/mac80211	EXPORT_SYMBOL	
++0x9904f4d7	ax25_display_timer	net/ax25/ax25	EXPORT_SYMBOL	
++0xd7d1b951	cfg80211_port_authorized	net/wireless/cfg80211	EXPORT_SYMBOL	
++0xfdfe8c4e	nf_dup_ipv4	net/ipv4/netfilter/nf_dup_ipv4	EXPORT_SYMBOL_GPL	
++0xa93b46aa	nf_nat_ipv4_unregister_fn	net/netfilter/nf_nat	EXPORT_SYMBOL_GPL	
++0xb8c09c6e	nf_ct_seqadj_init	net/netfilter/nf_conntrack	EXPORT_SYMBOL_GPL	
++0x5109f989	ahci_kick_engine	drivers/ata/libahci	EXPORT_SYMBOL_GPL	
++0xcda04a5b	v4l2_prio_close	drivers/media/v4l2-core/videodev	EXPORT_SYMBOL	
++0xf1392476	cdc_ncm_change_mtu	drivers/net/usb/cdc_ncm	EXPORT_SYMBOL_GPL	
++0x4e095f11	drm_get_format_name	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0xc5b07551	ip_set_test	net/netfilter/ipset/ip_set	EXPORT_SYMBOL_GPL	
++0x447ba356	__devm_iio_trigger_register	drivers/iio/industrialio	EXPORT_SYMBOL_GPL	
++0x440fd026	ip6_flush_pending_frames	net/ipv6/ipv6	EXPORT_SYMBOL_GPL	
++0x69102a20	arizona_sample_rate_text	sound/soc/codecs/snd-soc-arizona	EXPORT_SYMBOL_GPL	
++0xd640609f	iio_trigger_set_immutable	drivers/iio/industrialio	EXPORT_SYMBOL	
++0xd8fd86cf	synth_release_region	drivers/accessibility/speakup/speakup	EXPORT_SYMBOL_GPL	
++0x5e373fb4	gf128mul_64k_bbe	crypto/gf128mul	EXPORT_SYMBOL	
++0x5284626d	ieee80211_stop_rx_ba_session	net/mac80211/mac80211	EXPORT_SYMBOL	
++0x231961d4	ip_vs_scheduler_err	net/netfilter/ipvs/ip_vs	EXPORT_SYMBOL	
++0x214792c4	nft_chain_validate	net/netfilter/nf_tables	EXPORT_SYMBOL_GPL	
++0xa875c584	snd_soc_link_compr_startup	sound/soc/snd-soc-core	EXPORT_SYMBOL_GPL	
++0xa623245d	snd_soc_dai_set_bclk_ratio	sound/soc/snd-soc-core	EXPORT_SYMBOL_GPL	
++0x521c727e	rtl_init_rx_config	drivers/net/wireless/realtek/rtlwifi/rtlwifi	EXPORT_SYMBOL_GPL	
++0x26b617e6	mt76_wcid_key_setup	drivers/net/wireless/mediatek/mt76/mt76	EXPORT_SYMBOL	
++0xff282521	rfkill_register	net/rfkill/rfkill	EXPORT_SYMBOL	
++0xeb1a146c	ebt_unregister_table_pre_exit	net/bridge/netfilter/ebtables	EXPORT_SYMBOL	
++0x70fbb5bf	cfg80211_cqm_beacon_loss_notify	net/wireless/cfg80211	EXPORT_SYMBOL	
++0xa3cc1157	dm_btree_cursor_begin	drivers/md/persistent-data/dm-persistent-data	EXPORT_SYMBOL_GPL	
++0x3d022ba4	usb_os_desc_prepare_interf_dir	drivers/usb/gadget/libcomposite	EXPORT_SYMBOL	
++0xebaf13d9	drm_atomic_commit	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0xd3e9b349	drm_atomic_helper_check_plane_state	drivers/gpu/drm/drm_kms_helper	EXPORT_SYMBOL	
++0xc822e61d	snd_soc_component_async_complete	sound/soc/snd-soc-core	EXPORT_SYMBOL_GPL	
++0x5e7f4920	snd_pcm_format_set_silence	sound/core/snd-pcm	EXPORT_SYMBOL	
++0xb4cae620	drm_gem_mmap_obj	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0xe2cd2a87	ata_pci_bmdma_init	drivers/ata/libata	EXPORT_SYMBOL_GPL	
++0x1140f3ae	vb2_queue_error	drivers/media/common/videobuf2/videobuf2-common	EXPORT_SYMBOL_GPL	
++0x92d62957	mux_chip_register	drivers/mux/mux-core	EXPORT_SYMBOL_GPL	
++0xd23b5177	iio_device_claim_direct_mode	drivers/iio/industrialio	EXPORT_SYMBOL_GPL	
++0x554a2ee5	ath9k_hw_beaconinit	drivers/net/wireless/ath/ath9k/ath9k_hw	EXPORT_SYMBOL	
++0x32887f64	wiphy_rfkill_stop_polling	net/wireless/cfg80211	EXPORT_SYMBOL	
++0x6791a44e	dm_deferred_entry_dec	drivers/md/dm-bio-prison	EXPORT_SYMBOL_GPL	
++0xca2e3a88	dm_deferred_entry_inc	drivers/md/dm-bio-prison	EXPORT_SYMBOL_GPL	
++0xe0ab2b25	lnbh24_attach	drivers/media/dvb-frontends/lnbp21	EXPORT_SYMBOL	
++0x20ba45cc	rt2800_txdone_entry	drivers/net/wireless/ralink/rt2x00/rt2800lib	EXPORT_SYMBOL_GPL	
++0xf894b1cc	register_snap_client	net/802/psnap	EXPORT_SYMBOL	
++0xd33d0a2f	mtd_pairing_info_to_wunit	drivers/mtd/mtd	EXPORT_SYMBOL_GPL	
++0xc63fb319	ieee80211_radar_detected	net/mac80211/mac80211	EXPORT_SYMBOL	
++0x96cfa82c	sigmadsp_reset	sound/soc/codecs/snd-soc-sigmadsp	EXPORT_SYMBOL_GPL	
++0x0fbdeafd	snd_soc_info_volsw_range	sound/soc/snd-soc-core	EXPORT_SYMBOL_GPL	
++0xdb32c401	dpcm_be_dai_trigger	sound/soc/snd-soc-core	EXPORT_SYMBOL_GPL	
++0xdfff8a3b	snd_soc_find_dai	sound/soc/snd-soc-core	EXPORT_SYMBOL_GPL	
++0x8878cfa6	gether_cleanup	drivers/usb/gadget/function/u_ether	EXPORT_SYMBOL_GPL	
++0x06e8579f	_rtl_dbg_print	drivers/net/wireless/realtek/rtlwifi/rtlwifi	EXPORT_SYMBOL_GPL	
++0x8d01d35c	drm_fb_helper_check_var	drivers/gpu/drm/drm_kms_helper	EXPORT_SYMBOL	
++0xebd2ac81	bt_accept_unlink	net/bluetooth/bluetooth	EXPORT_SYMBOL	
++0x68887377	ip6_tnl_encap_del_ops	net/ipv6/ip6_tunnel	EXPORT_SYMBOL	
++0x04f3c6b3	nf_ct_gre_keymap_add	net/netfilter/nf_conntrack	EXPORT_SYMBOL_GPL	
++0x7ee6dcf3	line6_version_request_async	sound/usb/line6/snd-usb-line6	EXPORT_SYMBOL_GPL	
++0x5c341426	tm6000_init_digital_mode	drivers/media/usb/tm6000/tm6000	EXPORT_SYMBOL	
++0x167b10c7	vb2_request_validate	drivers/media/common/videobuf2/videobuf2-v4l2	EXPORT_SYMBOL_GPL	
++0xad31c60a	tap_del_queues	drivers/net/tap	EXPORT_SYMBOL_GPL	
++0x39e8fa4b	poly1305_update_generic	lib/crypto/libpoly1305	EXPORT_SYMBOL_GPL	
++0xbfe84d3e	xt_check_target	net/netfilter/x_tables	EXPORT_SYMBOL_GPL	
++0x70ef6405	ascot2e_attach	drivers/media/dvb-frontends/ascot2e	EXPORT_SYMBOL	
++0x59ec6e2d	rt2x00queue_pause_queue	drivers/net/wireless/ralink/rt2x00/rt2x00lib	EXPORT_SYMBOL_GPL	
++0x655d758d	atm_dev_signal_change	net/atm/atm	EXPORT_SYMBOL	
++0xd526f825	udp6_lib_lookup	net/ipv6/ipv6	EXPORT_SYMBOL_GPL	
++0x74810459	__nf_ct_try_assign_helper	net/netfilter/nf_conntrack	EXPORT_SYMBOL_GPL	
++0x84b87738	snd_jack_report	sound/core/snd	EXPORT_SYMBOL	
++0xf98605d5	ath_regd_get_band_ctl	drivers/net/wireless/ath/ath	EXPORT_SYMBOL	
++0xd17a882e	__drm_atomic_helper_disable_plane	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0x5da67adc	zs_compact	mm/zsmalloc	EXPORT_SYMBOL_GPL	
++0xac2716ca	l2cap_add_psm	net/bluetooth/bluetooth	EXPORT_SYMBOL_GPL	
++0x4dbed5ce	set_h245_addr_hook	net/netfilter/nf_conntrack_h323	EXPORT_SYMBOL_GPL	
++0x28eff409	nf_conntrack_hash	net/netfilter/nf_conntrack	EXPORT_SYMBOL_GPL	
++0xc41fc250	stp_proto_register	net/802/stp	EXPORT_SYMBOL_GPL	
++0x27b08abd	dm_internal_resume_fast	drivers/md/dm-mod	EXPORT_SYMBOL_GPL	
++0x017ea7c7	cx231xx_tuner_callback	drivers/media/usb/cx231xx/cx231xx	EXPORT_SYMBOL_GPL	
++0x6c628e91	bcm2835_smi_get	drivers/misc/bcm2835_smi	EXPORT_SYMBOL	
++0x33896c12	drm_writeback_queue_job	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0x3e874fb1	drm_class_device_unregister	drivers/gpu/drm/drm	EXPORT_SYMBOL_GPL	
++0x03a81e69	virtio_transport_stream_allow	net/vmw_vsock/vmw_vsock_virtio_transport_common	EXPORT_SYMBOL_GPL	
++0x1f8b4639	nft_fib_store_result	net/netfilter/nft_fib	EXPORT_SYMBOL_GPL	
++0x4f26e5d6	garp_register_application	net/802/garp	EXPORT_SYMBOL_GPL	
++0x7d1bfcbb	drm_dp_mst_topology_mgr_suspend	drivers/gpu/drm/drm_kms_helper	EXPORT_SYMBOL	
++0xf68741fb	drm_dp_subconnector_type	drivers/gpu/drm/drm_kms_helper	EXPORT_SYMBOL	
++0xa3263524	ieee80211_ave_rssi	net/mac80211/mac80211	EXPORT_SYMBOL_GPL	
++0x43dfbb12	ieee80211_rts_duration	net/mac80211/mac80211	EXPORT_SYMBOL	
++0xad264cff	dvb_ringbuffer_init	drivers/media/dvb-core/dvb-core	EXPORT_SYMBOL	
++0xe18c74de	s5h1420_get_tuner_i2c_adapter	drivers/media/dvb-frontends/s5h1420	EXPORT_SYMBOL	
++0x61bc71ec	rtl_cam_del_entry	drivers/net/wireless/realtek/rtlwifi/rtlwifi	EXPORT_SYMBOL	
++0x4d60b308	mt76x02_mac_wcid_setup	drivers/net/wireless/mediatek/mt76/mt76x02-lib	EXPORT_SYMBOL_GPL	
++0x0c941f51	drm_crtc_helper_set_config	drivers/gpu/drm/drm_kms_helper	EXPORT_SYMBOL	
++0xfe1298f3	o2net_register_handler	fs/ocfs2/cluster/ocfs2_nodemanager	EXPORT_SYMBOL_GPL	
++0xf474a207	usb_gadget_config_buf	drivers/usb/gadget/libcomposite	EXPORT_SYMBOL_GPL	
++0xe302def0	rtl_recognize_peer	drivers/net/wireless/realtek/rtlwifi/rtlwifi	EXPORT_SYMBOL_GPL	
++0x984c5e73	p9_fcall_fini	net/9p/9pnet	EXPORT_SYMBOL	
++0x25d428f0	ieee80211_gtk_rekey_notify	net/mac80211/mac80211	EXPORT_SYMBOL_GPL	
++0x3796bdcc	snd_pcm_format_little_endian	sound/core/snd-pcm	EXPORT_SYMBOL	
++0xb29533ee	zs_malloc	mm/zsmalloc	EXPORT_SYMBOL_GPL	
++0xb95711f0	br_forward	net/bridge/bridge	EXPORT_SYMBOL_GPL	
++0xc1950edd	udp_tunnel_sock_release	net/ipv4/udp_tunnel	EXPORT_SYMBOL_GPL	
++0x65766986	nft_unregister_obj	net/netfilter/nf_tables	EXPORT_SYMBOL_GPL	
++0x8f01906c	btrtl_initialize	drivers/bluetooth/btrtl	EXPORT_SYMBOL_GPL	
++0x91b3c4b6	btbcm_initialize	drivers/bluetooth/btbcm	EXPORT_SYMBOL_GPL	
++0x8fc2c461	pps_lookup_dev	drivers/pps/pps_core	EXPORT_SYMBOL	
++0x00a9361b	v4l2_try_ext_ctrls	drivers/media/v4l2-core/videodev	EXPORT_SYMBOL	
++0x0531135b	usb_string_id	drivers/usb/gadget/libcomposite	EXPORT_SYMBOL_GPL	
++0xcb62d004	iscsi_tcp_task_init	drivers/scsi/libiscsi_tcp	EXPORT_SYMBOL_GPL	
++0x1a66fc17	ieee80211_get_tkip_rx_p1k	net/mac80211/mac80211	EXPORT_SYMBOL	
++0x9e997afe	stp_proto_unregister	net/802/stp	EXPORT_SYMBOL_GPL	
++0x83d2aee5	snd_soc_pm_ops	sound/soc/snd-soc-core	EXPORT_SYMBOL_GPL	
++0x63343b1d	snd_usbmidi_input_stop	sound/usb/snd-usbmidi-lib	EXPORT_SYMBOL	
++0x61655067	dvb_net_release	drivers/media/dvb-core/dvb-core	EXPORT_SYMBOL	
++0xd034392d	v4l2_match_dv_timings	drivers/media/v4l2-core/v4l2-dv-timings	EXPORT_SYMBOL_GPL	
++0x721f7cc7	em28xx_free_device	drivers/media/usb/em28xx/em28xx	EXPORT_SYMBOL_GPL	
++0xe41476d9	ZSTD_getParams	lib/zstd/zstd_compress	EXPORT_SYMBOL	
++0xb7835d99	nf_tables_deactivate_set	net/netfilter/nf_tables	EXPORT_SYMBOL_GPL	
++0x617e906c	snd_seq_driver_unregister	sound/core/snd-seq-device	EXPORT_SYMBOL_GPL	
++0x5bc0b022	ata_sff_data_xfer32	drivers/ata/libata	EXPORT_SYMBOL_GPL	
++0x1e39eb14	synth_putws	drivers/accessibility/speakup/speakup	EXPORT_SYMBOL_GPL	
++0xe9fea220	videobuf_poll_stream	drivers/media/v4l2-core/videobuf-core	EXPORT_SYMBOL_GPL	
++0x336113f3	mt76x02_eeprom_copy	drivers/net/wireless/mediatek/mt76/mt76x02-lib	EXPORT_SYMBOL_GPL	
++0x204c2f05	drm_atomic_helper_commit_cleanup_done	drivers/gpu/drm/drm_kms_helper	EXPORT_SYMBOL	
++0x1b860d22	bt_sock_reclassify_lock	net/bluetooth/bluetooth	EXPORT_SYMBOL	
++0x9a51bdd9	ipt_register_table	net/ipv4/netfilter/ip_tables	EXPORT_SYMBOL	
++0xa5107942	arizona_adsp2_rate_controls	sound/soc/codecs/snd-soc-arizona	EXPORT_SYMBOL_GPL	
++0xe56a9336	snd_pcm_format_width	sound/core/snd-pcm	EXPORT_SYMBOL	
++0x09295736	ata_pio_need_iordy	drivers/ata/libata	EXPORT_SYMBOL_GPL	
++0x42866c88	tda10023_attach	drivers/media/dvb-frontends/tda10023	EXPORT_SYMBOL	
++0x6a65b57c	tda10021_attach	drivers/media/dvb-frontends/tda10021	EXPORT_SYMBOL	
++0x390e7d35	roccat_common2_receive	drivers/hid/hid-roccat-common	EXPORT_SYMBOL_GPL	
++0x249e5608	drm_crtc_cleanup	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0x5f05eb53	drm_atomic_helper_commit	drivers/gpu/drm/drm_kms_helper	EXPORT_SYMBOL	
++0x6a6a09c7	ipcomp_destroy	net/xfrm/xfrm_ipcomp	EXPORT_SYMBOL_GPL	
++0x9ba318df	ata_std_end_eh	drivers/ata/libata	EXPORT_SYMBOL	
++0x26963f15	fbtft_register_framebuffer	drivers/staging/fbtft/fbtft	EXPORT_SYMBOL	
++0xbd0d4550	rt2x00mac_flush	drivers/net/wireless/ralink/rt2x00/rt2x00lib	EXPORT_SYMBOL_GPL	
++0x12e826c8	mt76_set_tim	drivers/net/wireless/mediatek/mt76/mt76	EXPORT_SYMBOL_GPL	
++0x492bb516	fuse_mount_remove	fs/fuse/fuse	EXPORT_SYMBOL_GPL	
++0x49d7c235	ieee80211_unregister_hw	net/mac80211/mac80211	EXPORT_SYMBOL	
++0x25cc5b09	rtl92c_dm_init	drivers/net/wireless/realtek/rtlwifi/rtl8192c/rtl8192c-common	EXPORT_SYMBOL	
++0xd70d35a1	gf128mul_4k_bbe	crypto/gf128mul	EXPORT_SYMBOL	
++0x5a4d313e	gf128mul_4k_lle	crypto/gf128mul	EXPORT_SYMBOL	
++0x5ac1ac82	vc_sm_cma_import_dmabuf	drivers/staging/vc04_services/vc-sm-cma/vc-sm-cma	EXPORT_SYMBOL_GPL	
++0x2eb01e04	dm_deferred_set_destroy	drivers/md/dm-bio-prison	EXPORT_SYMBOL_GPL	
++0xbe4abaab	dibusb_read_eeprom_byte	drivers/media/usb/dvb-usb/dvb-usb-dibusb-common	EXPORT_SYMBOL	
++0x8ace2acf	vb2_queue_init_name	drivers/media/common/videobuf2/videobuf2-v4l2	EXPORT_SYMBOL_GPL	
++0xdcb71f6e	snd_pcm_stream_unlock	sound/core/snd-pcm	EXPORT_SYMBOL_GPL	
++0xd6ded32d	dib0090_set_switch	drivers/media/dvb-frontends/dib0090	EXPORT_SYMBOL	
++0x5e95598a	drm_atomic_bridge_chain_post_disable	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0x188d9d26	__cast5_decrypt	crypto/cast5_generic	EXPORT_SYMBOL_GPL	
++0xef81a4af	__cast5_encrypt	crypto/cast5_generic	EXPORT_SYMBOL_GPL	
++0x85639a9d	ieee80211_get_buffered_bc	net/mac80211/mac80211	EXPORT_SYMBOL	
++0xfdd43858	wm_adsp_compr_copy	sound/soc/codecs/snd-soc-wm-adsp	EXPORT_SYMBOL_GPL	
++0xb2438d54	dm_bufio_release_move	drivers/md/dm-bufio	EXPORT_SYMBOL_GPL	
++0x1e6fdc36	usb_serial_generic_resume	drivers/usb/serial/usbserial	EXPORT_SYMBOL_GPL	
++0x1afca229	ppp_channel_index	drivers/net/ppp/ppp_generic	EXPORT_SYMBOL	
++0xd2675dbc	rtl92c_set_fw_pwrmode_cmd	drivers/net/wireless/realtek/rtlwifi/rtl8192c/rtl8192c-common	EXPORT_SYMBOL	
++0x35be51bb	efuse_read_1byte	drivers/net/wireless/realtek/rtlwifi/rtlwifi	EXPORT_SYMBOL	
++0x5f08aeb6	rtl_deinit_rfkill	drivers/net/wireless/realtek/rtlwifi/rtlwifi	EXPORT_SYMBOL_GPL	
++0x5b388f0f	inter_copy_offload_enable	fs/nfsd/nfsd	EXPORT_SYMBOL_GPL	
++0x991a0ca0	ieee80211_parse_p2p_noa	net/mac80211/mac80211	EXPORT_SYMBOL	
++0x5fd46142	md_check_recovery	drivers/md/md-mod	EXPORT_SYMBOL	
++0x85e59017	macvlan_link_register	drivers/net/macvlan	EXPORT_SYMBOL_GPL	
++0x7dd23e06	drm_noop	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0xe4d9d4bd	drm_atomic_helper_damage_merged	drivers/gpu/drm/drm_kms_helper	EXPORT_SYMBOL	
++0xb672aa97	lc_create	lib/lru_cache	EXPORT_SYMBOL	
++0x2ca78cd8	btrtl_setup_realtek	drivers/bluetooth/btrtl	EXPORT_SYMBOL_GPL	
++0xb7249cbd	vchiq_mmal_component_disable	drivers/staging/vc04_services/vchiq-mmal/bcm2835-mmal-vchiq	EXPORT_SYMBOL_GPL	
++0x0321c50e	iscsi_boot_create_kset	drivers/scsi/iscsi_boot_sysfs	EXPORT_SYMBOL_GPL	
++0xd002e93a	__iscsi_put_task	drivers/scsi/libiscsi	EXPORT_SYMBOL_GPL	
++0xf83cc1ad	__iscsi_get_task	drivers/scsi/libiscsi	EXPORT_SYMBOL_GPL	
++0xd8b7c948	drm_gem_dma_resv_wait	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0x0df7fa3c	fuse_do_ioctl	fs/fuse/fuse	EXPORT_SYMBOL_GPL	
++0xb09faf79	register_atmdevice_notifier	net/atm/atm	EXPORT_SYMBOL_GPL	
++0xfa666fc9	ip6_fraglist_init	net/ipv6/ipv6	EXPORT_SYMBOL	
++0xbc546863	ata_bmdma_port_intr	drivers/ata/libata	EXPORT_SYMBOL_GPL	
++0x8fe0db01	synth_putwc_s	drivers/accessibility/speakup/speakup	EXPORT_SYMBOL_GPL	
++0x5f2b1d95	intlog2	drivers/media/dvb-core/dvb-core	EXPORT_SYMBOL	
++0xecbf1580	tda665x_attach	drivers/media/dvb-frontends/tda665x	EXPORT_SYMBOL	
++0x5f179bbb	ath9k_hw_setrxabort	drivers/net/wireless/ath/ath9k/ath9k_hw	EXPORT_SYMBOL	
++0x40cb3656	ip_tunnel_get_link_net	net/ipv4/ip_tunnel	EXPORT_SYMBOL	
++0x218d69e6	nft_fwd_dup_netdev_offload	net/netfilter/nf_dup_netdev	EXPORT_SYMBOL_GPL	
++0x0b1b9ca2	vhost_get_vq_desc	drivers/vhost/vhost	EXPORT_SYMBOL_GPL	
++0xb15c7465	ec100_attach	drivers/media/dvb-frontends/ec100	EXPORT_SYMBOL	
++0x1190d214	drm_writeback_signal_completion	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0xcd583bd2	drm_plane_create_zpos_property	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0x2ecf954b	nf_nat_pptp_hook_exp_gre	net/netfilter/nf_conntrack_pptp	EXPORT_SYMBOL_GPL	
++0xb50e063d	arizona_init_common	sound/soc/codecs/snd-soc-arizona	EXPORT_SYMBOL_GPL	
++0x458edee5	ata_bmdma_qc_prep	drivers/ata/libata	EXPORT_SYMBOL_GPL	
++0x339aa96a	rt2x00mac_config	drivers/net/wireless/ralink/rt2x00/rt2x00lib	EXPORT_SYMBOL_GPL	
++0xc053d665	nf_synproxy_ipv6_fini	net/netfilter/nf_synproxy_core	EXPORT_SYMBOL_GPL	
++0x1918e1e2	dm_cell_lock_promote_v2	drivers/md/dm-bio-prison	EXPORT_SYMBOL_GPL	
++0x70c1420b	drm_client_modeset_dpms	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0x7b2422d8	bt_sock_poll	net/bluetooth/bluetooth	EXPORT_SYMBOL	
++0xc65d480c	mt76x2_reset_wlan	drivers/net/wireless/mediatek/mt76/mt76x2/mt76x2-common	EXPORT_SYMBOL_GPL	
++0xff42c374	usb_role_switch_get_role	drivers/usb/roles/roles	EXPORT_SYMBOL_GPL	
++0xd5474690	usb_role_switch_set_role	drivers/usb/roles/roles	EXPORT_SYMBOL_GPL	
++0xf4ccce57	snd_soc_dapm_enable_pin	sound/soc/snd-soc-core	EXPORT_SYMBOL_GPL	
++0x7912cadb	sata_port_ops	drivers/ata/libata	EXPORT_SYMBOL_GPL	
++0xc584833b	md_bitmap_sync_with_cluster	drivers/md/md-mod	EXPORT_SYMBOL	
++0xae575c8f	v4l2_phys_addr_for_input	drivers/media/v4l2-core/v4l2-dv-timings	EXPORT_SYMBOL_GPL	
++0xcc501597	v4l2_fill_pixfmt	drivers/media/v4l2-core/videodev	EXPORT_SYMBOL_GPL	
++0xf4aef3a4	tpg_gen_text	drivers/media/common/v4l2-tpg/v4l2-tpg	EXPORT_SYMBOL_GPL	
++0x54b11e0a	line6_send_raw_message_async	sound/usb/line6/snd-usb-line6	EXPORT_SYMBOL_GPL	
++0xb71ae634	snd_soc_put_xr_sx	sound/soc/snd-soc-core	EXPORT_SYMBOL_GPL	
++0xf78a05ff	snd_soc_get_xr_sx	sound/soc/snd-soc-core	EXPORT_SYMBOL_GPL	
++0xd43d7247	snd_dmaengine_pcm_request_channel	sound/core/snd-pcm-dmaengine	EXPORT_SYMBOL_GPL	
++0x7ca3661a	md_kick_rdev_from_array	drivers/md/md-mod	EXPORT_SYMBOL_GPL	
++0x2593782f	__tracepoint_vb2_buf_queue	drivers/media/common/videobuf2/videobuf2-common	EXPORT_SYMBOL_GPL	
++0x423845e4	fsg_ss_bulk_in_comp_desc	drivers/usb/gadget/function/usb_f_mass_storage	EXPORT_SYMBOL_GPL	
++0x2eac7534	i2400m_dev_reset_handle	drivers/net/wimax/i2400m/i2400m	EXPORT_SYMBOL_GPL	
++0x3a444f4b	bcm2835_smi_read_buf	drivers/misc/bcm2835_smi	EXPORT_SYMBOL	
++0x2479193e	crypto_authenc_extractkeys	crypto/authenc	EXPORT_SYMBOL_GPL	
++0x2ffa15a6	__hci_cmd_send	net/bluetooth/bluetooth	EXPORT_SYMBOL	
++0x95fbeb7a	nf_ct_iterate_cleanup_net	net/netfilter/nf_conntrack	EXPORT_SYMBOL_GPL	
++0x5cb548dc	iio_map_array_unregister	drivers/iio/industrialio	EXPORT_SYMBOL_GPL	
++0x7415802d	ata_bmdma_post_internal_cmd	drivers/ata/libata	EXPORT_SYMBOL_GPL	
++0x70e42795	rt2800_clear_beacon	drivers/net/wireless/ralink/rt2x00/rt2800lib	EXPORT_SYMBOL_GPL	
++0x3664bf59	drm_atomic_helper_suspend	drivers/gpu/drm/drm_kms_helper	EXPORT_SYMBOL	
++0x0244ca43	drm_dp_mst_atomic_enable_dsc	drivers/gpu/drm/drm_kms_helper	EXPORT_SYMBOL	
++0x684ec29b	spk_do_catch_up	drivers/accessibility/speakup/speakup	EXPORT_SYMBOL_GPL	
++0x5375ca71	dm_bm_write_lock	drivers/md/persistent-data/dm-persistent-data	EXPORT_SYMBOL_GPL	
++0x3b79fa81	flexcop_eeprom_check_mac_addr	drivers/media/common/b2c2/b2c2-flexcop	EXPORT_SYMBOL	
++0xa554b313	nfc_unregister_device	net/nfc/nfc	EXPORT_SYMBOL	
++0x2fbe6617	hidp_hid_driver	net/bluetooth/hidp/hidp	EXPORT_SYMBOL_GPL	
++0x9ce050be	drm_mode_copy	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0x61577694	ZSTD_compressEnd	lib/zstd/zstd_compress	EXPORT_SYMBOL	
++0x71f6670b	__cookie_v6_check	net/ipv6/ipv6	EXPORT_SYMBOL_GPL	
++0xa8f2f4a4	ata_sff_pause	drivers/ata/libata	EXPORT_SYMBOL_GPL	
++0x69e3d779	iscsi_segment_init_linear	drivers/scsi/libiscsi_tcp	EXPORT_SYMBOL_GPL	
++0x3c64469a	v9fs_unregister_trans	net/9p/9pnet	EXPORT_SYMBOL	
++0xc667b80c	gameport_close	drivers/input/gameport/gameport	EXPORT_SYMBOL	
++0xec3393a3	v4l2_async_register_subdev	drivers/media/v4l2-core/videodev	EXPORT_SYMBOL	
++0x3152eb84	can_change_state	drivers/net/can/dev/can-dev	EXPORT_SYMBOL_GPL	
++0x64090f76	lbtf_bcn_sent	drivers/net/wireless/marvell/libertas_tf/libertas_tf	EXPORT_SYMBOL_GPL	
++0x8f447df6	drm_mode_create_tv_properties	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0xb02ca52d	virtio_transport_notify_poll_out	net/vmw_vsock/vmw_vsock_virtio_transport_common	EXPORT_SYMBOL_GPL	
++0x38a8d62b	nf_ct_port_tuple_to_nlattr	net/netfilter/nf_conntrack	EXPORT_SYMBOL_GPL	
++0x589160ba	dvb_ringbuffer_flush	drivers/media/dvb-core/dvb-core	EXPORT_SYMBOL	
++0x22ac6205	fsg_store_ro	drivers/usb/gadget/function/usb_f_mass_storage	EXPORT_SYMBOL_GPL	
++0x0b5afe98	_rtl92c_store_pwrindex_diffrate_offset	drivers/net/wireless/realtek/rtlwifi/rtl8192c/rtl8192c-common	EXPORT_SYMBOL	
++0x8b7a9e72	drm_edid_are_equal	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0x093cc090	drm_fb_helper_hotplug_event	drivers/gpu/drm/drm_kms_helper	EXPORT_SYMBOL	
++0x6d55ed44	drm_fb_helper_initial_config	drivers/gpu/drm/drm_kms_helper	EXPORT_SYMBOL	
++0x2deca5cd	nf_conntrack_helper_register	net/netfilter/nf_conntrack	EXPORT_SYMBOL_GPL	
++0x8a195af2	snd_seq_root	sound/core/snd	EXPORT_SYMBOL	
++0xd921364a	snd_tea575x_exit	drivers/media/radio/tea575x	EXPORT_SYMBOL	
++0x4dc749cc	snd_tea575x_init	drivers/media/radio/tea575x	EXPORT_SYMBOL	
++0xac5bfac5	media_graph_walk_start	drivers/media/mc/mc	EXPORT_SYMBOL_GPL	
++0xc64ad591	cx2341x_handler_set_50hz	drivers/media/common/cx2341x	EXPORT_SYMBOL	
++0xb2c9dab9	drm_mode_find_dmt	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0x4a4739dd	drm_atomic_helper_async_commit	drivers/gpu/drm/drm_kms_helper	EXPORT_SYMBOL	
++0x92b64400	aic32x4_regmap_config	sound/soc/codecs/snd-soc-tlv320aic32x4	EXPORT_SYMBOL	
++0x05ae8109	vb2_discard_done	drivers/media/common/videobuf2/videobuf2-common	EXPORT_SYMBOL_GPL	
++0x06c8f2de	slhc_compress	drivers/net/slip/slhc	EXPORT_SYMBOL	
++0x68be11fd	l2tp_session_create	net/l2tp/l2tp_core	EXPORT_SYMBOL_GPL	
++0x10a0c5b1	ieee80211_get_response_rate	net/wireless/cfg80211	EXPORT_SYMBOL	
++0xb2af19e1	snd_usbmidi_resume	sound/usb/snd-usbmidi-lib	EXPORT_SYMBOL	
++0x52348c07	ssb_bus_unregister	drivers/ssb/ssb	EXPORT_SYMBOL	
++0x623c6897	v4l2_m2m_fop_mmap	drivers/media/v4l2-core/v4l2-mem2mem	EXPORT_SYMBOL_GPL	
++0xa0437099	drm_gem_shmem_put_pages	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0x315220b7	drm_dp_read_sink_count_cap	drivers/gpu/drm/drm_kms_helper	EXPORT_SYMBOL	
++0x1c7a8dfc	virtio_transport_dgram_enqueue	net/vmw_vsock/vmw_vsock_virtio_transport_common	EXPORT_SYMBOL_GPL	
++0x7f0450af	lowpan_nhc_del	net/6lowpan/6lowpan	EXPORT_SYMBOL	
++0x4f816e9b	snd_pcm_format_big_endian	sound/core/snd-pcm	EXPORT_SYMBOL	
++0x4834e830	iio_read_channel_average_raw	drivers/iio/industrialio	EXPORT_SYMBOL_GPL	
++0xaf78f260	btrtl_free	drivers/bluetooth/btrtl	EXPORT_SYMBOL_GPL	
++0x050f6f42	mt2131_attach	drivers/media/tuners/mt2131	EXPORT_SYMBOL	
++0xd5966f43	cfg80211_abandon_assoc	net/wireless/cfg80211	EXPORT_SYMBOL	
++0x260c6f0b	cfg80211_cqm_pktloss_notify	net/wireless/cfg80211	EXPORT_SYMBOL	
++0xe5be1dd2	ip6_tnl_xmit_ctl	net/ipv6/ip6_tunnel	EXPORT_SYMBOL_GPL	
++0xd38d5dd4	ip6_sk_update_pmtu	net/ipv6/ipv6	EXPORT_SYMBOL_GPL	
++0xfdaef4e8	snd_soc_dapm_stream_stop	sound/soc/snd-soc-core	EXPORT_SYMBOL_GPL	
++0x30c37cc0	dm_bm_write_lock_zero	drivers/md/persistent-data/dm-persistent-data	EXPORT_SYMBOL_GPL	
++0xa78b16c4	au8522_get_state	drivers/media/dvb-frontends/au8522_common	EXPORT_SYMBOL	
++0xae07129b	rtl92c_phy_update_txpower_dbm	drivers/net/wireless/realtek/rtlwifi/rtl8192c/rtl8192c-common	EXPORT_SYMBOL	
++0xa320d3de	rtl_deinit_core	drivers/net/wireless/realtek/rtlwifi/rtlwifi	EXPORT_SYMBOL_GPL	
++0xfe7c6fd4	mt76x02u_mcu_fw_send_data	drivers/net/wireless/mediatek/mt76/mt76x02-usb	EXPORT_SYMBOL_GPL	
++0x65702bd6	drm_default_rgb_quant_range	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0x5407ae9e	drm_dp_get_dual_mode_type_name	drivers/gpu/drm/drm_kms_helper	EXPORT_SYMBOL	
++0x98170820	tpm2_get_cc_attrs_tbl	drivers/char/tpm/tpm	EXPORT_SYMBOL_GPL	
++0x851c747c	simd_aead_create	crypto/crypto_simd	EXPORT_SYMBOL_GPL	
++0x8786badb	ieee80211_reserve_tid	net/mac80211/mac80211	EXPORT_SYMBOL	
++0xe6c3886c	snd_soc_card_jack_new	sound/soc/snd-soc-core	EXPORT_SYMBOL_GPL	
++0x3948858c	v4l2_async_notifier_add_fwnode_remote_subdev	drivers/media/v4l2-core/videodev	EXPORT_SYMBOL_GPL	
++0x6a7cee09	vb2_expbuf	drivers/media/common/videobuf2/videobuf2-v4l2	EXPORT_SYMBOL_GPL	
++0x7257beee	lc_element_by_index	lib/lru_cache	EXPORT_SYMBOL	
++0x2cd60fc3	cfg80211_tx_mgmt_expired	net/wireless/cfg80211	EXPORT_SYMBOL	
++0x20e3a022	nf_ct_nat_ext_add	net/netfilter/nf_nat	EXPORT_SYMBOL_GPL	
++0xb56c878b	arizona_output_anc_src	sound/soc/codecs/snd-soc-arizona	EXPORT_SYMBOL_GPL	
++0x0eee68e2	iio_read_channel_raw	drivers/iio/industrialio	EXPORT_SYMBOL_GPL	
++0xbe94ac1c	vhost_enqueue_msg	drivers/vhost/vhost	EXPORT_SYMBOL_GPL	
++0xdf667ffe	ath9k_hw_startpcureceive	drivers/net/wireless/ath/ath9k/ath9k_hw	EXPORT_SYMBOL	
++0x0cc4b4b6	crc_ccitt_false	lib/crc-ccitt	EXPORT_SYMBOL	
++0x74dcbff6	bcma_host_pci_up	drivers/bcma/bcma	EXPORT_SYMBOL_GPL	
++0x4f6e9821	rdev_set_badblocks	drivers/md/md-mod	EXPORT_SYMBOL_GPL	
++0xd91319d6	raid6_gfmul	lib/raid6/raid6_pq	EXPORT_SYMBOL	
++0x2ece093b	l2tp_tunnel_get_session	net/l2tp/l2tp_core	EXPORT_SYMBOL_GPL	
++0x80223988	l2tp_tunnel_get	net/l2tp/l2tp_core	EXPORT_SYMBOL_GPL	
++0x4afb7a18	snd_midi_event_no_status	sound/core/seq/snd-seq-midi-event	EXPORT_SYMBOL	
++0x3971b4df	snd_ecards_limit	sound/core/snd	EXPORT_SYMBOL	
++0xba98a81d	btmrvl_send_module_cfg_cmd	drivers/bluetooth/btmrvl	EXPORT_SYMBOL_GPL	
++0x28cab10b	tda18271c2dd_attach	drivers/media/dvb-frontends/tda18271c2dd	EXPORT_SYMBOL_GPL	
++0x23f4d3a6	lnbh29_attach	drivers/media/dvb-frontends/lnbh29	EXPORT_SYMBOL	
++0xbfdd8165	unregister_gadget_item	drivers/usb/gadget/libcomposite	EXPORT_SYMBOL_GPL	
++0x0641307b	lc_destroy	lib/lru_cache	EXPORT_SYMBOL	
++0x7a224366	dib9000_get_slave_frontend	drivers/media/dvb-frontends/dib9000	EXPORT_SYMBOL	
++0xded000ef	dib9000_set_slave_frontend	drivers/media/dvb-frontends/dib9000	EXPORT_SYMBOL	
++0x44806e5b	drm_atomic_helper_resume	drivers/gpu/drm/drm_kms_helper	EXPORT_SYMBOL	
++0x55d3ca74	tpm_get_random	drivers/char/tpm/tpm	EXPORT_SYMBOL_GPL	
++0x18feb46b	nfc_targets_found	net/nfc/nfc	EXPORT_SYMBOL	
++0x4502c65a	asc2ax	net/ax25/ax25	EXPORT_SYMBOL	
++0xfe3d5865	ata_eh_freeze_port	drivers/ata/libata	EXPORT_SYMBOL_GPL	
++0xfb40daec	ds3000_attach	drivers/media/dvb-frontends/ds3000	EXPORT_SYMBOL	
++0xa5428c5b	dib0070_ctrl_agc_filter	drivers/media/dvb-frontends/dib0070	EXPORT_SYMBOL	
++0xc193d36f	i2c_bit_algo	drivers/i2c/algos/i2c-algo-bit	EXPORT_SYMBOL	
++0x7a6230d7	mt76x02_mac_set_beacon	drivers/net/wireless/mediatek/mt76/mt76x02-lib	EXPORT_SYMBOL_GPL	
++0xce88ae09	drm_gem_dumb_map_offset	drivers/gpu/drm/drm	EXPORT_SYMBOL_GPL	
++0x9f72c6bf	snd_soc_of_parse_node_prefix	sound/soc/snd-soc-core	EXPORT_SYMBOL_GPL	
++0xace9b57b	dm_bio_prison_destroy_v2	drivers/md/dm-bio-prison	EXPORT_SYMBOL_GPL	
++0xcc54f845	video_device_alloc	drivers/media/v4l2-core/videodev	EXPORT_SYMBOL	
++0xc9350eb2	cryptd_alloc_aead	crypto/cryptd	EXPORT_SYMBOL_GPL	
++0xd384c683	p9stat_free	net/9p/9pnet	EXPORT_SYMBOL	
++0xf26bf693	ubi_do_get_device_info	drivers/mtd/ubi/ubi	EXPORT_SYMBOL_GPL	
++0xd6b89a22	ata_sff_prereset	drivers/ata/libata	EXPORT_SYMBOL_GPL	
++0xc54dd90e	dm_rh_inc_pending	drivers/md/dm-region-hash	EXPORT_SYMBOL_GPL	
++0x1f880b75	ath9k_hw_btcoex_init_scheme	drivers/net/wireless/ath/ath9k/ath9k_hw	EXPORT_SYMBOL	
++0xc5a0dd91	async_gen_syndrome	crypto/async_tx/async_pq	EXPORT_SYMBOL_GPL	
++0x58c88ff2	o2hb_get_all_regions	fs/ocfs2/cluster/ocfs2_nodemanager	EXPORT_SYMBOL_GPL	
++0xa57ccc38	addrconf_prefix_rcv_add_addr	net/ipv6/ipv6	EXPORT_SYMBOL_GPL	
++0xba030cba	ip_set_get_byname	net/netfilter/ipset/ip_set	EXPORT_SYMBOL_GPL	
++0x0dfc8f52	mtd_add_partition	drivers/mtd/mtd	EXPORT_SYMBOL_GPL	
++0xd302a14b	mt76_rx_poll_complete	drivers/net/wireless/mediatek/mt76/mt76	EXPORT_SYMBOL_GPL	
++0x346ac905	ath9k_hw_gen_timer_stop	drivers/net/wireless/ath/ath9k/ath9k_hw	EXPORT_SYMBOL	
++0x92e7c351	drm_gem_fb_simple_display_pipe_prepare_fb	drivers/gpu/drm/drm_kms_helper	EXPORT_SYMBOL	
++0xa645b5fc	iscsi_session_recovery_timedout	drivers/scsi/libiscsi	EXPORT_SYMBOL_GPL	
++0x3822a4da	drm_atomic_set_mode_for_crtc	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0x0cf00a32	snd_rawmidi_new	sound/core/snd-rawmidi	EXPORT_SYMBOL	
++0xae7d6424	spk_ttyio_release	drivers/accessibility/speakup/speakup	EXPORT_SYMBOL_GPL	
++0xd8aa4284	dm_rh_region_context	drivers/md/dm-region-hash	EXPORT_SYMBOL_GPL	
++0x97f05281	ath9k_hw_updatetxtriglevel	drivers/net/wireless/ath/ath9k/ath9k_hw	EXPORT_SYMBOL	
++0x285ea3f8	ovs_netdev_tunnel_destroy	net/openvswitch/openvswitch	EXPORT_SYMBOL_GPL	
++0x9feaf287	sonet_subtract_stats	net/atm/atm	EXPORT_SYMBOL	
++0x7bce4603	xt_data_to_user	net/netfilter/x_tables	EXPORT_SYMBOL_GPL	
++0x46b291ce	nf_flow_rule_route_ipv6	net/netfilter/nf_flow_table	EXPORT_SYMBOL_GPL	
++0xb203f602	nf_flow_rule_route_ipv4	net/netfilter/nf_flow_table	EXPORT_SYMBOL_GPL	
++0x82915ea7	nf_conntrack_free	net/netfilter/nf_conntrack	EXPORT_SYMBOL_GPL	
++0x4b5fd49e	dm_kcopyd_do_callback	drivers/md/dm-mod	EXPORT_SYMBOL	
++0xf39bd7c6	is_fw_load	drivers/media/usb/cx231xx/cx231xx	EXPORT_SYMBOL_GPL	
++0x199204d5	macvlan_common_newlink	drivers/net/macvlan	EXPORT_SYMBOL_GPL	
++0x31b8e01e	mt76_tx_complete_skb	drivers/net/wireless/mediatek/mt76/mt76	EXPORT_SYMBOL_GPL	
++0x788b2a11	drm_dp_downstream_debug	drivers/gpu/drm/drm_kms_helper	EXPORT_SYMBOL	
++0xe5fc3812	atalk_find_dev_addr	net/appletalk/appletalk	EXPORT_SYMBOL	
++0x20679900	cfg80211_sched_scan_stopped	net/wireless/cfg80211	EXPORT_SYMBOL	
++0x2adee13f	dm_btree_cursor_next	drivers/md/persistent-data/dm-persistent-data	EXPORT_SYMBOL_GPL	
++0xbbb5df05	dm_array_cursor_skip	drivers/md/persistent-data/dm-persistent-data	EXPORT_SYMBOL_GPL	
++0xd4d15d49	drm_sched_init	drivers/gpu/drm/scheduler/gpu-sched	EXPORT_SYMBOL	
++0x0fd60df2	drm_get_connector_status_name	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0xf16a2f20	drm_gem_object_release	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0xd9334dad	cfg80211_get_bss	net/wireless/cfg80211	EXPORT_SYMBOL	
++0x7176d989	bmp280_common_probe	drivers/iio/pressure/bmp280	EXPORT_SYMBOL	
++0xc6d93103	vhost_add_used_and_signal	drivers/vhost/vhost	EXPORT_SYMBOL_GPL	
++0x1cfc110f	ahci_init_controller	drivers/ata/libahci	EXPORT_SYMBOL_GPL	
++0xf16ef22c	sata_std_hardreset	drivers/ata/libata	EXPORT_SYMBOL_GPL	
++0xc96e47ef	md_run	drivers/md/md-mod	EXPORT_SYMBOL_GPL	
++0x5981ca1e	__media_pipeline_start	drivers/media/mc/mc	EXPORT_SYMBOL_GPL	
++0x1ecff3d0	drm_property_add_enum	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0xad885165	drm_bus_flags_from_videomode	drivers/gpu/drm/drm	EXPORT_SYMBOL_GPL	
++0x838061af	__drm_atomic_helper_plane_destroy_state	drivers/gpu/drm/drm_kms_helper	EXPORT_SYMBOL	
++0xb77201de	drm_helper_resume_force_mode	drivers/gpu/drm/drm_kms_helper	EXPORT_SYMBOL	
++0x4ea1808a	hci_conn_switch_role	net/bluetooth/bluetooth	EXPORT_SYMBOL	
++0x15bafe29	unregister_md_cluster_operations	drivers/md/md-mod	EXPORT_SYMBOL	
++0xa9cb786a	mwifiex_fw_dump_event	drivers/net/wireless/marvell/mwifiex/mwifiex	EXPORT_SYMBOL_GPL	
++0x35afae24	__drm_puts_seq_file	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0x64fbcbad	drm_fb_helper_init	drivers/gpu/drm/drm_kms_helper	EXPORT_SYMBOL	
++0x73011db0	drm_dp_bw_code_to_link_rate	drivers/gpu/drm/drm_kms_helper	EXPORT_SYMBOL	
++0x05e4fe67	ata_ncq_sdev_attrs	drivers/ata/libata	EXPORT_SYMBOL_GPL	
++0x228f2809	mt76x02_rx_poll_complete	drivers/net/wireless/mediatek/mt76/mt76x02-lib	EXPORT_SYMBOL_GPL	
++0x9cab34a6	rfkill_set_led_trigger_name	net/rfkill/rfkill	EXPORT_SYMBOL	
++0xaa6f23ad	rfkill_get_led_trigger_name	net/rfkill/rfkill	EXPORT_SYMBOL	
++0xe6c2accc	vhost_signal	drivers/vhost/vhost	EXPORT_SYMBOL_GPL	
++0xca604a21	usb_serial_generic_wait_until_sent	drivers/usb/serial/usbserial	EXPORT_SYMBOL_GPL	
++0xd74e2959	l2tp_session_set_header_len	net/l2tp/l2tp_core	EXPORT_SYMBOL_GPL	
++0x7f599467	cfg80211_gtk_rekey_notify	net/wireless/cfg80211	EXPORT_SYMBOL	
++0xec8beba6	nf_ct_expect_hash	net/netfilter/nf_conntrack	EXPORT_SYMBOL_GPL	
++0x20a3d94b	p54_read_eeprom	drivers/net/wireless/intersil/p54/p54common	EXPORT_SYMBOL_GPL	
++0x6b1c205b	drm_color_lut_check	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0xdf61a500	br_multicast_list_adjacent	net/bridge/bridge	EXPORT_SYMBOL_GPL	
++0x85cf3124	cfg80211_probe_status	net/wireless/cfg80211	EXPORT_SYMBOL	
++0x29d4a9c6	line6_resume	sound/usb/line6/snd-usb-line6	EXPORT_SYMBOL_GPL	
++0xba7a8187	snd_timer_instance_free	sound/core/snd-timer	EXPORT_SYMBOL	
++0x1a0efb0c	snd_register_oss_device	sound/core/snd	EXPORT_SYMBOL	
++0x24a94b26	snd_info_get_line	sound/core/snd	EXPORT_SYMBOL	
++0xdb4a6ea0	mtd_point	drivers/mtd/mtd	EXPORT_SYMBOL_GPL	
++0x9d030ea5	ahci_qc_issue	drivers/ata/libahci	EXPORT_SYMBOL_GPL	
++0xdcd72b2c	v4l2_subdev_link_validate_default	drivers/media/v4l2-core/videodev	EXPORT_SYMBOL_GPL	
++0x36457c44	v4l2_ctrl_auto_cluster	drivers/media/v4l2-core/videodev	EXPORT_SYMBOL	
++0x2ce7da0c	v4l2_event_dequeue	drivers/media/v4l2-core/videodev	EXPORT_SYMBOL_GPL	
++0xc7412db5	em28xx_gpio_set	drivers/media/usb/em28xx/em28xx	EXPORT_SYMBOL_GPL	
++0x44a40288	nsh_pop	net/nsh/nsh	EXPORT_SYMBOL_GPL	
++0xc5d65807	snd_soc_dai_digital_mute	sound/soc/snd-soc-core	EXPORT_SYMBOL_GPL	
++0x2d2f5cd5	ms_sensors_reset	drivers/iio/common/ms_sensors/ms_sensors_i2c	EXPORT_SYMBOL	
++0xaa455b0f	gether_connect	drivers/usb/gadget/function/u_ether	EXPORT_SYMBOL_GPL	
++0xdb95e13c	rtl_action_proc	drivers/net/wireless/realtek/rtlwifi/rtlwifi	EXPORT_SYMBOL_GPL	
++0x929036ff	drm_i2c_encoder_restore	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0x59955a63	dib0090_set_tune_state	drivers/media/dvb-frontends/dib0090	EXPORT_SYMBOL	
++0x5bed3779	dib0090_get_tune_state	drivers/media/dvb-frontends/dib0090	EXPORT_SYMBOL	
++0xba4f5a31	drm_atomic_helper_swap_state	drivers/gpu/drm/drm_kms_helper	EXPORT_SYMBOL	
++0x0e27a2dd	ZSTD_initCCtx	lib/zstd/zstd_compress	EXPORT_SYMBOL	
++0x3c137f2a	fl6_merge_options	net/ipv6/ipv6	EXPORT_SYMBOL_GPL	
++0xbe7cb77c	rt2800_efuse_detect	drivers/net/wireless/ralink/rt2x00/rt2800lib	EXPORT_SYMBOL_GPL	
++0xd0f40599	nf_ct_l4proto_find	net/netfilter/nf_conntrack	EXPORT_SYMBOL_GPL	
++0x3fe34d75	snd_soc_component_write	sound/soc/snd-soc-core	EXPORT_SYMBOL_GPL	
++0xb657cbb2	spk_do_catch_up_unicode	drivers/accessibility/speakup/speakup	EXPORT_SYMBOL_GPL	
++0x943631ff	i2400m_tx_msg_get	drivers/net/wimax/i2400m/i2400m	EXPORT_SYMBOL_GPL	
++0x54303c77	drm_gem_prime_export	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0xf3b4d4ae	ip_set_alloc	net/netfilter/ipset/ip_set	EXPORT_SYMBOL_GPL	
++0x7b10e44b	videobuf_streamon	drivers/media/v4l2-core/videobuf-core	EXPORT_SYMBOL_GPL	
++0xda84e54d	mt76_mcu_msg_alloc	drivers/net/wireless/mediatek/mt76/mt76	EXPORT_SYMBOL_GPL	
++0xfd0f96e2	drm_sched_suspend_timeout	drivers/gpu/drm/scheduler/gpu-sched	EXPORT_SYMBOL	
++0xa003ef1b	drm_atomic_state_default_release	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0x84555a22	virtio_transport_release	net/vmw_vsock/vmw_vsock_virtio_transport_common	EXPORT_SYMBOL_GPL	
++0x5449a843	nfc_driver_failure	net/nfc/nfc	EXPORT_SYMBOL	
++0xcc4fad16	ubi_leb_read_sg	drivers/mtd/ubi/ubi	EXPORT_SYMBOL_GPL	
++0x90a4bc2f	dvb_frontend_suspend	drivers/media/dvb-core/dvb-core	EXPORT_SYMBOL	
++0x4099f919	tun_ptr_free	drivers/net/tun	EXPORT_SYMBOL_GPL	
++0x3bef2f73	iscsi_pool_init	drivers/scsi/libiscsi	EXPORT_SYMBOL_GPL	
++0x637ece65	cfg80211_report_obss_beacon_khz	net/wireless/cfg80211	EXPORT_SYMBOL	
++0xa9a6d178	dm_cell_error	drivers/md/dm-bio-prison	EXPORT_SYMBOL_GPL	
++0xb04f56ab	dm_bufio_read	drivers/md/dm-bufio	EXPORT_SYMBOL_GPL	
++0xd9b804f4	stv0297_attach	drivers/media/dvb-frontends/stv0297	EXPORT_SYMBOL	
++0xb6588ba6	ath_bus_type_strings	drivers/net/wireless/ath/ath	EXPORT_SYMBOL	
++0x4349ce63	register_mtd_chip_driver	drivers/mtd/chips/chipreg	EXPORT_SYMBOL	
++0xee4943b7	dm_bio_prison_free_cell_v2	drivers/md/dm-bio-prison	EXPORT_SYMBOL_GPL	
++0xe42bf3ee	dib9000_firmware_post_pll_init	drivers/media/dvb-frontends/dib9000	EXPORT_SYMBOL	
++0x098c5aab	mt76x0_mac_stop	drivers/net/wireless/mediatek/mt76/mt76x0/mt76x0-common	EXPORT_SYMBOL_GPL	
++0x314828e3	st_unregister	drivers/misc/ti-st/st_drv	EXPORT_SYMBOL_GPL	
++0xc5b372d0	drm_atomic_normalize_zpos	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0x27aa9adb	drm_fb_helper_sys_read	drivers/gpu/drm/drm_kms_helper	EXPORT_SYMBOL	
++0x93a148a9	snd_soc_dai_compr_get_metadata	sound/soc/snd-soc-core	EXPORT_SYMBOL_GPL	
++0x597b9706	snd_soc_dai_compr_set_metadata	sound/soc/snd-soc-core	EXPORT_SYMBOL_GPL	
++0xdbbe8741	deregister_mtd_parser	drivers/mtd/mtd	EXPORT_SYMBOL_GPL	
++0xb96a0d07	dm_rh_mark_nosync	drivers/md/dm-region-hash	EXPORT_SYMBOL_GPL	
++0xe10a42a2	dib3000mc_i2c_enumeration	drivers/media/dvb-frontends/dib3000mc	EXPORT_SYMBOL	
++0xed1c47a9	lowpan_register_netdevice	net/6lowpan/6lowpan	EXPORT_SYMBOL	
++0x640d2902	register_ip_vs_app	net/netfilter/ipvs/ip_vs	EXPORT_SYMBOL	
++0x36a34e58	dm_array_cursor_get_value	drivers/md/persistent-data/dm-persistent-data	EXPORT_SYMBOL_GPL	
++0xf2a353ac	v4l2_i2c_tuner_addrs	drivers/media/v4l2-core/videodev	EXPORT_SYMBOL_GPL	
++0xa441035d	ath9k_cmn_init_channels_rates	drivers/net/wireless/ath/ath9k/ath9k_common	EXPORT_SYMBOL	
++0xe32758e8	drmm_kfree	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0xedcf81ce	drm_dp_channel_eq_ok	drivers/gpu/drm/drm_kms_helper	EXPORT_SYMBOL	
++0x1fbc363d	fb_sys_write	drivers/video/fbdev/core/fb_sys_fops	EXPORT_SYMBOL_GPL	
++0xdfecde7e	fuse_dev_alloc_install	fs/fuse/fuse	EXPORT_SYMBOL_GPL	
++0xa094f1e8	sata_scr_write	drivers/ata/libata	EXPORT_SYMBOL_GPL	
++0x69403abb	usb_composite_overwrite_options	drivers/usb/gadget/libcomposite	EXPORT_SYMBOL_GPL	
++0xeef14d8c	drm_format_info_block_height	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0x99e8dc51	nf_reject_ip6_tcphdr_put	net/ipv6/netfilter/nf_reject_ipv6	EXPORT_SYMBOL_GPL	
++0xeb8f4955	asoc_simple_init_priv	sound/soc/generic/snd-soc-simple-card-utils	EXPORT_SYMBOL_GPL	
++0x2ffdaf51	ahci_pmp_retry_srst_ops	drivers/ata/libahci	EXPORT_SYMBOL_GPL	
++0xaf3e5e47	cec_received_msg_ts	drivers/media/cec/core/cec	EXPORT_SYMBOL_GPL	
++0x6ec8bd90	dvb_ringbuffer_read_user	drivers/media/dvb-core/dvb-core	EXPORT_SYMBOL	
++0x2bdccddf	mt76x2_read_rx_gain	drivers/net/wireless/mediatek/mt76/mt76x2/mt76x2-common	EXPORT_SYMBOL_GPL	
++0x1a411479	drm_syncobj_free	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0xbd1004fe	usb_string_ids_n	drivers/usb/gadget/libcomposite	EXPORT_SYMBOL_GPL	
++0xceaefd81	rtl_cmd_send_packet	drivers/net/wireless/realtek/rtlwifi/rtlwifi	EXPORT_SYMBOL	
++0x1902b865	ar9003_hw_bb_watchdog_check	drivers/net/wireless/ath/ath9k/ath9k_hw	EXPORT_SYMBOL	
++0x92668805	vli_cmp	crypto/ecc	EXPORT_SYMBOL	
++0x8dcafc3f	virtio_transport_stream_enqueue	net/vmw_vsock/vmw_vsock_virtio_transport_common	EXPORT_SYMBOL_GPL	
++0x2cd778f0	vsock_remove_tap	net/vmw_vsock/vsock	EXPORT_SYMBOL_GPL	
++0xdd514a5b	ipv6_setsockopt	net/ipv6/ipv6	EXPORT_SYMBOL	
++0x2ec4a240	asoc_simple_be_hw_params_fixup	sound/soc/generic/snd-soc-simple-card-utils	EXPORT_SYMBOL_GPL	
++0xf12ea17d	del_mtd_blktrans_dev	drivers/mtd/mtd_blkdevs	EXPORT_SYMBOL_GPL	
++0xd6ffc03d	dm_kcopyd_zero	drivers/md/dm-mod	EXPORT_SYMBOL	
++0x306d9199	usb_serial_port_softint	drivers/usb/serial/usbserial	EXPORT_SYMBOL_GPL	
++0x2c2f07bd	drm_property_destroy	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0xa06b8f71	fwnode_usb_role_switch_get	drivers/usb/roles/roles	EXPORT_SYMBOL_GPL	
++0x579e9446	bt_sock_wait_ready	net/bluetooth/bluetooth	EXPORT_SYMBOL	
++0x1856159a	bt_sock_wait_state	net/bluetooth/bluetooth	EXPORT_SYMBOL	
++0x8cae8160	snd_soc_get_pcm_runtime	sound/soc/snd-soc-core	EXPORT_SYMBOL_GPL	
++0x86b4ddf7	tpg_reset_source	drivers/media/common/v4l2-tpg/v4l2-tpg	EXPORT_SYMBOL_GPL	
++0xff8de91d	drm_print_bits	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0x807d2b2c	xt_recseq	net/netfilter/x_tables	EXPORT_SYMBOL_GPL	
++0x885da61a	dm_hold	drivers/md/dm-mod	EXPORT_SYMBOL_GPL	
++0xf56238f4	v4l2_find_dv_timings_cea861_vic	drivers/media/v4l2-core/v4l2-dv-timings	EXPORT_SYMBOL_GPL	
++0xa63aa533	cx22700_attach	drivers/media/dvb-frontends/cx22700	EXPORT_SYMBOL	
++0xd02753dc	usbip_header_correct_endian	drivers/usb/usbip/usbip-core	EXPORT_SYMBOL_GPL	
++0xc8941839	rt2x00mac_set_key	drivers/net/wireless/ralink/rt2x00/rt2x00lib	EXPORT_SYMBOL_GPL	
++0x89b487de	iscsi_eh_session_reset	drivers/scsi/libiscsi	EXPORT_SYMBOL_GPL	
++0x5cfeb832	mipi_dbi_pipe_update	drivers/gpu/drm/drm_mipi_dbi	EXPORT_SYMBOL	
++0x3e9c8692	drm_i2c_encoder_destroy	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0xdfc782f1	ieee80211_sta_set_buffered	net/mac80211/mac80211	EXPORT_SYMBOL	
++0xbc6b7140	xt_request_find_target	net/netfilter/x_tables	EXPORT_SYMBOL_GPL	
++0xe67f908e	vb2_querybuf	drivers/media/common/videobuf2/videobuf2-v4l2	EXPORT_SYMBOL	
++0xa18a7395	hdlcdrv_register	drivers/net/hamradio/hdlcdrv	EXPORT_SYMBOL	
++0x4ed0a673	sctp_get_sctp_info	net/sctp/sctp	EXPORT_SYMBOL_GPL	
++0xd315b63f	br_ip6_fragment	net/ipv6/ipv6	EXPORT_SYMBOL_GPL	
++0x4c3d8738	dm_rh_delay	drivers/md/dm-region-hash	EXPORT_SYMBOL_GPL	
++0xdad12523	md_write_inc	drivers/md/md-mod	EXPORT_SYMBOL	
++0x0c524d55	register_md_personality	drivers/md/md-mod	EXPORT_SYMBOL	
++0x940d6cab	mddev_unlock	drivers/md/md-mod	EXPORT_SYMBOL_GPL	
++0x51977b76	v4l2_m2m_register_media_controller	drivers/media/v4l2-core/v4l2-mem2mem	EXPORT_SYMBOL_GPL	
++0x49b9b1ba	v4l2_m2m_next_buf	drivers/media/v4l2-core/v4l2-mem2mem	EXPORT_SYMBOL_GPL	
++0x3fa4a52b	dib3000mc_get_tuner_i2c_master	drivers/media/dvb-frontends/dib3000mc	EXPORT_SYMBOL	
++0x2293c33a	rt2800_pre_reset_hw	drivers/net/wireless/ralink/rt2x00/rt2800lib	EXPORT_SYMBOL_GPL	
++0x3d8e5894	cfg80211_chandef_compatible	net/wireless/cfg80211	EXPORT_SYMBOL	
++0xe5efddd6	ms_sensors_show_battery_low	drivers/iio/common/ms_sensors/ms_sensors_i2c	EXPORT_SYMBOL	
++0x18fd97b1	spk_synth_get_index	drivers/accessibility/speakup/speakup	EXPORT_SYMBOL_GPL	
++0x0b36102c	dm_array_empty	drivers/md/persistent-data/dm-persistent-data	EXPORT_SYMBOL_GPL	
++0x627204cf	go7007_update_board	drivers/media/usb/go7007/go7007	EXPORT_SYMBOL	
++0x354b6817	gether_disconnect	drivers/usb/gadget/function/u_ether	EXPORT_SYMBOL_GPL	
++0x5ddeb680	gether_set_gadget	drivers/usb/gadget/function/u_ether	EXPORT_SYMBOL_GPL	
++0xc7fc08fa	drm_sched_entity_destroy	drivers/gpu/drm/scheduler/gpu-sched	EXPORT_SYMBOL	
++0x713a679e	snd_soc_dapm_kcontrol_widget	sound/soc/snd-soc-core	EXPORT_SYMBOL_GPL	
++0xff6104d0	snd_pcm_rate_bit_to_rate	sound/core/snd-pcm	EXPORT_SYMBOL	
++0xc07be1d6	usb_assign_descriptors	drivers/usb/gadget/libcomposite	EXPORT_SYMBOL_GPL	
++0xdeebddb6	ath9k_hw_btcoex_enable	drivers/net/wireless/ath/ath9k/ath9k_hw	EXPORT_SYMBOL	
++0xc889753c	snd_ctl_get_preferred_subdevice	sound/core/snd	EXPORT_SYMBOL_GPL	
++0xbbce632a	ata_ehi_push_desc	drivers/ata/libata	EXPORT_SYMBOL_GPL	
++0x01d9064c	dib0090_pwm_gain_reset	drivers/media/dvb-frontends/dib0090	EXPORT_SYMBOL	
++0xdf28dd8b	usb_serial_generic_write_start	drivers/usb/serial/usbserial	EXPORT_SYMBOL_GPL	
++0x8a2a97fd	rt2800_get_key_seq	drivers/net/wireless/ralink/rt2x00/rt2800lib	EXPORT_SYMBOL_GPL	
++0xd6315f31	ecc_gen_privkey	crypto/ecc	EXPORT_SYMBOL	
++0xfaebc4ca	wimax_msg_data	net/wimax/wimax	EXPORT_SYMBOL_GPL	
++0xe3efb2ab	v4l2_m2m_streamon	drivers/media/v4l2-core/v4l2-mem2mem	EXPORT_SYMBOL_GPL	
++0xdf3f760d	drm_mm_scan_color_evict	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0x2663cb64	vsock_addr_equals_addr	net/vmw_vsock/vsock	EXPORT_SYMBOL_GPL	
++0x4d17609c	p9_client_mkdir_dotl	net/9p/9pnet	EXPORT_SYMBOL	
++0x018f8d2d	p9_client_mknod_dotl	net/9p/9pnet	EXPORT_SYMBOL	
++0x337f2432	l2tp_nl_unregister_ops	net/l2tp/l2tp_netlink	EXPORT_SYMBOL_GPL	
++0x889818c7	bt_sock_stream_recvmsg	net/bluetooth/bluetooth	EXPORT_SYMBOL	
++0xafddd545	ata_id_c_string	drivers/ata/libata	EXPORT_SYMBOL_GPL	
++0xaec656ba	au8522_init	drivers/media/dvb-frontends/au8522_common	EXPORT_SYMBOL	
++0xa4a277bf	dib0090_dcc_freq	drivers/media/dvb-frontends/dib0090	EXPORT_SYMBOL	
++0xe705d08d	sp8870_attach	drivers/media/dvb-frontends/sp8870	EXPORT_SYMBOL	
++0x7bc6a4f0	mwifiex_enable_hs	drivers/net/wireless/marvell/mwifiex/mwifiex	EXPORT_SYMBOL_GPL	
++0x59b0ffe8	ath9k_hw_gettxbuf	drivers/net/wireless/ath/ath9k/ath9k_hw	EXPORT_SYMBOL	
++0xc00b0220	drm_syncobj_replace_fence	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0x1e7942c5	sctp_for_each_endpoint	net/sctp/sctp	EXPORT_SYMBOL_GPL	
++0xaca4e34e	cfg80211_pmsr_complete	net/wireless/cfg80211	EXPORT_SYMBOL_GPL	
++0x15a37cf3	cfg80211_calculate_bitrate	net/wireless/cfg80211	EXPORT_SYMBOL	
++0x0c29616b	ip_tunnel_get_iflink	net/ipv4/ip_tunnel	EXPORT_SYMBOL	
++0xf5ee9ba8	ubi_register_volume_notifier	drivers/mtd/ubi/ubi	EXPORT_SYMBOL_GPL	
++0xb3693613	mt76_alloc_phy	drivers/net/wireless/mediatek/mt76/mt76	EXPORT_SYMBOL_GPL	
++0x57c21e4d	drm_property_create	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0xd8ab1bad	nf_ct_gre_keymap_destroy	net/netfilter/nf_conntrack	EXPORT_SYMBOL_GPL	
++0x7fcb929a	arizona_sample_rate_val_to_name	sound/soc/codecs/snd-soc-arizona	EXPORT_SYMBOL_GPL	
++0xb2309abd	si470x_set_freq	drivers/media/radio/si470x/radio-si470x-common	EXPORT_SYMBOL_GPL	
++0x289d01e2	mt2266_attach	drivers/media/tuners/mt2266	EXPORT_SYMBOL	
++0x10bcc1ca	esp6_output_head	net/ipv6/esp6	EXPORT_SYMBOL_GPL	
++0x6b7499e4	nfnetlink_subsys_register	net/netfilter/nfnetlink	EXPORT_SYMBOL_GPL	
++0x1d11db52	snd_pcm_lib_free_vmalloc_buffer	sound/core/snd-pcm	EXPORT_SYMBOL	
++0x3ca39c3e	vb2_thread_stop	drivers/media/common/videobuf2/videobuf2-common	EXPORT_SYMBOL_GPL	
++0x62594fe1	ath9k_hw_gen_timer_start	drivers/net/wireless/ath/ath9k/ath9k_hw	EXPORT_SYMBOL	
++0x19563910	drm_dp_mst_topology_mgr_destroy	drivers/gpu/drm/drm_kms_helper	EXPORT_SYMBOL	
++0x5ed1b21e	br_fdb_clear_offload	net/bridge/bridge	EXPORT_SYMBOL_GPL	
++0x3e5d3f5d	nf_conncount_destroy	net/netfilter/nf_conncount	EXPORT_SYMBOL_GPL	
++0x6ce9b467	pie_calculate_probability	net/sched/sch_pie	EXPORT_SYMBOL_GPL	
++0x688d422d	dm_bm_block_size	drivers/md/persistent-data/dm-persistent-data	EXPORT_SYMBOL_GPL	
++0x0ad0dc4f	dm_bufio_mark_buffer_dirty	drivers/md/dm-bufio	EXPORT_SYMBOL_GPL	
++0xb351f1ca	dib9000_get_i2c_master	drivers/media/dvb-frontends/dib9000	EXPORT_SYMBOL	
++0x8ee5cbf2	gspca_dev_probe	drivers/media/usb/gspca/gspca_main	EXPORT_SYMBOL	
++0xcf788629	gether_setup_name	drivers/usb/gadget/function/u_ether	EXPORT_SYMBOL_GPL	
++0x0a726931	ocfs2_cluster_this_node	fs/ocfs2/ocfs2_stackglue	EXPORT_SYMBOL_GPL	
++0x8c5a4a7d	p9_client_destroy	net/9p/9pnet	EXPORT_SYMBOL	
++0x242cffd9	nf_log_dump_packet_common	net/netfilter/nf_log_common	EXPORT_SYMBOL_GPL	
++0x2eb866ff	btrtl_download_firmware	drivers/bluetooth/btrtl	EXPORT_SYMBOL_GPL	
++0x729b9816	mmal_vchi_buffer_cleanup	drivers/staging/vc04_services/vchiq-mmal/bcm2835-mmal-vchiq	EXPORT_SYMBOL_GPL	
++0x843e1342	iscsi_target_alloc	drivers/scsi/libiscsi	EXPORT_SYMBOL_GPL	
++0x8f3a46b1	iio_trigger_alloc	drivers/iio/industrialio	EXPORT_SYMBOL	
++0xdacd170e	mt76_tx_status_unlock	drivers/net/wireless/mediatek/mt76/mt76	EXPORT_SYMBOL_GPL	
++0x16a2a154	lbs_resume	drivers/net/wireless/marvell/libertas/libertas	EXPORT_SYMBOL_GPL	
++0xc5634064	ath6kl_read_tgt_stats	drivers/net/wireless/ath/ath6kl/ath6kl_core	EXPORT_SYMBOL	
++0xf5add10e	ata_bmdma32_port_ops	drivers/ata/libata	EXPORT_SYMBOL_GPL	
++0xc493c28a	sata_scr_valid	drivers/ata/libata	EXPORT_SYMBOL_GPL	
++0x107ac2e4	isl6421_attach	drivers/media/dvb-frontends/isl6421	EXPORT_SYMBOL	
++0x04cfcca5	md_bitmap_cond_end_sync	drivers/md/md-mod	EXPORT_SYMBOL	
++0xe95131bf	vb2_thread_start	drivers/media/common/videobuf2/videobuf2-common	EXPORT_SYMBOL_GPL	
++0xe89dc424	gserial_alloc_line_no_console	drivers/usb/gadget/function/u_serial	EXPORT_SYMBOL_GPL	
++0xf2346882	ath6kl_core_cleanup	drivers/net/wireless/ath/ath6kl/ath6kl_core	EXPORT_SYMBOL	
++0xf3a1fad0	usb_serial_generic_process_read_urb	drivers/usb/serial/usbserial	EXPORT_SYMBOL_GPL	
++0x8767cba3	rt2x00mac_rfkill_poll	drivers/net/wireless/ralink/rt2x00/rt2x00lib	EXPORT_SYMBOL_GPL	
++0x648d953b	drm_dsc_dp_pps_header_init	drivers/gpu/drm/drm_kms_helper	EXPORT_SYMBOL	
++0x37362f01	snd_soc_register_card	sound/soc/snd-soc-core	EXPORT_SYMBOL_GPL	
++0x7b8699eb	snd_seq_event_port_detach	sound/core/seq/snd-seq	EXPORT_SYMBOL	
++0x5ab8f93e	ssb_device_enable	drivers/ssb/ssb	EXPORT_SYMBOL	
++0xa6170019	v4l2_ctrl_new_std_compound	drivers/media/v4l2-core/videodev	EXPORT_SYMBOL	
++0xe76b81ef	drm_encoder_init	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0x47541c00	vsock_stream_has_data	net/vmw_vsock/vsock	EXPORT_SYMBOL_GPL	
++0x54faa860	l2tp_udp_encap_recv	net/l2tp/l2tp_core	EXPORT_SYMBOL_GPL	
++0x74710628	garp_unregister_application	net/802/garp	EXPORT_SYMBOL_GPL	
++0xe5593b5b	ata_host_alloc_pinfo	drivers/ata/libata	EXPORT_SYMBOL_GPL	
++0xcb99053b	rtl_ops	drivers/net/wireless/realtek/rtlwifi/rtlwifi	EXPORT_SYMBOL_GPL	
++0x47ea1367	rt2800_probe_hw	drivers/net/wireless/ralink/rt2x00/rt2800lib	EXPORT_SYMBOL_GPL	
++0xa37faf3a	btmrvl_interrupt	drivers/bluetooth/btmrvl	EXPORT_SYMBOL_GPL	
++0x1090668d	ata_sff_qc_fill_rtf	drivers/ata/libata	EXPORT_SYMBOL_GPL	
++0xe4ce80c3	mxl5007t_attach	drivers/media/tuners/mxl5007t	EXPORT_SYMBOL_GPL	
++0x1a508e9a	snd_ctl_remove	sound/core/snd	EXPORT_SYMBOL	
++0x7ddb8db4	ata_pci_remove_one	drivers/ata/libata	EXPORT_SYMBOL_GPL	
++0x9213f5c3	drm_edid_to_speaker_allocation	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0xbf9d428a	snd_ctl_apply_vmaster_followers	sound/core/snd	EXPORT_SYMBOL_GPL	
++0xabcd0e97	drm_dev_printk	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0x5a89e873	drm_connector_attach_content_type_property	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0x97d73d89	drm_i2c_encoder_mode_set	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0xefc32a9b	neon_aes_xts_decrypt	arch/arm64/crypto/aes-neon-blk	EXPORT_SYMBOL	
++0xea11590c	neon_aes_xts_encrypt	arch/arm64/crypto/aes-neon-blk	EXPORT_SYMBOL	
++0x7e431c15	cordic_calc_iq	lib/math/cordic	EXPORT_SYMBOL	
++0x3e4d5509	ieee80211_send_eosp_nullfunc	net/mac80211/mac80211	EXPORT_SYMBOL	
++0xae316c11	icmpv6_err_convert	net/ipv6/ipv6	EXPORT_SYMBOL	
++0xd629eb04	snd_soc_get_dai_id	sound/soc/snd-soc-core	EXPORT_SYMBOL_GPL	
++0x42b6a050	ms_sensors_convert_and_read	drivers/iio/common/ms_sensors/ms_sensors_i2c	EXPORT_SYMBOL	
++0x77ffbf3a	cx24117_attach	drivers/media/dvb-frontends/cx24117	EXPORT_SYMBOL_GPL	
++0xdbc5583a	cx2341x_update	drivers/media/common/cx2341x	EXPORT_SYMBOL	
++0x8e85b394	vb2_plane_vaddr	drivers/media/common/videobuf2/videobuf2-common	EXPORT_SYMBOL_GPL	
++0xf32aaf5e	rt2800_write_beacon	drivers/net/wireless/ralink/rt2x00/rt2800lib	EXPORT_SYMBOL_GPL	
++0xc5540980	drm_bridge_connector_init	drivers/gpu/drm/drm_kms_helper	EXPORT_SYMBOL_GPL	
++0x30a49ade	lowpan_header_compress	net/6lowpan/6lowpan	EXPORT_SYMBOL_GPL	
++0xb05e2255	fib6_get_table	net/ipv6/ipv6	EXPORT_SYMBOL_GPL	
++0xaa915adb	inet_diag_find_one_icsk	net/ipv4/inet_diag	EXPORT_SYMBOL_GPL	
++0xa683ff53	drm_debugfs_remove_files	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0xbd2c31d5	adau1977_probe	sound/soc/codecs/snd-soc-adau1977	EXPORT_SYMBOL_GPL	
++0xd74db71c	mt76u_alloc_queues	drivers/net/wireless/mediatek/mt76/mt76-usb	EXPORT_SYMBOL_GPL	
++0x7b89b527	snd_card_add_dev_attr	sound/core/snd	EXPORT_SYMBOL_GPL	
++0xadf25837	videobuf_streamoff	drivers/media/v4l2-core/videobuf-core	EXPORT_SYMBOL_GPL	
++0x7b4dd2cb	cx2341x_fill_defaults	drivers/media/common/cx2341x	EXPORT_SYMBOL	
++0x1680570a	vb2_core_prepare_buf	drivers/media/common/videobuf2/videobuf2-common	EXPORT_SYMBOL_GPL	
++0x98debf6a	r820t_attach	drivers/media/tuners/r820t	EXPORT_SYMBOL_GPL	
++0x5b65a07d	hostap_init_data	drivers/net/wireless/intersil/hostap/hostap	EXPORT_SYMBOL	
++0x81992424	drm_edid_header_is_valid	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0xfb02d01d	drm_gtf_mode_complex	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0xf2b2ffaa	cfg80211_sched_scan_stopped_rtnl	net/wireless/cfg80211	EXPORT_SYMBOL	
++0x582a1ce5	nft_meta_set_init	net/netfilter/nf_tables	EXPORT_SYMBOL_GPL	
++0x2d3017c8	nft_meta_get_init	net/netfilter/nf_tables	EXPORT_SYMBOL_GPL	
++0x449157b4	ata_port_wait_eh	drivers/ata/libata	EXPORT_SYMBOL_GPL	
++0xa7eadcb5	btracker_complete	drivers/md/dm-cache	EXPORT_SYMBOL_GPL	
++0x7148a399	v4l2_ctrl_subscribe_event	drivers/media/v4l2-core/videodev	EXPORT_SYMBOL	
++0x2566fb6f	ppp_input	drivers/net/ppp/ppp_generic	EXPORT_SYMBOL	
++0x7e6fdbfc	curve25519_base_point	lib/crypto/libcurve25519-generic	EXPORT_SYMBOL	
++0x9e565341	devm_snd_soc_register_card	sound/soc/snd-soc-core	EXPORT_SYMBOL_GPL	
++0x9b3182ce	au8522_writereg	drivers/media/dvb-frontends/au8522_common	EXPORT_SYMBOL	
++0xbc4a83bf	u_audio_stop_playback	drivers/usb/gadget/function/u_audio	EXPORT_SYMBOL_GPL	
++0xd4dad9f3	mwifiex_alloc_dma_align_buf	drivers/net/wireless/marvell/mwifiex/mwifiex	EXPORT_SYMBOL_GPL	
++0xfb6c9094	nfc_register_device	net/nfc/nfc	EXPORT_SYMBOL	
++0xbf0f2670	l2tp_tunnel_get_nth	net/l2tp/l2tp_core	EXPORT_SYMBOL_GPL	
++0x44b5ca33	xt_hook_ops_alloc	net/netfilter/x_tables	EXPORT_SYMBOL_GPL	
++0x24451812	__tracepoint_vb2_buf_done	drivers/media/common/videobuf2/videobuf2-common	EXPORT_SYMBOL_GPL	
++0x91820a57	rtl_lps_leave	drivers/net/wireless/realtek/rtlwifi/rtlwifi	EXPORT_SYMBOL_GPL	
++0xff7a0fdf	eeprom_93cx6_multiread	drivers/misc/eeprom/eeprom_93cx6	EXPORT_SYMBOL_GPL	
++0x758b1a3f	drm_mode_crtc_set_gamma_size	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0x7ec3d6a7	garp_uninit_applicant	net/802/garp	EXPORT_SYMBOL_GPL	
++0xdf84d988	snd_soc_runtime_set_dai_fmt	sound/soc/snd-soc-core	EXPORT_SYMBOL_GPL	
++0x3e07361f	dev_attr_sw_activity	drivers/ata/libata	EXPORT_SYMBOL_GPL	
++0xa5399ed9	v4l2_m2m_create_bufs	drivers/media/v4l2-core/v4l2-mem2mem	EXPORT_SYMBOL_GPL	
++0x4e9a461c	cx231xx_uninit_isoc	drivers/media/usb/cx231xx/cx231xx	EXPORT_SYMBOL_GPL	
++0xa43ac88c	usb_composite_setup_continue	drivers/usb/gadget/libcomposite	EXPORT_SYMBOL_GPL	
++0xccdfd528	rndis_borrow_net	drivers/usb/gadget/function/usb_f_rndis	EXPORT_SYMBOL_GPL	
++0xd1e02497	ar9003_mci_get_next_gpm_offset	drivers/net/wireless/ath/ath9k/ath9k_hw	EXPORT_SYMBOL	
++0x87e2553b	ieee802154_max_payload	net/ieee802154/ieee802154	EXPORT_SYMBOL_GPL	
++0xb62fd17a	br_port_flag_is_set	net/bridge/bridge	EXPORT_SYMBOL_GPL	
++0xbb93f201	nf_flow_dnat_port	net/netfilter/nf_flow_table	EXPORT_SYMBOL_GPL	
++0x1f62163e	nf_flow_snat_port	net/netfilter/nf_flow_table	EXPORT_SYMBOL_GPL	
++0x25da3884	iio_enum_write	drivers/iio/industrialio	EXPORT_SYMBOL_GPL	
++0xe9299581	dm_block_manager_create	drivers/md/persistent-data/dm-persistent-data	EXPORT_SYMBOL_GPL	
++0x2fe02e11	as102_attach	drivers/media/dvb-frontends/as102_fe	EXPORT_SYMBOL_GPL	
++0x6efe8574	pcm512x_pm_ops	sound/soc/codecs/snd-soc-pcm512x	EXPORT_SYMBOL_GPL	
++0xf70fa1fe	snd_soc_dai_compr_shutdown	sound/soc/snd-soc-core	EXPORT_SYMBOL_GPL	
++0x11b83147	v4l2_fwnode_connector_add_link	drivers/media/v4l2-core/v4l2-fwnode	EXPORT_SYMBOL_GPL	
++0x6405dcd3	slhc_toss	drivers/net/slip/slhc	EXPORT_SYMBOL	
++0x364e9fc5	rtl_dm_diginit	drivers/net/wireless/realtek/rtlwifi/rtlwifi	EXPORT_SYMBOL	
++0x722585e1	mt76x02_mac_shared_key_setup	drivers/net/wireless/mediatek/mt76/mt76x02-lib	EXPORT_SYMBOL_GPL	
++0x9c725117	mt76_get_min_avg_rssi	drivers/net/wireless/mediatek/mt76/mt76	EXPORT_SYMBOL_GPL	
++0xbda4dd70	drm_gem_vm_close	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0x0e65c69a	fuse_conn_init	fs/fuse/fuse	EXPORT_SYMBOL_GPL	
++0xa1247034	ieee80211_remove_key	net/mac80211/mac80211	EXPORT_SYMBOL_GPL	
++0xa966749d	ieee80211_scan_completed	net/mac80211/mac80211	EXPORT_SYMBOL	
++0xc32cc061	go7007_read_addr	drivers/media/usb/go7007/go7007	EXPORT_SYMBOL	
++0xf37de163	tda829x_probe	drivers/media/tuners/tda8290	EXPORT_SYMBOL_GPL	
++0x0a520dc8	drm_kms_helper_poll_disable	drivers/gpu/drm/drm_kms_helper	EXPORT_SYMBOL	
++0x7a1211f8	dlm_setup_eviction_cb	fs/ocfs2/dlm/ocfs2_dlm	EXPORT_SYMBOL_GPL	
++0x3a56e39b	br_handle_frame_finish	net/bridge/bridge	EXPORT_SYMBOL_GPL	
++0xe204e042	xt_free_table_info	net/netfilter/x_tables	EXPORT_SYMBOL	
++0x6e994a9b	arizona_init_gpio	sound/soc/codecs/snd-soc-arizona	EXPORT_SYMBOL_GPL	
++0x9b9e07fd	bcma_pmu_get_bus_clock	drivers/bcma/bcma	EXPORT_SYMBOL_GPL	
++0xea50dad3	ahci_ignore_sss	drivers/ata/libahci	EXPORT_SYMBOL_GPL	
++0xff6f3769	ata_bmdma_setup	drivers/ata/libata	EXPORT_SYMBOL_GPL	
++0x0a6c4041	cn_netlink_send	drivers/connector/cn	EXPORT_SYMBOL_GPL	
++0x4c82d377	prism2_update_comms_qual	drivers/net/wireless/intersil/hostap/hostap	EXPORT_SYMBOL	
++0x990c5465	drm_property_create_blob	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0xc6e8e151	async_raid6_datap_recov	crypto/async_tx/async_raid6_recov	EXPORT_SYMBOL_GPL	
++0xd43ecbf1	null_ax25_address	net/ax25/ax25	EXPORT_SYMBOL	
++0x6df9bb42	asoc_simple_parse_daifmt	sound/soc/generic/snd-soc-simple-card-utils	EXPORT_SYMBOL_GPL	
++0xac608920	snd_soc_component_get_pin_status	sound/soc/snd-soc-core	EXPORT_SYMBOL_GPL	
++0x270d155e	snd_dma_alloc_pages_fallback	sound/core/snd-pcm	EXPORT_SYMBOL	
++0x89b9bfb3	drxk_attach	drivers/media/dvb-frontends/drxk	EXPORT_SYMBOL	
++0xa763e0f5	drxd_attach	drivers/media/dvb-frontends/drxd	EXPORT_SYMBOL	
++0xa5fefa8e	dvb_usbv2_probe	drivers/media/usb/dvb-usb-v2/dvb_usb_v2	EXPORT_SYMBOL	
++0x58a17884	p54_unregister_common	drivers/net/wireless/intersil/p54/p54common	EXPORT_SYMBOL_GPL	
++0x64f3da4a	rate_control_set_rates	net/mac80211/mac80211	EXPORT_SYMBOL	
++0x8cfacc9b	cfg80211_connect_done	net/wireless/cfg80211	EXPORT_SYMBOL	
++0xbb2ba58e	mt76x02_set_coverage_class	drivers/net/wireless/mediatek/mt76/mt76x02-lib	EXPORT_SYMBOL_GPL	
++0x19d669d2	iscsi_segment_seek_sg	drivers/scsi/libiscsi_tcp	EXPORT_SYMBOL_GPL	
++0x3ba17eab	drm_ht_insert_item	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0x05e41e4e	ipcomp_input	net/xfrm/xfrm_ipcomp	EXPORT_SYMBOL_GPL	
++0xbda14dfa	nft_reject_validate	net/netfilter/nft_reject	EXPORT_SYMBOL_GPL	
++0xb3501092	nat_h245_hook	net/netfilter/nf_conntrack_h323	EXPORT_SYMBOL_GPL	
++0x5083aa0a	snd_ctl_register_ioctl	sound/core/snd	EXPORT_SYMBOL	
++0xed3c5c7b	v4l2_m2m_ioctl_qbuf	drivers/media/v4l2-core/v4l2-mem2mem	EXPORT_SYMBOL_GPL	
++0x4add3b25	rndis_get_next_response	drivers/usb/gadget/function/usb_f_rndis	EXPORT_SYMBOL_GPL	
++0xe9133839	mt76x02_remove_interface	drivers/net/wireless/mediatek/mt76/mt76x02-lib	EXPORT_SYMBOL_GPL	
++0x6122d219	drm_vma_offset_remove	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0xeac9b99a	vli_from_le64	crypto/ecc	EXPORT_SYMBOL	
++0x16e410ff	vli_from_be64	crypto/ecc	EXPORT_SYMBOL	
++0x624e0eb3	virtio_transport_connect	net/vmw_vsock/vmw_vsock_virtio_transport_common	EXPORT_SYMBOL_GPL	
++0xcfd14140	inet6_sk_rebuild_header	net/ipv6/ipv6	EXPORT_SYMBOL_GPL	
++0xb1f5a31d	v4l2_event_queue	drivers/media/v4l2-core/videodev	EXPORT_SYMBOL_GPL	
++0x50b83e27	dib3000mc_set_config	drivers/media/dvb-frontends/dib3000mc	EXPORT_SYMBOL	
++0xac79f712	nf_ct_extend_register	net/netfilter/nf_conntrack	EXPORT_SYMBOL_GPL	
++0xeb8a5dcb	wm8804_regmap_config	sound/soc/codecs/snd-soc-wm8804	EXPORT_SYMBOL_GPL	
++0xb0351ec9	v4l2_clk_register	drivers/media/v4l2-core/videodev	EXPORT_SYMBOL	
++0x123959a1	v4l2_type_names	drivers/media/v4l2-core/videodev	EXPORT_SYMBOL	
++0x2e766b86	free_mdio_bitbang	drivers/net/mdio/mdio-bitbang	EXPORT_SYMBOL	
++0x84a7dda5	drm_gem_dmabuf_mmap	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0xb6d4a9eb	l2tp_session_get_nth	net/l2tp/l2tp_core	EXPORT_SYMBOL_GPL	
++0x296ccb0b	nf_nat_sip_hooks	net/netfilter/nf_conntrack_sip	EXPORT_SYMBOL_GPL	
++0xfd93482e	dm_rh_recovery_in_flight	drivers/md/dm-region-hash	EXPORT_SYMBOL_GPL	
++0x21261260	vb2_dma_contig_set_max_seg_size	drivers/media/common/videobuf2/videobuf2-dma-contig	EXPORT_SYMBOL_GPL	
++0xc3d536d7	ip6_sk_dst_lookup_flow	net/ipv6/ipv6	EXPORT_SYMBOL_GPL	
++0x60c352ac	__snd_usbmidi_create	sound/usb/snd-usbmidi-lib	EXPORT_SYMBOL	
++0xba11a045	cxd2841er_attach_s	drivers/media/dvb-frontends/cxd2841er	EXPORT_SYMBOL	
++0x5db4028c	brcmu_pktq_pdeq	drivers/net/wireless/broadcom/brcm80211/brcmutil/brcmutil	EXPORT_SYMBOL	
++0x6712b30d	brcmu_pktq_penq	drivers/net/wireless/broadcom/brcm80211/brcmutil/brcmutil	EXPORT_SYMBOL	
++0xb8ed1bd4	snd_timer_new	sound/core/snd-timer	EXPORT_SYMBOL	
++0x1cd53abd	dev_attr_em_message_type	drivers/ata/libata	EXPORT_SYMBOL_GPL	
++0x921d7c65	em28xx_boards	drivers/media/usb/em28xx/em28xx	EXPORT_SYMBOL_GPL	
++0x222cd9d0	mt76_txq_schedule	drivers/net/wireless/mediatek/mt76/mt76	EXPORT_SYMBOL_GPL	
++0x8d701329	drm_dp_clock_recovery_ok	drivers/gpu/drm/drm_kms_helper	EXPORT_SYMBOL	
++0x7eceff55	mt76x02_tx	drivers/net/wireless/mediatek/mt76/mt76x02-lib	EXPORT_SYMBOL_GPL	
++0x2b30f429	raid6_call	lib/raid6/raid6_pq	EXPORT_SYMBOL_GPL	
++0xd0932ec7	iio_trigger_notify_done	drivers/iio/industrialio	EXPORT_SYMBOL	
++0x43f56e82	ata_xfer_mode2shift	drivers/ata/libata	EXPORT_SYMBOL_GPL	
++0x82decbb8	v4l2_m2m_streamoff	drivers/media/v4l2-core/v4l2-mem2mem	EXPORT_SYMBOL_GPL	
++0x0b4d54f2	ath9k_hw_numtxpending	drivers/net/wireless/ath/ath9k/ath9k_hw	EXPORT_SYMBOL	
++0xb56d9c45	ieee80211_report_low_ack	net/mac80211/mac80211	EXPORT_SYMBOL	
++0xb62fc017	btintel_reset_to_bootloader	drivers/bluetooth/btintel	EXPORT_SYMBOL_GPL	
++0xa47a493e	drm_atomic_helper_disable_planes_on_crtc	drivers/gpu/drm/drm_kms_helper	EXPORT_SYMBOL	
++0x61f397b0	drm_dp_dpcd_read_link_status	drivers/gpu/drm/drm_kms_helper	EXPORT_SYMBOL	
++0x9f6efabd	vli_sub	crypto/ecc	EXPORT_SYMBOL	
++0xc3fcf7e0	esp_output_tail	net/ipv4/esp4	EXPORT_SYMBOL_GPL	
++0x13704aea	mtd_ooblayout_count_eccbytes	drivers/mtd/mtd	EXPORT_SYMBOL_GPL	
++0x215a8ec8	slhc_init	drivers/net/slip/slhc	EXPORT_SYMBOL	
++0x29537641	mt76_sta_pre_rcu_remove	drivers/net/wireless/mediatek/mt76/mt76	EXPORT_SYMBOL_GPL	
++0xbeac48e9	drm_dp_set_subconnector_property	drivers/gpu/drm/drm_kms_helper	EXPORT_SYMBOL	
++0x6185addc	af_alg_get_rsgl	crypto/af_alg	EXPORT_SYMBOL_GPL	
++0xd69901b0	nf_conntrack_helper_put	net/netfilter/nf_conntrack	EXPORT_SYMBOL_GPL	
++0x69255f54	snd_pcm_hw_limit_rates	sound/core/snd-pcm	EXPORT_SYMBOL	
++0x57e97aef	ath9k_hw_btcoex_init_3wire	drivers/net/wireless/ath/ath9k/ath9k_hw	EXPORT_SYMBOL	
++0xce5bad0c	ath9k_hw_gpio_request_in	drivers/net/wireless/ath/ath9k/ath9k_hw	EXPORT_SYMBOL	
++0xa88945ed	iscsi_verify_itt	drivers/scsi/libiscsi	EXPORT_SYMBOL_GPL	
++0x12812b76	ieee80211_beacon_update_cntdwn	net/mac80211/mac80211	EXPORT_SYMBOL	
++0xfb56bfbc	nf_send_unreach6	net/ipv6/netfilter/nf_reject_ipv6	EXPORT_SYMBOL_GPL	
++0x9480b264	esp_input_done2	net/ipv4/esp4	EXPORT_SYMBOL_GPL	
++0xc0fec227	snd_mpu401_uart_interrupt	sound/drivers/mpu401/snd-mpu401-uart	EXPORT_SYMBOL	
++0x756516e7	tpg_s_fourcc	drivers/media/common/v4l2-tpg/v4l2-tpg	EXPORT_SYMBOL_GPL	
++0x7ccf4112	rt2800_get_txwi_rxwi_size	drivers/net/wireless/ralink/rt2x00/rt2800lib	EXPORT_SYMBOL_GPL	
++0x6fdd5915	mt76_release_buffered_frames	drivers/net/wireless/mediatek/mt76/mt76	EXPORT_SYMBOL_GPL	
++0x30109384	mwifiex_reinit_sw	drivers/net/wireless/marvell/mwifiex/mwifiex	EXPORT_SYMBOL_GPL	
++0xc94be716	drm_plane_init	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0xb9cba57f	cast_s3	crypto/cast_common	EXPORT_SYMBOL_GPL	
++0xfbb3e20e	bt_sock_recvmsg	net/bluetooth/bluetooth	EXPORT_SYMBOL	
++0xe774f0ca	snd_soc_link_compr_set_params	sound/soc/snd-soc-core	EXPORT_SYMBOL_GPL	
++0xb365bfca	snd_timer_notify	sound/core/snd-timer	EXPORT_SYMBOL	
++0x6f30c5d2	l64781_attach	drivers/media/dvb-frontends/l64781	EXPORT_SYMBOL	
++0xabbbb380	usb_add_function	drivers/usb/gadget/libcomposite	EXPORT_SYMBOL_GPL	
++0x0cb7e477	usb_ep_autoconfig_release	drivers/usb/gadget/libcomposite	EXPORT_SYMBOL_GPL	
++0xa7e8b31e	ath_key_config	drivers/net/wireless/ath/ath	EXPORT_SYMBOL	
++0xa819e96e	tpm_tis_core_init	drivers/char/tpm/tpm_tis_core	EXPORT_SYMBOL_GPL	
++0xb14844c6	hci_mgmt_chan_register	net/bluetooth/bluetooth	EXPORT_SYMBOL	
++0x6f5fab40	devm_snd_soc_register_component	sound/soc/snd-soc-core	EXPORT_SYMBOL_GPL	
++0x578ec685	btintel_exit_mfg	drivers/bluetooth/btintel	EXPORT_SYMBOL_GPL	
++0xf299660d	snd_tea575x_enum_freq_bands	drivers/media/radio/tea575x	EXPORT_SYMBOL	
++0x7cf4b083	dvb_usb_nec_rc_key_to_event	drivers/media/usb/dvb-usb/dvb-usb	EXPORT_SYMBOL	
++0x48cdd8a7	i2400m_netdev_setup	drivers/net/wimax/i2400m/i2400m	EXPORT_SYMBOL_GPL	
++0x4dbf4623	drm_property_create_enum	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0x09f69483	drm_i2c_encoder_save	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0x5a4734d1	drm_kms_helper_is_poll_worker	drivers/gpu/drm/drm_kms_helper	EXPORT_SYMBOL	
++0x13131f0c	pcm179x_common_init	sound/soc/codecs/snd-soc-pcm179x-codec	EXPORT_SYMBOL_GPL	
++0x7c36ce0a	snd_rawmidi_transmit_peek	sound/core/snd-rawmidi	EXPORT_SYMBOL	
++0x6d498f77	video_devdata	drivers/media/v4l2-core/videodev	EXPORT_SYMBOL	
++0x57958d14	fsg_store_removable	drivers/usb/gadget/function/usb_f_mass_storage	EXPORT_SYMBOL_GPL	
++0x3c6a07d0	fsg_common_create_lun	drivers/usb/gadget/function/usb_f_mass_storage	EXPORT_SYMBOL_GPL	
++0x74bef890	drm_probe_ddc	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0xae476c4b	videobuf_queue_core_init	drivers/media/v4l2-core/videobuf-core	EXPORT_SYMBOL_GPL	
++0xcddf0021	v4l2_src_change_event_subdev_subscribe	drivers/media/v4l2-core/videodev	EXPORT_SYMBOL_GPL	
++0x988bede2	usbatm_usb_disconnect	drivers/usb/atm/usbatm	EXPORT_SYMBOL_GPL	
++0x2fe56dd3	ath9k_hw_set_txpowerlimit	drivers/net/wireless/ath/ath9k/ath9k_hw	EXPORT_SYMBOL	
++0x3a8063f3	drm_dp_dsc_sink_supported_input_bpcs	drivers/gpu/drm/drm_kms_helper	EXPORT_SYMBOL	
++0x3e701bce	drm_dp_downstream_is_tmds	drivers/gpu/drm/drm_kms_helper	EXPORT_SYMBOL	
++0x321c0c34	virtio_transport_inc_tx_pkt	net/vmw_vsock/vmw_vsock_virtio_transport_common	EXPORT_SYMBOL_GPL	
++0xfba9c8ef	snd_midi_event_reset_decode	sound/core/seq/snd-seq-midi-event	EXPORT_SYMBOL	
++0xb24ca9b3	md_do_sync	drivers/md/md-mod	EXPORT_SYMBOL_GPL	
++0xb4141611	snd_tea575x_set_freq	drivers/media/radio/tea575x	EXPORT_SYMBOL	
++0x8292ab40	usbnet_cdc_update_filter	drivers/net/usb/cdc_ether	EXPORT_SYMBOL_GPL	
++0x43382e94	drm_fb_helper_sys_imageblit	drivers/gpu/drm/drm_kms_helper	EXPORT_SYMBOL	
++0x2bd3680d	ieee80211_data_to_8023_exthdr	net/wireless/cfg80211	EXPORT_SYMBOL	
++0x932a6ffc	dm_tm_shadow_block	drivers/md/persistent-data/dm-persistent-data	EXPORT_SYMBOL_GPL	
++0xdd2bb958	v4l2_subdev_notify_event	drivers/media/v4l2-core/videodev	EXPORT_SYMBOL_GPL	
++0xd1b2dfe2	spi_bitbang_setup_transfer	drivers/spi/spi-bitbang	EXPORT_SYMBOL_GPL	
++0xadb68777	line6_init_midi	sound/usb/line6/snd-usb-line6	EXPORT_SYMBOL_GPL	
++0xa51fbedc	dm_bitset_new	drivers/md/persistent-data/dm-persistent-data	EXPORT_SYMBOL_GPL	
++0xb91ed44f	drm_vma_offset_manager_destroy	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0xad206d0e	__ieee80211_create_tpt_led_trigger	net/mac80211/mac80211	EXPORT_SYMBOL	
++0x6f39abd4	ata_pci_device_do_suspend	drivers/ata/libata	EXPORT_SYMBOL_GPL	
++0xfa728ce9	dvb_ringbuffer_flush_spinlock_wakeup	drivers/media/dvb-core/dvb-core	EXPORT_SYMBOL	
++0x6a140efc	sp887x_attach	drivers/media/dvb-frontends/sp887x	EXPORT_SYMBOL	
++0xf308214b	ppp_unregister_channel	drivers/net/ppp/ppp_generic	EXPORT_SYMBOL	
++0x90b8bde2	lbtf_cmd_response_rx	drivers/net/wireless/marvell/libertas_tf/libertas_tf	EXPORT_SYMBOL_GPL	
++0x2d20f030	ieee80211_amsdu_to_8023s	net/wireless/cfg80211	EXPORT_SYMBOL	
++0x73f3be9c	mt76x02_queue_rx_skb	drivers/net/wireless/mediatek/mt76/mt76x02-lib	EXPORT_SYMBOL_GPL	
++0xf9b56873	drm_atomic_helper_bridge_destroy_state	drivers/gpu/drm/drm_kms_helper	EXPORT_SYMBOL	
++0x8261eccb	ecc_get_curve25519	crypto/ecc	EXPORT_SYMBOL	
++0x1f099794	synproxy_init_timestamp_cookie	net/netfilter/nf_synproxy_core	EXPORT_SYMBOL_GPL	
++0x81b857b3	fbtft_write_spi_emulate_9	drivers/staging/fbtft/fbtft	EXPORT_SYMBOL	
++0x749e05f2	ledtrig_flash_ctrl	drivers/leds/trigger/ledtrig-camera	EXPORT_SYMBOL_GPL	
++0x09b0835a	cx231xx_uninit_vbi_isoc	drivers/media/usb/cx231xx/cx231xx	EXPORT_SYMBOL_GPL	
++0x54ec9daa	iscsi_session_setup	drivers/scsi/libiscsi	EXPORT_SYMBOL_GPL	
++0x3339b78f	cfg80211_new_sta	net/wireless/cfg80211	EXPORT_SYMBOL	
++0x3a6cf72d	ata_sff_freeze	drivers/ata/libata	EXPORT_SYMBOL_GPL	
++0x7b6ac78f	v4l2_phys_addr_validate	drivers/media/v4l2-core/v4l2-dv-timings	EXPORT_SYMBOL_GPL	
++0x0fe7e75d	line6_write_data	sound/usb/line6/snd-usb-line6	EXPORT_SYMBOL_GPL	
++0x22b39f9e	vb2_queue_init	drivers/media/common/videobuf2/videobuf2-v4l2	EXPORT_SYMBOL_GPL	
++0x72f70250	ath_rxbuf_alloc	drivers/net/wireless/ath/ath	EXPORT_SYMBOL	
++0x5f7985a5	drm_mm_scan_remove_block	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0x9aa0e1c8	crypto_nhpoly1305_final	crypto/nhpoly1305	EXPORT_SYMBOL	
++0x85dfd5b1	cfg80211_shutdown_all_interfaces	net/wireless/cfg80211	EXPORT_SYMBOL_GPL	
++0x977fd4bf	xt_alloc_table_info	net/netfilter/x_tables	EXPORT_SYMBOL	
++0xc4f48541	v4l2_fwnode_endpoint_alloc_parse	drivers/media/v4l2-core/v4l2-fwnode	EXPORT_SYMBOL_GPL	
++0x60989b92	s5h1420_attach	drivers/media/dvb-frontends/s5h1420	EXPORT_SYMBOL	
++0x1609266e	cx231xx_enable_i2c_port_3	drivers/media/usb/cx231xx/cx231xx	EXPORT_SYMBOL_GPL	
++0x22e1bc49	lbtf_rx	drivers/net/wireless/marvell/libertas_tf/libertas_tf	EXPORT_SYMBOL_GPL	
++0x72b62d7e	af_alg_wmem_wakeup	crypto/af_alg	EXPORT_SYMBOL_GPL	
++0x47874be1	ieee80211_register_hw	net/mac80211/mac80211	EXPORT_SYMBOL	
++0x599f01e6	l2cap_chan_connect	net/bluetooth/bluetooth	EXPORT_SYMBOL_GPL	
++0x8c4a2807	arizona_hp_ev	sound/soc/codecs/snd-soc-arizona	EXPORT_SYMBOL_GPL	
++0xa30ee713	arizona_in_ev	sound/soc/codecs/snd-soc-arizona	EXPORT_SYMBOL_GPL	
++0x3a4f6a32	ata_sff_interrupt	drivers/ata/libata	EXPORT_SYMBOL_GPL	
++0x48d1c7dc	dm_btree_find_lowest_key	drivers/md/persistent-data/dm-persistent-data	EXPORT_SYMBOL_GPL	
++0xd1620afd	drm_helper_crtc_in_use	drivers/gpu/drm/drm_kms_helper	EXPORT_SYMBOL	
++0x1d8f8d4d	tpm_pcr_extend	drivers/char/tpm/tpm	EXPORT_SYMBOL_GPL	
++0x751ff010	vsock_addr_unbind	net/vmw_vsock/vsock	EXPORT_SYMBOL_GPL	
++0x23ebd5fb	dm_bitset_set_bit	drivers/md/persistent-data/dm-persistent-data	EXPORT_SYMBOL_GPL	
++0xc5119e7d	cec_allocate_adapter	drivers/media/cec/core/cec	EXPORT_SYMBOL_GPL	
++0x4cc9a7a4	dvb_ca_en50221_frda_irq	drivers/media/dvb-core/dvb-core	EXPORT_SYMBOL	
++0xe2f927e7	em28xx_uninit_usb_xfer	drivers/media/usb/em28xx/em28xx	EXPORT_SYMBOL_GPL	
++0x6e30ba8e	drm_rect_rotate_inv	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0x98cf6c53	p9_is_proto_dotu	net/9p/9pnet	EXPORT_SYMBOL	
++0xeccfeaca	ieee80211_sta_register_airtime	net/mac80211/mac80211	EXPORT_SYMBOL	
++0x23ad593a	arizona_dai_ops	sound/soc/codecs/snd-soc-arizona	EXPORT_SYMBOL_GPL	
++0x20ed76b6	mb86a20s_attach	drivers/media/dvb-frontends/mb86a20s	EXPORT_SYMBOL	
++0x99fd20aa	drm_rect_clip_scaled	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0x25df0931	drm_self_refresh_helper_alter_state	drivers/gpu/drm/drm_kms_helper	EXPORT_SYMBOL	
++0x221e93cc	l2cap_chan_create	net/bluetooth/bluetooth	EXPORT_SYMBOL_GPL	
++0x55ed92b2	ip_tunnel_lookup	net/ipv4/ip_tunnel	EXPORT_SYMBOL_GPL	
++0x5101f640	snd_dmaengine_pcm_refine_runtime_hwparams	sound/core/snd-pcm-dmaengine	EXPORT_SYMBOL_GPL	
++0x6db5c873	__put_mtd_device	drivers/mtd/mtd	EXPORT_SYMBOL_GPL	
++0x1f6a4c3a	__get_mtd_device	drivers/mtd/mtd	EXPORT_SYMBOL_GPL	
++0xa905b3f9	mtd_wunit_to_pairing_info	drivers/mtd/mtd	EXPORT_SYMBOL_GPL	
++0x2911c6fc	ata_sff_thaw	drivers/ata/libata	EXPORT_SYMBOL_GPL	
++0x7c381a76	dm_bufio_get_block_size	drivers/md/dm-bufio	EXPORT_SYMBOL_GPL	
++0x0958448b	v4l2_set_edid_phys_addr	drivers/media/v4l2-core/v4l2-dv-timings	EXPORT_SYMBOL_GPL	
++0xd3ff04c0	media_create_intf_link	drivers/media/mc/mc	EXPORT_SYMBOL_GPL	
++0x20aa166d	tda10086_attach	drivers/media/dvb-frontends/tda10086	EXPORT_SYMBOL	
++0xb01797b8	dvb_usb_generic_write	drivers/media/usb/dvb-usb/dvb-usb	EXPORT_SYMBOL	
++0xde95b75f	ath9k_hw_resume_interrupts	drivers/net/wireless/ath/ath9k/ath9k_hw	EXPORT_SYMBOL	
++0x47e0ad82	drm_connector_set_path_property	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0x39e1255d	backlight_device_register	drivers/video/backlight/backlight	EXPORT_SYMBOL	
++0x98defa15	nf_ct_helper_log	net/netfilter/nf_conntrack	EXPORT_SYMBOL_GPL	
++0xc742d6e8	__tracepoint_vb2_v4l2_qbuf	drivers/media/v4l2-core/videodev	EXPORT_SYMBOL_GPL	
++0x3cb83d5b	eeprom_93cx6_multireadb	drivers/misc/eeprom/eeprom_93cx6	EXPORT_SYMBOL_GPL	
++0x1803a6ed	raid6_2data_recov	lib/raid6/raid6_pq	EXPORT_SYMBOL_GPL	
++0x0c906053	ieee80211_sta_ps_transition	net/mac80211/mac80211	EXPORT_SYMBOL	
++0xfac6ab3f	ieee80211_update_mu_groups	net/mac80211/mac80211	EXPORT_SYMBOL_GPL	
++0x98fa1e20	dm_get_reserved_rq_based_ios	drivers/md/dm-mod	EXPORT_SYMBOL_GPL	
++0xda49f0c9	ath9k_cmn_beacon_config_adhoc	drivers/net/wireless/ath/ath9k/ath9k_common	EXPORT_SYMBOL	
++0x70fd408c	drm_put_dev	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0xaf9b100c	drm_gem_vm_open	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0x0e957d78	drm_fb_helper_setcmap	drivers/gpu/drm/drm_kms_helper	EXPORT_SYMBOL	
++0x76676ed2	drm_panel_bridge_connector	drivers/gpu/drm/drm_kms_helper	EXPORT_SYMBOL	
++0xe4d23300	drm_lspcon_set_mode	drivers/gpu/drm/drm_kms_helper	EXPORT_SYMBOL	
++0x0cfd3fc5	ocfs2_cluster_connect_agnostic	fs/ocfs2/ocfs2_stackglue	EXPORT_SYMBOL_GPL	
++0x382459c7	ieee80211_find_sta_by_ifaddr	net/mac80211/mac80211	EXPORT_SYMBOL_GPL	
++0x7109a2e4	snd_soc_dapm_info_pin_switch	sound/soc/snd-soc-core	EXPORT_SYMBOL_GPL	
++0xc9a3422d	dm_bufio_write_dirty_buffers_async	drivers/md/dm-bufio	EXPORT_SYMBOL_GPL	
++0x5efafe98	md_rdev_clear	drivers/md/md-mod	EXPORT_SYMBOL_GPL	
++0xea2cdcf3	drm_bridge_hpd_disable	drivers/gpu/drm/drm	EXPORT_SYMBOL_GPL	
++0xacbf0c9a	vhost_poll_init	drivers/vhost/vhost	EXPORT_SYMBOL_GPL	
++0xd0cc2e18	charlcd_free	drivers/auxdisplay/charlcd	EXPORT_SYMBOL_GPL	
++0x6a7592fb	mtd_ooblayout_count_freebytes	drivers/mtd/mtd	EXPORT_SYMBOL_GPL	
++0x6e30004f	ata_scsi_port_error_handler	drivers/ata/libata	EXPORT_SYMBOL_GPL	
++0xf626dd03	v4l2_m2m_suspend	drivers/media/v4l2-core/v4l2-mem2mem	EXPORT_SYMBOL	
++0xbccec530	rtl_send_smps_action	drivers/net/wireless/realtek/rtlwifi/rtlwifi	EXPORT_SYMBOL	
++0x8d7fe9f2	cfg80211_report_wowlan_wakeup	net/wireless/cfg80211	EXPORT_SYMBOL	
++0xcd27eea5	snd_compr_malloc_pages	sound/core/snd-compress	EXPORT_SYMBOL	
++0x46d4c171	ms_sensors_read_serial	drivers/iio/common/ms_sensors/ms_sensors_i2c	EXPORT_SYMBOL	
++0xce28622b	ata_pci_device_do_resume	drivers/ata/libata	EXPORT_SYMBOL_GPL	
++0x55d40273	v4l2_m2m_update_stop_streaming_state	drivers/media/v4l2-core/v4l2-mem2mem	EXPORT_SYMBOL_GPL	
++0x652e3062	v4l2_fh_del	drivers/media/v4l2-core/videodev	EXPORT_SYMBOL_GPL	
++0x671f7aa5	ecc_is_key_valid	crypto/ecc	EXPORT_SYMBOL	
++0x894458f3	wm_adsp_fw_enum	sound/soc/codecs/snd-soc-wm-adsp	EXPORT_SYMBOL_GPL	
++0x2e9ca125	snd_ctl_rename_id	sound/core/snd	EXPORT_SYMBOL	
++0x19ab4ab7	ata_pci_sff_init_host	drivers/ata/libata	EXPORT_SYMBOL_GPL	
++0xf912bde8	cec_fill_conn_info_from_drm	drivers/media/cec/core/cec	EXPORT_SYMBOL_GPL	
++0x67648e04	rt2x00queue_unpause_queue	drivers/net/wireless/ralink/rt2x00/rt2x00lib	EXPORT_SYMBOL_GPL	
++0xdc63a338	rt2x00lib_txdone	drivers/net/wireless/ralink/rt2x00/rt2x00lib	EXPORT_SYMBOL_GPL	
++0x8d1f4e87	cryptd_aead_child	crypto/cryptd	EXPORT_SYMBOL_GPL	
++0x03aabf67	ip6_route_input_lookup	net/ipv6/ipv6	EXPORT_SYMBOL_GPL	
++0x58d5a0b5	gre_del_protocol	net/ipv4/gre	EXPORT_SYMBOL_GPL	
++0xc9b9e182	line6_pcm_acquire	sound/usb/line6/snd-usb-line6	EXPORT_SYMBOL_GPL	
++0x70543460	iio_get_debugfs_dentry	drivers/iio/industrialio	EXPORT_SYMBOL_GPL	
++0x6b07332a	bcma_core_dma_translation	drivers/bcma/bcma	EXPORT_SYMBOL	
++0x79f10568	mwifiex_deauthenticate_all	drivers/net/wireless/marvell/mwifiex/mwifiex	EXPORT_SYMBOL_GPL	
++0x630fcfd1	ath9k_hw_check_nav	drivers/net/wireless/ath/ath9k/ath9k_hw	EXPORT_SYMBOL	
++0xcbc24b19	drm_gem_private_object_init	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0x7a6ab8c7	devm_mux_chip_register	drivers/mux/mux-core	EXPORT_SYMBOL_GPL	
++0x58aad6fd	ata_sff_postreset	drivers/ata/libata	EXPORT_SYMBOL_GPL	
++0x7ac9aeab	ata_sas_port_resume	drivers/ata/libata	EXPORT_SYMBOL_GPL	
++0x30a956d7	rtl_query_rxpwrpercentage	drivers/net/wireless/realtek/rtlwifi/rtlwifi	EXPORT_SYMBOL	
++0x6ff66ff7	ath9k_hw_btcoex_disable	drivers/net/wireless/ath/ath9k/ath9k_hw	EXPORT_SYMBOL	
++0x5e904a70	__regmap_init_i2c	drivers/base/regmap/regmap-i2c	EXPORT_SYMBOL_GPL	
++0x3b556779	sys_imageblit	drivers/video/fbdev/core/sysimgblt	EXPORT_SYMBOL	
++0xb4f43b13	vsock_core_unregister	net/vmw_vsock/vsock	EXPORT_SYMBOL_GPL	
++0xd9c25654	nf_nat_masquerade_inet_unregister_notifiers	net/netfilter/nf_nat	EXPORT_SYMBOL_GPL	
++0x624a78b0	w1_touch_block	drivers/w1/wire	EXPORT_SYMBOL_GPL	
++0xfdc447f3	dibusb_dib3000mc_tuner_attach	drivers/media/usb/dvb-usb/dvb-usb-dibusb-mc-common	EXPORT_SYMBOL	
++0x15ac1bd0	cx2341x_ctrl_query	drivers/media/common/cx2341x	EXPORT_SYMBOL	
++0x8b918a4d	llc_mac_hdr_init	net/llc/llc	EXPORT_SYMBOL	
++0xf38bcdf3	nf_conntrack_max	net/netfilter/nf_conntrack	EXPORT_SYMBOL_GPL	
++0xc605106b	vb2_core_expbuf_dmabuf	drivers/media/common/videobuf2/videobuf2-common	EXPORT_SYMBOL_GPL	
++0xe42620e0	drm_mode_create_aspect_ratio_property	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0xb4e0a211	hci_conn_check_secure	net/bluetooth/bluetooth	EXPORT_SYMBOL	
++0xbb5b4e09	dm_put_table_device	drivers/md/dm-mod	EXPORT_SYMBOL	
++0x33f3f55f	dm_get_table_device	drivers/md/dm-mod	EXPORT_SYMBOL_GPL	
++0xecacee77	v4l2_m2m_buf_remove	drivers/media/v4l2-core/v4l2-mem2mem	EXPORT_SYMBOL_GPL	
++0x6d6038ce	video_unregister_device	drivers/media/v4l2-core/videodev	EXPORT_SYMBOL	
++0x32eb8529	dib7000m_get_i2c_master	drivers/media/dvb-frontends/dib7000m	EXPORT_SYMBOL	
++0x46c24170	rt2x00queue_get_entry	drivers/net/wireless/ralink/rt2x00/rt2x00lib	EXPORT_SYMBOL_GPL	
++0x21360133	rt2x00mac_get_antenna	drivers/net/wireless/ralink/rt2x00/rt2x00lib	EXPORT_SYMBOL_GPL	
++0xbe41c4e5	ath9k_hw_enable_interrupts	drivers/net/wireless/ath/ath9k/ath9k_hw	EXPORT_SYMBOL	
++0x1c9d61c8	ath9k_hw_write_associd	drivers/net/wireless/ath/ath9k/ath9k_hw	EXPORT_SYMBOL	
++0x3517dc34	drm_atomic_helper_dirtyfb	drivers/gpu/drm/drm_kms_helper	EXPORT_SYMBOL	
++0x32cbc7a3	nfc_add_se	net/nfc/nfc	EXPORT_SYMBOL	
++0x9c8592cf	nf_ct_seqadj_set	net/netfilter/nf_conntrack	EXPORT_SYMBOL_GPL	
++0xfd2b3e45	vhost_dev_reset_owner_prepare	drivers/vhost/vhost	EXPORT_SYMBOL_GPL	
++0x90a04502	rtl_get_tcb_desc	drivers/net/wireless/realtek/rtlwifi/rtlwifi	EXPORT_SYMBOL	
++0xd928afdc	drm_hdmi_avi_infoframe_from_display_mode	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0x8ef0f0e6	cfg80211_get_station	net/wireless/cfg80211	EXPORT_SYMBOL	
++0xd9d2bb03	snd_usbmidi_disconnect	sound/usb/snd-usbmidi-lib	EXPORT_SYMBOL	
++0x331ce916	snd_timer_continue	sound/core/snd-timer	EXPORT_SYMBOL	
++0x58199fd2	iio_get_time_res	drivers/iio/industrialio	EXPORT_SYMBOL	
++0x127a5901	drbd_set_st_err_str	drivers/block/drbd/drbd	EXPORT_SYMBOL	
++0x8cae3198	cs42xx8_probe	sound/soc/codecs/snd-soc-cs42xx8	EXPORT_SYMBOL_GPL	
++0xe273df29	dm_internal_resume	drivers/md/dm-mod	EXPORT_SYMBOL_GPL	
++0xd3a263f3	dvb_dmx_swfilter_raw	drivers/media/dvb-core/dvb-core	EXPORT_SYMBOL	
++0xf71c6bd0	dvb_dmx_swfilter_204	drivers/media/dvb-core/dvb-core	EXPORT_SYMBOL	
++0xe263c78a	mipi_dbi_poweron_conditional_reset	drivers/gpu/drm/drm_mipi_dbi	EXPORT_SYMBOL	
++0xb4933e28	nf_xfrm_me_harder	net/netfilter/nf_nat	EXPORT_SYMBOL	
++0x8abb776a	arizona_eq_coeff_put	sound/soc/codecs/snd-soc-arizona	EXPORT_SYMBOL_GPL	
++0xae753e57	v4l2_ctrl_request_setup	drivers/media/v4l2-core/videodev	EXPORT_SYMBOL	
++0x5ffb02db	ath9k_hw_beaconq_setup	drivers/net/wireless/ath/ath9k/ath9k_hw	EXPORT_SYMBOL	
++0x11369778	drm_i2c_encoder_prepare	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0x5bc47afd	snd_card_file_add	sound/core/snd	EXPORT_SYMBOL	
++0x24772bfe	dm_bufio_get	drivers/md/dm-bufio	EXPORT_SYMBOL_GPL	
++0x3aeecbbb	ttpci_eeprom_parse_mac	drivers/media/pci/ttpci/ttpci-eeprom	EXPORT_SYMBOL	
++0x28240e61	cx2341x_ctrl_get_menu	drivers/media/common/cx2341x	EXPORT_SYMBOL	
++0x70ad3a51	cdrom_dummy_generic_packet	drivers/cdrom/cdrom	EXPORT_SYMBOL	
++0x6c43d790	drm_connector_attach_dp_subconnector_property	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0x0f0414c7	snd_midi_event_new	sound/core/seq/snd-seq-midi-event	EXPORT_SYMBOL	
++0x2aac07d1	ata_cable_80wire	drivers/ata/libata	EXPORT_SYMBOL_GPL	
++0x89937b74	v4l2_m2m_ioctl_stateless_decoder_cmd	drivers/media/v4l2-core/v4l2-mem2mem	EXPORT_SYMBOL_GPL	
++0x57b6efe3	drm_ioctl_flags	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0x29a44ff0	drm_gem_fb_init_with_funcs	drivers/gpu/drm/drm_kms_helper	EXPORT_SYMBOL_GPL	
++0x0467b432	drm_helper_probe_detect	drivers/gpu/drm/drm_kms_helper	EXPORT_SYMBOL	
++0x8063db06	nf_nat_tftp_hook	net/netfilter/nf_conntrack_tftp	EXPORT_SYMBOL_GPL	
++0xda8c1caf	nf_nat_snmp_hook	net/netfilter/nf_conntrack_snmp	EXPORT_SYMBOL_GPL	
++0x90d33c29	get_h225_addr	net/netfilter/nf_conntrack_h323	EXPORT_SYMBOL_GPL	
++0x1b4aaba7	v4l2_ctrl_handler_free	drivers/media/v4l2-core/videodev	EXPORT_SYMBOL	
++0x83004020	dvb_usbv2_generic_rw_locked	drivers/media/usb/dvb-usb-v2/dvb_usb_v2	EXPORT_SYMBOL	
++0x411249f0	can_rx_offload_queue_tail	drivers/net/can/dev/can-dev	EXPORT_SYMBOL_GPL	
++0xd74bdd57	ath9k_cmn_beacon_config_ap	drivers/net/wireless/ath/ath9k/ath9k_common	EXPORT_SYMBOL	
++0x58d8fcaa	drm_dsc_pps_payload_pack	drivers/gpu/drm/drm_kms_helper	EXPORT_SYMBOL	
++0x2c92e736	ip6_tnl_parse_tlv_enc_lim	net/ipv6/ip6_tunnel	EXPORT_SYMBOL	
++0x0ac3c0cc	snd_soc_dapm_new_widgets	sound/soc/snd-soc-core	EXPORT_SYMBOL_GPL	
++0x81731f93	snd_info_create_module_entry	sound/core/snd	EXPORT_SYMBOL	
++0xc3744628	drm_plane_create_zpos_immutable_property	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0x1bea7792	l2cap_is_socket	net/bluetooth/bluetooth	EXPORT_SYMBOL	
++0x711a06de	ip6_route_lookup	net/ipv6/ipv6	EXPORT_SYMBOL_GPL	
++0xf3812d39	rtl_process_phyinfo	drivers/net/wireless/realtek/rtlwifi/rtlwifi	EXPORT_SYMBOL	
++0x3f3c58ca	mux_chip_unregister	drivers/mux/mux-core	EXPORT_SYMBOL_GPL	
++0x267c0508	iio_channel_release_all_cb	drivers/iio/buffer/industrialio-buffer-cb	EXPORT_SYMBOL_GPL	
++0x61809343	__v4l2_ctrl_handler_setup	drivers/media/v4l2-core/videodev	EXPORT_SYMBOL_GPL	
++0xbbdb5c42	smscore_unregister_client	drivers/media/common/siano/smsmdtv	EXPORT_SYMBOL_GPL	
++0x16c2c3c5	drm_gem_shmem_print_info	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0xf929f47a	drm_atomic_state_alloc	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0x41b71e65	nft_trace_enabled	net/netfilter/nf_tables	EXPORT_SYMBOL_GPL	
++0x63f083f7	snd_pcm_lib_get_vmalloc_page	sound/core/snd-pcm	EXPORT_SYMBOL	
++0xef8043de	iio_write_channel_ext_info	drivers/iio/industrialio	EXPORT_SYMBOL_GPL	
++0x6be9b6b4	v4l2_m2m_ioctl_streamon	drivers/media/v4l2-core/v4l2-mem2mem	EXPORT_SYMBOL_GPL	
++0x94df0961	rtl_init_core	drivers/net/wireless/realtek/rtlwifi/rtlwifi	EXPORT_SYMBOL_GPL	
++0x6c3d519f	rt2x00lib_suspend	drivers/net/wireless/ralink/rt2x00/rt2x00lib	EXPORT_SYMBOL_GPL	
++0xaf9a8cdc	of_drm_get_panel_orientation	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0x09a4ecaa	drm_gem_fb_prepare_fb	drivers/gpu/drm/drm_kms_helper	EXPORT_SYMBOL_GPL	
++0x171839d3	p9_client_open	net/9p/9pnet	EXPORT_SYMBOL	
++0xe4b1a7b3	nf_ct_tmpl_alloc	net/netfilter/nf_conntrack	EXPORT_SYMBOL_GPL	
++0x36b84cda	dm_array_del	drivers/md/persistent-data/dm-persistent-data	EXPORT_SYMBOL_GPL	
++0xb6d5c65d	dm_deferred_set_add_work	drivers/md/dm-bio-prison	EXPORT_SYMBOL_GPL	
++0x3b93d71a	dvb_frontend_sleep_until	drivers/media/dvb-core/dvb-core	EXPORT_SYMBOL	
++0xfff3fea2	media_entity_get_fwnode_pad	drivers/media/mc/mc	EXPORT_SYMBOL_GPL	
++0xe618e377	rndis_msg_parser	drivers/usb/gadget/function/usb_f_rndis	EXPORT_SYMBOL_GPL	
++0xfd4d8f79	ath9k_cmn_reload_chainmask	drivers/net/wireless/ath/ath9k/ath9k_common	EXPORT_SYMBOL	
++0x05411c52	fuse_direct_io	fs/fuse/fuse	EXPORT_SYMBOL_GPL	
++0x41a160e5	synth_buffer_empty	drivers/accessibility/speakup/speakup	EXPORT_SYMBOL_GPL	
++0x87c8a46f	v4l2_fh_release	drivers/media/v4l2-core/videodev	EXPORT_SYMBOL_GPL	
++0x82c3ca57	or51211_attach	drivers/media/dvb-frontends/or51211	EXPORT_SYMBOL	
++0xce2f7ad1	drm_flip_work_cleanup	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0x265cb0dd	drm_get_edid_switcheroo	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0x9b1798ba	async_memcpy	crypto/async_tx/async_memcpy	EXPORT_SYMBOL_GPL	
++0x33b866ce	crypto_ecdh_decode_key	crypto/ecdh_generic	EXPORT_SYMBOL_GPL	
++0xb230d2ec	crypto_ecdh_encode_key	crypto/ecdh_generic	EXPORT_SYMBOL_GPL	
++0x7c86b22f	cryptd_free_skcipher	crypto/cryptd	EXPORT_SYMBOL_GPL	
++0xc215e249	nfc_dep_link_is_up	net/nfc/nfc	EXPORT_SYMBOL	
++0xcf0c9e4d	llc_sap_open	net/llc/llc	EXPORT_SYMBOL	
++0x3949ce0a	rt2x00lib_beacondone	drivers/net/wireless/ralink/rt2x00/rt2x00lib	EXPORT_SYMBOL_GPL	
++0x9dbcd801	brcmu_dbg_hex_dump	drivers/net/wireless/broadcom/brcm80211/brcmutil/brcmutil	EXPORT_SYMBOL	
++0xc67473c0	fib6_rule_default	net/ipv6/ipv6	EXPORT_SYMBOL_GPL	
++0x4ba31b79	v4l2_g_ctrl	drivers/media/v4l2-core/videodev	EXPORT_SYMBOL	
++0x287afd01	rt2x00mac_set_antenna	drivers/net/wireless/ralink/rt2x00/rt2x00lib	EXPORT_SYMBOL_GPL	
++0x6e80043c	drm_atomic_helper_connector_destroy_state	drivers/gpu/drm/drm_kms_helper	EXPORT_SYMBOL	
++0xc840695d	ip6_tnl_encap_add_ops	net/ipv6/ip6_tunnel	EXPORT_SYMBOL	
++0xd87ae60d	xt_check_entry_offsets	net/netfilter/x_tables	EXPORT_SYMBOL	
++0x0e93f73b	arizona_anc_input_src	sound/soc/codecs/snd-soc-arizona	EXPORT_SYMBOL_GPL	
++0x6a163ad7	snd_soc_add_component	sound/soc/snd-soc-core	EXPORT_SYMBOL_GPL	
++0x77bb9dd2	snd_pcm_hw_constraint_integer	sound/core/snd-pcm	EXPORT_SYMBOL	
++0xa995fe6c	iscsi_boot_destroy_kset	drivers/scsi/iscsi_boot_sysfs	EXPORT_SYMBOL_GPL	
++0xba896c7b	iscsi_boot_create_initiator	drivers/scsi/iscsi_boot_sysfs	EXPORT_SYMBOL_GPL	
++0xd97f2a40	drm_gem_dmabuf_release	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0xb3f3fe93	snd_soc_dpcm_can_be_free_stop	sound/soc/snd-soc-core	EXPORT_SYMBOL_GPL	
++0xbc774dd8	si470x_start	drivers/media/radio/si470x/radio-si470x-common	EXPORT_SYMBOL_GPL	
++0xe565cc6e	dvb_ringbuffer_write_user	drivers/media/dvb-core/dvb-core	EXPORT_SYMBOL	
++0x5d405226	ath_hw_cycle_counters_update	drivers/net/wireless/ath/ath	EXPORT_SYMBOL	
++0x2754dad8	drm_mm_reserve_node	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0x9a22630d	drm_gem_fence_array_add	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0x8c73cdc6	__nf_nat_mangle_tcp_packet	net/netfilter/nf_nat	EXPORT_SYMBOL	
++0x46bcaff7	snd_dma_alloc_pages	sound/core/snd-pcm	EXPORT_SYMBOL	
++0xeb65f972	iio_device_unregister	drivers/iio/industrialio	EXPORT_SYMBOL	
++0xf0198612	mt76x02_dfs_init_params	drivers/net/wireless/mediatek/mt76/mt76x02-lib	EXPORT_SYMBOL_GPL	
++0x9343115e	hostap_remove_proc	drivers/net/wireless/intersil/hostap/hostap	EXPORT_SYMBOL	
++0xfcc647f9	drm_modeset_lock_all_ctx	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0xf78cb28d	ieee80211_beacon_cntdwn_is_complete	net/mac80211/mac80211	EXPORT_SYMBOL	
++0x2fb74ea2	ata_std_qc_defer	drivers/ata/libata	EXPORT_SYMBOL_GPL	
++0xec900ba6	v4l2_m2m_update_start_streaming_state	drivers/media/v4l2-core/v4l2-mem2mem	EXPORT_SYMBOL_GPL	
++0xc9818bd5	drm_gem_create_mmap_offset	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0x50feaf88	drm_helper_force_disable_all	drivers/gpu/drm/drm_kms_helper	EXPORT_SYMBOL	
++0xa9cba6bf	nfc_proto_register	net/nfc/nfc	EXPORT_SYMBOL	
++0x55197ae2	p9_req_put	net/9p/9pnet	EXPORT_SYMBOL	
++0xf28d90b4	snd_seq_event_port_attach	sound/core/seq/snd-seq	EXPORT_SYMBOL	
++0x1bc33cab	v4l2_g_ext_ctrls	drivers/media/v4l2-core/videodev	EXPORT_SYMBOL	
++0x1e5f9566	cdrom_release	drivers/cdrom/cdrom	EXPORT_SYMBOL	
++0xa289b6ea	rt2x00usb_vendor_req_buff_lock	drivers/net/wireless/ralink/rt2x00/rt2x00usb	EXPORT_SYMBOL_GPL	
++0xc8ed9614	mt76x0_config	drivers/net/wireless/mediatek/mt76/mt76x0/mt76x0-common	EXPORT_SYMBOL_GPL	
++0x8af13ce1	mwifiex_dnld_fw	drivers/net/wireless/marvell/mwifiex/mwifiex	EXPORT_SYMBOL_GPL	
++0x5a56989d	drm_gem_cma_create	drivers/gpu/drm/drm	EXPORT_SYMBOL_GPL	
++0x6fc61e07	drm_vblank_work_init	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0x1282ab5c	ip6_datagram_connect	net/ipv6/ipv6	EXPORT_SYMBOL_GPL	
++0x437eb1df	ipv6_mod_enabled	net/ipv6/ipv6	EXPORT_SYMBOL_GPL	
++0x4ef555a0	nf_conntrack_helper_try_module_get	net/netfilter/nf_conntrack	EXPORT_SYMBOL_GPL	
++0x05b6498d	h4_recv_buf	drivers/bluetooth/hci_uart	EXPORT_SYMBOL_GPL	
++0x2c435bcd	ata_pci_sff_init_one	drivers/ata/libata	EXPORT_SYMBOL_GPL	
++0x8178b6c7	spk_synth_is_alive_nop	drivers/accessibility/speakup/speakup	EXPORT_SYMBOL_GPL	
++0xb04eb493	mt76_tx_status_skb_get	drivers/net/wireless/mediatek/mt76/mt76	EXPORT_SYMBOL_GPL	
++0x635ff76d	LZ4_saveDict	lib/lz4/lz4_compress	EXPORT_SYMBOL	
++0xd702abfb	snd_soc_dai_compr_pointer	sound/soc/snd-soc-core	EXPORT_SYMBOL_GPL	
++0x1ea2e29e	v4l2_ctrl_poll	drivers/media/v4l2-core/videodev	EXPORT_SYMBOL	
++0x460a64a1	virtio_transport_shutdown	net/vmw_vsock/vmw_vsock_virtio_transport_common	EXPORT_SYMBOL_GPL	
++0x07727e3a	wimax_dev_rm	net/wimax/wimax	EXPORT_SYMBOL_GPL	
++0x0a687419	snd_rawmidi_kernel_write	sound/core/snd-rawmidi	EXPORT_SYMBOL	
++0x4c63b19c	gspca_disconnect	drivers/media/usb/gspca/gspca_main	EXPORT_SYMBOL	
++0x95ad86c1	fc0012_attach	drivers/media/tuners/fc0012	EXPORT_SYMBOL	
++0xd9c7847a	ftdi_elan_gone_away	drivers/usb/misc/ftdi-elan	EXPORT_SYMBOL_GPL	
++0x83e557f2	spi_bitbang_stop	drivers/spi/spi-bitbang	EXPORT_SYMBOL_GPL	
++0x8bf5f748	drm_syncobj_add_point	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0x4c48939e	tuners	drivers/media/tuners/tuner-types	EXPORT_SYMBOL	
++0xaff56b05	mt76x02_mcu_calibrate	drivers/net/wireless/mediatek/mt76/mt76x02-lib	EXPORT_SYMBOL_GPL	
++0xd6217d91	brcmu_d11_attach	drivers/net/wireless/broadcom/brcm80211/brcmutil/brcmutil	EXPORT_SYMBOL	
++0x5326836f	inv_mpu_core_probe	drivers/iio/imu/inv_mpu6050/inv-mpu6050	EXPORT_SYMBOL_GPL	
++0x204e7c35	usb_serial_generic_tiocmiwait	drivers/usb/serial/usbserial	EXPORT_SYMBOL_GPL	
++0x2dc2d26d	rtl92c_phy_set_io_cmd	drivers/net/wireless/realtek/rtlwifi/rtl8192c/rtl8192c-common	EXPORT_SYMBOL	
++0x530e2adc	nfc_proto_unregister	net/nfc/nfc	EXPORT_SYMBOL	
++0xd81af417	ieee80211_txq_get_depth	net/mac80211/mac80211	EXPORT_SYMBOL	
++0xe5752af3	ieee80211_get_bssid	net/mac80211/mac80211	EXPORT_SYMBOL	
++0x348a4041	llc_sap_find	net/llc/llc	EXPORT_SYMBOL	
++0x7aac9741	ata_host_init	drivers/ata/libata	EXPORT_SYMBOL_GPL	
++0xd19aa5d6	usbip_pad_iso	drivers/usb/usbip/usbip-core	EXPORT_SYMBOL_GPL	
++0x8dc7f848	alloc_ltalkdev	net/appletalk/appletalk	EXPORT_SYMBOL	
++0x79f42d8f	ip6_route_output_flags	net/ipv6/ipv6	EXPORT_SYMBOL_GPL	
++0x3b0f7785	iio_read_channel_scale	drivers/iio/industrialio	EXPORT_SYMBOL_GPL	
++0x7deff673	dm_consume_args	drivers/md/dm-mod	EXPORT_SYMBOL	
++0xcf29e308	pppox_unbind_sock	drivers/net/ppp/pppox	EXPORT_SYMBOL	
++0xe1cec772	_rtl92c_phy_rf_serial_write	drivers/net/wireless/realtek/rtlwifi/rtl8192c/rtl8192c-common	EXPORT_SYMBOL	
++0x80caf0eb	rt2800_sta_remove	drivers/net/wireless/ralink/rt2x00/rt2800lib	EXPORT_SYMBOL_GPL	
++0x5f495857	drm_atomic_helper_setup_commit	drivers/gpu/drm/drm_kms_helper	EXPORT_SYMBOL	
++0x04c14756	async_trigger_callback	crypto/async_tx/async_tx	EXPORT_SYMBOL_GPL	
++0x4c281912	vli_is_zero	crypto/ecc	EXPORT_SYMBOL	
++0xc6d5add2	bcma_core_is_enabled	drivers/bcma/bcma	EXPORT_SYMBOL_GPL	
++0xfa5e3388	do_map_probe	drivers/mtd/chips/chipreg	EXPORT_SYMBOL	
++0x4c349a72	drm_dp_mst_allocate_vcpi	drivers/gpu/drm/drm_kms_helper	EXPORT_SYMBOL	
++0x76f40744	ocfs2_dlm_lvb	fs/ocfs2/ocfs2_stackglue	EXPORT_SYMBOL_GPL	
++0x892321f4	hci_uart_unregister_device	drivers/bluetooth/hci_uart	EXPORT_SYMBOL_GPL	
++0xef15cc44	v4l2_hdmi_rx_colorimetry	drivers/media/v4l2-core/v4l2-dv-timings	EXPORT_SYMBOL_GPL	
++0x52d02fca	media_request_put	drivers/media/mc/mc	EXPORT_SYMBOL_GPL	
++0x2b6ddf3f	qcafrm_fsm_decode	drivers/net/ethernet/qualcomm/qca_7k_common	EXPORT_SYMBOL_GPL	
++0xd5165517	drm_display_mode_from_cea_vic	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0x16f37dd8	nf_ct_kill_acct	net/netfilter/nf_conntrack	EXPORT_SYMBOL_GPL	
++0x04268d71	wm_adsp2_component_probe	sound/soc/codecs/snd-soc-wm-adsp	EXPORT_SYMBOL_GPL	
++0xdb9864a8	sata_lpm_ignore_phy_events	drivers/ata/libata	EXPORT_SYMBOL_GPL	
++0xc43b3bb4	mt76x02_mac_reset_counters	drivers/net/wireless/mediatek/mt76/mt76x02-lib	EXPORT_SYMBOL_GPL	
++0x7e9861bd	mt76x02_sw_scan_complete	drivers/net/wireless/mediatek/mt76/mt76x02-lib	EXPORT_SYMBOL_GPL	
++0xdb68bbad	rfkill_destroy	net/rfkill/rfkill	EXPORT_SYMBOL	
++0x555a7f8a	ieee80211_rx_ba_timer_expired	net/mac80211/mac80211	EXPORT_SYMBOL	
++0xba7a2b48	hci_recv_frame	net/bluetooth/bluetooth	EXPORT_SYMBOL	
++0xaadb0612	synth_buffer_peek	drivers/accessibility/speakup/speakup	EXPORT_SYMBOL_GPL	
++0xf1e2b023	v4l2_m2m_ctx_release	drivers/media/v4l2-core/v4l2-mem2mem	EXPORT_SYMBOL_GPL	
++0xd2981357	ath9k_cmn_count_streams	drivers/net/wireless/ath/ath9k/ath9k_common	EXPORT_SYMBOL	
++0x857373cb	drm_vma_offset_add	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0x833af3b7	v4l2_m2m_ioctl_expbuf	drivers/media/v4l2-core/v4l2-mem2mem	EXPORT_SYMBOL_GPL	
++0x2c1737f0	dibusb_streaming_ctrl	drivers/media/usb/dvb-usb/dvb-usb-dibusb-common	EXPORT_SYMBOL	
++0x4620dc25	vb2_common_vm_ops	drivers/media/common/videobuf2/videobuf2-memops	EXPORT_SYMBOL_GPL	
++0x9947d2fd	drm_simple_display_pipe_init	drivers/gpu/drm/drm_kms_helper	EXPORT_SYMBOL	
++0x6bb71038	snd_seq_delete_kernel_client	sound/core/seq/snd-seq	EXPORT_SYMBOL	
++0x9c5ce344	ata_qc_get_active	drivers/ata/libata	EXPORT_SYMBOL_GPL	
++0x88cc627b	rt2x00lib_resume	drivers/net/wireless/ralink/rt2x00/rt2x00lib	EXPORT_SYMBOL_GPL	
++0x840a70eb	snd_pcm_kernel_ioctl	sound/core/snd-pcm	EXPORT_SYMBOL	
++0x5475ba9e	dm_block_location	drivers/md/persistent-data/dm-persistent-data	EXPORT_SYMBOL_GPL	
++0x318ec940	fsg_common_set_cdev	drivers/usb/gadget/function/usb_f_mass_storage	EXPORT_SYMBOL_GPL	
++0xa096944c	l2cap_conn_put	net/bluetooth/bluetooth	EXPORT_SYMBOL	
++0x25aa749f	l2cap_chan_put	net/bluetooth/bluetooth	EXPORT_SYMBOL_GPL	
++0x1879fcbd	bridge_tunnel_header	net/wireless/cfg80211	EXPORT_SYMBOL	
++0xcd53c4f0	ip6_datagram_release_cb	net/ipv6/ipv6	EXPORT_SYMBOL_GPL	
++0xd873da04	nf_conncount_count	net/netfilter/nf_conncount	EXPORT_SYMBOL_GPL	
++0x743ec3d3	snd_card_free_when_closed	sound/core/snd	EXPORT_SYMBOL	
++0xfdc96768	mtd_erase	drivers/mtd/mtd	EXPORT_SYMBOL_GPL	
++0xd4bddf5c	dm_bufio_issue_flush	drivers/md/dm-bufio	EXPORT_SYMBOL_GPL	
++0x0aa563ee	mt76x02_update_beacon_iter	drivers/net/wireless/mediatek/mt76/mt76x02-lib	EXPORT_SYMBOL_GPL	
++0xd13f9985	drm_edid_block_valid	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0x1c0a7d08	udp_sock_create6	net/ipv6/ip6_udp_tunnel	EXPORT_SYMBOL_GPL	
++0x6894895d	nft_unregister_expr	net/netfilter/nf_tables	EXPORT_SYMBOL_GPL	
++0x0e21d94d	snd_soc_runtime_action	sound/soc/snd-soc-core	EXPORT_SYMBOL_GPL	
++0xef376a3b	cxd2841er_attach_t_c	drivers/media/dvb-frontends/cxd2841er	EXPORT_SYMBOL	
++0x79adb872	em28xx_init_camera	drivers/media/usb/em28xx/em28xx	EXPORT_SYMBOL_GPL	
++0x30a62bf3	drm_fb_helper_sys_copyarea	drivers/gpu/drm/drm_kms_helper	EXPORT_SYMBOL	
++0x9f06dd67	ieee80211_chswitch_done	net/mac80211/mac80211	EXPORT_SYMBOL	
++0x46317ae6	iio_channel_get_all	drivers/iio/industrialio	EXPORT_SYMBOL_GPL	
++0x107d9409	spk_synth_flush	drivers/accessibility/speakup/speakup	EXPORT_SYMBOL_GPL	
++0xfe47fb36	rt2x00usb_disconnect	drivers/net/wireless/ralink/rt2x00/rt2x00usb	EXPORT_SYMBOL_GPL	
++0x3236cee1	__drm_atomic_helper_crtc_destroy_state	drivers/gpu/drm/drm_kms_helper	EXPORT_SYMBOL	
++0xde57b5f5	nft_parse_u32_check	net/netfilter/nf_tables	EXPORT_SYMBOL_GPL	
++0xb1b8ab36	nf_log_l2packet	net/netfilter/nf_log_common	EXPORT_SYMBOL_GPL	
++0x10b7fc38	snd_pci_quirk_lookup	sound/core/snd	EXPORT_SYMBOL	
++0x002ba2df	vhost_init_device_iotlb	drivers/vhost/vhost	EXPORT_SYMBOL_GPL	
++0x19bde83a	of_can_transceiver	drivers/net/can/dev/can-dev	EXPORT_SYMBOL_GPL	
++0x01336176	ath9k_cmn_process_rate	drivers/net/wireless/ath/ath9k/ath9k_common	EXPORT_SYMBOL	
++0x0b351225	arizona_init_spk_irqs	sound/soc/codecs/snd-soc-arizona	EXPORT_SYMBOL_GPL	
++0x6941fa2e	snd_info_free_entry	sound/core/snd	EXPORT_SYMBOL	
++0xd4c5dede	v4l2_async_subdev_notifier_register	drivers/media/v4l2-core/videodev	EXPORT_SYMBOL	
++0x3a72dacd	v4l2_ctrl_handler_init_class	drivers/media/v4l2-core/videodev	EXPORT_SYMBOL	
++0x844539ae	sms_get_board	drivers/media/common/siano/smsmdtv	EXPORT_SYMBOL_GPL	
++0x99980359	mt76u_queues_deinit	drivers/net/wireless/mediatek/mt76/mt76-usb	EXPORT_SYMBOL_GPL	
++0x8ae01331	ath9k_hw_reset_calvalid	drivers/net/wireless/ath/ath9k/ath9k_hw	EXPORT_SYMBOL	
++0xce2b1bd7	drm_gem_prime_fd_to_handle	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0xe475fb1a	drm_scdc_write	drivers/gpu/drm/drm_kms_helper	EXPORT_SYMBOL	
++0xd3d13b7f	ieee80211_connection_loss	net/mac80211/mac80211	EXPORT_SYMBOL	
++0x224aed3d	ieee80211_get_tkip_p2k	net/mac80211/mac80211	EXPORT_SYMBOL	
++0xfbb64628	snd_pcm_hw_constraint_ranges	sound/core/snd-pcm	EXPORT_SYMBOL	
++0xdc9977d5	ata_host_put	drivers/ata/libata	EXPORT_SYMBOL_GPL	
++0x14353e3b	drm_release	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0x85f548ee	register_ip_vs_scheduler	net/netfilter/ipvs/ip_vs	EXPORT_SYMBOL	
++0xafbd6cf5	nf_ct_port_nlattr_to_tuple	net/netfilter/nf_conntrack	EXPORT_SYMBOL_GPL	
++0xd5c05ccf	snd_pcm_set_ops	sound/core/snd-pcm	EXPORT_SYMBOL	
++0x970d888b	mt76u_stop_rx	drivers/net/wireless/mediatek/mt76/mt76-usb	EXPORT_SYMBOL_GPL	
++0x31b9b408	iio_read_channel_attribute	drivers/iio/industrialio	EXPORT_SYMBOL_GPL	
++0x59d3b103	media_entity_remove_links	drivers/media/mc/mc	EXPORT_SYMBOL_GPL	
++0xab98fd41	rt2800_config	drivers/net/wireless/ralink/rt2x00/rt2800lib	EXPORT_SYMBOL_GPL	
++0xc13eeefc	drm_connector_cleanup	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0xf39bc1da	ax25_linkfail_release	net/ax25/ax25	EXPORT_SYMBOL	
++0x11f10ccd	inet_diag_msg_common_fill	net/ipv4/inet_diag	EXPORT_SYMBOL_GPL	
++0xd7a9cf42	drm_mode_validate_size	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0xd3536748	gretap_fb_dev_create	net/ipv4/ip_gre	EXPORT_SYMBOL_GPL	
++0xfe502f66	snd_soc_dpcm_runtime_update	sound/soc/snd-soc-core	EXPORT_SYMBOL_GPL	
++0x5fdf38b8	lbs_disablemesh	drivers/net/wireless/marvell/libertas/libertas	EXPORT_SYMBOL_GPL	
++0xf0517d7a	drm_mm_init	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0x55f9dbd7	fuse_dev_operations	fs/fuse/fuse	EXPORT_SYMBOL_GPL	
++0xa2365f44	btracker_issue	drivers/md/dm-cache	EXPORT_SYMBOL_GPL	
++0x7da6c32c	dibusb_pid_filter_ctrl	drivers/media/usb/dvb-usb/dvb-usb-dibusb-common	EXPORT_SYMBOL	
++0x468c5d89	mt76x02_dma_disable	drivers/net/wireless/mediatek/mt76/mt76x02-lib	EXPORT_SYMBOL_GPL	
++0x2d653cac	arizona_input_analog	sound/soc/codecs/snd-soc-arizona	EXPORT_SYMBOL_GPL	
++0x168f2d56	snd_pcm_lib_malloc_pages	sound/core/snd-pcm	EXPORT_SYMBOL	
++0x114ccf0c	drm_mode_create_content_type_property	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0x559921f4	xt_match_to_user	net/netfilter/x_tables	EXPORT_SYMBOL_GPL	
++0x23590dad	v4l2_m2m_ioctl_streamoff	drivers/media/v4l2-core/v4l2-mem2mem	EXPORT_SYMBOL_GPL	
++0x871ab41a	drm_rect_intersect	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0xbf330c52	wpan_phy_new	net/ieee802154/ieee802154	EXPORT_SYMBOL	
++0x42801d20	ubi_sync	drivers/mtd/ubi/ubi	EXPORT_SYMBOL_GPL	
++0x13359ad2	dvb_generic_release	drivers/media/dvb-core/dvb-core	EXPORT_SYMBOL	
++0x51170e36	ath9k_hw_setuprxdesc	drivers/net/wireless/ath/ath9k/ath9k_hw	EXPORT_SYMBOL	
++0x95a8fcce	drm_bridge_hpd_notify	drivers/gpu/drm/drm	EXPORT_SYMBOL_GPL	
++0x895ec820	ip6_datagram_connect_v6_only	net/ipv6/ipv6	EXPORT_SYMBOL_GPL	
++0x5587d1d5	mt76_alloc_device	drivers/net/wireless/mediatek/mt76/mt76	EXPORT_SYMBOL_GPL	
++0x99e43281	unregister_8022_client	net/802/p8022	EXPORT_SYMBOL	
++0x7bd3bd01	md_cluster_ops	drivers/md/md-mod	EXPORT_SYMBOL	
++0x16565f16	v4l2_m2m_get_vq	drivers/media/v4l2-core/v4l2-mem2mem	EXPORT_SYMBOL	
++0x46996b6b	lbtf_cmd_copyback	drivers/net/wireless/marvell/libertas_tf/libertas_tf	EXPORT_SYMBOL_GPL	
++0x1eba314a	hostap_set_word	drivers/net/wireless/intersil/hostap/hostap	EXPORT_SYMBOL	
++0x71bb6d92	sys_fillrect	drivers/video/fbdev/core/sysfillrect	EXPORT_SYMBOL	
++0xdeb2df62	crypto_nhpoly1305_setkey	crypto/nhpoly1305	EXPORT_SYMBOL	
++0x35eff5e0	nf_osf_fingers	net/netfilter/nfnetlink_osf	EXPORT_SYMBOL_GPL	
++0xc0d3cc4b	ata_sff_dma_pause	drivers/ata/libata	EXPORT_SYMBOL_GPL	
++0x07646cee	ata_tf_to_fis	drivers/ata/libata	EXPORT_SYMBOL_GPL	
++0x5994eafd	drm_helper_probe_single_connector_modes	drivers/gpu/drm/drm_kms_helper	EXPORT_SYMBOL	
++0xe121e885	ieee802154_free_hw	net/mac802154/mac802154	EXPORT_SYMBOL	
++0x59258a53	llc_set_station_handler	net/llc/llc	EXPORT_SYMBOL	
++0x02bb043a	snd_ctl_add_vmaster_hook	sound/core/snd	EXPORT_SYMBOL_GPL	
++0xcf17df5e	__v4l2_device_register_subdev_nodes	drivers/media/v4l2-core/videodev	EXPORT_SYMBOL_GPL	
++0xd6c59a59	drm_property_blob_get	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0xa0bb762d	drm_property_blob_put	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0x839db969	drm_connector_init_with_ddc	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0xb5790037	iio_channel_release	drivers/iio/industrialio	EXPORT_SYMBOL_GPL	
++0x3b6727ae	w5100_probe	drivers/net/ethernet/wiznet/w5100	EXPORT_SYMBOL_GPL	
++0xcb2340b8	drm_rect_debug_print	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0xf4075dc8	drm_simple_display_pipe_attach_bridge	drivers/gpu/drm/drm_kms_helper	EXPORT_SYMBOL	
++0x234ced31	wiphy_unregister	net/wireless/cfg80211	EXPORT_SYMBOL	
++0xf71bdc1d	snd_soc_register_component	sound/soc/snd-soc-core	EXPORT_SYMBOL_GPL	
++0xe3100075	dvb_ca_en50221_camchange_irq	drivers/media/dvb-core/dvb-core	EXPORT_SYMBOL	
++0x082737e8	v4l2_ctrl_merge	drivers/media/v4l2-core/videodev	EXPORT_SYMBOL	
++0xf08af907	ata_print_version	drivers/ata/libata	EXPORT_SYMBOL	
++0x1188b81f	usb_gstrings_attach	drivers/usb/gadget/libcomposite	EXPORT_SYMBOL_GPL	
++0x693c3961	nf_ct_helper_hash	net/netfilter/nf_conntrack	EXPORT_SYMBOL_GPL	
++0xdf9079bb	snd_soc_dai_set_sysclk	sound/soc/snd-soc-core	EXPORT_SYMBOL_GPL	
++0x55aa7c5f	cx2341x_mpeg_ctrls	drivers/media/common/cx2341x	EXPORT_SYMBOL	
++0xb30ab4b4	fc0013_rc_cal_add	drivers/media/tuners/fc0013	EXPORT_SYMBOL	
++0xd7187252	mt76x2_phy_set_txpower_regs	drivers/net/wireless/mediatek/mt76/mt76x2/mt76x2-common	EXPORT_SYMBOL_GPL	
++0x33c0b57d	iscsi_complete_scsi_task	drivers/scsi/libiscsi	EXPORT_SYMBOL_GPL	
++0x1f847a86	br_multicast_enabled	net/bridge/bridge	EXPORT_SYMBOL_GPL	
++0x10d08087	__raw_v6_lookup	net/ipv6/ipv6	EXPORT_SYMBOL_GPL	
++0x9ce83d46	ip_tunnel_encap_add_ops	net/ipv4/ip_tunnel	EXPORT_SYMBOL	
++0xb9277621	btbcm_check_bdaddr	drivers/bluetooth/btbcm	EXPORT_SYMBOL_GPL	
++0x5c3d3a92	dm_device_name	drivers/md/dm-mod	EXPORT_SYMBOL_GPL	
++0x6714e83b	rtl_tx_mgmt_proc	drivers/net/wireless/realtek/rtlwifi/rtlwifi	EXPORT_SYMBOL_GPL	
++0x0ce30beb	rt2800_disable_wpdma	drivers/net/wireless/ralink/rt2x00/rt2800lib	EXPORT_SYMBOL_GPL	
++0x01f91812	drm_helper_hpd_irq_event	drivers/gpu/drm/drm_kms_helper	EXPORT_SYMBOL	
++0x91fa6da8	tpm_get_timeouts	drivers/char/tpm/tpm	EXPORT_SYMBOL_GPL	
++0x31e64c2d	cryptd_alloc_skcipher	crypto/cryptd	EXPORT_SYMBOL_GPL	
++0xd806a273	ocfs2_dlm_dump_lksb	fs/ocfs2/ocfs2_stackglue	EXPORT_SYMBOL_GPL	
++0x44331ce5	snd_soc_component_force_enable_pin_unlocked	sound/soc/snd-soc-core	EXPORT_SYMBOL_GPL	
++0x4259df80	snd_soc_component_disable_pin	sound/soc/snd-soc-core	EXPORT_SYMBOL_GPL	
++0xb53c1137	bcma_host_pci_irq_ctl	drivers/bcma/bcma	EXPORT_SYMBOL_GPL	
++0xc99e81da	vchiq_mmal_port_parameter_get	drivers/staging/vc04_services/vchiq-mmal/bcm2835-mmal-vchiq	EXPORT_SYMBOL_GPL	
++0x91c21480	vchiq_mmal_port_parameter_set	drivers/staging/vc04_services/vchiq-mmal/bcm2835-mmal-vchiq	EXPORT_SYMBOL_GPL	
++0x473defa9	lnbh25_attach	drivers/media/dvb-frontends/lnbh25	EXPORT_SYMBOL	
++0x34dbd2b6	smscore_onresponse	drivers/media/common/siano/smsmdtv	EXPORT_SYMBOL_GPL	
++0x5fc93bf4	iscsi_eh_cmd_timed_out	drivers/scsi/libiscsi	EXPORT_SYMBOL_GPL	
++0xec65839b	cfg80211_iftype_allowed	net/wireless/cfg80211	EXPORT_SYMBOL	
++0xd470251b	__fl6_sock_lookup	net/ipv6/ipv6	EXPORT_SYMBOL_GPL	
++0xfffd89db	copy_from_user_toio	sound/core/snd	EXPORT_SYMBOL	
++0xedf50552	dm_kcopyd_copy	drivers/md/dm-mod	EXPORT_SYMBOL	
++0x7ba093f9	v4l2_m2m_ioctl_create_bufs	drivers/media/v4l2-core/v4l2-mem2mem	EXPORT_SYMBOL_GPL	
++0x9a06d634	dib7000m_pid_filter_ctrl	drivers/media/dvb-frontends/dib7000m	EXPORT_SYMBOL	
++0xdc359b18	usb_serial_handle_dcd_change	drivers/usb/serial/usbserial	EXPORT_SYMBOL_GPL	
++0xbcebc97e	iscsi_suspend_queue	drivers/scsi/libiscsi	EXPORT_SYMBOL_GPL	
++0x24179da7	pps_event	drivers/pps/pps_core	EXPORT_SYMBOL	
++0xf1c27cd4	ata_sff_queue_pio_task	drivers/ata/libata	EXPORT_SYMBOL_GPL	
++0x76b264d3	vchiq_mmal_component_init	drivers/staging/vc04_services/vchiq-mmal/bcm2835-mmal-vchiq	EXPORT_SYMBOL_GPL	
++0x21b6decb	v4l2_ctrl_add_handler	drivers/media/v4l2-core/videodev	EXPORT_SYMBOL	
++0x58abea09	drm_sched_resubmit_jobs	drivers/gpu/drm/scheduler/gpu-sched	EXPORT_SYMBOL	
++0xd6f3887c	xfrm6_input_addr	net/ipv6/ipv6	EXPORT_SYMBOL	
++0x2cdde7cf	asoc_simple_hw_params	sound/soc/generic/snd-soc-simple-card-utils	EXPORT_SYMBOL_GPL	
++0x6c740f97	line6_read_serial_number	sound/usb/line6/snd-usb-line6	EXPORT_SYMBOL_GPL	
++0x08eef203	tda8083_attach	drivers/media/dvb-frontends/tda8083	EXPORT_SYMBOL	
++0x63685ae2	rt2800_write_tx_data	drivers/net/wireless/ralink/rt2x00/rt2800lib	EXPORT_SYMBOL_GPL	
++0x030bb4a1	ar9003_hw_bb_watchdog_dbg_info	drivers/net/wireless/ath/ath9k/ath9k_hw	EXPORT_SYMBOL	
++0xf9eced44	LZ4_compress_fast_continue	lib/lz4/lz4_compress	EXPORT_SYMBOL	
++0xcce3b685	hci_get_route	net/bluetooth/bluetooth	EXPORT_SYMBOL	
++0x3a29dce3	drm_fb_helper_fill_info	drivers/gpu/drm/drm_kms_helper	EXPORT_SYMBOL	
++0xdd626ee3	fuse_len_args	fs/fuse/fuse	EXPORT_SYMBOL_GPL	
++0xb432591f	nft_register_obj	net/netfilter/nf_tables	EXPORT_SYMBOL_GPL	
++0xb77b0159	v4l2_prio_init	drivers/media/v4l2-core/videodev	EXPORT_SYMBOL	
++0x6bfff31c	rndis_deregister	drivers/usb/gadget/function/usb_f_rndis	EXPORT_SYMBOL_GPL	
++0x3009d31d	_rtl92c_phy_init_bb_rf_register_definition	drivers/net/wireless/realtek/rtlwifi/rtl8192c/rtl8192c-common	EXPORT_SYMBOL	
++0x581efc7c	rt2x00usb_regbusy_read	drivers/net/wireless/ralink/rt2x00/rt2x00usb	EXPORT_SYMBOL_GPL	
++0xb64cdff4	drm_gem_cma_print_info	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0x4d3808b4	sigmadsp_restrict_params	sound/soc/codecs/snd-soc-sigmadsp	EXPORT_SYMBOL_GPL	
++0x74dcd98c	dm_bufio_get_aux_data	drivers/md/dm-bufio	EXPORT_SYMBOL_GPL	
++0x665a24f6	rtl_debug_add_one	drivers/net/wireless/realtek/rtlwifi/rtlwifi	EXPORT_SYMBOL_GPL	
++0x9c33104c	snd_timer_close	sound/core/snd-timer	EXPORT_SYMBOL	
++0xff7717db	mt76x02_tx_complete_skb	drivers/net/wireless/mediatek/mt76/mt76x02-lib	EXPORT_SYMBOL_GPL	
++0xbaca9889	drm_mode_create_scaling_mode_property	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0x0c89a76f	drm_fb_cma_get_gem_addr	drivers/gpu/drm/drm_kms_helper	EXPORT_SYMBOL_GPL	
++0x6addad6c	drm_atomic_helper_fake_vblank	drivers/gpu/drm/drm_kms_helper	EXPORT_SYMBOL	
++0x4f618ea9	drm_dp_aux_register	drivers/gpu/drm/drm_kms_helper	EXPORT_SYMBOL	
++0x3f465f08	async_xor_val_offs	crypto/async_tx/async_xor	EXPORT_SYMBOL_GPL	
++0x66e12cc8	af_alg_release	crypto/af_alg	EXPORT_SYMBOL_GPL	
++0xdf72e920	nf_conntrack_broadcast_help	net/netfilter/nf_conntrack_broadcast	EXPORT_SYMBOL_GPL	
++0xcb3a2ba5	line6_init_pcm	sound/usb/line6/snd-usb-line6	EXPORT_SYMBOL_GPL	
++0x37e08d1a	dib0090_get_wbd_target	drivers/media/dvb-frontends/dib0090	EXPORT_SYMBOL	
++0x7cedb17d	i2400m_init	drivers/net/wimax/i2400m/i2400m	EXPORT_SYMBOL_GPL	
++0xa58eba37	drm_gem_shmem_mmap	drivers/gpu/drm/drm	EXPORT_SYMBOL_GPL	
++0x53efa2f9	drm_gem_shmem_vmap	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0x82f64aae	ar9003_mci_state	drivers/net/wireless/ath/ath9k/ath9k_hw	EXPORT_SYMBOL	
++0xa8ad5d01	drm_detect_hdmi_monitor	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0xef8a5ca5	drm_atomic_helper_update_plane	drivers/gpu/drm/drm_kms_helper	EXPORT_SYMBOL	
++0xfa7d4868	nf_nat_redirect_ipv6	net/netfilter/nf_nat	EXPORT_SYMBOL_GPL	
++0xc7a09876	nf_nat_redirect_ipv4	net/netfilter/nf_nat	EXPORT_SYMBOL_GPL	
++0x89ea3f0e	mtd_unpoint	drivers/mtd/mtd	EXPORT_SYMBOL_GPL	
++0x8b27713a	lgs8gxx_attach	drivers/media/dvb-frontends/lgs8gxx	EXPORT_SYMBOL	
++0xa506aa2c	u_audio_start_capture	drivers/usb/gadget/function/u_audio	EXPORT_SYMBOL_GPL	
++0xb7c5b28d	rt2800_config_filter	drivers/net/wireless/ralink/rt2x00/rt2800lib	EXPORT_SYMBOL_GPL	
++0xf75999b3	mt76x02_init_device	drivers/net/wireless/mediatek/mt76/mt76x02-lib	EXPORT_SYMBOL_GPL	
++0xceacbad8	l2tp_session_dec_refcount	net/l2tp/l2tp_core	EXPORT_SYMBOL_GPL	
++0xf1d33a48	l2tp_session_inc_refcount	net/l2tp/l2tp_core	EXPORT_SYMBOL_GPL	
++0x893b6abf	atm_dev_deregister	net/atm/atm	EXPORT_SYMBOL	
++0xc7451486	snd_soc_add_dai_controls	sound/soc/snd-soc-core	EXPORT_SYMBOL_GPL	
++0x6ba8662d	ahci_port_resume	drivers/ata/libahci	EXPORT_SYMBOL_GPL	
++0xc4119ab9	mt76_wake_tx_queue	drivers/net/wireless/mediatek/mt76/mt76	EXPORT_SYMBOL_GPL	
++0x8615c20e	ndisc_mc_map	net/ipv6/ipv6	EXPORT_SYMBOL	
++0xf03fa52b	flow_offload_refresh	net/netfilter/nf_flow_table	EXPORT_SYMBOL_GPL	
++0x009f0c37	nft_do_chain	net/netfilter/nf_tables	EXPORT_SYMBOL_GPL	
++0xdad439e7	nf_nat_masquerade_ipv6	net/netfilter/nf_nat	EXPORT_SYMBOL_GPL	
++0xd28a389d	nf_nat_masquerade_ipv4	net/netfilter/nf_nat	EXPORT_SYMBOL_GPL	
++0x08af4c14	nf_ct_helper_expectfn_find_by_symbol	net/netfilter/nf_conntrack	EXPORT_SYMBOL_GPL	
++0x6ad5626f	dm_internal_suspend_fast	drivers/md/dm-mod	EXPORT_SYMBOL_GPL	
++0xf3fd5a3a	virtio_transport_free_pkt	net/vmw_vsock/vmw_vsock_virtio_transport_common	EXPORT_SYMBOL_GPL	
++0xe7efa19a	wimax_state_change	net/wimax/wimax	EXPORT_SYMBOL_GPL	
++0xd36073d8	snd_soc_put_strobe	sound/soc/snd-soc-core	EXPORT_SYMBOL_GPL	
++0xdf96f803	snd_soc_get_strobe	sound/soc/snd-soc-core	EXPORT_SYMBOL_GPL	
++0x78564a56	media_device_register_entity	drivers/media/mc/mc	EXPORT_SYMBOL_GPL	
++0xb7c64a49	usb_add_config	drivers/usb/gadget/libcomposite	EXPORT_SYMBOL_GPL	
++0x0eaee5be	rtl_cam_add_one_entry	drivers/net/wireless/realtek/rtlwifi/rtlwifi	EXPORT_SYMBOL	
++0x832c6f16	drm_event_cancel_free	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0xa139245d	ip_tunnel_ioctl	net/ipv4/ip_tunnel	EXPORT_SYMBOL_GPL	
++0x457a0bbd	vb2_request_buffer_cnt	drivers/media/common/videobuf2/videobuf2-common	EXPORT_SYMBOL_GPL	
++0x7edc546f	drm_mm_print	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0x59a2712d	raid6_gfinv	lib/raid6/raid6_pq	EXPORT_SYMBOL	
++0x08929468	nf_ct_extend_unregister	net/netfilter/nf_conntrack	EXPORT_SYMBOL_GPL	
++0x7689772c	can_get_echo_skb	drivers/net/can/dev/can-dev	EXPORT_SYMBOL_GPL	
++0x1ad11d27	hdlcdrv_transmitter	drivers/net/hamradio/hdlcdrv	EXPORT_SYMBOL	
++0xf9a14ded	drm_gem_cma_prime_import_sg_table_vmap	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0x89264b7e	drm_dp_mst_connector_late_register	drivers/gpu/drm/drm_kms_helper	EXPORT_SYMBOL	
++0x769ff43b	snd_pcm_set_managed_buffer_all	sound/core/snd-pcm	EXPORT_SYMBOL	
++0xf2942cd7	nxt200x_attach	drivers/media/dvb-frontends/nxt200x	EXPORT_SYMBOL	
++0xda861edf	alloc_canfd_skb	drivers/net/can/dev/can-dev	EXPORT_SYMBOL_GPL	
++0x022965d7	ipt_unregister_table_pre_exit	net/ipv4/netfilter/ip_tables	EXPORT_SYMBOL	
++0xde5be3e7	arizona_asrc_rate1	sound/soc/codecs/snd-soc-arizona	EXPORT_SYMBOL_GPL	
++0x8e115857	ahci_stop_engine	drivers/ata/libahci	EXPORT_SYMBOL_GPL	
++0x33128230	ath9k_hw_ani_monitor	drivers/net/wireless/ath/ath9k/ath9k_hw	EXPORT_SYMBOL	
++0x1933674d	videobuf_reqbufs	drivers/media/v4l2-core/videobuf-core	EXPORT_SYMBOL_GPL	
++0x0213875f	v4l2_queryctrl	drivers/media/v4l2-core/videodev	EXPORT_SYMBOL	
++0xfcaae7ac	rtl_usb_resume	drivers/net/wireless/realtek/rtlwifi/rtl_usb	EXPORT_SYMBOL	
++0x08179734	rt2800_load_firmware	drivers/net/wireless/ralink/rt2x00/rt2800lib	EXPORT_SYMBOL_GPL	
++0x1a01b921	tpm_send	drivers/char/tpm/tpm	EXPORT_SYMBOL_GPL	
++0x3eea9e85	ieee80211_wake_queue	net/mac80211/mac80211	EXPORT_SYMBOL	
++0x41f05d93	ip_vs_new_conn_out	net/netfilter/ipvs/ip_vs	EXPORT_SYMBOL	
++0x697eaa11	v4l2_ctrl_handler_log_status	drivers/media/v4l2-core/videodev	EXPORT_SYMBOL	
++0x1544ec3e	inet6_csk_addr2sockaddr	net/ipv6/ipv6	EXPORT_SYMBOL_GPL	
++0xb685b285	ata_link_printk	drivers/ata/libata	EXPORT_SYMBOL	
++0xf6425ee5	gspca_suspend	drivers/media/usb/gspca/gspca_main	EXPORT_SYMBOL	
++0x841d897b	mt76x02u_init_mcu	drivers/net/wireless/mediatek/mt76/mt76x02-usb	EXPORT_SYMBOL_GPL	
++0xc13c9426	ath_gen_timer_alloc	drivers/net/wireless/ath/ath9k/ath9k_hw	EXPORT_SYMBOL	
++0x4efac35d	drm_mode_parse_command_line_for_connector	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0xa5370313	devm_of_find_backlight	drivers/video/backlight/backlight	EXPORT_SYMBOL	
++0x34922afd	xt_unregister_targets	net/netfilter/x_tables	EXPORT_SYMBOL	
++0x9c63cf5c	ahci_set_em_messages	drivers/ata/libahci	EXPORT_SYMBOL_GPL	
++0x3fcb80f3	register_candev	drivers/net/can/dev/can-dev	EXPORT_SYMBOL_GPL	
++0xf0a88c89	drm_mode_object_get	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0x4adb654e	drm_dp_read_dpcd_caps	drivers/gpu/drm/drm_kms_helper	EXPORT_SYMBOL	
++0x7f26f273	arizona_mixer_texts	sound/soc/codecs/snd-soc-arizona	EXPORT_SYMBOL_GPL	
++0xacb5e787	tda826x_attach	drivers/media/dvb-frontends/tda826x	EXPORT_SYMBOL	
++0xb9cad492	__drm_atomic_state_free	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0xf424f7d3	drm_panel_bridge_add	drivers/gpu/drm/drm_kms_helper	EXPORT_SYMBOL	
++0x033fac32	snd_soc_dai_set_tdm_slot	sound/soc/snd-soc-core	EXPORT_SYMBOL_GPL	
++0x609d3d55	videobuf_qbuf	drivers/media/v4l2-core/videobuf-core	EXPORT_SYMBOL_GPL	
++0x8b9fdb3a	drm_gem_cma_prime_get_sg_table	drivers/gpu/drm/drm	EXPORT_SYMBOL_GPL	
++0xd5ee5e8b	drm_fb_xrgb8888_to_rgb888_dstclip	drivers/gpu/drm/drm_kms_helper	EXPORT_SYMBOL	
++0xa3509708	ata_port_printk	drivers/ata/libata	EXPORT_SYMBOL	
++0x70703dea	em28xx_write_reg_bits	drivers/media/usb/em28xx/em28xx	EXPORT_SYMBOL_GPL	
++0x0fb52ee8	iscsi_set_param	drivers/scsi/libiscsi	EXPORT_SYMBOL_GPL	
++0x6e252522	__ieee80211_get_rx_led_name	net/mac80211/mac80211	EXPORT_SYMBOL	
++0xda527f19	ax25_ip_xmit	net/ax25/ax25	EXPORT_SYMBOL	
++0x83380ffd	wm_adsp_fw_put	sound/soc/codecs/snd-soc-wm-adsp	EXPORT_SYMBOL_GPL	
++0x80802430	v4l2_m2m_fop_poll	drivers/media/v4l2-core/v4l2-mem2mem	EXPORT_SYMBOL_GPL	
++0xdd0a184b	dib9000_fw_pid_filter	drivers/media/dvb-frontends/dib9000	EXPORT_SYMBOL	
++0x7371b5fb	drm_crtc_arm_vblank_event	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0x04c408a1	drm_mode_create	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0x1560879f	inet6_release	net/ipv6/ipv6	EXPORT_SYMBOL	
++0xc18ac88d	nf_ct_expect_hsize	net/netfilter/nf_conntrack	EXPORT_SYMBOL_GPL	
++0x3499e814	v4l2_ctrl_new_int_menu	drivers/media/v4l2-core/videodev	EXPORT_SYMBOL	
++0xf774197f	drm_syncobj_find	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0x8e2940db	drm_mode_destroy	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0x5a1efaaa	drm_gem_fb_afbc_init	drivers/gpu/drm/drm_kms_helper	EXPORT_SYMBOL_GPL	
++0xe5a39ec9	drm_dp_mst_topology_mgr_resume	drivers/gpu/drm/drm_kms_helper	EXPORT_SYMBOL	
++0x9152786e	nfc_set_remote_general_bytes	net/nfc/nfc	EXPORT_SYMBOL	
++0x238d29bc	drm_dp_mst_atomic_check	drivers/gpu/drm/drm_kms_helper	EXPORT_SYMBOL	
++0x2f1fa5e9	br_dev_queue_push_xmit	net/bridge/bridge	EXPORT_SYMBOL_GPL	
++0x3e3524c1	fl6_update_dst	net/ipv6/ipv6	EXPORT_SYMBOL_GPL	
++0x5fa9360d	ata_host_resume	drivers/ata/libata	EXPORT_SYMBOL_GPL	
++0x7903e46e	ledtrig_torch_ctrl	drivers/leds/trigger/ledtrig-camera	EXPORT_SYMBOL_GPL	
++0xd344e4ee	ocfs2_stack_glue_set_max_proto_version	fs/ocfs2/ocfs2_stackglue	EXPORT_SYMBOL_GPL	
++0x99e745e1	__media_remove_intf_links	drivers/media/mc/mc	EXPORT_SYMBOL_GPL	
++0xa608465a	crypto_nhpoly1305_init	crypto/nhpoly1305	EXPORT_SYMBOL	
++0xa9cd9b0f	l2tp_tunnel_create	net/l2tp/l2tp_core	EXPORT_SYMBOL_GPL	
++0x0f72ab2a	snd_soc_jack_report	sound/soc/snd-soc-core	EXPORT_SYMBOL_GPL	
++0xc18b942d	snd_soc_dapm_put_enum_double	sound/soc/snd-soc-core	EXPORT_SYMBOL_GPL	
++0xb5a052e9	snd_soc_dapm_get_enum_double	sound/soc/snd-soc-core	EXPORT_SYMBOL_GPL	
++0x26676452	btrtl_shutdown_realtek	drivers/bluetooth/btrtl	EXPORT_SYMBOL_GPL	
++0xd163cade	dm_tm_commit	drivers/md/persistent-data/dm-persistent-data	EXPORT_SYMBOL_GPL	
++0x48b62a57	drm_dp_link_train_channel_eq_delay	drivers/gpu/drm/drm_kms_helper	EXPORT_SYMBOL	
++0xabced5ab	snd_soc_of_get_slot_mask	sound/soc/snd-soc-core	EXPORT_SYMBOL_GPL	
++0xb1a6a09b	gameport_unregister_port	drivers/input/gameport/gameport	EXPORT_SYMBOL	
++0x1ae8f512	dm_accept_partial_bio	drivers/md/dm-mod	EXPORT_SYMBOL_GPL	
++0xcf7d506f	cx231xx_disable656	drivers/media/usb/cx231xx/cx231xx	EXPORT_SYMBOL_GPL	
++0xcd0c4755	ath9k_hw_set_tsfadjust	drivers/net/wireless/ath/ath9k/ath9k_hw	EXPORT_SYMBOL	
++0xde867c29	ecc_is_pubkey_valid_partial	crypto/ecc	EXPORT_SYMBOL	
++0x66c0948f	cfg80211_nan_func_terminated	net/wireless/cfg80211	EXPORT_SYMBOL	
++0x577623a0	nd_tbl	net/ipv6/ipv6	EXPORT_SYMBOL_GPL	
++0x766d9d28	vhost_disable_notify	drivers/vhost/vhost	EXPORT_SYMBOL_GPL	
++0xb507fc0d	vhost_vq_avail_empty	drivers/vhost/vhost	EXPORT_SYMBOL_GPL	
++0x9903a2ca	btintel_set_diag_mfg	drivers/bluetooth/btintel	EXPORT_SYMBOL_GPL	
++0x1b945315	rtl_addr_delay	drivers/net/wireless/realtek/rtlwifi/rtlwifi	EXPORT_SYMBOL	
++0xd6949b7f	iscsi_conn_teardown	drivers/scsi/libiscsi	EXPORT_SYMBOL_GPL	
++0xeb3d8e6c	drm_client_framebuffer_flush	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0xcafdd707	ocfs2_dlm_lock_status	fs/ocfs2/ocfs2_stackglue	EXPORT_SYMBOL_GPL	
++0x289c3714	nf_ct_alloc_hashtable	net/netfilter/nf_conntrack	EXPORT_SYMBOL_GPL	
++0xe369bb9e	rt6_lookup	net/ipv6/ipv6	EXPORT_SYMBOL	
++0x9fef35ac	v4l2_apply_frmsize_constraints	drivers/media/v4l2-core/videodev	EXPORT_SYMBOL_GPL	
++0xe5bc9a53	slhc_free	drivers/net/slip/slhc	EXPORT_SYMBOL	
++0x556defeb	spi_bitbang_cleanup	drivers/spi/spi-bitbang	EXPORT_SYMBOL_GPL	
++0xb755de80	drm_gem_mmap	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0xd14acc49	ieee80211_tx_status_8023	net/mac80211/mac80211	EXPORT_SYMBOL	
++0xff11d992	nf_ct_tmpl_free	net/netfilter/nf_conntrack	EXPORT_SYMBOL_GPL	
++0xbe55b0d8	fbtft_write_vmem16_bus9	drivers/staging/fbtft/fbtft	EXPORT_SYMBOL	
++0x63ca98b6	fbtft_write_vmem16_bus8	drivers/staging/fbtft/fbtft	EXPORT_SYMBOL	
++0x908ff288	drm_fb_helper_restore_fbdev_mode_unlocked	drivers/gpu/drm/drm_kms_helper	EXPORT_SYMBOL	
++0xad1baa75	ieee80211_beacon_loss	net/mac80211/mac80211	EXPORT_SYMBOL	
++0x0320e932	v4l2_m2m_reqbufs	drivers/media/v4l2-core/v4l2-mem2mem	EXPORT_SYMBOL_GPL	
++0xb476fe47	drm_legacy_ioremapfree	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0xdd3c79ef	wm_adsp2_bus_error	sound/soc/codecs/snd-soc-wm-adsp	EXPORT_SYMBOL_GPL	
++0x68c82ea5	get_tree_mtd	drivers/mtd/mtd	EXPORT_SYMBOL_GPL	
++0x432b8178	dm_array_cursor_begin	drivers/md/persistent-data/dm-persistent-data	EXPORT_SYMBOL_GPL	
++0x86490c12	vb2_prepare_buf	drivers/media/common/videobuf2/videobuf2-v4l2	EXPORT_SYMBOL_GPL	
++0x98bf039f	nft_flowtable_lookup	net/netfilter/nf_tables	EXPORT_SYMBOL_GPL	
++0xf9c69313	wm_adsp_early_event	sound/soc/codecs/snd-soc-wm-adsp	EXPORT_SYMBOL_GPL	
++0xf80487a7	snd_rawmidi_kernel_release	sound/core/snd-rawmidi	EXPORT_SYMBOL	
++0x88e02148	drm_modeset_acquire_init	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0x403bd3ea	drm_mode_is_420_only	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0xb137492b	hostap_init_ap_proc	drivers/net/wireless/intersil/hostap/hostap	EXPORT_SYMBOL	
++0x375ca4ea	l2tp_tunnel_register	net/l2tp/l2tp_core	EXPORT_SYMBOL_GPL	
++0x759edd83	nf_ct_seq_offset	net/netfilter/nf_conntrack	EXPORT_SYMBOL_GPL	
++0x237d67e9	devm_sigmadsp_init	sound/soc/codecs/snd-soc-sigmadsp	EXPORT_SYMBOL_GPL	
++0x82fd19e4	snd_soc_dapm_init	sound/soc/snd-soc-core	EXPORT_SYMBOL_GPL	
++0x61ae608a	qt1010_attach	drivers/media/tuners/qt1010	EXPORT_SYMBOL	
++0xb39c5e98	usb_remove_function	drivers/usb/gadget/libcomposite	EXPORT_SYMBOL_GPL	
++0x5dbf0f1f	mipi_dbi_hw_reset	drivers/gpu/drm/drm_mipi_dbi	EXPORT_SYMBOL	
++0xe03d2eb5	ms_sensors_write_resolution	drivers/iio/common/ms_sensors/ms_sensors_i2c	EXPORT_SYMBOL	
++0x147df3cd	v4l2_m2m_qbuf	drivers/media/v4l2-core/v4l2-mem2mem	EXPORT_SYMBOL_GPL	
++0xf5ef842e	v4l_bound_align_image	drivers/media/v4l2-core/videodev	EXPORT_SYMBOL_GPL	
++0x47596ef5	cx231xx_unmute_audio	drivers/media/usb/cx231xx/cx231xx	EXPORT_SYMBOL_GPL	
++0xd714516e	flexcop_pass_dmx_data	drivers/media/common/b2c2/b2c2-flexcop	EXPORT_SYMBOL	
++0x69d2a72d	drm_wait_one_vblank	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0xb913f21a	cfg80211_auth_timeout	net/wireless/cfg80211	EXPORT_SYMBOL	
++0x9fb184f6	devm_snd_soc_register_dai	sound/soc/snd-soc-core	EXPORT_SYMBOL_GPL	
++0x96c2992c	ata_common_sdev_attrs	drivers/ata/libata	EXPORT_SYMBOL_GPL	
++0xe8afe6d8	v4l2_ctrl_new_std_menu	drivers/media/v4l2-core/videodev	EXPORT_SYMBOL	
++0xfee621b6	ath9k_hw_bstuck_nfcal	drivers/net/wireless/ath/ath9k/ath9k_hw	EXPORT_SYMBOL	
++0x6b4e0c4e	drm_add_edid_modes	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0xedfcccd5	nfnetlink_set_err	net/netfilter/nfnetlink	EXPORT_SYMBOL_GPL	
++0xbd4ac6e1	mtd_lock_user_prot_reg	drivers/mtd/mtd	EXPORT_SYMBOL_GPL	
++0xab77d808	ata_pci_device_suspend	drivers/ata/libata	EXPORT_SYMBOL_GPL	
++0xd8a2778c	mddev_init	drivers/md/md-mod	EXPORT_SYMBOL_GPL	
++0xa7465453	mt76x02_get_lna_gain	drivers/net/wireless/mediatek/mt76/mt76x02-lib	EXPORT_SYMBOL_GPL	
++0x5d105033	drm_gem_object_put_locked	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0xa924a303	bt_sock_register	net/bluetooth/bluetooth	EXPORT_SYMBOL	
++0xd4883a5e	mxl5xx_attach	drivers/media/dvb-frontends/mxl5xx	EXPORT_SYMBOL_GPL	
++0xd1d37d8a	mwifiex_disable_auto_ds	drivers/net/wireless/marvell/mwifiex/mwifiex	EXPORT_SYMBOL_GPL	
++0x752a6932	drm_hdmi_vendor_infoframe_from_display_mode	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0x0b93c902	snd_pcm_hw_constraint_minmax	sound/core/snd-pcm	EXPORT_SYMBOL	
++0x479b652a	au8522_readreg	drivers/media/dvb-frontends/au8522_common	EXPORT_SYMBOL	
++0xb5a1c792	cx231xx_get_i2c_adap	drivers/media/usb/cx231xx/cx231xx	EXPORT_SYMBOL_GPL	
++0x74ea34cb	rt2x00queue_flush_queue	drivers/net/wireless/ralink/rt2x00/rt2x00lib	EXPORT_SYMBOL_GPL	
++0xc535337e	snd_midi_event_free	sound/core/seq/snd-seq-midi-event	EXPORT_SYMBOL	
++0xb00b793c	i2400m_bm_cmd_prepare	drivers/net/wimax/i2400m/i2400m	EXPORT_SYMBOL_GPL	
++0xc85e6899	lbtf_debug	drivers/net/wireless/marvell/libertas_tf/libertas_tf	EXPORT_SYMBOL_GPL	
++0x6482a679	drm_client_modeset_commit_locked	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0x65abae4c	drm_atomic_state_clear	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0x785983bb	ieee80211_free_txskb	net/mac80211/mac80211	EXPORT_SYMBOL	
++0x1dbb621b	llc_sap_close	net/llc/llc	EXPORT_SYMBOL	
++0x4f0e3bbe	garp_request_leave	net/802/garp	EXPORT_SYMBOL_GPL	
++0x7a904ad9	ad193x_probe	sound/soc/codecs/snd-soc-ad193x	EXPORT_SYMBOL_GPL	
++0x167a2fcd	mux_control_try_select	drivers/mux/mux-core	EXPORT_SYMBOL_GPL	
++0xea76a951	ata_bmdma_port_start32	drivers/ata/libata	EXPORT_SYMBOL_GPL	
++0xfaf1a9ec	__v4l2_ctrl_s_ctrl_compound	drivers/media/v4l2-core/videodev	EXPORT_SYMBOL	
++0x795478ce	ad714x_probe	drivers/input/misc/ad714x	EXPORT_SYMBOL	
++0x64717be6	drm_client_register	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0x82a8984c	async_xor_offs	crypto/async_tx/async_xor	EXPORT_SYMBOL_GPL	
++0x86676829	rtl_signal_scale_mapping	drivers/net/wireless/realtek/rtlwifi/rtlwifi	EXPORT_SYMBOL	
++0xa2f97f4f	wimax_msg_data_len	net/wimax/wimax	EXPORT_SYMBOL_GPL	
++0x00ca2577	bt_procfs_cleanup	net/bluetooth/bluetooth	EXPORT_SYMBOL	
++0x3e8ba5d1	btmrvl_pscan_window_reporting	drivers/bluetooth/btmrvl	EXPORT_SYMBOL_GPL	
++0x8c3decfd	media_device_usb_allocate	drivers/media/mc/mc	EXPORT_SYMBOL_GPL	
++0x21e36bf2	smscore_registry_getmode	drivers/media/common/siano/smsmdtv	EXPORT_SYMBOL_GPL	
++0xda822f5a	ipv6_push_frag_opts	net/ipv6/ipv6	EXPORT_SYMBOL	
++0xe9a445c5	dvb_module_probe	drivers/media/dvb-core/dvb-core	EXPORT_SYMBOL_GPL	
++0xe52ddb0d	vb2_verify_memory_type	drivers/media/common/videobuf2/videobuf2-common	EXPORT_SYMBOL	
++0x33484aab	rtl_cam_get_free_entry	drivers/net/wireless/realtek/rtlwifi/rtlwifi	EXPORT_SYMBOL	
++0x9357eb55	rt2x00mac_tx	drivers/net/wireless/ralink/rt2x00/rt2x00lib	EXPORT_SYMBOL_GPL	
++0x7730f22d	drbd_conn_str	drivers/block/drbd/drbd	EXPORT_SYMBOL	
++0x831ffead	__drm_atomic_helper_plane_duplicate_state	drivers/gpu/drm/drm_kms_helper	EXPORT_SYMBOL	
++0xe8e4baf5	p9_client_unlinkat	net/9p/9pnet	EXPORT_SYMBOL	
++0x76555ca9	snd_pcm_hw_constraint_ratnums	sound/core/snd-pcm	EXPORT_SYMBOL	
++0xad221d73	snd_ctl_replace	sound/core/snd	EXPORT_SYMBOL	
++0x73d62d09	ata_cable_ignore	drivers/ata/libata	EXPORT_SYMBOL_GPL	
++0x0dedd9fd	md_allow_write	drivers/md/md-mod	EXPORT_SYMBOL_GPL	
++0x192ae281	v4l2_async_notifier_add_fwnode_subdev	drivers/media/v4l2-core/videodev	EXPORT_SYMBOL_GPL	
++0x0fa22981	virtio_transport_notify_recv_pre_dequeue	net/vmw_vsock/vmw_vsock_virtio_transport_common	EXPORT_SYMBOL_GPL	
++0xb2eb9d66	vsock_assign_transport	net/vmw_vsock/vsock	EXPORT_SYMBOL_GPL	
++0xf242cb45	ip_md_tunnel_xmit	net/ipv4/ip_tunnel	EXPORT_SYMBOL_GPL	
++0x53142ce2	usb_serial_resume	drivers/usb/serial/usbserial	EXPORT_SYMBOL	
++0x39fefecc	drm_invalid_op	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0x3753a425	ieee80211_rx_irqsafe	net/mac80211/mac80211	EXPORT_SYMBOL	
++0xd9007eba	drm_connector_set_tile_property	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0x7950a3c3	drm_atomic_helper_plane_reset	drivers/gpu/drm/drm_kms_helper	EXPORT_SYMBOL	
++0xb454e4f0	drm_gem_objects_lookup	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0xe8302af3	snd_soc_of_parse_audio_simple_widgets	sound/soc/snd-soc-core	EXPORT_SYMBOL_GPL	
++0x581ed030	deregister_mtd_blktrans	drivers/mtd/mtd_blkdevs	EXPORT_SYMBOL_GPL	
++0xcdfeb8e6	mt76_queues_read	drivers/net/wireless/mediatek/mt76/mt76	EXPORT_SYMBOL_GPL	
++0x29a0e6f4	lbs_suspend	drivers/net/wireless/marvell/libertas/libertas	EXPORT_SYMBOL_GPL	
++0x910e8455	ath9k_hw_kill_interrupts	drivers/net/wireless/ath/ath9k/ath9k_hw	EXPORT_SYMBOL	
++0x0ad62db9	drm_simple_encoder_init	drivers/gpu/drm/drm_kms_helper	EXPORT_SYMBOL	
++0xa1fefe6a	drm_dp_psr_setup_time	drivers/gpu/drm/drm_kms_helper	EXPORT_SYMBOL	
++0x52d7b2fd	llc_sap_list	net/llc/llc	EXPORT_SYMBOL	
++0xacab6609	dvb_unregister_adapter	drivers/media/dvb-core/dvb-core	EXPORT_SYMBOL	
++0x4c9df33c	gether_get_ifname	drivers/usb/gadget/function/u_ether	EXPORT_SYMBOL_GPL	
++0x2f3dcecb	lc_index_of	lib/lru_cache	EXPORT_SYMBOL	
++0x5b94328b	nf_defrag_ipv6_enable	net/ipv6/netfilter/nf_defrag_ipv6	EXPORT_SYMBOL_GPL	
++0x765c1ded	nf_defrag_ipv4_enable	net/ipv4/netfilter/nf_defrag_ipv4	EXPORT_SYMBOL_GPL	
++0x6de56150	snd_compr_stop_error	sound/core/snd-compress	EXPORT_SYMBOL_GPL	
++0x0a7e77f3	dm_btree_cursor_end	drivers/md/persistent-data/dm-persistent-data	EXPORT_SYMBOL_GPL	
++0x612ddce5	v4l2_fwnode_connector_free	drivers/media/v4l2-core/v4l2-fwnode	EXPORT_SYMBOL_GPL	
++0xed981b55	nf_ct_tcp_seqadj_set	net/netfilter/nf_conntrack	EXPORT_SYMBOL_GPL	
++0x94fbe179	drm_gem_cma_prime_vmap	drivers/gpu/drm/drm	EXPORT_SYMBOL_GPL	
++0x567997f6	drm_gem_cma_prime_mmap	drivers/gpu/drm/drm	EXPORT_SYMBOL_GPL	
++0x097f173b	fbtft_write_gpio16_wr_latched	drivers/staging/fbtft/fbtft	EXPORT_SYMBOL	
++0x90b70c61	stv6111_attach	drivers/media/dvb-frontends/stv6111	EXPORT_SYMBOL_GPL	
++0xea1308ab	or51132_attach	drivers/media/dvb-frontends/or51132	EXPORT_SYMBOL	
++0x19ee2933	drm_writeback_get_out_fence	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0xc986de74	drm_fb_helper_output_poll_changed	drivers/gpu/drm/drm_kms_helper	EXPORT_SYMBOL	
++0xc709abb7	__drm_atomic_helper_connector_state_reset	drivers/gpu/drm/drm_kms_helper	EXPORT_SYMBOL	
++0x6e0106bc	drm_dp_update_payload_part2	drivers/gpu/drm/drm_kms_helper	EXPORT_SYMBOL	
++0xa399be9d	drm_dp_update_payload_part1	drivers/gpu/drm/drm_kms_helper	EXPORT_SYMBOL	
++0x367e5bb4	af_alg_register_type	crypto/af_alg	EXPORT_SYMBOL_GPL	
++0xd1d34e06	ieee80211_iterate_active_interfaces_atomic	net/mac80211/mac80211	EXPORT_SYMBOL_GPL	
++0x37cbae67	ip6_datagram_send_ctl	net/ipv6/ipv6	EXPORT_SYMBOL_GPL	
++0x8debddaf	nf_ct_acct_add	net/netfilter/nf_conntrack	EXPORT_SYMBOL_GPL	
++0xb6633d27	rtl_mrate_idx_to_arfr_id	drivers/net/wireless/realtek/rtlwifi/rtlwifi	EXPORT_SYMBOL	
++0x0d87c907	ath9k_hw_init	drivers/net/wireless/ath/ath9k/ath9k_hw	EXPORT_SYMBOL	
++0xfaad0992	async_xor_val	crypto/async_tx/async_xor	EXPORT_SYMBOL_GPL	
++0xd51c29f1	dm_sm_disk_create	drivers/md/persistent-data/dm-persistent-data	EXPORT_SYMBOL_GPL	
++0x0f836bef	v4l2_spi_new_subdev	drivers/media/v4l2-core/videodev	EXPORT_SYMBOL_GPL	
++0x8461af8c	v4l2_ctrl_handler_setup	drivers/media/v4l2-core/videodev	EXPORT_SYMBOL	
++0xb9d2df39	__SCK__tp_func_vb2_dqbuf	drivers/media/common/videobuf2/videobuf2-common	EXPORT_SYMBOL_GPL	
++0xd2ba16c2	md_integrity_add_rdev	drivers/md/md-mod	EXPORT_SYMBOL	
++0x02048d4f	__traceiter_vb2_v4l2_buf_queue	drivers/media/v4l2-core/videodev	EXPORT_SYMBOL_GPL	
++0x62b571f9	go7007_snd_remove	drivers/media/usb/go7007/go7007	EXPORT_SYMBOL	
++0x6eade4ec	mt76_register_phy	drivers/net/wireless/mediatek/mt76/mt76	EXPORT_SYMBOL_GPL	
++0x21b496c1	iscsi_tcp_r2tpool_alloc	drivers/scsi/libiscsi_tcp	EXPORT_SYMBOL_GPL	
++0x7e15bf20	drm_dev_unplug	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0x794e05ca	cfg80211_check_combinations	net/wireless/cfg80211	EXPORT_SYMBOL	
++0x2f01a734	snd_soc_component_test_bits	sound/soc/snd-soc-core	EXPORT_SYMBOL_GPL	
++0xeb711ae7	snd_soc_params_to_bclk	sound/soc/snd-soc-core	EXPORT_SYMBOL_GPL	
++0x71d8a60e	v4l2_m2m_try_schedule	drivers/media/v4l2-core/v4l2-mem2mem	EXPORT_SYMBOL_GPL	
++0xff7cbfbb	cdc_ncm_unbind	drivers/net/usb/cdc_ncm	EXPORT_SYMBOL_GPL	
++0xb92b787f	ipt_alloc_initial_table	net/ipv4/netfilter/ip_tables	EXPORT_SYMBOL_GPL	
++0x8c031122	ct_sip_get_header	net/netfilter/nf_conntrack_sip	EXPORT_SYMBOL_GPL	
++0x59e7b6fc	dvb_net_init	drivers/media/dvb-core/dvb-core	EXPORT_SYMBOL	
++0xe8a034df	drm_dev_exit	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0x5c9f18fe	tpm_chip_alloc	drivers/char/tpm/tpm	EXPORT_SYMBOL_GPL	
++0x3d73a797	p9_errstr2errno	net/9p/9pnet	EXPORT_SYMBOL	
++0xfbfb2175	snd_rawmidi_input_params	sound/core/snd-rawmidi	EXPORT_SYMBOL	
++0x8cf0e96b	serio_rescan	drivers/input/serio/serio	EXPORT_SYMBOL	
++0x1e3f728d	dm_block_data	drivers/md/persistent-data/dm-persistent-data	EXPORT_SYMBOL_GPL	
++0xf98d3c7d	md_error	drivers/md/md-mod	EXPORT_SYMBOL	
++0xd6e580af	v4l2_clk_unregister	drivers/media/v4l2-core/videodev	EXPORT_SYMBOL	
++0xe0a1710d	ezusb_fx1_ihex_firmware_download	drivers/usb/misc/ezusb	EXPORT_SYMBOL_GPL	
++0x251642cc	mtd_panic_write	drivers/mtd/mtd	EXPORT_SYMBOL_GPL	
++0x38efaf5a	dm_region_hash_destroy	drivers/md/dm-region-hash	EXPORT_SYMBOL_GPL	
++0xc727331c	dm_post_suspending	drivers/md/dm-mod	EXPORT_SYMBOL_GPL	
++0xe501ef9a	vb2_fop_read	drivers/media/common/videobuf2/videobuf2-v4l2	EXPORT_SYMBOL_GPL	
++0x0f77dafc	ath9k_hw_get_tsf_offset	drivers/net/wireless/ath/ath9k/ath9k_hw	EXPORT_SYMBOL	
++0x72a8a3e8	tpm_transmit_cmd	drivers/char/tpm/tpm	EXPORT_SYMBOL_GPL	
++0xca870598	wm_adsp_compr_free	sound/soc/codecs/snd-soc-wm-adsp	EXPORT_SYMBOL_GPL	
++0x57e16c3e	dm_rh_get_state	drivers/md/dm-region-hash	EXPORT_SYMBOL_GPL	
++0x0be67537	dm_btree_walk	drivers/md/persistent-data/dm-persistent-data	EXPORT_SYMBOL_GPL	
++0xaf1c6b40	rtl92ce_phy_set_rf_on	drivers/net/wireless/realtek/rtlwifi/rtl8192c/rtl8192c-common	EXPORT_SYMBOL	
++0x294c15ff	rtl_rfreg_delay	drivers/net/wireless/realtek/rtlwifi/rtlwifi	EXPORT_SYMBOL	
++0x8bb562e4	ath9k_cmn_get_hw_crypto_keytype	drivers/net/wireless/ath/ath9k/ath9k_common	EXPORT_SYMBOL	
++0x6f1d843c	ath9k_hw_btcoex_bt_stomp	drivers/net/wireless/ath/ath9k/ath9k_hw	EXPORT_SYMBOL	
++0xf9c057a4	ath9k_hw_txstart	drivers/net/wireless/ath/ath9k/ath9k_hw	EXPORT_SYMBOL	
++0x77bd5e5b	drm_self_refresh_helper_init	drivers/gpu/drm/drm_kms_helper	EXPORT_SYMBOL	
++0x1eaddbc6	btbcm_patchram	drivers/bluetooth/btbcm	EXPORT_SYMBOL	
++0x134adbed	ubi_open_volume	drivers/mtd/ubi/ubi	EXPORT_SYMBOL_GPL	
++0x5eb24829	dm_shift_arg	drivers/md/dm-mod	EXPORT_SYMBOL	
++0x390c7926	v4l2_async_unregister_subdev	drivers/media/v4l2-core/videodev	EXPORT_SYMBOL	
++0x6ebf3e5c	dib9000_get_tuner_interface	drivers/media/dvb-frontends/dib9000	EXPORT_SYMBOL	
++0x5281533c	open_candev	drivers/net/can/dev/can-dev	EXPORT_SYMBOL_GPL	
++0xb513a144	rtl92c_set_fw_joinbss_report_cmd	drivers/net/wireless/realtek/rtlwifi/rtl8192c/rtl8192c-common	EXPORT_SYMBOL	
++0x00ddc0af	ath9k_hw_gpio_request_out	drivers/net/wireless/ath/ath9k/ath9k_hw	EXPORT_SYMBOL	
++0x6d300802	drm_client_dev_hotplug	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0x43d07f75	ata_sas_scsi_ioctl	drivers/ata/libata	EXPORT_SYMBOL_GPL	
++0xac655f3b	ath_reg_notifier_apply	drivers/net/wireless/ath/ath	EXPORT_SYMBOL	
++0x870b53e9	eeprom_93cx6_write	drivers/misc/eeprom/eeprom_93cx6	EXPORT_SYMBOL_GPL	
++0x21c6bfca	nfc_send_to_raw_sock	net/nfc/nfc	EXPORT_SYMBOL	
++0xce935038	ieee80211_enable_rssi_reports	net/mac80211/mac80211	EXPORT_SYMBOL	
++0xc1fc5606	unregister_ip_vs_pe	net/netfilter/ipvs/ip_vs	EXPORT_SYMBOL_GPL	
++0x43c4f29b	nft_fib_init	net/netfilter/nft_fib	EXPORT_SYMBOL_GPL	
++0x30c120bb	snd_soc_put_volsw	sound/soc/snd-soc-core	EXPORT_SYMBOL_GPL	
++0x7051c370	snd_soc_get_volsw	sound/soc/snd-soc-core	EXPORT_SYMBOL_GPL	
++0x7731fc31	fbtft_write_vmem16_bus16	drivers/staging/fbtft/fbtft	EXPORT_SYMBOL	
++0xc0d7df85	dm_bufio_new	drivers/md/dm-bufio	EXPORT_SYMBOL_GPL	
++0xc9d65104	dibx000_reset_i2c_master	drivers/media/dvb-frontends/dibx000_common	EXPORT_SYMBOL	
++0x6b97a483	usb_wwan_resume	drivers/usb/serial/usb_wwan	EXPORT_SYMBOL	
++0x4fb207f4	mwifiex_shutdown_sw	drivers/net/wireless/marvell/mwifiex/mwifiex	EXPORT_SYMBOL_GPL	
++0xed27f2bc	spk_ttyio_synth_immediate	drivers/accessibility/speakup/speakup	EXPORT_SYMBOL_GPL	
++0xd840f6c8	cdrom_multisession	drivers/cdrom/cdrom	EXPORT_SYMBOL_GPL	
++0xc4575681	drm_plane_create_alpha_property	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0x7c0fbb00	vli_mod_mult_slow	crypto/ecc	EXPORT_SYMBOL	
++0x49ed86a0	ZSTD_endStream	lib/zstd/zstd_compress	EXPORT_SYMBOL	
++0xf06c022f	ip6_tnl_rcv_ctl	net/ipv6/ip6_tunnel	EXPORT_SYMBOL_GPL	
++0x71ce074f	wm8804_remove	sound/soc/codecs/snd-soc-wm8804	EXPORT_SYMBOL_GPL	
++0xddae4053	snd_pcm_stream_lock	sound/core/snd-pcm	EXPORT_SYMBOL_GPL	
++0x298b9731	spi_nor_restore	drivers/mtd/spi-nor/spi-nor	EXPORT_SYMBOL_GPL	
++0x8762619a	can_len2dlc	drivers/net/can/dev/can-dev	EXPORT_SYMBOL_GPL	
++0x8a300d2c	nf_tproxy_get_sock_v6	net/ipv6/netfilter/nf_tproxy_ipv6	EXPORT_SYMBOL_GPL	
++0x0ce3a9f8	__nf_conntrack_helper_find	net/netfilter/nf_conntrack	EXPORT_SYMBOL_GPL	
++0xeea5f02b	gether_register_netdev	drivers/usb/gadget/function/u_ether	EXPORT_SYMBOL_GPL	
++0xc8af37b2	ppp_input_error	drivers/net/ppp/ppp_generic	EXPORT_SYMBOL	
++0x2cae3657	ppp_unit_number	drivers/net/ppp/ppp_generic	EXPORT_SYMBOL	
++0x78d3b159	can_change_mtu	drivers/net/can/dev/can-dev	EXPORT_SYMBOL_GPL	
++0x8e31f453	lbs_notify_command_response	drivers/net/wireless/marvell/libertas/libertas	EXPORT_SYMBOL_GPL	
++0xde493e64	drm_dev_enter	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0xbbc4ef97	ocfs2_stack_supports_plocks	fs/ocfs2/ocfs2_stackglue	EXPORT_SYMBOL_GPL	
++0x6ffdc187	p9_client_link	net/9p/9pnet	EXPORT_SYMBOL	
++0x8cd2acfe	ahci_reset_em	drivers/ata/libahci	EXPORT_SYMBOL_GPL	
++0xbbf0bf47	v4l2_device_disconnect	drivers/media/v4l2-core/videodev	EXPORT_SYMBOL_GPL	
++0xdd4c4891	usb_serial_generic_open	drivers/usb/serial/usbserial	EXPORT_SYMBOL_GPL	
++0x65edabf3	can_rx_offload_queue_sorted	drivers/net/can/dev/can-dev	EXPORT_SYMBOL_GPL	
++0xb11ac7a7	__drm_err	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0xfa4f35ec	drm_universal_plane_init	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0x6ba704c2	drm_connector_update_edid_property	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0xeecf2ad0	drm_gem_create_mmap_offset_size	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0xe49d01f8	drm_primary_helper_funcs	drivers/gpu/drm/drm_kms_helper	EXPORT_SYMBOL	
++0xb0381159	hci_unregister_cb	net/bluetooth/bluetooth	EXPORT_SYMBOL	
++0xe9fe8e1d	ebt_do_table	net/bridge/netfilter/ebtables	EXPORT_SYMBOL	
++0x15f2e702	ip_set_type_unregister	net/netfilter/ipset/ip_set	EXPORT_SYMBOL_GPL	
++0x3f0d969e	md_wait_for_blocked_rdev	drivers/md/md-mod	EXPORT_SYMBOL	
++0x72ff5527	cx24110_attach	drivers/media/dvb-frontends/cx24110	EXPORT_SYMBOL	
++0x4a3df9d0	gs_alloc_req	drivers/usb/gadget/function/u_serial	EXPORT_SYMBOL_GPL	
++0x6016841a	ipvlan_link_delete	drivers/net/ipvlan/ipvlan	EXPORT_SYMBOL_GPL	
++0x12591e61	__devm_regmap_init_i2c	drivers/base/regmap/regmap-i2c	EXPORT_SYMBOL_GPL	
++0x9086628d	snd_soc_dai_set_fmt	sound/soc/snd-soc-core	EXPORT_SYMBOL_GPL	
++0x9f8f134a	snd_virmidi_new	sound/core/seq/snd-seq-virmidi	EXPORT_SYMBOL	
++0xfdf5efdd	ata_sff_tf_load	drivers/ata/libata	EXPORT_SYMBOL_GPL	
++0xd6eea00b	__media_device_usb_init	drivers/media/mc/mc	EXPORT_SYMBOL_GPL	
++0x8cac86e7	drm_atomic_nonblocking_commit	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0x752329e9	p9_client_setattr	net/9p/9pnet	EXPORT_SYMBOL	
++0x10e6ccea	dm_bitset_clear_bit	drivers/md/persistent-data/dm-persistent-data	EXPORT_SYMBOL_GPL	
++0x6dc5c6f3	media_remove_intf_link	drivers/media/mc/mc	EXPORT_SYMBOL_GPL	
++0x59624a34	iscsi_tcp_segment_done	drivers/scsi/libiscsi_tcp	EXPORT_SYMBOL_GPL	
++0x9507547f	ocfs2_cluster_disconnect	fs/ocfs2/ocfs2_stackglue	EXPORT_SYMBOL_GPL	
++0x1679b0a9	arizona_init_mono	sound/soc/codecs/snd-soc-arizona	EXPORT_SYMBOL_GPL	
++0x885b0024	dm_array_new	drivers/md/persistent-data/dm-persistent-data	EXPORT_SYMBOL_GPL	
++0xf72ca296	videobuf_queue_is_busy	drivers/media/v4l2-core/videobuf-core	EXPORT_SYMBOL_GPL	
++0xabbf80a7	drm_dp_get_vc_payload_bw	drivers/gpu/drm/drm_kms_helper	EXPORT_SYMBOL	
++0x38b92846	llc_remove_pack	net/llc/llc	EXPORT_SYMBOL	
++0x2a2c9238	xt_target_to_user	net/netfilter/x_tables	EXPORT_SYMBOL_GPL	
++0x61c60882	snd_timer_instance_new	sound/core/snd-timer	EXPORT_SYMBOL	
++0xa1342f90	rndis_add_hdr	drivers/usb/gadget/function/usb_f_rndis	EXPORT_SYMBOL_GPL	
++0x8a384314	drm_mode_create_dvi_i_properties	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0x95dbc76d	drm_ht_create	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0x18f8d09b	fuse_conn_destroy	fs/fuse/fuse	EXPORT_SYMBOL_GPL	
++0x1c43ea43	cfg80211_disconnected	net/wireless/cfg80211	EXPORT_SYMBOL	
++0x936a2147	nft_chain_validate_hooks	net/netfilter/nf_tables	EXPORT_SYMBOL_GPL	
++0xf6115f3c	dvb_register_adapter	drivers/media/dvb-core/dvb-core	EXPORT_SYMBOL	
++0x88231aad	gspca_expo_autogain	drivers/media/usb/gspca/gspca_main	EXPORT_SYMBOL	
++0xe0656a77	vb2_ioctl_querybuf	drivers/media/common/videobuf2/videobuf2-v4l2	EXPORT_SYMBOL_GPL	
++0x4beb505d	usb_gadget_get_string	drivers/usb/gadget/libcomposite	EXPORT_SYMBOL_GPL	
++0x3188b3d4	rt2x00queue_flush_queues	drivers/net/wireless/ralink/rt2x00/rt2x00lib	EXPORT_SYMBOL_GPL	
++0xfb4a5c93	ieee80211_tx_prepare_skb	net/mac80211/mac80211	EXPORT_SYMBOL	
++0x519ffece	cfg80211_nan_match	net/wireless/cfg80211	EXPORT_SYMBOL	
++0x67f55868	nf_send_reset	net/ipv4/netfilter/nf_reject_ipv4	EXPORT_SYMBOL_GPL	
++0x17be45c0	dm_cell_promote_or_release	drivers/md/dm-bio-prison	EXPORT_SYMBOL_GPL	
++0xa7b7f1cd	rt2800_config_ant	drivers/net/wireless/ralink/rt2x00/rt2800lib	EXPORT_SYMBOL_GPL	
++0x0380e9ed	drm_framebuffer_unregister_private	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0x4437fdcf	p9_client_read	net/9p/9pnet	EXPORT_SYMBOL	
++0x8bc29eee	udp_tunnel_drop_rx_port	net/ipv4/udp_tunnel	EXPORT_SYMBOL_GPL	
++0x3251d762	nf_tables_trans_destroy_flush_work	net/netfilter/nf_tables	EXPORT_SYMBOL_GPL	
++0xe59948d6	snd_dmaengine_pcm_prepare_slave_config	sound/soc/snd-soc-core	EXPORT_SYMBOL_GPL	
++0x209b1dbb	media_entity_remote_pad	drivers/media/mc/mc	EXPORT_SYMBOL_GPL	
++0x3342748e	zd1301_demod_get_i2c_adapter	drivers/media/dvb-frontends/zd1301_demod	EXPORT_SYMBOL	
++0x23eac4eb	p9_client_write	net/9p/9pnet	EXPORT_SYMBOL	
++0xd505c3e0	nf_ct_port_nlattr_tuple_size	net/netfilter/nf_conntrack	EXPORT_SYMBOL_GPL	
++0xa9e671fa	wm_adsp2_preloader_put	sound/soc/codecs/snd-soc-wm-adsp	EXPORT_SYMBOL_GPL	
++0x15d8aa41	__drm_printfn_seq_file	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0x2b383e38	drm_mode_probed_add	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0x95ce5e51	snd_soc_component_force_enable_pin	sound/soc/snd-soc-core	EXPORT_SYMBOL_GPL	
++0x21513969	rtl92c_phy_sw_chnl	drivers/net/wireless/realtek/rtlwifi/rtl8192c/rtl8192c-common	EXPORT_SYMBOL	
++0xaf311cf7	drm_crtc_set_max_vblank_count	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0xcaccebc3	drm_dp_mst_detect_port	drivers/gpu/drm/drm_kms_helper	EXPORT_SYMBOL	
++0x504cb053	simd_aead_create_compat	crypto/crypto_simd	EXPORT_SYMBOL_GPL	
++0xc0245614	snd_compress_new	sound/core/snd-compress	EXPORT_SYMBOL_GPL	
++0x105d53d8	iio_trigger_poll	drivers/iio/industrialio	EXPORT_SYMBOL	
++0xd0cc0401	w1_reset_bus	drivers/w1/wire	EXPORT_SYMBOL_GPL	
++0x78665106	md_bitmap_close_sync	drivers/md/md-mod	EXPORT_SYMBOL	
++0x5a86cf59	md_bitmap_startwrite	drivers/md/md-mod	EXPORT_SYMBOL	
++0xb4b77c8b	hostap_80211_get_hdrlen	drivers/net/wireless/intersil/hostap/hostap	EXPORT_SYMBOL	
++0x7a408110	ath9k_hw_reset	drivers/net/wireless/ath/ath9k/ath9k_hw	EXPORT_SYMBOL	
++0x03c63897	__drm_get_edid_firmware_path	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0x25b0bb6c	ieee802154_wake_queue	net/mac802154/mac802154	EXPORT_SYMBOL	
++0x57686c15	iio_get_channel_ext_info_count	drivers/iio/industrialio	EXPORT_SYMBOL_GPL	
++0x77f512aa	uio_unregister_device	drivers/uio/uio	EXPORT_SYMBOL_GPL	
++0x66c0289a	b2c2_flexcop_debug	drivers/media/common/b2c2/b2c2-flexcop	EXPORT_SYMBOL_GPL	
++0xcc883dfb	hostap_set_auth_algs	drivers/net/wireless/intersil/hostap/hostap	EXPORT_SYMBOL	
++0x5863e3c2	drm_atomic_helper_duplicate_state	drivers/gpu/drm/drm_kms_helper	EXPORT_SYMBOL	
++0x34ad6f70	vhost_new_msg	drivers/vhost/vhost	EXPORT_SYMBOL_GPL	
++0x3c784589	kill_mtd_super	drivers/mtd/mtd	EXPORT_SYMBOL_GPL	
++0x9c744b2f	ahci_shost_attrs	drivers/ata/libahci	EXPORT_SYMBOL_GPL	
++0x5fe617e6	dm_table_get_size	drivers/md/dm-mod	EXPORT_SYMBOL	
++0x2e3be815	gether_get_host_addr	drivers/usb/gadget/function/u_ether	EXPORT_SYMBOL_GPL	
++0x89ffec16	gether_set_host_addr	drivers/usb/gadget/function/u_ether	EXPORT_SYMBOL_GPL	
++0x2b786830	wm_adsp2_set_dspclk	sound/soc/codecs/snd-soc-wm-adsp	EXPORT_SYMBOL_GPL	
++0xd701f9a3	ssb_dma_translation	drivers/ssb/ssb	EXPORT_SYMBOL	
++0xea85c736	md_bitmap_update_sb	drivers/md/md-mod	EXPORT_SYMBOL	
++0xd18c21d6	cx231xx_init_isoc	drivers/media/usb/cx231xx/cx231xx	EXPORT_SYMBOL_GPL	
++0x3a5a7715	vb2_streamon	drivers/media/common/videobuf2/videobuf2-v4l2	EXPORT_SYMBOL_GPL	
++0xbf11e70f	lbs_cmd_copyback	drivers/net/wireless/marvell/libertas/libertas	EXPORT_SYMBOL_GPL	
++0x81bbe36b	drm_connector_attach_scaling_mode_property	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0xc6ec0284	snd_dmaengine_pcm_close_release_chan	sound/core/snd-pcm-dmaengine	EXPORT_SYMBOL_GPL	
++0x4ac8d13e	lbs_host_to_card_done	drivers/net/wireless/marvell/libertas/libertas	EXPORT_SYMBOL_GPL	
++0x600fb2ad	af_alg_sendmsg	crypto/af_alg	EXPORT_SYMBOL_GPL	
++0x4d3af7fa	ocfs2_cluster_hangup	fs/ocfs2/ocfs2_stackglue	EXPORT_SYMBOL_GPL	
++0x650f8603	snd_pcm_format_silence_64	sound/core/snd-pcm	EXPORT_SYMBOL	
++0xa24517eb	vhost_iotlb_free	drivers/vhost/vhost_iotlb	EXPORT_SYMBOL_GPL	
++0x25f8f25a	ata_std_error_handler	drivers/ata/libata	EXPORT_SYMBOL_GPL	
++0x2508f4d5	md_stop	drivers/md/md-mod	EXPORT_SYMBOL_GPL	
++0x6e89d9df	v4l2_device_unregister	drivers/media/v4l2-core/videodev	EXPORT_SYMBOL_GPL	
++0x561f6b9d	iscsi_eh_recover_target	drivers/scsi/libiscsi	EXPORT_SYMBOL_GPL	
++0x0904ca6c	drm_crtc_vblank_waitqueue	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0x090ec636	bt_sock_ioctl	net/bluetooth/bluetooth	EXPORT_SYMBOL	
++0x85a8ee76	ubi_unregister_volume_notifier	drivers/mtd/ubi/ubi	EXPORT_SYMBOL_GPL	
++0x7f145a0d	ubi_open_volume_nm	drivers/mtd/ubi/ubi	EXPORT_SYMBOL_GPL	
++0xd7685169	ata_pci_shutdown_one	drivers/ata/libata	EXPORT_SYMBOL_GPL	
++0xe6237cbd	md_bitmap_load	drivers/md/md-mod	EXPORT_SYMBOL_GPL	
++0x90864e5a	v4l2_m2m_ioctl_stateless_try_decoder_cmd	drivers/media/v4l2-core/v4l2-mem2mem	EXPORT_SYMBOL_GPL	
++0xf43cf147	v4l2_async_notifier_cleanup	drivers/media/v4l2-core/videodev	EXPORT_SYMBOL_GPL	
++0xdf1af923	ipv6_opt_accepted	net/ipv6/ipv6	EXPORT_SYMBOL_GPL	
++0x4b1702d5	arpt_register_table	net/ipv4/netfilter/arp_tables	EXPORT_SYMBOL	
++0xdfe804b8	arizona_sample_rate_val	sound/soc/codecs/snd-soc-arizona	EXPORT_SYMBOL_GPL	
++0xbd701dcd	ssb_bus_powerup	drivers/ssb/ssb	EXPORT_SYMBOL	
++0x1ff1ea98	rtl_usb_disconnect	drivers/net/wireless/realtek/rtlwifi/rtl_usb	EXPORT_SYMBOL	
++0xe583a05e	drm_modeset_lock	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0x6ddf27bc	poly1305_update_arch	arch/arm64/crypto/poly1305-neon	EXPORT_SYMBOL	
++0x0916f40d	atm_alloc_charge	net/atm/atm	EXPORT_SYMBOL	
++0x46277216	arizona_rate_val	sound/soc/codecs/snd-soc-arizona	EXPORT_SYMBOL_GPL	
++0x39bf9301	_snd_pcm_hw_param_setempty	sound/core/snd-pcm	EXPORT_SYMBOL	
++0xca3f55e4	drm_atomic_helper_commit_hw_done	drivers/gpu/drm/drm_kms_helper	EXPORT_SYMBOL	
++0xa60ee00c	nfc_tm_data_received	net/nfc/nfc	EXPORT_SYMBOL	
++0xf8c8bbbc	ieee802154_rx_irqsafe	net/mac802154/mac802154	EXPORT_SYMBOL	
++0x8ede9e26	ax25_protocol_release	net/ax25/ax25	EXPORT_SYMBOL	
++0x56451625	iio_trigger_using_own	drivers/iio/industrialio	EXPORT_SYMBOL	
++0x6bb4bf8f	dm_array_cursor_next	drivers/md/persistent-data/dm-persistent-data	EXPORT_SYMBOL_GPL	
++0x053ecada	rt2800_sta_add	drivers/net/wireless/ralink/rt2x00/rt2800lib	EXPORT_SYMBOL_GPL	
++0x077bad18	rt2800_txdone_nostatus	drivers/net/wireless/ralink/rt2x00/rt2800lib	EXPORT_SYMBOL_GPL	
++0x60a7a33e	of_drm_find_panel	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0x6a31184d	xt_rateest_lookup	net/netfilter/xt_RATEEST	EXPORT_SYMBOL_GPL	
++0x94154017	ata_std_bios_param	drivers/ata/libata	EXPORT_SYMBOL_GPL	
++0xd6711a58	dm_bitset_cursor_next	drivers/md/persistent-data/dm-persistent-data	EXPORT_SYMBOL_GPL	
++0x939c59bd	md_wakeup_thread	drivers/md/md-mod	EXPORT_SYMBOL	
++0xdc13f30f	drm_gem_cma_free_object	drivers/gpu/drm/drm	EXPORT_SYMBOL_GPL	
++0x2a6b6d67	drm_gem_map_dma_buf	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0x193a8be4	drm_clflush_pages	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0xb66e1051	drm_gem_fb_create_with_funcs	drivers/gpu/drm/drm_kms_helper	EXPORT_SYMBOL_GPL	
++0x1e296dc4	cfg80211_ft_event	net/wireless/cfg80211	EXPORT_SYMBOL	
++0x393d0645	arpt_unregister_table_pre_exit	net/ipv4/netfilter/arp_tables	EXPORT_SYMBOL	
++0x34bf0e61	smscore_translate_msg	drivers/media/common/siano/smsmdtv	EXPORT_SYMBOL_GPL	
++0xa808ad2d	rndis_tx_fixup	drivers/net/usb/rndis_host	EXPORT_SYMBOL_GPL	
++0x1750bf4c	iscsi_boot_create_acpitbl	drivers/scsi/iscsi_boot_sysfs	EXPORT_SYMBOL_GPL	
++0x1fd28299	drm_gem_shmem_dumb_create	drivers/gpu/drm/drm	EXPORT_SYMBOL_GPL	
++0x1e794542	drm_read	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0x5f246cc4	vcc_sklist_lock	net/atm/atm	EXPORT_SYMBOL	
++0xe613922e	ip_vs_conn_out_get	net/netfilter/ipvs/ip_vs	EXPORT_SYMBOL	
++0x202a1b1b	line6_midi_id	sound/usb/line6/snd-usb-line6	EXPORT_SYMBOL_GPL	
++0x0b49b18c	ath6kl_stop_txrx	drivers/net/wireless/ath/ath6kl/ath6kl_core	EXPORT_SYMBOL	
++0x54c6149f	drm_fb_helper_debug_enter	drivers/gpu/drm/drm_kms_helper	EXPORT_SYMBOL	
++0xc78fd10e	p9_release_pages	net/9p/9pnet	EXPORT_SYMBOL	
++0x69d5f7c1	ip_tunnel_encap_setup	net/ipv4/ip_tunnel	EXPORT_SYMBOL_GPL	
++0x6fa2a386	vc_sm_cma_int_handle	drivers/staging/vc04_services/vc-sm-cma/vc-sm-cma	EXPORT_SYMBOL_GPL	
++0xadaa5b62	dvb_ca_en50221_camready_irq	drivers/media/dvb-core/dvb-core	EXPORT_SYMBOL	
++0x3f9723ad	v4l2_ctrl_new_std_menu_items	drivers/media/v4l2-core/videodev	EXPORT_SYMBOL	
++0xb6652875	gserial_free_line	drivers/usb/gadget/function/u_serial	EXPORT_SYMBOL_GPL	
++0xb51cf25e	drm_bridge_chain_disable	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0xd861b69e	drm_mode_prune_invalid	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0x79f7f08f	cfg80211_unregister_wdev	net/wireless/cfg80211	EXPORT_SYMBOL	
++0x3c1daf08	v4l2_m2m_poll	drivers/media/v4l2-core/v4l2-mem2mem	EXPORT_SYMBOL_GPL	
++0xa7415b24	v4l_enable_media_source	drivers/media/v4l2-core/videodev	EXPORT_SYMBOL_GPL	
++0x4250e19f	em28xx_unregister_extension	drivers/media/usb/em28xx/em28xx	EXPORT_SYMBOL	
++0xcd5977a0	xc2028_attach	drivers/media/tuners/tuner-xc2028	EXPORT_SYMBOL	
++0x564243f4	i2c_mux_del_adapters	drivers/i2c/i2c-mux	EXPORT_SYMBOL_GPL	
++0x71e9427b	wpan_phy_register	net/ieee802154/ieee802154	EXPORT_SYMBOL	
++0x34c85bc7	ip_set_nfnl_get_byindex	net/netfilter/ipset/ip_set	EXPORT_SYMBOL_GPL	
++0xad200a40	nf_flow_table_free	net/netfilter/nf_flow_table	EXPORT_SYMBOL_GPL	
++0xd16d9c01	v4l2_ctrl_get_int_menu	drivers/media/v4l2-core/videodev	EXPORT_SYMBOL	
++0x849b0941	__media_device_register	drivers/media/mc/mc	EXPORT_SYMBOL_GPL	
++0x220c2fb3	rtl_phy_scan_operation_backup	drivers/net/wireless/realtek/rtlwifi/rtlwifi	EXPORT_SYMBOL	
++0xe7c10743	rt2x00lib_rxdone	drivers/net/wireless/ralink/rt2x00/rt2x00lib	EXPORT_SYMBOL_GPL	
++0x9e173134	ieee80211_iter_chan_contexts_atomic	net/mac80211/mac80211	EXPORT_SYMBOL_GPL	
++0xe71e822c	drm_gem_fence_array_add_implicit	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0x6c66a8c5	drm_is_current_master	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0xf7b709bd	nf_nat_inet_fn	net/netfilter/nf_nat	EXPORT_SYMBOL_GPL	
++0x99951373	snd_soc_component_set_pll	sound/soc/snd-soc-core	EXPORT_SYMBOL_GPL	
++0x4a5eae31	snd_pcm_hw_param_last	sound/core/snd-pcm	EXPORT_SYMBOL	
++0x33d2f848	ata_dev_disable	drivers/ata/libata	EXPORT_SYMBOL_GPL	
++0xd5402b9c	fbtft_register_backlight	drivers/staging/fbtft/fbtft	EXPORT_SYMBOL	
++0x3a0cbaa6	mt76x02_init_beacon_config	drivers/net/wireless/mediatek/mt76/mt76x02-lib	EXPORT_SYMBOL_GPL	
++0x27f98842	__gue_build_header	net/ipv4/fou	EXPORT_SYMBOL	
++0x93008223	__fou_build_header	net/ipv4/fou	EXPORT_SYMBOL	
++0xf0bb9d96	nf_ct_l4proto_log_invalid	net/netfilter/nf_conntrack	EXPORT_SYMBOL_GPL	
++0x160fc095	vb2_core_streamon	drivers/media/common/videobuf2/videobuf2-common	EXPORT_SYMBOL_GPL	
++0xb617588d	i2400m_cmd_enter_powersave	drivers/net/wimax/i2400m/i2400m	EXPORT_SYMBOL_GPL	
++0x274ac1b2	nf_log_dump_sk_uid_gid	net/netfilter/nf_log_common	EXPORT_SYMBOL_GPL	
++0xcc6a729f	snd_ctl_enum_info	sound/core/snd	EXPORT_SYMBOL	
++0xab2dd12b	v4l2_m2m_buf_copy_metadata	drivers/media/v4l2-core/v4l2-mem2mem	EXPORT_SYMBOL_GPL	
++0x7a5d8c0b	tpg_update_mv_step	drivers/media/common/v4l2-tpg/v4l2-tpg	EXPORT_SYMBOL_GPL	
++0xa5b1a4dc	af_alg_count_tsgl	crypto/af_alg	EXPORT_SYMBOL_GPL	
++0xf1f6cf25	__v4l2_ctrl_s_ctrl	drivers/media/v4l2-core/videodev	EXPORT_SYMBOL	
++0x78f4e4e3	snd_pcm_hw_refine	sound/core/snd-pcm	EXPORT_SYMBOL	
++0x7551b46e	dm_tm_open_with_sm	drivers/md/persistent-data/dm-persistent-data	EXPORT_SYMBOL_GPL	
++0x15ca25d7	cec_transmit_attempt_done_ts	drivers/media/cec/core/cec	EXPORT_SYMBOL_GPL	
++0x7e32a3d2	v4l2_m2m_encoder_cmd	drivers/media/v4l2-core/v4l2-mem2mem	EXPORT_SYMBOL_GPL	
++0xfa158404	usbnet_ether_cdc_bind	drivers/net/usb/cdc_ether	EXPORT_SYMBOL_GPL	
++0x0d0026aa	vsock_add_tap	net/vmw_vsock/vsock	EXPORT_SYMBOL_GPL	
++0xd8ad95c8	unregister_ip_vs_app	net/netfilter/ipvs/ip_vs	EXPORT_SYMBOL	
++0xaf90ce5a	dib0090_fw_register	drivers/media/dvb-frontends/dib0090	EXPORT_SYMBOL	
++0x1956674a	rt2x00lib_probe_dev	drivers/net/wireless/ralink/rt2x00/rt2x00lib	EXPORT_SYMBOL_GPL	
++0x94a7bf29	pie_drop_early	net/sched/sch_pie	EXPORT_SYMBOL_GPL	
++0x745efab6	dapm_mark_endpoints_dirty	sound/soc/snd-soc-core	EXPORT_SYMBOL_GPL	
++0xf8f2a4eb	snd_kill_fasync	sound/core/snd	EXPORT_SYMBOL_GPL	
++0xbbe8b343	can_bus_off	drivers/net/can/dev/can-dev	EXPORT_SYMBOL_GPL	
++0x2524ba17	ZSTD_getCParams	lib/zstd/zstd_compress	EXPORT_SYMBOL	
++0xa7656d8e	ata_sff_check_status	drivers/ata/libata	EXPORT_SYMBOL_GPL	
++0x00c12014	usb_serial_register_drivers	drivers/usb/serial/usbserial	EXPORT_SYMBOL_GPL	
++0xf7234b9c	mt76x02_reconfig_complete	drivers/net/wireless/mediatek/mt76/mt76x02-lib	EXPORT_SYMBOL_GPL	
++0x159ae94c	cryptd_ahash_child	crypto/cryptd	EXPORT_SYMBOL_GPL	
++0x14291b36	fuse_get_unique	fs/fuse/fuse	EXPORT_SYMBOL_GPL	
++0x2181bec0	roccat_common2_send_with_status	drivers/hid/hid-roccat-common	EXPORT_SYMBOL_GPL	
++0x7eadb2c0	dvb_dmxdev_release	drivers/media/dvb-core/dvb-core	EXPORT_SYMBOL	
++0xefe9005c	horus3a_attach	drivers/media/dvb-frontends/horus3a	EXPORT_SYMBOL	
++0x7e3a17a8	esp6_input_done2	net/ipv6/esp6	EXPORT_SYMBOL_GPL	
++0x8c6dcb55	dm_copy_name_and_uuid	drivers/md/dm-mod	EXPORT_SYMBOL_GPL	
++0xf4c77046	brcmu_pktq_pflush	drivers/net/wireless/broadcom/brcm80211/brcmutil/brcmutil	EXPORT_SYMBOL	
++0x496156f8	ar9003_paprd_populate_single_table	drivers/net/wireless/ath/ath9k/ath9k_hw	EXPORT_SYMBOL	
++0x7924b6de	ip_set_hostmask_map	net/netfilter/ipset/ip_set	EXPORT_SYMBOL_GPL	
++0x2ca3070c	tua6100_attach	drivers/media/dvb-frontends/tua6100	EXPORT_SYMBOL	
++0x7475be8e	crypto_ecdh_key_len	crypto/ecdh_generic	EXPORT_SYMBOL_GPL	
++0x3c2df3e0	nfc_find_se	net/nfc/nfc	EXPORT_SYMBOL	
++0x817364ba	cfg80211_scan_done	net/wireless/cfg80211	EXPORT_SYMBOL	
++0xea2869df	ip6_tnl_get_link_net	net/ipv6/ip6_tunnel	EXPORT_SYMBOL	
++0x30519a2e	inet6_csk_xmit	net/ipv6/ipv6	EXPORT_SYMBOL_GPL	
++0xcbe7a610	register_ip_vs_pe	net/netfilter/ipvs/ip_vs	EXPORT_SYMBOL_GPL	
++0xcbb22f42	vhost_dev_ioctl	drivers/vhost/vhost	EXPORT_SYMBOL_GPL	
++0x849f6284	ata_eh_analyze_ncq_error	drivers/ata/libata	EXPORT_SYMBOL_GPL	
++0xc3afdfd7	videobuf_alloc_vb	drivers/media/v4l2-core/videobuf-core	EXPORT_SYMBOL_GPL	
++0x5f4ff093	iforce_init_device	drivers/input/joystick/iforce/iforce	EXPORT_SYMBOL	
++0xb52ba28a	fsg_intf_desc	drivers/usb/gadget/function/usb_f_mass_storage	EXPORT_SYMBOL_GPL	
++0x05cef980	drm_fb_helper_sys_fillrect	drivers/gpu/drm/drm_kms_helper	EXPORT_SYMBOL	
++0x14824c21	media_remove_intf_links	drivers/media/mc/mc	EXPORT_SYMBOL_GPL	
++0x96a5a6cf	mwifiex_queue_main_work	drivers/net/wireless/marvell/mwifiex/mwifiex	EXPORT_SYMBOL_GPL	
++0x9ef9262e	cfg80211_radar_event	net/wireless/cfg80211	EXPORT_SYMBOL	
++0xa4a8481d	cfg80211_inform_bss_data	net/wireless/cfg80211	EXPORT_SYMBOL	
++0x42dc51cb	snd_soc_dapm_kcontrol_dapm	sound/soc/snd-soc-core	EXPORT_SYMBOL_GPL	
++0x3ec4695b	v4l2_async_notifier_parse_fwnode_endpoints_by_port	drivers/media/v4l2-core/v4l2-fwnode	EXPORT_SYMBOL_GPL	
++0xe6b95b45	ieee80211_proberesp_get	net/mac80211/mac80211	EXPORT_SYMBOL	
++0x1861e81d	ipv6_recv_error	net/ipv6/ipv6	EXPORT_SYMBOL_GPL	
++0x34a31720	snd_soc_put_enum_double	sound/soc/snd-soc-core	EXPORT_SYMBOL_GPL	
++0xed22283c	snd_soc_get_enum_double	sound/soc/snd-soc-core	EXPORT_SYMBOL_GPL	
++0x466f5eb7	synth_putwc	drivers/accessibility/speakup/speakup	EXPORT_SYMBOL_GPL	
++0x49d33b90	_rtl92c_phy_fw_rf_serial_write	drivers/net/wireless/realtek/rtlwifi/rtl8192c/rtl8192c-common	EXPORT_SYMBOL	
++0xa26a8bd4	drm_atomic_helper_calc_timestamping_constants	drivers/gpu/drm/drm_kms_helper	EXPORT_SYMBOL	
++0x4dc20147	cryptd_skcipher_child	crypto/cryptd	EXPORT_SYMBOL_GPL	
++0x6ed9227d	unregister_snap_client	net/802/psnap	EXPORT_SYMBOL	
++0x7485935a	dm_btree_lookup	drivers/md/persistent-data/dm-persistent-data	EXPORT_SYMBOL_GPL	
++0x08402862	v4l2_print_dv_timings	drivers/media/v4l2-core/v4l2-dv-timings	EXPORT_SYMBOL_GPL	
++0x4dc892e9	drx39xxj_attach	drivers/media/dvb-frontends/drx39xyj/drx39xyj	EXPORT_SYMBOL	
++0x1f1c5a6e	drm_atomic_state_default_clear	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0x4f718e31	drm_mode_config_helper_suspend	drivers/gpu/drm/drm_kms_helper	EXPORT_SYMBOL	
++0x595fb20c	drm_dp_mst_put_port_malloc	drivers/gpu/drm/drm_kms_helper	EXPORT_SYMBOL	
++0x7b82e2e0	cfg80211_rx_unprot_mlme_mgmt	net/wireless/cfg80211	EXPORT_SYMBOL	
++0xbdf0d85f	nf_send_reset6	net/ipv6/netfilter/nf_reject_ipv6	EXPORT_SYMBOL_GPL	
++0x366c8e51	nf_conntrack_register_notifier	net/netfilter/nf_conntrack	EXPORT_SYMBOL_GPL	
++0xbb98a68d	devm_iio_trigger_alloc	drivers/iio/industrialio	EXPORT_SYMBOL_GPL	
++0x26174170	dm_exception_store_type_register	drivers/md/dm-snapshot	EXPORT_SYMBOL	
++0xdb66d437	rt2800_config_intf	drivers/net/wireless/ralink/rt2x00/rt2800lib	EXPORT_SYMBOL_GPL	
++0x000fc73e	ath6kl_hif_intr_bh_handler	drivers/net/wireless/ath/ath6kl/ath6kl_core	EXPORT_SYMBOL	
++0x91cfb84a	ath6kl_hif_rw_comp_handler	drivers/net/wireless/ath/ath6kl/ath6kl_core	EXPORT_SYMBOL	
++0x30308b69	w1_write_block	drivers/w1/wire	EXPORT_SYMBOL_GPL	
++0x3c74ff79	fbtft_write_gpio16_wr	drivers/staging/fbtft/fbtft	EXPORT_SYMBOL	
++0xdec667eb	itd1000_attach	drivers/media/dvb-frontends/itd1000	EXPORT_SYMBOL	
++0x70e564d0	iscsi_boot_create_target	drivers/scsi/iscsi_boot_sysfs	EXPORT_SYMBOL_GPL	
++0xfd8aa8fe	snd_soc_component_disable_pin_unlocked	sound/soc/snd-soc-core	EXPORT_SYMBOL_GPL	
++0x8d23f26a	bcma_chipco_get_alp_clock	drivers/bcma/bcma	EXPORT_SYMBOL_GPL	
++0x03df925e	tm6000_unregister_extension	drivers/media/usb/tm6000/tm6000	EXPORT_SYMBOL	
++0x8275c5ff	flexcop_device_kmalloc	drivers/media/common/b2c2/b2c2-flexcop	EXPORT_SYMBOL	
++0x12c34769	drm_state_dump	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0x2454cbcc	o2nm_node_put	fs/ocfs2/cluster/ocfs2_nodemanager	EXPORT_SYMBOL_GPL	
++0x2a5d816f	cfg80211_chandef_valid	net/wireless/cfg80211	EXPORT_SYMBOL	
++0x05b64f2e	arizona_init_fll	sound/soc/codecs/snd-soc-arizona	EXPORT_SYMBOL_GPL	
++0xc3e704ef	drm_atomic_helper_crtc_duplicate_state	drivers/gpu/drm/drm_kms_helper	EXPORT_SYMBOL	
++0x342a2354	copy_to_user_fromio	sound/core/snd	EXPORT_SYMBOL	
++0xd741d474	bcma_core_enable	drivers/bcma/bcma	EXPORT_SYMBOL_GPL	
++0x38e10c1d	ubi_flush	drivers/mtd/ubi/ubi	EXPORT_SYMBOL_GPL	
++0x98db2687	dm_bitset_cursor_end	drivers/md/persistent-data/dm-persistent-data	EXPORT_SYMBOL_GPL	
++0x573b5453	ipv6_fixup_options	net/ipv6/ipv6	EXPORT_SYMBOL_GPL	
++0x96071f00	dvb_usbv2_generic_write	drivers/media/usb/dvb-usb-v2/dvb_usb_v2	EXPORT_SYMBOL	
++0xea39e4cd	usb_get_function	drivers/usb/gadget/libcomposite	EXPORT_SYMBOL_GPL	
++0x08dd61fd	gether_get_qmult	drivers/usb/gadget/function/u_ether	EXPORT_SYMBOL_GPL	
++0x7aa2e05d	gether_set_qmult	drivers/usb/gadget/function/u_ether	EXPORT_SYMBOL_GPL	
++0xd3f548c2	cdrom_open	drivers/cdrom/cdrom	EXPORT_SYMBOL	
++0xb7322b91	drm_panel_unprepare	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0x5cfddb5d	drm_dp_dual_mode_read	drivers/gpu/drm/drm_kms_helper	EXPORT_SYMBOL	
++0x816c2d4d	arizona_ng_hold	sound/soc/codecs/snd-soc-arizona	EXPORT_SYMBOL_GPL	
++0x9cd07cb4	ata_scsi_slave_config	drivers/ata/libata	EXPORT_SYMBOL_GPL	
++0x321be6bd	ata_pci_device_resume	drivers/ata/libata	EXPORT_SYMBOL_GPL	
++0x9885e908	drm_client_buffer_vmap	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0xeabf69a7	drm_connector_attach_tv_margin_properties	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0x912c2c6a	drm_dp_set_phy_test_pattern	drivers/gpu/drm/drm_kms_helper	EXPORT_SYMBOL	
++0xc662f0fd	drm_dp_get_phy_test_pattern	drivers/gpu/drm/drm_kms_helper	EXPORT_SYMBOL	
++0xa7baa8ea	backlight_device_set_brightness	drivers/video/backlight/backlight	EXPORT_SYMBOL	
++0x39a55bcf	snd_device_get_state	sound/core/snd	EXPORT_SYMBOL_GPL	
++0x9b71a87e	ata_port_pbar_desc	drivers/ata/libata	EXPORT_SYMBOL_GPL	
++0x5638016c	vb2_streamoff	drivers/media/common/videobuf2/videobuf2-v4l2	EXPORT_SYMBOL_GPL	
++0xe47339b5	ath9k_cmn_setup_ht_cap	drivers/net/wireless/ath/ath9k/ath9k_common	EXPORT_SYMBOL	
++0x87f21bca	ath9k_hw_gpio_free	drivers/net/wireless/ath/ath9k/ath9k_hw	EXPORT_SYMBOL	
++0xf898b14d	cryptd_alloc_ahash	crypto/cryptd	EXPORT_SYMBOL_GPL	
++0x2a1538ec	p9_client_stat	net/9p/9pnet	EXPORT_SYMBOL	
++0x263c7535	nft_parse_register_store	net/netfilter/nf_tables	EXPORT_SYMBOL_GPL	
++0xca0c8e00	dapm_regulator_event	sound/soc/snd-soc-core	EXPORT_SYMBOL_GPL	
++0x28723004	dm_table_device_name	drivers/md/dm-mod	EXPORT_SYMBOL_GPL	
++0xcf70b9d9	vb2_core_create_bufs	drivers/media/common/videobuf2/videobuf2-common	EXPORT_SYMBOL_GPL	
++0xafb2e7d2	mt76x2_get_rate_power	drivers/net/wireless/mediatek/mt76/mt76x2/mt76x2-common	EXPORT_SYMBOL_GPL	
++0x7b6372ba	drm_sched_entity_flush	drivers/gpu/drm/scheduler/gpu-sched	EXPORT_SYMBOL	
++0xdcfcff50	drm_syncobj_get_handle	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0x5f4e5249	vhost_iotlb_reset	drivers/vhost/vhost_iotlb	EXPORT_SYMBOL_GPL	
++0x8217e677	drm_dev_put	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0x76256dec	drm_dev_get	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0x5972619a	nfc_se_transaction	net/nfc/nfc	EXPORT_SYMBOL	
++0xc4a3ee41	inet_diag_dump_icsk	net/ipv4/inet_diag	EXPORT_SYMBOL_GPL	
++0xf51cde48	line6_alloc_sysex_buffer	sound/usb/line6/snd-usb-line6	EXPORT_SYMBOL_GPL	
++0x9b5da724	ms_sensors_write_heater	drivers/iio/common/ms_sensors/ms_sensors_i2c	EXPORT_SYMBOL	
++0x648aaeb0	ubi_leb_write	drivers/mtd/ubi/ubi	EXPORT_SYMBOL_GPL	
++0x4d088dc7	mtd_concat_create	drivers/mtd/mtd	EXPORT_SYMBOL	
++0x42b1db2e	v4l2_m2m_ioctl_reqbufs	drivers/media/v4l2-core/v4l2-mem2mem	EXPORT_SYMBOL_GPL	
++0x0ae17e85	efuse_shadow_read	drivers/net/wireless/realtek/rtlwifi/rtlwifi	EXPORT_SYMBOL	
++0x2d2f91ea	ath9k_hw_name	drivers/net/wireless/ath/ath9k/ath9k_hw	EXPORT_SYMBOL	
++0xdb065657	nfnl_unlock	net/netfilter/nfnetlink	EXPORT_SYMBOL_GPL	
++0x18318f2e	w1_next_pullup	drivers/w1/wire	EXPORT_SYMBOL_GPL	
++0x490c8380	usb_ftdi_elan_read_pcimem	drivers/usb/misc/ftdi-elan	EXPORT_SYMBOL_GPL	
++0x3cff3f97	snd_device_disconnect	sound/core/snd	EXPORT_SYMBOL_GPL	
++0x487e326d	ahci_sdev_attrs	drivers/ata/libahci	EXPORT_SYMBOL_GPL	
++0x97263968	dm_bitset_resize	drivers/md/persistent-data/dm-persistent-data	EXPORT_SYMBOL_GPL	
++0x467838d8	au8522_attach	drivers/media/dvb-frontends/au8522_dig	EXPORT_SYMBOL	
++0x11f86787	vb2_poll	drivers/media/common/videobuf2/videobuf2-v4l2	EXPORT_SYMBOL_GPL	
++0x4073d4da	brcmu_pktq_flush	drivers/net/wireless/broadcom/brcm80211/brcmutil/brcmutil	EXPORT_SYMBOL	
++0x70bf5bee	drm_modeset_drop_locks	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0x28ea0f5e	drm_helper_connector_dpms	drivers/gpu/drm/drm_kms_helper	EXPORT_SYMBOL	
++0x6339b6d0	snd_seq_device_load_drivers	sound/core/snd-seq-device	EXPORT_SYMBOL	
++0xe2cb3f61	bio_alloc_mddev	drivers/md/md-mod	EXPORT_SYMBOL_GPL	
++0x9a4aed3b	usbip_event_happened	drivers/usb/usbip/usbip-core	EXPORT_SYMBOL_GPL	
++0x37f3106d	i2400m_pre_reset	drivers/net/wimax/i2400m/i2400m	EXPORT_SYMBOL_GPL	
++0x2c9d1e51	rtl92c_firmware_selfreset	drivers/net/wireless/realtek/rtlwifi/rtl8192c/rtl8192c-common	EXPORT_SYMBOL	
++0xcd15cb06	mt76x02_update_channel	drivers/net/wireless/mediatek/mt76/mt76x02-lib	EXPORT_SYMBOL_GPL	
++0xb9a689dd	ath6kl_err	drivers/net/wireless/ath/ath6kl/ath6kl_core	EXPORT_SYMBOL	
++0xf0ff4d36	drm_gem_shmem_unpin	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0x5d4dfb61	ieee80211_cqm_beacon_loss_notify	net/mac80211/mac80211	EXPORT_SYMBOL	
++0x0c99b38e	snd_pcm_hw_constraint_pow2	sound/core/snd-pcm	EXPORT_SYMBOL	
++0x6010237d	vhost_dev_stop	drivers/vhost/vhost	EXPORT_SYMBOL_GPL	
++0x48c8742c	ssb_set_devtypedata	drivers/ssb/ssb	EXPORT_SYMBOL	
++0x12aa0940	m88ds3103_get_agc_pwm	drivers/media/dvb-frontends/m88ds3103	EXPORT_SYMBOL	
++0x3e8f9807	dib0090_register	drivers/media/dvb-frontends/dib0090	EXPORT_SYMBOL	
++0x020dde67	drm_gem_free_mmap_offset	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0x64561198	dlm_register_eviction_cb	fs/ocfs2/dlm/ocfs2_dlm	EXPORT_SYMBOL_GPL	
++0xbe9329a1	rt2800_get_survey	drivers/net/wireless/ralink/rt2x00/rt2800lib	EXPORT_SYMBOL_GPL	
++0xf591763c	lbtf_add_card	drivers/net/wireless/marvell/libertas_tf/libertas_tf	EXPORT_SYMBOL_GPL	
++0x191ce017	drm_panel_prepare	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0xde076a22	drm_atomic_helper_wait_for_flip_done	drivers/gpu/drm/drm_kms_helper	EXPORT_SYMBOL	
++0xa998de33	btintel_read_version_tlv	drivers/bluetooth/btintel	EXPORT_SYMBOL_GPL	
++0x4c638bce	__videobuf_mmap_setup	drivers/media/v4l2-core/videobuf-core	EXPORT_SYMBOL_GPL	
++0x8403b963	rt2800_vco_calibration	drivers/net/wireless/ralink/rt2x00/rt2800lib	EXPORT_SYMBOL_GPL	
++0xd9da198a	mt76x02u_init_beacon_config	drivers/net/wireless/mediatek/mt76/mt76x02-usb	EXPORT_SYMBOL_GPL	
++0x771f53f8	mt76x02e_init_beacon_config	drivers/net/wireless/mediatek/mt76/mt76x02-lib	EXPORT_SYMBOL_GPL	
++0x131df09c	ath_hw_keyreset	drivers/net/wireless/ath/ath	EXPORT_SYMBOL	
++0xc5dcacef	ieee80211_operating_class_to_band	net/wireless/cfg80211	EXPORT_SYMBOL	
++0x63073d9b	arizona_init_vol_limit	sound/soc/codecs/snd-soc-arizona	EXPORT_SYMBOL_GPL	
++0xb9d8681a	iio_update_buffers	drivers/iio/industrialio	EXPORT_SYMBOL_GPL	
++0xa302e414	ahci_check_ready	drivers/ata/libahci	EXPORT_SYMBOL_GPL	
++0x950628ab	usb_wwan_dtr_rts	drivers/usb/serial/usb_wwan	EXPORT_SYMBOL	
++0x60eee437	mt76_get_txpower	drivers/net/wireless/mediatek/mt76/mt76	EXPORT_SYMBOL_GPL	
++0xaf27bebf	drbd_disk_str	drivers/block/drbd/drbd	EXPORT_SYMBOL	
++0xae277372	__drm_crtc_commit_free	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0xf5894835	asoc_simple_parse_clk	sound/soc/generic/snd-soc-simple-card-utils	EXPORT_SYMBOL_GPL	
++0x45dd17d9	media_graph_walk_next	drivers/media/mc/mc	EXPORT_SYMBOL_GPL	
++0xfd67e702	media_graph_walk_init	drivers/media/mc/mc	EXPORT_SYMBOL_GPL	
++0xb389e28e	mt76_tx	drivers/net/wireless/mediatek/mt76/mt76	EXPORT_SYMBOL_GPL	
++0x616161b0	ath9k_cmn_rx_skb_postprocess	drivers/net/wireless/ath/ath9k/ath9k_common	EXPORT_SYMBOL	
++0x4ccf246d	drm_mode_validate_driver	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0xc683961c	drm_add_override_edid_modes	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0xda22f988	drm_fb_helper_alloc_fbi	drivers/gpu/drm/drm_kms_helper	EXPORT_SYMBOL	
++0x0dbf4f3e	virtio_transport_do_socket_init	net/vmw_vsock/vmw_vsock_virtio_transport_common	EXPORT_SYMBOL_GPL	
++0xa34137f9	nfnetlink_send	net/netfilter/nfnetlink	EXPORT_SYMBOL_GPL	
++0x3f6e3f87	snd_soc_info_volsw_sx	sound/soc/snd-soc-core	EXPORT_SYMBOL_GPL	
++0x7e26d4a5	fsg_common_set_sysfs	drivers/usb/gadget/function/usb_f_mass_storage	EXPORT_SYMBOL_GPL	
++0x920aedf9	drm_crtc_wait_one_vblank	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0x77724e2e	drm_dev_unregister	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0x7a2dcfc2	drm_scdc_set_high_tmds_clock_ratio	drivers/gpu/drm/drm_kms_helper	EXPORT_SYMBOL	
++0x56c3512a	l2cap_chan_send	net/bluetooth/bluetooth	EXPORT_SYMBOL_GPL	
++0x7eed5bf1	xt_request_find_table_lock	net/netfilter/x_tables	EXPORT_SYMBOL_GPL	
++0xf0dcbcad	bcma_chipco_pll_write	drivers/bcma/bcma	EXPORT_SYMBOL_GPL	
++0xa5e9cc7b	serio_open	drivers/input/serio/serio	EXPORT_SYMBOL	
++0x00f39cdd	fbtft_dbg_hex	drivers/staging/fbtft/fbtft	EXPORT_SYMBOL	
++0xa53387c7	dm_rh_flush	drivers/md/dm-region-hash	EXPORT_SYMBOL_GPL	
++0x3ad0f55b	dm_bm_flush	drivers/md/persistent-data/dm-persistent-data	EXPORT_SYMBOL_GPL	
++0x36d3eaa0	v4l2_m2m_mmap	drivers/media/v4l2-core/v4l2-mem2mem	EXPORT_SYMBOL	
++0x9910f1e8	cx24113_attach	drivers/media/dvb-frontends/cx24113	EXPORT_SYMBOL	
++0xff3b697d	gserial_resume	drivers/usb/gadget/function/u_serial	EXPORT_SYMBOL_GPL	
++0xfdfc605b	ieee80211_get_fils_discovery_tmpl	net/mac80211/mac80211	EXPORT_SYMBOL	
++0x0d3db06e	nf_fwd_netdev_egress	net/netfilter/nf_dup_netdev	EXPORT_SYMBOL_GPL	
++0x57756ce2	serio_close	drivers/input/serio/serio	EXPORT_SYMBOL	
++0x5e01a82b	ata_link_next	drivers/ata/libata	EXPORT_SYMBOL_GPL	
++0x2d38fb4b	vb2_ioctl_qbuf	drivers/media/common/videobuf2/videobuf2-v4l2	EXPORT_SYMBOL_GPL	
++0x6531e0a0	vb2_core_streamoff	drivers/media/common/videobuf2/videobuf2-common	EXPORT_SYMBOL_GPL	
++0x941ef884	drm_vblank_restore	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0x9e5c8a77	tpm2_probe	drivers/char/tpm/tpm	EXPORT_SYMBOL_GPL	
++0x9c3ec4f9	inet6_register_protosw	net/ipv6/ipv6	EXPORT_SYMBOL	
++0x5ce3b588	nfnl_lock	net/netfilter/nfnetlink	EXPORT_SYMBOL_GPL	
++0x3e2225d9	register_mtd_blktrans	drivers/mtd/mtd_blkdevs	EXPORT_SYMBOL_GPL	
++0xbb8a6401	rtl92c_dm_rf_saving	drivers/net/wireless/realtek/rtlwifi/rtl8192c/rtl8192c-common	EXPORT_SYMBOL	
++0x9824bd30	rt2x00usb_suspend	drivers/net/wireless/ralink/rt2x00/rt2x00usb	EXPORT_SYMBOL_GPL	
++0xb4032484	drm_mm_insert_node_in_range	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0x69b18f43	rfc1042_header	net/wireless/cfg80211	EXPORT_SYMBOL	
++0x60987229	iio_buffer_init	drivers/iio/industrialio	EXPORT_SYMBOL	
++0xbc14dae0	media_device_register_entity_notify	drivers/media/mc/mc	EXPORT_SYMBOL_GPL	
++0x95b8c71d	rtl_ips_nic_on	drivers/net/wireless/realtek/rtlwifi/rtlwifi	EXPORT_SYMBOL_GPL	
++0x92d6455a	drm_fb_xrgb8888_to_gray8	drivers/gpu/drm/drm_kms_helper	EXPORT_SYMBOL	
++0x5ffd9876	drm_atomic_helper_update_legacy_modeset_state	drivers/gpu/drm/drm_kms_helper	EXPORT_SYMBOL	
++0xa2c1d0c1	cfg80211_rx_mgmt_khz	net/wireless/cfg80211	EXPORT_SYMBOL	
++0x54cc3a27	dm_disk	drivers/md/dm-mod	EXPORT_SYMBOL_GPL	
++0xfa5bffb2	videobuf_next_field	drivers/media/v4l2-core/videobuf-core	EXPORT_SYMBOL_GPL	
++0xa6305eb8	af9005_rc_decode	drivers/media/usb/dvb-usb/dvb-usb-af9005-remote	EXPORT_SYMBOL	
++0x03005a48	tpg_alloc	drivers/media/common/v4l2-tpg/v4l2-tpg	EXPORT_SYMBOL_GPL	
++0x59ce9d7f	iscsi_tcp_conn_get_stats	drivers/scsi/libiscsi_tcp	EXPORT_SYMBOL_GPL	
++0x7afcadc4	snd_soc_of_get_dai_name	sound/soc/snd-soc-core	EXPORT_SYMBOL_GPL	
++0x0b2098bf	dvb_usbv2_disconnect	drivers/media/usb/dvb-usb-v2/dvb_usb_v2	EXPORT_SYMBOL	
++0xe7f4d564	mt76_tx_status_lock	drivers/net/wireless/mediatek/mt76/mt76	EXPORT_SYMBOL_GPL	
++0x737320d5	hostap_set_hostapd_sta	drivers/net/wireless/intersil/hostap/hostap	EXPORT_SYMBOL	
++0x1354043d	ath6kl_warn	drivers/net/wireless/ath/ath6kl/ath6kl_core	EXPORT_SYMBOL	
++0x17f3fccd	drm_atomic_helper_async_check	drivers/gpu/drm/drm_kms_helper	EXPORT_SYMBOL	
++0x128341fb	drm_dp_atomic_find_vcpi_slots	drivers/gpu/drm/drm_kms_helper	EXPORT_SYMBOL	
++0x81a17396	mlog_and_bits	fs/ocfs2/cluster/ocfs2_nodemanager	EXPORT_SYMBOL_GPL	
++0x0338a7db	p9_client_fcreate	net/9p/9pnet	EXPORT_SYMBOL	
++0xd9a2dc5c	atm_dev_lookup	net/atm/atm	EXPORT_SYMBOL	
++0xf13dfd4b	br_forward_finish	net/bridge/bridge	EXPORT_SYMBOL_GPL	
++0x7c4b5e62	nf_synproxy_ipv4_fini	net/netfilter/nf_synproxy_core	EXPORT_SYMBOL_GPL	
++0xd735b817	v4l2_g_parm_cap	drivers/media/v4l2-core/videodev	EXPORT_SYMBOL_GPL	
++0xcfb916b4	drm_hdmi_infoframe_set_hdr_metadata	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0x2f02b956	set_ras_addr_hook	net/netfilter/nf_conntrack_h323	EXPORT_SYMBOL_GPL	
++0x4d2ac3e5	drm_open	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0x27304fa5	tpm1_do_selftest	drivers/char/tpm/tpm	EXPORT_SYMBOL_GPL	
++0x99e1f04c	wimax_report_rfkill_hw	net/wimax/wimax	EXPORT_SYMBOL_GPL	
++0x270450c4	ip6_tnl_change_mtu	net/ipv6/ip6_tunnel	EXPORT_SYMBOL	
++0x1d1563e2	vhost_dequeue_msg	drivers/vhost/vhost	EXPORT_SYMBOL_GPL	
++0xf1dba12f	bcma_find_core_unit	drivers/bcma/bcma	EXPORT_SYMBOL_GPL	
++0x374c53e1	ata_get_cmd_descript	drivers/ata/libata	EXPORT_SYMBOL_GPL	
++0x21f581ce	dm_dirty_log_type_register	drivers/md/dm-log	EXPORT_SYMBOL	
++0xf5dad5f9	usb_cypress_load_firmware	drivers/media/usb/dvb-usb/dvb-usb	EXPORT_SYMBOL	
++0xfc841bbf	mt76x2_mcu_set_channel	drivers/net/wireless/mediatek/mt76/mt76x2/mt76x2-common	EXPORT_SYMBOL_GPL	
++0xf982e6db	o2net_send_message	fs/ocfs2/cluster/ocfs2_nodemanager	EXPORT_SYMBOL_GPL	
++0xd1323773	v9fs_get_default_trans	net/9p/9pnet	EXPORT_SYMBOL	
++0x4b4ad0b3	ata_pci_sff_activate_host	drivers/ata/libata	EXPORT_SYMBOL_GPL	
++0xb5d5ec58	ata_scsi_queuecmd	drivers/ata/libata	EXPORT_SYMBOL_GPL	
++0xea4a883e	dvb_ringbuffer_avail	drivers/media/dvb-core/dvb-core	EXPORT_SYMBOL	
++0x66551bc7	drm_detect_monitor_audio	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0x9fe3e631	xt_register_match	net/netfilter/x_tables	EXPORT_SYMBOL	
++0x0ed3227e	nf_flow_offload_ip_hook	net/netfilter/nf_flow_table	EXPORT_SYMBOL_GPL	
++0xf58eee2f	vb2_fop_release	drivers/media/common/videobuf2/videobuf2-v4l2	EXPORT_SYMBOL_GPL	
++0x6b753017	u_audio_start_playback	drivers/usb/gadget/function/u_audio	EXPORT_SYMBOL_GPL	
++0x6c924096	mt76x02u_tx_complete_skb	drivers/net/wireless/mediatek/mt76/mt76x02-usb	EXPORT_SYMBOL_GPL	
++0xcf3fd722	drm_crtc_vblank_put	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0xd6e1a861	drm_gem_unmap_dma_buf	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0x091def1c	snd_seq_autoload_exit	sound/core/snd-seq-device	EXPORT_SYMBOL	
++0x370a0736	snd_seq_autoload_init	sound/core/snd-seq-device	EXPORT_SYMBOL	
++0x8c129d55	__devm_iio_device_register	drivers/iio/industrialio	EXPORT_SYMBOL_GPL	
++0xbb05f8ec	ahci_do_softreset	drivers/ata/libahci	EXPORT_SYMBOL_GPL	
++0xbf17ddeb	vb2_mmap	drivers/media/common/videobuf2/videobuf2-common	EXPORT_SYMBOL_GPL	
++0x229c1024	ieee80211_txq_airtime_check	net/mac80211/mac80211	EXPORT_SYMBOL	
++0x3faa41ff	snd_soc_dai_action	sound/soc/snd-soc-core	EXPORT_SYMBOL_GPL	
++0xb20c8ddc	iscsi_host_alloc	drivers/scsi/libiscsi	EXPORT_SYMBOL_GPL	
++0xaac39ff3	__drm_printfn_info	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0x489b33ae	drm_atomic_check_only	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0xfd525ec7	lc_put	lib/lru_cache	EXPORT_SYMBOL	
++0x9134feb7	lc_get	lib/lru_cache	EXPORT_SYMBOL	
++0xcc979a91	lc_set	lib/lru_cache	EXPORT_SYMBOL	
++0xfe1e9255	drm_dp_downstream_mode	drivers/gpu/drm/drm_kms_helper	EXPORT_SYMBOL	
++0xb4985beb	ZSTD_resetCStream	lib/zstd/zstd_compress	EXPORT_SYMBOL	
++0x59d943c8	vsock_addr_cast	net/vmw_vsock/vsock	EXPORT_SYMBOL_GPL	
++0xb57c6d63	nf_conntrack_hash_check_insert	net/netfilter/nf_conntrack	EXPORT_SYMBOL_GPL	
++0xa3ef787a	wm_adsp_compr_handle_irq	sound/soc/codecs/snd-soc-wm-adsp	EXPORT_SYMBOL_GPL	
++0x372cd219	ata_dummy_port_ops	drivers/ata/libata	EXPORT_SYMBOL_GPL	
++0xaca4dd80	vchiq_mmal_init	drivers/staging/vc04_services/vchiq-mmal/bcm2835-mmal-vchiq	EXPORT_SYMBOL_GPL	
++0x1d88aadb	__traceiter_vb2_buf_queue	drivers/media/common/videobuf2/videobuf2-common	EXPORT_SYMBOL_GPL	
++0xe1da0755	drm_of_find_panel_or_bridge	drivers/gpu/drm/drm	EXPORT_SYMBOL_GPL	
++0x3dd840e7	drm_bridge_chain_mode_fixup	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0xb748b3fb	l2tp_tunnel_dec_refcount	net/l2tp/l2tp_core	EXPORT_SYMBOL_GPL	
++0x55329195	l2tp_tunnel_inc_refcount	net/l2tp/l2tp_core	EXPORT_SYMBOL_GPL	
++0x252400ae	iio_read_const_attr	drivers/iio/industrialio	EXPORT_SYMBOL	
++0x1cb92948	v4l2_spi_subdev_init	drivers/media/v4l2-core/videodev	EXPORT_SYMBOL_GPL	
++0x8ab400c0	nft_meta_set_validate	net/netfilter/nf_tables	EXPORT_SYMBOL_GPL	
++0x8e7328a6	iio_alloc_pollfunc	drivers/iio/industrialio	EXPORT_SYMBOL_GPL	
++0xb9cee6a6	bcma_chipco_regctl_maskset	drivers/bcma/bcma	EXPORT_SYMBOL_GPL	
++0xe3f8e950	videobuf_iolock	drivers/media/v4l2-core/videobuf-core	EXPORT_SYMBOL_GPL	
++0x104fa84e	drm_atomic_helper_connector_duplicate_state	drivers/gpu/drm/drm_kms_helper	EXPORT_SYMBOL	
++0xa148a741	crypto_nhpoly1305_update_helper	crypto/nhpoly1305	EXPORT_SYMBOL	
++0x1df63e88	ZSTD_compressBegin	lib/zstd/zstd_compress	EXPORT_SYMBOL	
++0x0f76ff17	cfg80211_bss_iter	net/wireless/cfg80211	EXPORT_SYMBOL	
++0xa57b9778	snd_rawmidi_drain_input	sound/core/snd-rawmidi	EXPORT_SYMBOL	
++0x6cc2bc70	media_request_object_bind	drivers/media/mc/mc	EXPORT_SYMBOL_GPL	
++0x82e12325	media_request_object_find	drivers/media/mc/mc	EXPORT_SYMBOL_GPL	
++0x7f50e8cd	rtl_ps_disable_nic	drivers/net/wireless/realtek/rtlwifi/rtlwifi	EXPORT_SYMBOL	
++0x8587f222	drm_atomic_helper_commit_planes	drivers/gpu/drm/drm_kms_helper	EXPORT_SYMBOL	
++0xfb08625d	icmp6_send	net/ipv6/ipv6	EXPORT_SYMBOL	
++0xfc30bc64	ip6_dst_lookup	net/ipv6/ipv6	EXPORT_SYMBOL_GPL	
++0x7e14ed02	iio_push_event	drivers/iio/industrialio	EXPORT_SYMBOL	
++0xa374360d	ssb_pcihost_register	drivers/ssb/ssb	EXPORT_SYMBOL	
++0x8f74ca61	fc0013_rc_cal_reset	drivers/media/tuners/fc0013	EXPORT_SYMBOL	
++0xf64277de	lbs_debug	drivers/net/wireless/marvell/libertas/libertas	EXPORT_SYMBOL_GPL	
++0xc4ecb7c7	ath6kl_core_init	drivers/net/wireless/ath/ath6kl/ath6kl_core	EXPORT_SYMBOL	
++0x389899ba	drmm_mode_config_init	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0x4cc29809	drm_flip_work_queue	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0xfe224992	drm_vma_offset_lookup_locked	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0x4a35d30d	drm_mode_set_name	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0x33122ca3	drm_legacy_ioremap_wc	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0xbaffff96	ZSTD_CStreamWorkspaceBound	lib/zstd/zstd_compress	EXPORT_SYMBOL	
++0x0bea3a58	ieee80211_free_hw	net/mac80211/mac80211	EXPORT_SYMBOL	
++0x358f1961	hci_resume_dev	net/bluetooth/bluetooth	EXPORT_SYMBOL	
++0x725d51e3	cfg80211_reg_can_beacon_relax	net/wireless/cfg80211	EXPORT_SYMBOL	
++0x1661f85b	cfg80211_inform_bss_frame_data	net/wireless/cfg80211	EXPORT_SYMBOL	
++0x01eb4ad2	media_device_unregister	drivers/media/mc/mc	EXPORT_SYMBOL_GPL	
++0xcb2c4550	mwifiex_remove_card	drivers/net/wireless/marvell/mwifiex/mwifiex	EXPORT_SYMBOL_GPL	
++0x047b7499	iio_buffer_set_attrs	drivers/iio/industrialio	EXPORT_SYMBOL_GPL	
++0xc5c7bb8f	pppox_ioctl	drivers/net/ppp/pppox	EXPORT_SYMBOL	
++0x333b8215	rt2800_txstatus_pending	drivers/net/wireless/ralink/rt2x00/rt2800lib	EXPORT_SYMBOL_GPL	
++0x5c4620b1	__mt76_poll_msec	drivers/net/wireless/mediatek/mt76/mt76	EXPORT_SYMBOL_GPL	
++0x841e2a31	drm_fb_helper_prepare	drivers/gpu/drm/drm_kms_helper	EXPORT_SYMBOL	
++0xf86c7ace	__drm_atomic_helper_connector_duplicate_state	drivers/gpu/drm/drm_kms_helper	EXPORT_SYMBOL	
++0xc73c8acc	af_alg_wait_for_data	crypto/af_alg	EXPORT_SYMBOL_GPL	
++0xb70fd13a	dlmunlock	fs/ocfs2/dlm/ocfs2_dlm	EXPORT_SYMBOL_GPL	
++0x9603e84b	nf_conncount_gc_list	net/netfilter/nf_conncount	EXPORT_SYMBOL_GPL	
++0xc74261ab	ms_sensors_tp_read_prom	drivers/iio/common/ms_sensors/ms_sensors_i2c	EXPORT_SYMBOL	
++0x93e4e4c6	mtd_device_unregister	drivers/mtd/mtd	EXPORT_SYMBOL_GPL	
++0x6192e1a2	vchiq_mmal_version	drivers/staging/vc04_services/vchiq-mmal/bcm2835-mmal-vchiq	EXPORT_SYMBOL_GPL	
++0xdabbc59b	asoc_simple_parse_card_name	sound/soc/generic/snd-soc-simple-card-utils	EXPORT_SYMBOL_GPL	
++0x16d56902	snd_pcm_stop	sound/core/snd-pcm	EXPORT_SYMBOL	
++0x52b0c484	dm_cell_lock_v2	drivers/md/dm-bio-prison	EXPORT_SYMBOL_GPL	
++0x8c21e023	close_candev	drivers/net/can/dev/can-dev	EXPORT_SYMBOL_GPL	
++0x9aa2b554	mt76x0_init_hardware	drivers/net/wireless/mediatek/mt76/mt76x0/mt76x0-common	EXPORT_SYMBOL_GPL	
++0x7d05786f	cs4271_dt_ids	sound/soc/codecs/snd-soc-cs4271	EXPORT_SYMBOL_GPL	
++0xab4d845c	arizona_rate_text	sound/soc/codecs/snd-soc-arizona	EXPORT_SYMBOL_GPL	
++0xae6eed95	snd_device_initialize	sound/core/snd	EXPORT_SYMBOL_GPL	
++0x65904553	btintel_read_version	drivers/bluetooth/btintel	EXPORT_SYMBOL_GPL	
++0xf551714d	em28xx_write_ac97	drivers/media/usb/em28xx/em28xx	EXPORT_SYMBOL_GPL	
++0x0d577e95	iscsi_session_get_param	drivers/scsi/libiscsi	EXPORT_SYMBOL_GPL	
++0xddbab06c	mipi_dbi_pipe_disable	drivers/gpu/drm/drm_mipi_dbi	EXPORT_SYMBOL	
++0x8e5f9a61	drm_atomic_helper_page_flip_target	drivers/gpu/drm/drm_kms_helper	EXPORT_SYMBOL	
++0x57bb976e	cfg80211_pmksa_candidate_notify	net/wireless/cfg80211	EXPORT_SYMBOL	
++0x08733236	intlog10	drivers/media/dvb-core/dvb-core	EXPORT_SYMBOL	
++0x0996c890	brcmu_pktq_pdeq_match	drivers/net/wireless/broadcom/brcm80211/brcmutil/brcmutil	EXPORT_SYMBOL	
++0x84d728e8	iscsi_host_get_param	drivers/scsi/libiscsi	EXPORT_SYMBOL_GPL	
++0xd56d55f3	ieee80211_get_mesh_hdrlen	net/wireless/cfg80211	EXPORT_SYMBOL	
++0x3bf9d084	xt_check_table_hooks	net/netfilter/x_tables	EXPORT_SYMBOL	
++0x2a1fab3c	iio_channel_stop_all_cb	drivers/iio/buffer/industrialio-buffer-cb	EXPORT_SYMBOL_GPL	
++0x1b5059ce	ata_id_xfermask	drivers/ata/libata	EXPORT_SYMBOL_GPL	
++0xea2d3987	rt2x00usb_resume	drivers/net/wireless/ralink/rt2x00/rt2x00usb	EXPORT_SYMBOL_GPL	
++0x07a1c7c3	ieee80211_pspoll_get	net/mac80211/mac80211	EXPORT_SYMBOL	
++0x720313ab	lib80211_get_crypto_ops	net/wireless/lib80211	EXPORT_SYMBOL	
++0xbfb17a79	arizona_isrc_fsh	sound/soc/codecs/snd-soc-arizona	EXPORT_SYMBOL_GPL	
++0x281bde18	stv0900_attach	drivers/media/dvb-frontends/stv0900	EXPORT_SYMBOL	
++0x3724f0a2	stb6000_attach	drivers/media/dvb-frontends/stb6000	EXPORT_SYMBOL	
++0xc0255d58	lnbp21_attach	drivers/media/dvb-frontends/lnbp21	EXPORT_SYMBOL	
++0x4bae69eb	stb6100_attach	drivers/media/dvb-frontends/stb6100	EXPORT_SYMBOL	
++0x7cbedc21	usbip_start_eh	drivers/usb/usbip/usbip-core	EXPORT_SYMBOL_GPL	
++0x22a0f031	drm_fb_swab	drivers/gpu/drm/drm_kms_helper	EXPORT_SYMBOL	
++0xbfd7d7a2	o2hb_global_heartbeat_active	fs/ocfs2/cluster/ocfs2_nodemanager	EXPORT_SYMBOL	
++0xd822c63f	ieee80211_rts_get	net/mac80211/mac80211	EXPORT_SYMBOL	
++0xd45538ce	w1_read_block	drivers/w1/wire	EXPORT_SYMBOL_GPL	
++0x9862ceda	serio_bus	drivers/input/serio/serio	EXPORT_SYMBOL	
++0xea043512	ahci_do_hardreset	drivers/ata/libahci	EXPORT_SYMBOL_GPL	
++0x5de611a9	btracker_nr_writebacks_queued	drivers/md/dm-cache	EXPORT_SYMBOL_GPL	
++0x70e8b993	video_ioctl2	drivers/media/v4l2-core/videodev	EXPORT_SYMBOL	
++0xc17d5c1d	dib0090_update_tuning_table_7090	drivers/media/dvb-frontends/dib0090	EXPORT_SYMBOL	
++0x159c5af7	smscore_get_device_mode	drivers/media/common/siano/smsmdtv	EXPORT_SYMBOL_GPL	
++0xf1496eef	virtio_transport_stream_dequeue	net/vmw_vsock/vmw_vsock_virtio_transport_common	EXPORT_SYMBOL_GPL	
++0xac93ae05	ax25_bcast	net/ax25/ax25	EXPORT_SYMBOL_GPL	
++0x13e4c1cc	ms_sensors_ht_read_humidity	drivers/iio/common/ms_sensors/ms_sensors_i2c	EXPORT_SYMBOL	
++0x96fea52c	cx231xx_set_mode	drivers/media/usb/cx231xx/cx231xx	EXPORT_SYMBOL_GPL	
++0x6b5c2b06	drm_atomic_helper_damage_iter_next	drivers/gpu/drm/drm_kms_helper	EXPORT_SYMBOL	
++0xd12f54c4	hci_mgmt_chan_unregister	net/bluetooth/bluetooth	EXPORT_SYMBOL	
++0x99bbb721	snd_rawmidi_receive	sound/core/snd-rawmidi	EXPORT_SYMBOL	
++0x1a041a25	ssb_pmu_set_ldo_voltage	drivers/ssb/ssb	EXPORT_SYMBOL	
++0xd7048781	ahci_print_info	drivers/ata/libahci	EXPORT_SYMBOL_GPL	
++0xcd472347	can_rx_offload_add_manual	drivers/net/can/dev/can-dev	EXPORT_SYMBOL_GPL	
++0xadcc5f13	drm_framebuffer_remove	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0x36c52e42	drm_atomic_get_bridge_state	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0x4bac5808	l2tp_session_register	net/l2tp/l2tp_core	EXPORT_SYMBOL_GPL	
++0x53dea1ff	ax2asc	net/ax25/ax25	EXPORT_SYMBOL	
++0x4bcbd3a1	wiphy_new_nm	net/wireless/cfg80211	EXPORT_SYMBOL	
++0xd1ca3376	__nf_ct_refresh_acct	net/netfilter/nf_conntrack	EXPORT_SYMBOL_GPL	
++0xac02806e	sigmadsp_setup	sound/soc/codecs/snd-soc-sigmadsp	EXPORT_SYMBOL_GPL	
++0xba3143e8	snd_seq_kernel_client_enqueue	sound/core/seq/snd-seq	EXPORT_SYMBOL	
++0x7a6575a8	vhost_enable_notify	drivers/vhost/vhost	EXPORT_SYMBOL_GPL	
++0xcbe311aa	ata_sff_queue_delayed_work	drivers/ata/libata	EXPORT_SYMBOL_GPL	
++0x8462cb62	atapi_cmd_type	drivers/ata/libata	EXPORT_SYMBOL_GPL	
++0x1b13cfe1	flexcop_device_exit	drivers/media/common/b2c2/b2c2-flexcop	EXPORT_SYMBOL	
++0x892d76b2	cma3000_resume	drivers/input/misc/cma3000_d0x	EXPORT_SYMBOL	
++0xbb24f607	init_cdrom_command	drivers/cdrom/cdrom	EXPORT_SYMBOL	
++0x49c1222b	ata_sff_drain_fifo	drivers/ata/libata	EXPORT_SYMBOL_GPL	
++0x6eca84b1	dm_rh_bio_to_region	drivers/md/dm-region-hash	EXPORT_SYMBOL_GPL	
++0x9becf492	em28xx_audio_setup	drivers/media/usb/em28xx/em28xx	EXPORT_SYMBOL_GPL	
++0xcd6aa4d7	tpm1_getcap	drivers/char/tpm/tpm	EXPORT_SYMBOL_GPL	
++0x6f020cf5	nf_ct_expect_register_notifier	net/netfilter/nf_conntrack	EXPORT_SYMBOL_GPL	
++0x09249fd6	rtl92c_dm_init_edca_turbo	drivers/net/wireless/realtek/rtlwifi/rtl8192c/rtl8192c-common	EXPORT_SYMBOL	
++0xb6127243	drm_need_swiotlb	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0x9b2c51d6	nf_flow_table_offload_setup	net/netfilter/nf_flow_table	EXPORT_SYMBOL_GPL	
++0x964c7d80	snd_soc_component_nc_pin	sound/soc/snd-soc-core	EXPORT_SYMBOL_GPL	
++0xd6ce0eae	iio_trigger_poll_chained	drivers/iio/industrialio	EXPORT_SYMBOL	
++0x1b921b55	mt76_queue_tx_complete	drivers/net/wireless/mediatek/mt76/mt76	EXPORT_SYMBOL_GPL	
++0x1fb31643	drm_sched_job_cleanup	drivers/gpu/drm/scheduler/gpu-sched	EXPORT_SYMBOL	
++0xbb7b9417	virtio_transport_notify_send_init	net/vmw_vsock/vmw_vsock_virtio_transport_common	EXPORT_SYMBOL_GPL	
++0x49d8f6c9	ata_pci_bmdma_prepare_host	drivers/ata/libata	EXPORT_SYMBOL_GPL	
++0x8d482edb	roccat_common2_sysfs_write	drivers/hid/hid-roccat-common	EXPORT_SYMBOL_GPL	
++0xc50fb4bf	media_pipeline_stop	drivers/media/mc/mc	EXPORT_SYMBOL_GPL	
++0x801509c6	drm_dev_has_vblank	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0xa2678ad1	ieee80211_request_smps	net/mac80211/mac80211	EXPORT_SYMBOL_GPL	
++0xd7bc65f5	regulatory_pre_cac_allowed	net/wireless/cfg80211	EXPORT_SYMBOL	
++0xbf26488e	dm_get_md	drivers/md/dm-mod	EXPORT_SYMBOL_GPL	
++0x351315a9	fc0013_attach	drivers/media/tuners/fc0013	EXPORT_SYMBOL	
++0xc40f284c	nf_ct_helper_hsize	net/netfilter/nf_conntrack	EXPORT_SYMBOL_GPL	
++0x29a11f4c	arizona_dvfs_up	sound/soc/codecs/snd-soc-arizona	EXPORT_SYMBOL_GPL	
++0x859140d6	iio_enum_available_read	drivers/iio/industrialio	EXPORT_SYMBOL_GPL	
++0xa11fffa9	sata_link_scr_lpm	drivers/ata/libata	EXPORT_SYMBOL_GPL	
++0x2623e501	cdrom_ioctl	drivers/cdrom/cdrom	EXPORT_SYMBOL	
++0x8698f539	rt2800_set_rts_threshold	drivers/net/wireless/ralink/rt2x00/rt2800lib	EXPORT_SYMBOL_GPL	
++0xc5992401	__drm_puts_coredump	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0x4701d6b2	drm_connector_list_update	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0x2ed3c600	drm_mode_debug_printmodeline	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0x2b0b8fab	hci_recv_diag	net/bluetooth/bluetooth	EXPORT_SYMBOL	
++0x7128f640	snd_soc_new_compress	sound/soc/snd-soc-core	EXPORT_SYMBOL_GPL	
++0x2a962499	drm_mm_scan_init_with_range	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0x0f16cb30	cfg80211_mgmt_tx_status	net/wireless/cfg80211	EXPORT_SYMBOL	
++0xd3fcc511	xt_tee_enabled	net/netfilter/x_tables	EXPORT_SYMBOL_GPL	
++0xefe0066b	nfnl_acct_update	net/netfilter/nfnetlink_acct	EXPORT_SYMBOL_GPL	
++0x8f595b11	snd_major	sound/core/snd	EXPORT_SYMBOL	
++0x890d777c	iio_push_to_buffers	drivers/iio/industrialio	EXPORT_SYMBOL_GPL	
++0xc79bcd36	dm_vcalloc	drivers/md/dm-mod	EXPORT_SYMBOL	
++0x67410438	videobuf_read_stop	drivers/media/v4l2-core/videobuf-core	EXPORT_SYMBOL_GPL	
++0xd1236949	drm_flip_work_commit	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0xbc5612b0	__nf_ip6_route	net/ipv6/ipv6	EXPORT_SYMBOL_GPL	
++0x09e913c1	snd_pcm_alt_chmaps	sound/core/snd-pcm	EXPORT_SYMBOL_GPL	
++0xc5602ac6	videobuf_waiton	drivers/media/v4l2-core/videobuf-core	EXPORT_SYMBOL_GPL	
++0x6e9acc41	v4l2_fill_pixfmt_mp	drivers/media/v4l2-core/videodev	EXPORT_SYMBOL_GPL	
++0x625a7386	ppp_register_compressor	drivers/net/ppp/ppp_generic	EXPORT_SYMBOL	
++0x07f88521	drm_edid_is_valid	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0x9881d6c3	drm_dp_dual_mode_set_tmds_output	drivers/gpu/drm/drm_kms_helper	EXPORT_SYMBOL	
++0xe5f6845c	drm_dp_dual_mode_get_tmds_output	drivers/gpu/drm/drm_kms_helper	EXPORT_SYMBOL	
++0x3939f8f0	rfkill_pause_polling	net/rfkill/rfkill	EXPORT_SYMBOL	
++0x9503875a	snd_soc_add_pcm_runtime	sound/soc/snd-soc-core	EXPORT_SYMBOL_GPL	
++0x6de7228e	snd_dmaengine_pcm_pointer	sound/core/snd-pcm-dmaengine	EXPORT_SYMBOL_GPL	
++0x551dc423	media_request_object_complete	drivers/media/mc/mc	EXPORT_SYMBOL_GPL	
++0x816e4fc4	atbm8830_attach	drivers/media/dvb-frontends/atbm8830	EXPORT_SYMBOL	
++0x2c63723a	freq_reg_info	net/wireless/cfg80211	EXPORT_SYMBOL	
++0x6978b1c9	snd_soc_put_volsw_sx	sound/soc/snd-soc-core	EXPORT_SYMBOL_GPL	
++0x71defb43	snd_soc_get_volsw_sx	sound/soc/snd-soc-core	EXPORT_SYMBOL_GPL	
++0x96bfe75b	dm_get_queue_limits	drivers/md/dm-mod	EXPORT_SYMBOL_GPL	
++0x08a237f6	dm_per_bio_data	drivers/md/dm-mod	EXPORT_SYMBOL_GPL	
++0x79b6a729	tda10048_attach	drivers/media/dvb-frontends/tda10048	EXPORT_SYMBOL	
++0xf1ccae68	tda10046_attach	drivers/media/dvb-frontends/tda1004x	EXPORT_SYMBOL	
++0x57cd63bc	tda10045_attach	drivers/media/dvb-frontends/tda1004x	EXPORT_SYMBOL	
++0x0af1dd29	rtl_usb_suspend	drivers/net/wireless/realtek/rtlwifi/rtl_usb	EXPORT_SYMBOL	
++0x7e56bdf6	drm_dp_mst_get_edid	drivers/gpu/drm/drm_kms_helper	EXPORT_SYMBOL	
++0x5f5fdf58	o2hb_register_callback	fs/ocfs2/cluster/ocfs2_nodemanager	EXPORT_SYMBOL_GPL	
++0xdc94f829	chacha_init_arch	arch/arm64/crypto/chacha-neon	EXPORT_SYMBOL	
++0x208850aa	p9_client_getattr_dotl	net/9p/9pnet	EXPORT_SYMBOL	
++0x39feb0b5	nf_ct_expect_iterate_destroy	net/netfilter/nf_conntrack	EXPORT_SYMBOL_GPL	
++0x9f5426eb	snd_soc_remove_pcm_runtime	sound/soc/snd-soc-core	EXPORT_SYMBOL_GPL	
++0x2a013e1e	spi_bitbang_setup	drivers/spi/spi-bitbang	EXPORT_SYMBOL_GPL	
++0x935982de	br_multicast_router	net/bridge/bridge	EXPORT_SYMBOL_GPL	
++0x181affe9	__ip6_datagram_connect	net/ipv6/ipv6	EXPORT_SYMBOL_GPL	
++0x371e7f3a	ZSTD_initCDict	lib/zstd/zstd_compress	EXPORT_SYMBOL	
++0x88fbfe72	fuse_mount_get	fs/fuse/fuse	EXPORT_SYMBOL_GPL	
++0x8c93942c	p9_client_create_dotl	net/9p/9pnet	EXPORT_SYMBOL	
++0x1202661a	xt_unregister_match	net/netfilter/x_tables	EXPORT_SYMBOL	
++0x340f08e7	snd_soc_dapm_new_control	sound/soc/snd-soc-core	EXPORT_SYMBOL_GPL	
++0xaed66725	drm_plane_enable_fb_damage_clips	drivers/gpu/drm/drm_kms_helper	EXPORT_SYMBOL	
++0xabe28922	drm_connector_helper_hpd_irq_event	drivers/gpu/drm/drm_kms_helper	EXPORT_SYMBOL	
++0xc341ae6d	zs_map_object	mm/zsmalloc	EXPORT_SYMBOL_GPL	
++0xbdc65fe7	ip_vs_conn_in_get_proto	net/netfilter/ipvs/ip_vs	EXPORT_SYMBOL_GPL	
++0x0ef3a6bb	ip_set_extensions	net/netfilter/ipset/ip_set	EXPORT_SYMBOL_GPL	
++0x7fc8652c	em28xx_tuner_callback	drivers/media/usb/em28xx/em28xx	EXPORT_SYMBOL_GPL	
++0x24ee5526	gspca_coarse_grained_expo_autogain	drivers/media/usb/gspca/gspca_main	EXPORT_SYMBOL	
++0x9efc54b6	can_rx_offload_add_fifo	drivers/net/can/dev/can-dev	EXPORT_SYMBOL_GPL	
++0xf24f5637	vxlan_fdb_replay	drivers/net/vxlan	EXPORT_SYMBOL_GPL	
++0xdbc34611	iscsi_prep_data_out_pdu	drivers/scsi/libiscsi	EXPORT_SYMBOL_GPL	
++0x39a6a159	drm_master_get	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0x497e3584	snd_soc_jack_add_gpios	sound/soc/snd-soc-core	EXPORT_SYMBOL_GPL	
++0x50421665	snd_soc_add_component_controls	sound/soc/snd-soc-core	EXPORT_SYMBOL_GPL	
++0x5726200d	rtl_usb_probe	drivers/net/wireless/realtek/rtlwifi/rtl_usb	EXPORT_SYMBOL	
++0x1ec57b4f	__mt76_worker_fn	drivers/net/wireless/mediatek/mt76/mt76	EXPORT_SYMBOL_GPL	
++0x35131b36	drbd_role_str	drivers/block/drbd/drbd	EXPORT_SYMBOL	
++0x60370d3a	rfkill_alloc	net/rfkill/rfkill	EXPORT_SYMBOL	
++0xc8eb686a	go7007_boot_encoder	drivers/media/usb/go7007/go7007	EXPORT_SYMBOL	
++0xc85d77fb	usbnet_cdc_bind	drivers/net/usb/cdc_ether	EXPORT_SYMBOL_GPL	
++0xf30be93c	udp_tunnel_notify_add_rx_port	net/ipv4/udp_tunnel	EXPORT_SYMBOL_GPL	
++0x514d0e6a	vhost_iotlb_itree_first	drivers/vhost/vhost_iotlb	EXPORT_SYMBOL_GPL	
++0x13a5adbd	ata_sff_port_ops	drivers/ata/libata	EXPORT_SYMBOL_GPL	
++0x49081644	dm_btree_remove	drivers/md/persistent-data/dm-persistent-data	EXPORT_SYMBOL_GPL	
++0x1068004b	gf128mul_bbe	crypto/gf128mul	EXPORT_SYMBOL	
++0x04cda566	snd_interval_refine	sound/core/snd-pcm	EXPORT_SYMBOL	
++0x2368c9af	p54_parse_firmware	drivers/net/wireless/intersil/p54/p54common	EXPORT_SYMBOL_GPL	
++0x85f2b6f9	hostap_master_start_xmit	drivers/net/wireless/intersil/hostap/hostap	EXPORT_SYMBOL	
++0x4b7ebf95	drm_mm_remove_node	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0xffc26a5e	nfc_allocate_device	net/nfc/nfc	EXPORT_SYMBOL	
++0xc06679f6	nfnetlink_subsys_unregister	net/netfilter/nfnetlink	EXPORT_SYMBOL_GPL	
++0x2a046658	dapm_kcontrol_get_value	sound/soc/snd-soc-core	EXPORT_SYMBOL_GPL	
++0x573cad11	ata_dev_pair	drivers/ata/libata	EXPORT_SYMBOL_GPL	
++0x908494c3	usb_get_function_instance	drivers/usb/gadget/libcomposite	EXPORT_SYMBOL_GPL	
++0x8fc38c69	tpm2_get_tpm_pt	drivers/char/tpm/tpm	EXPORT_SYMBOL_GPL	
++0xd45b9cf4	poly1305_core_setkey	lib/crypto/libpoly1305	EXPORT_SYMBOL	
++0x639436bc	p9_client_create	net/9p/9pnet	EXPORT_SYMBOL	
++0x63d2ff63	eeprom_93cx6_wren	drivers/misc/eeprom/eeprom_93cx6	EXPORT_SYMBOL_GPL	
++0x9b7611e0	drm_atomic_bridge_chain_check	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0x4b83b001	drm_dp_downstream_max_tmds_clock	drivers/gpu/drm/drm_kms_helper	EXPORT_SYMBOL	
++0x9827b3e9	nat_callforwarding_hook	net/netfilter/nf_conntrack_h323	EXPORT_SYMBOL_GPL	
++0xafcacf31	snd_ctl_find_numid	sound/core/snd	EXPORT_SYMBOL	
++0xc6406aaf	spi_nor_scan	drivers/mtd/spi-nor/spi-nor	EXPORT_SYMBOL_GPL	
++0xe1e23451	dm_bio_detain	drivers/md/dm-bio-prison	EXPORT_SYMBOL_GPL	
++0xc95d9f15	devm_backlight_device_register	drivers/video/backlight/backlight	EXPORT_SYMBOL	
++0x762b4aa8	nf_ct_helper_ext_add	net/netfilter/nf_conntrack	EXPORT_SYMBOL_GPL	
++0x5af58be9	nf_ct_unconfirmed_destroy	net/netfilter/nf_conntrack	EXPORT_SYMBOL_GPL	
++0x48bc5ad5	media_request_unpin	drivers/media/mc/mc	EXPORT_SYMBOL_GPL	
++0x4900035b	o2hb_stop_all_regions	fs/ocfs2/cluster/ocfs2_nodemanager	EXPORT_SYMBOL_GPL	
++0x214e4265	bt_warn	net/bluetooth/bluetooth	EXPORT_SYMBOL	
++0x46312808	ieee80211_radiotap_iterator_next	net/wireless/cfg80211	EXPORT_SYMBOL	
++0xf5dae06b	drm_mode_is_420	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0x1278221d	ZSTD_compressBegin_usingCDict	lib/zstd/zstd_compress	EXPORT_SYMBOL	
++0x5569c922	ieee80211_iterate_interfaces	net/mac80211/mac80211	EXPORT_SYMBOL_GPL	
++0x45c14de3	__nft_release_basechain	net/netfilter/nf_tables	EXPORT_SYMBOL_GPL	
++0x71ac3bdb	nf_conncount_add	net/netfilter/nf_conncount	EXPORT_SYMBOL_GPL	
++0x033e1aae	snd_rawmidi_kernel_read	sound/core/snd-rawmidi	EXPORT_SYMBOL	
++0x3aa68d7a	v4l2_find_dv_timings_cap	drivers/media/v4l2-core/v4l2-dv-timings	EXPORT_SYMBOL_GPL	
++0x2ea32699	__v4l2_clk_register_fixed	drivers/media/v4l2-core/videodev	EXPORT_SYMBOL	
++0x398546e5	usb_serial_generic_chars_in_buffer	drivers/usb/serial/usbserial	EXPORT_SYMBOL_GPL	
++0x32a40405	mt76x02_get_rx_gain	drivers/net/wireless/mediatek/mt76/mt76x02-lib	EXPORT_SYMBOL_GPL	
++0x0f9bd085	iscsi_host_remove	drivers/scsi/libiscsi	EXPORT_SYMBOL_GPL	
++0x1d2b3d55	drm_crtc_init_with_planes	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0xb73aafb1	ieee80211_chandef_to_operating_class	net/wireless/cfg80211	EXPORT_SYMBOL	
++0x92318bee	snd_soc_dai_set_tristate	sound/soc/snd-soc-core	EXPORT_SYMBOL_GPL	
++0x3de59da2	mtd_table_mutex_unlock	drivers/mtd/mtd	EXPORT_SYMBOL_GPL	
++0x2bb1f465	mt76_dma_cleanup	drivers/net/wireless/mediatek/mt76/mt76	EXPORT_SYMBOL_GPL	
++0x75772df1	drm_gem_shmem_madvise	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0x375cba43	drm_client_framebuffer_create	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0x11294d84	v4l2_subdev_link_validate	drivers/media/v4l2-core/videodev	EXPORT_SYMBOL_GPL	
++0x02e3b47a	drm_client_modeset_probe	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0x947283ea	snd_soc_bytes_info_ext	sound/soc/snd-soc-core	EXPORT_SYMBOL_GPL	
++0x8ad69261	mt76u_vendor_request	drivers/net/wireless/mediatek/mt76/mt76-usb	EXPORT_SYMBOL_GPL	
++0x12cd8045	drm_gem_object_init	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0xaad6d92f	rfkill_init_sw_state	net/rfkill/rfkill	EXPORT_SYMBOL	
++0x9c059dfa	hci_unregister_dev	net/bluetooth/bluetooth	EXPORT_SYMBOL	
++0x4c531ba9	v4l2_subdev_call_wrappers	drivers/media/v4l2-core/videodev	EXPORT_SYMBOL	
++0x85fbc931	slhc_uncompress	drivers/net/slip/slhc	EXPORT_SYMBOL	
++0x3adea705	mt76x02_set_key	drivers/net/wireless/mediatek/mt76/mt76x02-lib	EXPORT_SYMBOL_GPL	
++0x0e198232	dm_btree_insert	drivers/md/persistent-data/dm-persistent-data	EXPORT_SYMBOL_GPL	
++0x14ebe004	rt2x00mac_configure_filter	drivers/net/wireless/ralink/rt2x00/rt2x00lib	EXPORT_SYMBOL_GPL	
++0x8be62da5	ip6_sk_redirect	net/ipv6/ipv6	EXPORT_SYMBOL_GPL	
++0x764567c8	dm_btree_find_highest_key	drivers/md/persistent-data/dm-persistent-data	EXPORT_SYMBOL_GPL	
++0x9e9f4c5c	cx231xx_set_alt_setting	drivers/media/usb/cx231xx/cx231xx	EXPORT_SYMBOL_GPL	
++0x2168ebc6	nft_data_dump	net/netfilter/nf_tables	EXPORT_SYMBOL_GPL	
++0xd99e003d	dm_bio_prison_create_v2	drivers/md/dm-bio-prison	EXPORT_SYMBOL_GPL	
++0x3785b99d	v4l2_m2m_ioctl_prepare_buf	drivers/media/v4l2-core/v4l2-mem2mem	EXPORT_SYMBOL_GPL	
++0xe6110f20	cx24116_attach	drivers/media/dvb-frontends/cx24116	EXPORT_SYMBOL	
++0xe4586827	adxl34x_resume	drivers/input/misc/adxl34x	EXPORT_SYMBOL_GPL	
++0x1c37be4d	rtl_tx_ackqueue	drivers/net/wireless/realtek/rtlwifi/rtlwifi	EXPORT_SYMBOL_GPL	
++0xab7a4d1d	bcm2835_smi_set_regs_from_settings	drivers/misc/bcm2835_smi	EXPORT_SYMBOL	
++0xea6f7409	drm_sysfs_hotplug_event	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0x7ac103a4	snd_info_register	sound/core/snd	EXPORT_SYMBOL	
++0xeca9a4b4	btintel_set_bdaddr	drivers/bluetooth/btintel	EXPORT_SYMBOL_GPL	
++0x16af9071	dm_array_set_value	drivers/md/persistent-data/dm-persistent-data	EXPORT_SYMBOL_GPL	
++0xb6949944	dm_array_get_value	drivers/md/persistent-data/dm-persistent-data	EXPORT_SYMBOL_GPL	
++0x61fb1993	radio_tea5777_init	drivers/media/radio/shark2	EXPORT_SYMBOL_GPL	
++0xed7c8cf2	rtl_evm_db_to_percentage	drivers/net/wireless/realtek/rtlwifi/rtlwifi	EXPORT_SYMBOL	
++0x7ab9a0aa	__drm_atomic_helper_crtc_state_reset	drivers/gpu/drm/drm_kms_helper	EXPORT_SYMBOL	
++0x0283dfe3	_snd_pcm_hw_params_any	sound/core/snd-pcm	EXPORT_SYMBOL	
++0x73577d20	vchiq_mmal_finalise	drivers/staging/vc04_services/vchiq-mmal/bcm2835-mmal-vchiq	EXPORT_SYMBOL_GPL	
++0x37097633	drm_self_refresh_helper_update_avg_times	drivers/gpu/drm/drm_kms_helper	EXPORT_SYMBOL	
++0x9357bb5c	nsh_push	net/nsh/nsh	EXPORT_SYMBOL_GPL	
++0x14f63389	ip_tunnel_rcv	net/ipv4/ip_tunnel	EXPORT_SYMBOL_GPL	
++0xc8db6ab7	sata_link_hardreset	drivers/ata/libata	EXPORT_SYMBOL_GPL	
++0x38972f23	dm_rh_region_to_sector	drivers/md/dm-region-hash	EXPORT_SYMBOL_GPL	
++0xe7a454ce	snd_tea575x_s_hw_freq_seek	drivers/media/radio/tea575x	EXPORT_SYMBOL	
++0x65099a26	videobuf_dqbuf	drivers/media/v4l2-core/videobuf-core	EXPORT_SYMBOL_GPL	
++0xc75ba940	ffs_name_dev	drivers/usb/gadget/function/usb_f_fs	EXPORT_SYMBOL_GPL	
++0x0b038e24	channel5g_80m	drivers/net/wireless/realtek/rtlwifi/rtlwifi	EXPORT_SYMBOL	
++0x2c3347c1	rt2x00mac_stop	drivers/net/wireless/ralink/rt2x00/rt2x00lib	EXPORT_SYMBOL_GPL	
++0x6241b40e	nft_meta_set_eval	net/netfilter/nf_tables	EXPORT_SYMBOL_GPL	
++0x9c8bfd6a	nft_meta_get_eval	net/netfilter/nf_tables	EXPORT_SYMBOL_GPL	
++0xa2465cb5	nf_conntrack_helper_unregister	net/netfilter/nf_conntrack	EXPORT_SYMBOL_GPL	
++0xdff8e89d	tm6000_tuner_callback	drivers/media/usb/tm6000/tm6000	EXPORT_SYMBOL_GPL	
++0x6d07e7e6	ar9003_mci_setup	drivers/net/wireless/ath/ath9k/ath9k_hw	EXPORT_SYMBOL	
++0x26fe936e	ieee80211_gtk_rekey_add	net/mac80211/mac80211	EXPORT_SYMBOL_GPL	
++0x0b337877	rtl92c_download_fw	drivers/net/wireless/realtek/rtlwifi/rtl8192c/rtl8192c-common	EXPORT_SYMBOL	
++0x39539ed9	drm_atomic_get_new_bridge_state	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0xb83af97b	drm_gem_prime_handle_to_fd	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0x03fd1da5	cryptd_free_ahash	crypto/cryptd	EXPORT_SYMBOL_GPL	
++0x5b19e187	chacha20poly1305_decrypt_sg_inplace	lib/crypto/libchacha20poly1305	EXPORT_SYMBOL	
++0x37b34b92	chacha20poly1305_encrypt_sg_inplace	lib/crypto/libchacha20poly1305	EXPORT_SYMBOL	
++0x089c9436	nf_synproxy_ipv6_init	net/netfilter/nf_synproxy_core	EXPORT_SYMBOL_GPL	
++0x693b6833	__ata_change_queue_depth	drivers/ata/libata	EXPORT_SYMBOL_GPL	
++0xe66285ce	iscsi_conn_failure	drivers/scsi/libiscsi	EXPORT_SYMBOL_GPL	
++0xc406219f	snd_pcm_mmap_data	sound/core/snd-pcm	EXPORT_SYMBOL	
++0x5eae4600	matrix_keypad_build_keymap	drivers/input/matrix-keymap	EXPORT_SYMBOL	
++0x85eace20	rtl_hal_pwrseqcmdparsing	drivers/net/wireless/realtek/rtlwifi/rtlwifi	EXPORT_SYMBOL	
++0x4b24e86d	drm_sched_entity_modify_sched	drivers/gpu/drm/scheduler/gpu-sched	EXPORT_SYMBOL	
++0xae070932	mipi_dbi_spi_init	drivers/gpu/drm/drm_mipi_dbi	EXPORT_SYMBOL	
++0x2b4c4555	w1_write_8	drivers/w1/wire	EXPORT_SYMBOL_GPL	
++0xfbb858d1	ata_dev_next	drivers/ata/libata	EXPORT_SYMBOL_GPL	
++0xc0d8be59	media_pipeline_start	drivers/media/mc/mc	EXPORT_SYMBOL_GPL	
++0x52fd981f	rt2x00queue_start_queue	drivers/net/wireless/ralink/rt2x00/rt2x00lib	EXPORT_SYMBOL_GPL	
++0xd722baa0	mt76x02_phy_adjust_vga_gain	drivers/net/wireless/mediatek/mt76/mt76x02-lib	EXPORT_SYMBOL_GPL	
++0x9907f1a2	mt76x02_sta_rate_tbl_update	drivers/net/wireless/mediatek/mt76/mt76x02-lib	EXPORT_SYMBOL_GPL	
++0x26bf0cbb	ath9k_hw_btcoex_init_mci	drivers/net/wireless/ath/ath9k/ath9k_hw	EXPORT_SYMBOL	
++0xf826786c	drm_format_info	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0x96085abf	ip_set_nfnl_put	net/netfilter/ipset/ip_set	EXPORT_SYMBOL_GPL	
++0xeb94d829	nf_conntrack_helpers_register	net/netfilter/nf_conntrack	EXPORT_SYMBOL_GPL	
++0x0b832244	snd_soc_unregister_card	sound/soc/snd-soc-core	EXPORT_SYMBOL_GPL	
++0x5baa8cec	dm_bufio_client_create	drivers/md/dm-bufio	EXPORT_SYMBOL_GPL	
++0x5afe3eae	v4l2_pipeline_link_notify	drivers/media/v4l2-core/videodev	EXPORT_SYMBOL_GPL	
++0x4b9475ed	v4l2_fwnode_endpoint_free	drivers/media/v4l2-core/v4l2-fwnode	EXPORT_SYMBOL_GPL	
++0xa54b4c79	tda8261_attach	drivers/media/dvb-frontends/tda8261	EXPORT_SYMBOL	
++0x7cc62828	vb2_find_timestamp	drivers/media/common/videobuf2/videobuf2-v4l2	EXPORT_SYMBOL_GPL	
++0x028f03ed	drm_fb_xrgb8888_to_rgb565_dstclip	drivers/gpu/drm/drm_kms_helper	EXPORT_SYMBOL	
++0xf1d1cf9d	drm_atomic_helper_set_config	drivers/gpu/drm/drm_kms_helper	EXPORT_SYMBOL	
++0x3d8baf3b	zs_huge_class_size	mm/zsmalloc	EXPORT_SYMBOL_GPL	
++0xcb3e91cc	xt_counters_alloc	net/netfilter/x_tables	EXPORT_SYMBOL	
++0xf7ad4d29	nft_chain_validate_dependency	net/netfilter/nf_tables	EXPORT_SYMBOL_GPL	
++0x1f46b598	usb_interface_id	drivers/usb/gadget/libcomposite	EXPORT_SYMBOL_GPL	
++0x7a912e8f	rt2x00mac_set_tim	drivers/net/wireless/ralink/rt2x00/rt2x00lib	EXPORT_SYMBOL_GPL	
++0xc0e51d59	ath9k_hw_get_txq_props	drivers/net/wireless/ath/ath9k/ath9k_hw	EXPORT_SYMBOL	
++0x68d5a229	ath9k_hw_set_txq_props	drivers/net/wireless/ath/ath9k/ath9k_hw	EXPORT_SYMBOL	
++0xee2312da	drm_fb_helper_blank	drivers/gpu/drm/drm_kms_helper	EXPORT_SYMBOL	
++0x004f21e3	__drm_atomic_helper_plane_state_reset	drivers/gpu/drm/drm_kms_helper	EXPORT_SYMBOL	
++0x00ca3ba1	vhost_work_queue	drivers/vhost/vhost	EXPORT_SYMBOL_GPL	
++0x7499da0c	ata_pci_bmdma_clear_simplex	drivers/ata/libata	EXPORT_SYMBOL_GPL	
++0xf398644f	dm_btree_lookup_next	drivers/md/persistent-data/dm-persistent-data	EXPORT_SYMBOL_GPL	
++0x983ce39e	dvb_usb_generic_rw	drivers/media/usb/dvb-usb/dvb-usb	EXPORT_SYMBOL	
++0x691586c6	rndis_uninit	drivers/usb/gadget/function/usb_f_rndis	EXPORT_SYMBOL_GPL	
++0x4e8be596	mipi_dbi_dev_init_with_formats	drivers/gpu/drm/drm_mipi_dbi	EXPORT_SYMBOL	
++0xce0b8526	xfrm6_rcv_encap	net/ipv6/ipv6	EXPORT_SYMBOL	
++0xb56ca1e9	ahci_host_activate	drivers/ata/libahci	EXPORT_SYMBOL_GPL	
++0x5d8dd600	isl6405_attach	drivers/media/dvb-frontends/isl6405	EXPORT_SYMBOL	
++0x5556fc91	dibusb_pid_filter	drivers/media/usb/dvb-usb/dvb-usb-dibusb-common	EXPORT_SYMBOL	
++0x56463e65	fsg_common_remove_lun	drivers/usb/gadget/function/usb_f_mass_storage	EXPORT_SYMBOL_GPL	
++0x22d4115f	gserial_disconnect	drivers/usb/gadget/function/u_serial	EXPORT_SYMBOL_GPL	
++0xa431672a	mt76_sw_scan	drivers/net/wireless/mediatek/mt76/mt76	EXPORT_SYMBOL_GPL	
++0x14c936a1	inet6_getname	net/ipv6/ipv6	EXPORT_SYMBOL	
++0xc413cdbd	nf_conntrack_tuple_taken	net/netfilter/nf_conntrack	EXPORT_SYMBOL_GPL	
++0x972102f6	snd_soc_of_parse_daifmt	sound/soc/snd-soc-core	EXPORT_SYMBOL_GPL	
++0xf7ae9c82	snd_device_register	sound/core/snd	EXPORT_SYMBOL	
++0xa0a98c3b	sata_pmp_port_ops	drivers/ata/libata	EXPORT_SYMBOL_GPL	
++0x6f2fe3c4	dm_btree_remove_leaves	drivers/md/persistent-data/dm-persistent-data	EXPORT_SYMBOL_GPL	
++0x970585dd	drm_client_release	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0x3ab87110	drm_mode_equal_no_clocks	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0x22d966c6	ip_set_range_to_cidr	net/netfilter/ipset/ip_set	EXPORT_SYMBOL_GPL	
++0xd35bad25	register_mtd_user	drivers/mtd/mtd	EXPORT_SYMBOL_GPL	
++0x4fdc945d	sata_deb_timing_normal	drivers/ata/libata	EXPORT_SYMBOL_GPL	
++0x8f1380a7	mwifiex_multi_chan_resync	drivers/net/wireless/marvell/mwifiex/mwifiex	EXPORT_SYMBOL_GPL	
++0xad17de5c	drm_mode_config_reset	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0xd25be20f	snd_ctl_find_id	sound/core/snd	EXPORT_SYMBOL	
++0xd07a1aef	__uio_register_device	drivers/uio/uio	EXPORT_SYMBOL_GPL	
++0xf406e46a	drm_get_connector_type_name	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0xec700382	drm_dev_set_unique	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0xd6eced5d	drm_dp_start_crc	drivers/gpu/drm/drm_kms_helper	EXPORT_SYMBOL	
++0xd47f987d	drm_gem_fb_create_with_dirty	drivers/gpu/drm/drm_kms_helper	EXPORT_SYMBOL_GPL	
++0xe5a33113	__SCK__tp_func_vb2_v4l2_qbuf	drivers/media/v4l2-core/videodev	EXPORT_SYMBOL_GPL	
++0x20663c98	v4l2_fh_exit	drivers/media/v4l2-core/videodev	EXPORT_SYMBOL_GPL	
++0xe3f692d5	v4l2_fh_init	drivers/media/v4l2-core/videodev	EXPORT_SYMBOL_GPL	
++0x0682a306	llc_build_and_send_ui_pkt	net/llc/llc	EXPORT_SYMBOL	
++0xad976070	mt76x02_config_mac_addr_list	drivers/net/wireless/mediatek/mt76/mt76x02-lib	EXPORT_SYMBOL_GPL	
++0xc9d378a5	hostap_remove_interface	drivers/net/wireless/intersil/hostap/hostap	EXPORT_SYMBOL	
++0x5bd6b192	drm_atomic_bridge_chain_disable	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0xf90554ab	drm_fb_helper_ioctl	drivers/gpu/drm/drm_kms_helper	EXPORT_SYMBOL	
++0x00c1c6ec	rt2800_get_tsf	drivers/net/wireless/ralink/rt2x00/rt2800lib	EXPORT_SYMBOL_GPL	
++0x9042718d	cfg80211_ch_switch_started_notify	net/wireless/cfg80211	EXPORT_SYMBOL	
++0xcccafc4c	xt_register_matches	net/netfilter/x_tables	EXPORT_SYMBOL	
++0x0102fbc7	line6_probe	sound/usb/line6/snd-usb-line6	EXPORT_SYMBOL_GPL	
++0x441fe710	sata_sff_hardreset	drivers/ata/libata	EXPORT_SYMBOL_GPL	
++0x3e4427c8	roccat_report_event	drivers/hid/hid-roccat	EXPORT_SYMBOL_GPL	
++0x38f21859	cx24123_get_tuner_i2c_adapter	drivers/media/dvb-frontends/cx24123	EXPORT_SYMBOL	
++0xd541e42b	mt76x02_mcu_function_select	drivers/net/wireless/mediatek/mt76/mt76x02-lib	EXPORT_SYMBOL_GPL	
++0x635664b4	mt76x02_sta_ps	drivers/net/wireless/mediatek/mt76/mt76x02-lib	EXPORT_SYMBOL_GPL	
++0x451f9ef4	ssb_driver_unregister	drivers/ssb/ssb	EXPORT_SYMBOL	
++0xf3092a84	v4l2_m2m_dqbuf	drivers/media/v4l2-core/v4l2-mem2mem	EXPORT_SYMBOL_GPL	
++0x9670af2c	gspca_debug	drivers/media/usb/gspca/gspca_main	EXPORT_SYMBOL	
++0xd331830c	i2c_mux_alloc	drivers/i2c/i2c-mux	EXPORT_SYMBOL_GPL	
++0xb2dbe441	ar9003_paprd_setup_gain_table	drivers/net/wireless/ath/ath9k/ath9k_hw	EXPORT_SYMBOL	
++0xd0a5e322	drm_gem_dumb_destroy	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0x2c9ec4a4	drm_atomic_helper_check_plane_damage	drivers/gpu/drm/drm_kms_helper	EXPORT_SYMBOL	
++0x9961d9fd	async_xor	crypto/async_tx/async_xor	EXPORT_SYMBOL_GPL	
++0x5f4a6e61	dm_rh_dec	drivers/md/dm-region-hash	EXPORT_SYMBOL_GPL	
++0xe781f874	dm_tm_dec	drivers/md/persistent-data/dm-persistent-data	EXPORT_SYMBOL_GPL	
++0x001ac31c	usbip_recv	drivers/usb/usbip/usbip-core	EXPORT_SYMBOL_GPL	
++0x88cb8f5a	usb_free_all_descriptors	drivers/usb/gadget/libcomposite	EXPORT_SYMBOL_GPL	
++0x84e39f99	i2400m_release	drivers/net/wimax/i2400m/i2400m	EXPORT_SYMBOL_GPL	
++0xfa4cc113	drm_gem_fb_create	drivers/gpu/drm/drm_kms_helper	EXPORT_SYMBOL_GPL	
++0x324708ef	ipcomp_output	net/xfrm/xfrm_ipcomp	EXPORT_SYMBOL_GPL	
++0xfabe4e55	nf_ct_expect_related_report	net/netfilter/nf_conntrack	EXPORT_SYMBOL_GPL	
++0xfeb17f2e	arizona_dvfs_down	sound/soc/codecs/snd-soc-arizona	EXPORT_SYMBOL_GPL	
++0x55c914ae	dm_unregister_target	drivers/md/dm-mod	EXPORT_SYMBOL	
++0x74725e69	ZSTD_compressContinue	lib/zstd/zstd_compress	EXPORT_SYMBOL	
++0x89c09e31	mux_control_deselect	drivers/mux/mux-core	EXPORT_SYMBOL_GPL	
++0x56e0aedc	iio_kfifo_allocate	drivers/iio/buffer/kfifo_buf	EXPORT_SYMBOL	
++0xfadc9e99	mtd_read	drivers/mtd/mtd	EXPORT_SYMBOL_GPL	
++0x7fc1cb76	ata_sas_port_destroy	drivers/ata/libata	EXPORT_SYMBOL_GPL	
++0xb14f354f	ata_sas_port_suspend	drivers/ata/libata	EXPORT_SYMBOL_GPL	
++0x96ca13cf	dm_mq_kick_requeue_list	drivers/md/dm-mod	EXPORT_SYMBOL	
++0xe1775ee7	dm_get_reserved_bio_based_ios	drivers/md/dm-mod	EXPORT_SYMBOL_GPL	
++0x28692b62	dvb_dmx_release	drivers/media/dvb-core/dvb-core	EXPORT_SYMBOL	
++0xe69ffb52	cs42xx8_regmap_config	sound/soc/codecs/snd-soc-cs42xx8	EXPORT_SYMBOL_GPL	
++0x350804ad	go7007_snd_init	drivers/media/usb/go7007/go7007	EXPORT_SYMBOL	
++0xa580187a	sms_board_power	drivers/media/common/siano/smsmdtv	EXPORT_SYMBOL_GPL	
++0x07bbff3a	brcmu_pkt_buf_free_skb	drivers/net/wireless/broadcom/brcm80211/brcmutil/brcmutil	EXPORT_SYMBOL	
++0xf1c16d92	drm_atomic_helper_disable_plane	drivers/gpu/drm/drm_kms_helper	EXPORT_SYMBOL	
++0x115eedd6	af_alg_alloc_areq	crypto/af_alg	EXPORT_SYMBOL_GPL	
++0x5609ce41	cast_s2	crypto/cast_common	EXPORT_SYMBOL_GPL	
++0xfbea11a7	inet6_destroy_sock	net/ipv6/ipv6	EXPORT_SYMBOL_GPL	
++0x0f71364f	nft_meta_policy	net/netfilter/nf_tables	EXPORT_SYMBOL_GPL	
++0x8c0cbaa8	snd_rawmidi_transmit	sound/core/snd-rawmidi	EXPORT_SYMBOL	
++0x43d66c37	md_find_rdev_rcu	drivers/md/md-mod	EXPORT_SYMBOL_GPL	
++0x5e55cfc5	cdrom_mode_sense	drivers/cdrom/cdrom	EXPORT_SYMBOL	
++0x37c9941a	iscsi_tcp_cleanup_task	drivers/scsi/libiscsi_tcp	EXPORT_SYMBOL_GPL	
++0xd3bb38e6	drm_gem_shmem_purge_locked	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0x5c6a9570	af_alg_unregister_type	crypto/af_alg	EXPORT_SYMBOL_GPL	
++0x4d3ccf4e	qtree_delete_dquot	fs/quota/quota_tree	EXPORT_SYMBOL	
++0x5dcad5b3	v4l2_ctrl_log_status	drivers/media/v4l2-core/videodev	EXPORT_SYMBOL	
++0x1ccb58f7	fsg_common_set_num_buffers	drivers/usb/gadget/function/usb_f_mass_storage	EXPORT_SYMBOL_GPL	
++0x4a89ee20	iscsi_conn_send_pdu	drivers/scsi/libiscsi	EXPORT_SYMBOL_GPL	
++0xfea03747	drm_sched_entity_set_priority	drivers/gpu/drm/scheduler/gpu-sched	EXPORT_SYMBOL	
++0x0108576a	ieee80211_sta_eosp	net/mac80211/mac80211	EXPORT_SYMBOL	
++0x9c2a6a2e	inet6_unregister_protosw	net/ipv6/ipv6	EXPORT_SYMBOL	
++0x68dc6ced	gre_add_protocol	net/ipv4/gre	EXPORT_SYMBOL_GPL	
++0xd831a1a2	ip_vs_proto_name	net/netfilter/ipvs/ip_vs	EXPORT_SYMBOL	
++0x4f3c527a	wm8804_probe	sound/soc/codecs/snd-soc-wm8804	EXPORT_SYMBOL_GPL	
++0x7880c781	dm_kcopyd_prepare_callback	drivers/md/dm-mod	EXPORT_SYMBOL	
++0x502e45ac	__v4l2_ctrl_s_ctrl_int64	drivers/media/v4l2-core/videodev	EXPORT_SYMBOL	
++0x865738d3	vb2_dma_contig_memops	drivers/media/common/videobuf2/videobuf2-dma-contig	EXPORT_SYMBOL_GPL	
++0xa21fa765	vb2_create_framevec	drivers/media/common/videobuf2/videobuf2-memops	EXPORT_SYMBOL	
++0xab951d97	alloc_candev_mqs	drivers/net/can/dev/can-dev	EXPORT_SYMBOL_GPL	
++0xbe8dd02b	ieee80211_tx_status	net/mac80211/mac80211	EXPORT_SYMBOL	
++0xa986af04	ipv6_dev_mc_dec	net/ipv6/ipv6	EXPORT_SYMBOL	
++0xec447dc3	ipv6_dev_mc_inc	net/ipv6/ipv6	EXPORT_SYMBOL	
++0xb8e448a0	snd_seq_set_queue_tempo	sound/core/seq/snd-seq	EXPORT_SYMBOL	
++0x07fd71cc	mtd_write_user_prot_reg	drivers/mtd/mtd	EXPORT_SYMBOL_GPL	
++0xe2b92059	v4l2_video_std_construct	drivers/media/v4l2-core/videodev	EXPORT_SYMBOL	
++0xb03a8f19	media_device_init	drivers/media/mc/mc	EXPORT_SYMBOL_GPL	
++0xfe7954ed	snd_soc_dapm_disable_pin	sound/soc/snd-soc-core	EXPORT_SYMBOL_GPL	
++0x9e98460e	dm_bitset_empty	drivers/md/persistent-data/dm-persistent-data	EXPORT_SYMBOL_GPL	
++0xb70b342a	dm_bio_prison_destroy	drivers/md/dm-bio-prison	EXPORT_SYMBOL_GPL	
++0xd62fd132	hostap_get_porttype	drivers/net/wireless/intersil/hostap/hostap	EXPORT_SYMBOL	
++0x4575a0ca	drm_mode_set_crtcinfo	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0xf1b5340a	drm_mode_vrefresh	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0x787ac1b1	__drm_atomic_helper_plane_reset	drivers/gpu/drm/drm_kms_helper	EXPORT_SYMBOL	
++0x2833f577	ZSTD_compressBegin_advanced	lib/zstd/zstd_compress	EXPORT_SYMBOL	
++0x9412400f	cfg80211_stop_iface	net/wireless/cfg80211	EXPORT_SYMBOL	
++0xb2cc132e	nf_conntrack_alloc	net/netfilter/nf_conntrack	EXPORT_SYMBOL_GPL	
++0xcd08ee07	__ssb_driver_register	drivers/ssb/ssb	EXPORT_SYMBOL	
++0x3ca72088	media_entity_setup_link	drivers/media/mc/mc	EXPORT_SYMBOL_GPL	
++0xc517e5cd	tda827x_attach	drivers/media/tuners/tda827x	EXPORT_SYMBOL_GPL	
++0x7266283e	iscsi_host_free	drivers/scsi/libiscsi	EXPORT_SYMBOL_GPL	
++0x27a1f713	drm_panel_of_backlight	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0x0b24d743	dm_bio_prison_free_cell	drivers/md/dm-bio-prison	EXPORT_SYMBOL_GPL	
++0x4b269167	stb0899_attach	drivers/media/dvb-frontends/stb0899	EXPORT_SYMBOL	
++0x14fd2d64	stv0299_attach	drivers/media/dvb-frontends/stv0299	EXPORT_SYMBOL	
++0x2deb6096	mt76_set_stream_caps	drivers/net/wireless/mediatek/mt76/mt76	EXPORT_SYMBOL_GPL	
++0xed0016a5	wpan_phy_for_each	net/ieee802154/ieee802154	EXPORT_SYMBOL	
++0xee28b16b	ieee80211_tx_status_ext	net/mac80211/mac80211	EXPORT_SYMBOL	
++0xf806155c	snd_soc_bytes_tlv_callback	sound/soc/snd-soc-core	EXPORT_SYMBOL_GPL	
++0x6f3eef64	__snd_rawmidi_transmit_ack	sound/core/snd-rawmidi	EXPORT_SYMBOL	
++0x94098ff8	snd_interval_list	sound/core/snd-pcm	EXPORT_SYMBOL	
++0x4c889742	virtio_transport_notify_recv_post_dequeue	net/vmw_vsock/vmw_vsock_virtio_transport_common	EXPORT_SYMBOL_GPL	
++0x5803d5f7	snd_soc_close_delayed_work	sound/soc/snd-soc-core	EXPORT_SYMBOL_GPL	
++0x7a68954f	iio_trigger_free	drivers/iio/industrialio	EXPORT_SYMBOL	
++0xa4534463	mwifiex_write_data_complete	drivers/net/wireless/marvell/mwifiex/mwifiex	EXPORT_SYMBOL_GPL	
++0xc97fd89a	drm_atomic_helper_commit_modeset_enables	drivers/gpu/drm/drm_kms_helper	EXPORT_SYMBOL	
++0xb03684eb	snd_compress_register	sound/core/snd-compress	EXPORT_SYMBOL_GPL	
++0x27a0b5e4	snd_ctl_make_virtual_master	sound/core/snd	EXPORT_SYMBOL	
++0xdd689060	rndis_signal_connect	drivers/usb/gadget/function/usb_f_rndis	EXPORT_SYMBOL_GPL	
++0xc9739498	mt76_put_txwi	drivers/net/wireless/mediatek/mt76/mt76	EXPORT_SYMBOL_GPL	
++0x1a107de2	ZSTD_compressCCtx	lib/zstd/zstd_compress	EXPORT_SYMBOL	
++0xc23994d2	ieee80211_probereq_get	net/mac80211/mac80211	EXPORT_SYMBOL	
++0x58c9851e	ieee80211_send_bar	net/mac80211/mac80211	EXPORT_SYMBOL	
++0xc871f4bf	hci_alloc_dev	net/bluetooth/bluetooth	EXPORT_SYMBOL	
++0xaa389a54	nft_meta_set_dump	net/netfilter/nf_tables	EXPORT_SYMBOL_GPL	
++0xb90edfba	nft_meta_get_dump	net/netfilter/nf_tables	EXPORT_SYMBOL_GPL	
++0xa77ab1c4	usb_wwan_port_remove	drivers/usb/serial/usb_wwan	EXPORT_SYMBOL	
++0x1744c86b	hdlcdrv_arbitrate	drivers/net/hamradio/hdlcdrv	EXPORT_SYMBOL	
++0x51ccc69c	drm_crtc_vblank_helper_get_vblank_timestamp_internal	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0x12a840ec	ip6_tnl_get_cap	net/ipv6/ip6_tunnel	EXPORT_SYMBOL	
++0x9b40be3a	dapm_clock_event	sound/soc/snd-soc-core	EXPORT_SYMBOL_GPL	
++0xa77cbd64	v4l2_m2m_buf_remove_by_idx	drivers/media/v4l2-core/v4l2-mem2mem	EXPORT_SYMBOL_GPL	
++0x2316f727	vb2_ioctl_streamon	drivers/media/common/videobuf2/videobuf2-v4l2	EXPORT_SYMBOL_GPL	
++0x58f37cc1	drm_connector_set_panel_orientation	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0x087b671a	ip6mr_rule_default	net/ipv6/ipv6	EXPORT_SYMBOL	
++0x922a0413	snd_soc_cnew	sound/soc/snd-soc-core	EXPORT_SYMBOL_GPL	
++0x3aa47393	read_efuse_byte	drivers/net/wireless/realtek/rtlwifi/rtlwifi	EXPORT_SYMBOL_GPL	
++0x9b574e1c	drm_atomic_helper_crtc_reset	drivers/gpu/drm/drm_kms_helper	EXPORT_SYMBOL	
++0x70134601	ieee80211_rate_control_unregister	net/mac80211/mac80211	EXPORT_SYMBOL	
++0x8df7183f	inet6_ioctl	net/ipv6/ipv6	EXPORT_SYMBOL	
++0x6ef8fcd8	snd_pcm_format_linear	sound/core/snd-pcm	EXPORT_SYMBOL	
++0x5aeaf14c	ves1820_attach	drivers/media/dvb-frontends/ves1820	EXPORT_SYMBOL	
++0xb4163c2a	rt2x00usb_watchdog	drivers/net/wireless/ralink/rt2x00/rt2x00usb	EXPORT_SYMBOL_GPL	
++0x52f2ac18	mt76_tx_check_agg_ssn	drivers/net/wireless/mediatek/mt76/mt76	EXPORT_SYMBOL_GPL	
++0x2a32fa1a	mt76_update_survey_active_time	drivers/net/wireless/mediatek/mt76/mt76	EXPORT_SYMBOL_GPL	
++0x3e603ed9	hostap_setup_dev	drivers/net/wireless/intersil/hostap/hostap	EXPORT_SYMBOL	
++0x59428f88	drm_property_create_range	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0x220b49ab	chacha_crypt_arch	arch/arm64/crypto/chacha-neon	EXPORT_SYMBOL	
++0x4744995a	usb_role_switch_register	drivers/usb/roles/roles	EXPORT_SYMBOL_GPL	
++0xcec08e95	rt2x00mac_start	drivers/net/wireless/ralink/rt2x00/rt2x00lib	EXPORT_SYMBOL_GPL	
++0x23369db5	mt76x02_ext_pa_enabled	drivers/net/wireless/mediatek/mt76/mt76x02-lib	EXPORT_SYMBOL_GPL	
++0xed848101	ath9k_cmn_beacon_config_sta	drivers/net/wireless/ath/ath9k/ath9k_common	EXPORT_SYMBOL	
++0x23dd1f9c	ieee80211_iter_keys	net/mac80211/mac80211	EXPORT_SYMBOL	
++0x715fd8f9	ip6t_register_table	net/ipv6/netfilter/ip6_tables	EXPORT_SYMBOL	
++0x9384cd49	ata_tf_from_fis	drivers/ata/libata	EXPORT_SYMBOL_GPL	
++0xca149ff4	snd_tea575x_hw_init	drivers/media/radio/tea575x	EXPORT_SYMBOL	
++0x0dbf0296	tveeprom_hauppauge_analog	drivers/media/common/tveeprom	EXPORT_SYMBOL	
++0x2882d40e	usb_role_switch_unregister	drivers/usb/roles/roles	EXPORT_SYMBOL_GPL	
++0xd0929f10	pie_process_dequeue	net/sched/sch_pie	EXPORT_SYMBOL_GPL	
++0xbdfccb62	v4l2_async_notifier_parse_fwnode_endpoints	drivers/media/v4l2-core/v4l2-fwnode	EXPORT_SYMBOL_GPL	
++0xd36e603a	cx22702_attach	drivers/media/dvb-frontends/cx22702	EXPORT_SYMBOL	
++0x90493fdd	lbs_process_rxed_packet	drivers/net/wireless/marvell/libertas/libertas	EXPORT_SYMBOL_GPL	
++0xe0e06355	drm_writeback_prepare_job	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0xf9fe4b16	backlight_device_unregister	drivers/video/backlight/backlight	EXPORT_SYMBOL	
++0xb4042055	crypto_nhpoly1305_update	crypto/nhpoly1305	EXPORT_SYMBOL	
++0xc0763484	rfkill_blocked	net/rfkill/rfkill	EXPORT_SYMBOL	
++0x61c6a2d1	ip6_push_pending_frames	net/ipv6/ipv6	EXPORT_SYMBOL_GPL	
++0xa301f09c	nft_fib_dump	net/netfilter/nft_fib	EXPORT_SYMBOL_GPL	
++0x8efe421f	unregister_mtd_user	drivers/mtd/mtd	EXPORT_SYMBOL_GPL	
++0xdfb07d85	ahci_dev_classify	drivers/ata/libahci	EXPORT_SYMBOL_GPL	
++0x1d69bde0	mt76_write_mac_initvals	drivers/net/wireless/mediatek/mt76/mt76x2/mt76x2-common	EXPORT_SYMBOL_GPL	
++0x6a0c3847	__mlog_printk	fs/ocfs2/cluster/ocfs2_nodemanager	EXPORT_SYMBOL_GPL	
++0x8f6c93b8	iio_dealloc_pollfunc	drivers/iio/industrialio	EXPORT_SYMBOL_GPL	
++0xdb0a254f	btintel_download_firmware_newgen	drivers/bluetooth/btintel	EXPORT_SYMBOL_GPL	
++0x4dd9d14d	cn_netlink_send_mult	drivers/connector/cn	EXPORT_SYMBOL_GPL	
++0x839f84fa	md_write_end	drivers/md/md-mod	EXPORT_SYMBOL	
++0xf857e167	v4l2_src_change_event_subscribe	drivers/media/v4l2-core/videodev	EXPORT_SYMBOL_GPL	
++0xd0745ed4	__media_entity_setup_link	drivers/media/mc/mc	EXPORT_SYMBOL_GPL	
++0x873fe8d6	mt76_get_antenna	drivers/net/wireless/mediatek/mt76/mt76	EXPORT_SYMBOL_GPL	
++0x4ca32435	mwifiex_init_shutdown_fw	drivers/net/wireless/marvell/mwifiex/mwifiex	EXPORT_SYMBOL_GPL	
++0x578c2053	lbs_queue_event	drivers/net/wireless/marvell/libertas/libertas	EXPORT_SYMBOL_GPL	
++0x3e8d2fd4	hostap_set_antsel	drivers/net/wireless/intersil/hostap/hostap	EXPORT_SYMBOL	
++0x6de3c9db	ip6t_unregister_table_pre_exit	net/ipv6/netfilter/ip6_tables	EXPORT_SYMBOL	
++0xa286a234	snd_pcm_format_name	sound/core/snd-pcm	EXPORT_SYMBOL_GPL	
++0x9a72228a	devm_iio_channel_get_all	drivers/iio/industrialio	EXPORT_SYMBOL_GPL	
++0x2493c654	rt2x00queue_start_queues	drivers/net/wireless/ralink/rt2x00/rt2x00lib	EXPORT_SYMBOL_GPL	
++0x643320ec	ieee80211_calc_tx_airtime	net/mac80211/mac80211	EXPORT_SYMBOL_GPL	
++0x1ed697ae	roccat_common2_sysfs_read	drivers/hid/hid-roccat-common	EXPORT_SYMBOL_GPL	
++0x8146acbe	drm_mode_plane_set_obj_prop	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0x320c1819	cryptd_aead_queued	crypto/cryptd	EXPORT_SYMBOL_GPL	
++0xd9bb821b	xt_copy_counters	net/netfilter/x_tables	EXPORT_SYMBOL_GPL	
++0x3df42048	sms_board_lna_control	drivers/media/common/siano/smsmdtv	EXPORT_SYMBOL_GPL	
++0xd16c4d36	ath9k_hw_set_rx_bufsize	drivers/net/wireless/ath/ath9k/ath9k_hw	EXPORT_SYMBOL	
++0x9daf91c9	drm_connector_list_iter_end	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0x6a84e5b7	drm_set_preferred_mode	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0xa9226f2e	cfg80211_get_drvinfo	net/wireless/cfg80211	EXPORT_SYMBOL	
++0xa8a3846d	nfnetlink_has_listeners	net/netfilter/nfnetlink	EXPORT_SYMBOL_GPL	
++0x7cac7292	cs42888_data	sound/soc/codecs/snd-soc-cs42xx8	EXPORT_SYMBOL_GPL	
++0xd51f74eb	ahci_ops	drivers/ata/libahci	EXPORT_SYMBOL_GPL	
++0x0fc2b686	ata_wait_after_reset	drivers/ata/libata	EXPORT_SYMBOL_GPL	
++0x8b35d0ea	v4l2_m2m_ioctl_encoder_cmd	drivers/media/v4l2-core/v4l2-mem2mem	EXPORT_SYMBOL_GPL	
++0x75da1aa1	ax25_header_ops	net/ax25/ax25	EXPORT_SYMBOL	
++0x55075ecc	ip_tunnel_encap_del_ops	net/ipv4/ip_tunnel	EXPORT_SYMBOL	
++0x111614d4	snd_pcm_suspend_all	sound/core/snd-pcm	EXPORT_SYMBOL	
++0x3e9347d4	mt2063_attach	drivers/media/tuners/mt2063	EXPORT_SYMBOL_GPL	
++0x3511ef6b	rtl92c_phy_sw_chnl_callback	drivers/net/wireless/realtek/rtlwifi/rtl8192c/rtl8192c-common	EXPORT_SYMBOL	
++0x2921a4d4	rtl_btc_status_false	drivers/net/wireless/realtek/rtlwifi/rtlwifi	EXPORT_SYMBOL_GPL	
++0x19f37f0d	ieee80211_update_p2p_noa	net/mac80211/mac80211	EXPORT_SYMBOL	
++0x5db749b0	inet6_bind	net/ipv6/ipv6	EXPORT_SYMBOL	
++0x98cf0e93	flow_offload_lookup	net/netfilter/nf_flow_table	EXPORT_SYMBOL_GPL	
++0x28b5d002	cs4271_regmap_config	sound/soc/codecs/snd-soc-cs4271	EXPORT_SYMBOL_GPL	
++0x02651956	snd_card_ref	sound/core/snd	EXPORT_SYMBOL_GPL	
++0xf2228a7c	mt76x02_configure_filter	drivers/net/wireless/mediatek/mt76/mt76x02-lib	EXPORT_SYMBOL_GPL	
++0xd90cb249	ZSTD_getBlockSizeMax	lib/zstd/zstd_compress	EXPORT_SYMBOL	
++0x270403a5	ieee80211_ap_probereq_get	net/mac80211/mac80211	EXPORT_SYMBOL	
++0x851fe124	__SCK__tp_func_fib6_table_lookup	net/ipv6/ipv6	EXPORT_SYMBOL_GPL	
++0x3bbe63d0	snd_soc_dai_compr_ack	sound/soc/snd-soc-core	EXPORT_SYMBOL_GPL	
++0xd67a3501	af_alg_sendpage	crypto/af_alg	EXPORT_SYMBOL_GPL	
++0xae6f6564	virtio_transport_notify_buffer_size	net/vmw_vsock/vmw_vsock_virtio_transport_common	EXPORT_SYMBOL_GPL	
++0x9d4cfc2d	ieee80211_resume_disconnect	net/mac80211/mac80211	EXPORT_SYMBOL_GPL	
++0x48bce387	bt_accept_enqueue	net/bluetooth/bluetooth	EXPORT_SYMBOL	
++0xf65791b5	v4l2_device_register_subdev	drivers/media/v4l2-core/videodev	EXPORT_SYMBOL_GPL	
++0x4668c655	media_devnode_create	drivers/media/mc/mc	EXPORT_SYMBOL_GPL	
++0xa917c0f4	lgdt3305_attach	drivers/media/dvb-frontends/lgdt3305	EXPORT_SYMBOL	
++0x01af691c	lgdt330x_attach	drivers/media/dvb-frontends/lgdt330x	EXPORT_SYMBOL	
++0xfad6675b	sms_board_led_feedback	drivers/media/common/siano/smsmdtv	EXPORT_SYMBOL_GPL	
++0xa175097e	register_8022_client	net/802/p8022	EXPORT_SYMBOL	
++0xf15cc9ea	vhost_vq_access_ok	drivers/vhost/vhost	EXPORT_SYMBOL_GPL	
++0xadf59fe1	vchiq_mmal_port_connect_tunnel	drivers/staging/vc04_services/vchiq-mmal/bcm2835-mmal-vchiq	EXPORT_SYMBOL_GPL	
++0x7b047bd9	dm_tm_create_non_blocking_clone	drivers/md/persistent-data/dm-persistent-data	EXPORT_SYMBOL_GPL	
++0x13b2c5fb	bcm3510_attach	drivers/media/dvb-frontends/bcm3510	EXPORT_SYMBOL	
++0x3cae9df0	em28xx_find_led	drivers/media/usb/em28xx/em28xx	EXPORT_SYMBOL_GPL	
++0xec60d672	em28xx_read_reg	drivers/media/usb/em28xx/em28xx	EXPORT_SYMBOL_GPL	
++0x984e21a4	sms_board_event	drivers/media/common/siano/smsmdtv	EXPORT_SYMBOL_GPL	
++0x388d20e7	cdc_ncm_bind_common	drivers/net/usb/cdc_ncm	EXPORT_SYMBOL_GPL	
++0xfa82674e	drm_i2c_encoder_detect	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0x3db56617	simd_register_aeads_compat	crypto/crypto_simd	EXPORT_SYMBOL_GPL	
++0x062e7196	fuse_request_end	fs/fuse/fuse	EXPORT_SYMBOL_GPL	
++0xd5f4dfb0	snd_soc_info_enum_double	sound/soc/snd-soc-core	EXPORT_SYMBOL_GPL	
++0x92086d90	_rtl92c_phy_fw_rf_serial_read	drivers/net/wireless/realtek/rtlwifi/rtl8192c/rtl8192c-common	EXPORT_SYMBOL	
++0x2af6ea96	btmrvl_remove_card	drivers/bluetooth/btmrvl	EXPORT_SYMBOL_GPL	
++0x964c518e	btintel_check_bdaddr	drivers/bluetooth/btintel	EXPORT_SYMBOL_GPL	
++0x9effa2df	cfg80211_pmsr_report	net/wireless/cfg80211	EXPORT_SYMBOL_GPL	
++0x96cfd208	isl6423_attach	drivers/media/dvb-frontends/isl6423	EXPORT_SYMBOL	
++0xc4e3c271	tveeprom_read	drivers/media/common/tveeprom	EXPORT_SYMBOL	
++0xe1fe1432	cx2341x_log_status	drivers/media/common/cx2341x	EXPORT_SYMBOL	
++0x6acb4179	fsg_common_set_inquiry_string	drivers/usb/gadget/function/usb_f_mass_storage	EXPORT_SYMBOL_GPL	
++0x6e2215f8	rt2x00mac_get_ringparam	drivers/net/wireless/ralink/rt2x00/rt2x00lib	EXPORT_SYMBOL_GPL	
++0xeab9cbd5	iscsi_conn_get_addr_param	drivers/scsi/libiscsi	EXPORT_SYMBOL_GPL	
++0x66cf2f64	drm_display_mode_from_videomode	drivers/gpu/drm/drm	EXPORT_SYMBOL_GPL	
++0x0b2fc69c	br_multicast_has_querier_adjacent	net/bridge/bridge	EXPORT_SYMBOL_GPL	
++0xea38ee07	wm_halo_bus_error	sound/soc/codecs/snd-soc-wm-adsp	EXPORT_SYMBOL_GPL	
++0xa1989079	iio_read_mount_matrix	drivers/iio/industrialio	EXPORT_SYMBOL	
++0x93e4ef60	vchiq_mmal_port_enable	drivers/staging/vc04_services/vchiq-mmal/bcm2835-mmal-vchiq	EXPORT_SYMBOL_GPL	
++0xfeb6a920	mt76x02_sta_add	drivers/net/wireless/mediatek/mt76/mt76x02-lib	EXPORT_SYMBOL_GPL	
++0x2feb95e8	btmrvl_send_hscfg_cmd	drivers/bluetooth/btmrvl	EXPORT_SYMBOL_GPL	
++0x6f77964e	ata_sff_exec_command	drivers/ata/libata	EXPORT_SYMBOL_GPL	
++0x844260d8	ath9k_cmn_update_txpow	drivers/net/wireless/ath/ath9k/ath9k_common	EXPORT_SYMBOL	
++0x43474430	af_alg_free_sg	crypto/af_alg	EXPORT_SYMBOL_GPL	
++0xebaa2ed2	af_alg_make_sg	crypto/af_alg	EXPORT_SYMBOL_GPL	
++0x11f11632	bcma_core_pci_power_save	drivers/bcma/bcma	EXPORT_SYMBOL_GPL	
++0x46efdcd0	dib0090_get_wbd_offset	drivers/media/dvb-frontends/dib0090	EXPORT_SYMBOL	
++0xf3389071	rtl_cam_mark_invalid	drivers/net/wireless/realtek/rtlwifi/rtlwifi	EXPORT_SYMBOL	
++0xead035ee	__tracepoint_fib6_table_lookup	net/ipv6/ipv6	EXPORT_SYMBOL_GPL	
++0x01be7dd2	rt2800_gain_calibration	drivers/net/wireless/ralink/rt2x00/rt2800lib	EXPORT_SYMBOL_GPL	
++0xe4bd8a08	ath_printk	drivers/net/wireless/ath/ath	EXPORT_SYMBOL	
++0x8d1f6faa	ath9k_hw_disable	drivers/net/wireless/ath/ath9k/ath9k_hw	EXPORT_SYMBOL	
++0x5cf0d0bb	dm_tm_create_with_sm	drivers/md/persistent-data/dm-persistent-data	EXPORT_SYMBOL_GPL	
++0xed0f23bb	v4l2_event_unsubscribe_all	drivers/media/v4l2-core/videodev	EXPORT_SYMBOL_GPL	
++0xff5ae52c	tap_queue_resize	drivers/net/tap	EXPORT_SYMBOL_GPL	
++0x4bf55a76	ath9k_hw_resettxqueue	drivers/net/wireless/ath/ath9k/ath9k_hw	EXPORT_SYMBOL	
++0x18650207	iscsi_session_failure	drivers/scsi/libiscsi	EXPORT_SYMBOL_GPL	
++0x25790947	drm_gem_shmem_create	drivers/gpu/drm/drm	EXPORT_SYMBOL_GPL	
++0xdace9618	asoc_simple_parse_routing	sound/soc/generic/snd-soc-simple-card-utils	EXPORT_SYMBOL_GPL	
++0x949ddef0	ata_sas_sync_probe	drivers/ata/libata	EXPORT_SYMBOL_GPL	
++0x5547e3ca	v4l2_event_queue_fh	drivers/media/v4l2-core/videodev	EXPORT_SYMBOL_GPL	
++0x9a0221c7	fsg_common_free_buffers	drivers/usb/gadget/function/usb_f_mass_storage	EXPORT_SYMBOL_GPL	
++0x35d74aa6	mt76x02_dma_init	drivers/net/wireless/mediatek/mt76/mt76x02-lib	EXPORT_SYMBOL_GPL	
++0xf98faffc	drm_atomic_helper_page_flip	drivers/gpu/drm/drm_kms_helper	EXPORT_SYMBOL	
++0x9a4b24f1	fb_sys_read	drivers/video/fbdev/core/fb_sys_fops	EXPORT_SYMBOL_GPL	
++0xa05be2b9	wpan_phy_unregister	net/ieee802154/ieee802154	EXPORT_SYMBOL	
++0xfa101ca1	wm_adsp_compr_pointer	sound/soc/codecs/snd-soc-wm-adsp	EXPORT_SYMBOL_GPL	
++0x8df3789f	snd_oss_info_register	sound/core/snd	EXPORT_SYMBOL	
++0x73dbe995	mtd_get_device_size	drivers/mtd/mtd	EXPORT_SYMBOL_GPL	
++0x2342f1ae	v4l2_prio_open	drivers/media/v4l2-core/videodev	EXPORT_SYMBOL	
++0xb151cbb0	simd_unregister_aeads	crypto/crypto_simd	EXPORT_SYMBOL_GPL	
++0x9fb9edd8	ip_set_del	net/netfilter/ipset/ip_set	EXPORT_SYMBOL_GPL	
++0x9f48f89b	ip_set_add	net/netfilter/ipset/ip_set	EXPORT_SYMBOL_GPL	
++0x22a5efa4	cec_transmit_done_ts	drivers/media/cec/core/cec	EXPORT_SYMBOL_GPL	
++0x5fc9e7df	fsg_store_nofua	drivers/usb/gadget/function/usb_f_mass_storage	EXPORT_SYMBOL_GPL	
++0x045a0916	bcm2835_smi_write_buf	drivers/misc/bcm2835_smi	EXPORT_SYMBOL	
++0xd26e707c	vsock_for_each_connected_socket	net/vmw_vsock/vsock	EXPORT_SYMBOL_GPL	
++0x2a59eb23	ipv6_sock_mc_join	net/ipv6/ipv6	EXPORT_SYMBOL	
++0x753e20b2	dm_bio_prison_create	drivers/md/dm-bio-prison	EXPORT_SYMBOL_GPL	
++0x7647c5f5	v4l2_create_fwnode_links_to_pad	drivers/media/v4l2-core/videodev	EXPORT_SYMBOL_GPL	
++0x0856f360	fsg_store_inquiry_string	drivers/usb/gadget/function/usb_f_mass_storage	EXPORT_SYMBOL_GPL	
++0xf8b3fcd8	drmm_kmalloc	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0x2d39633a	udp_tun_rx_dst	net/ipv4/udp_tunnel	EXPORT_SYMBOL_GPL	
++0x10594878	media_device_unregister_entity_notify	drivers/media/mc/mc	EXPORT_SYMBOL_GPL	
++0x7da0ce1d	em28xx_read_ac97	drivers/media/usb/em28xx/em28xx	EXPORT_SYMBOL_GPL	
++0xa9e4133b	gspca_resume	drivers/media/usb/gspca/gspca_main	EXPORT_SYMBOL	
++0xd1ee69c4	drm_atomic_helper_bridge_duplicate_state	drivers/gpu/drm/drm_kms_helper	EXPORT_SYMBOL	
++0xf499a6ce	nfc_vendor_cmd_reply	net/nfc/nfc	EXPORT_SYMBOL	
++0xc0655bc3	ssb_chipco_gpio_control	drivers/ssb/ssb	EXPORT_SYMBOL	
++0x9c8ac8be	__mtd_next_device	drivers/mtd/mtd	EXPORT_SYMBOL_GPL	
++0x7e2d5902	vb2_core_reqbufs	drivers/media/common/videobuf2/videobuf2-common	EXPORT_SYMBOL_GPL	
++0x6d570e48	__regmap_init_spi	drivers/base/regmap/regmap-spi	EXPORT_SYMBOL_GPL	
++0xb7568d0a	regulatory_set_wiphy_regd	net/wireless/cfg80211	EXPORT_SYMBOL	
++0xd3a290db	snd_rawmidi_output_params	sound/core/snd-rawmidi	EXPORT_SYMBOL	
++0xc5c99a79	drm_dp_get_adjust_request_voltage	drivers/gpu/drm/drm_kms_helper	EXPORT_SYMBOL	
++0xe7106fd0	ieee80211_ctstoself_get	net/mac80211/mac80211	EXPORT_SYMBOL	
++0x8ffe7e89	nf_conntrack_htable_size	net/netfilter/nf_conntrack	EXPORT_SYMBOL_GPL	
++0x71b03539	ata_port_desc	drivers/ata/libata	EXPORT_SYMBOL_GPL	
++0x00471e38	em28xx_register_extension	drivers/media/usb/em28xx/em28xx	EXPORT_SYMBOL	
++0x2309a6d6	tm6000_xc5000_callback	drivers/media/usb/tm6000/tm6000	EXPORT_SYMBOL_GPL	
++0xf13c4a85	can_rx_offload_enable	drivers/net/can/dev/can-dev	EXPORT_SYMBOL_GPL	
++0x1bb24324	drm_flip_work_init	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0xb739e3b5	ipv6_flowlabel_exclusive	net/ipv6/ipv6	EXPORT_SYMBOL	
++0x74e8b1b9	v4l2_m2m_job_finish	drivers/media/v4l2-core/v4l2-mem2mem	EXPORT_SYMBOL	
++0x2183c08c	drm_mm_scan_add_block	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0xc9f980b5	drm_fb_helper_sys_write	drivers/gpu/drm/drm_kms_helper	EXPORT_SYMBOL	
++0xe672fea0	drm_scdc_get_scrambling_status	drivers/gpu/drm/drm_kms_helper	EXPORT_SYMBOL	
++0x0c7247e9	ax25_register_pid	net/ax25/ax25	EXPORT_SYMBOL_GPL	
++0x5b5a4234	snd_pcm_lib_preallocate_pages	sound/core/snd-pcm	EXPORT_SYMBOL	
++0xcb08f11f	btintel_send_intel_reset	drivers/bluetooth/btintel	EXPORT_SYMBOL_GPL	
++0x89b611dd	tm6000_debug	drivers/media/usb/tm6000/tm6000	EXPORT_SYMBOL_GPL	
++0x68c7ecd4	rt2800_conf_tx	drivers/net/wireless/ralink/rt2x00/rt2800lib	EXPORT_SYMBOL_GPL	
++0xfcdd2c64	ax25_linkfail_register	net/ax25/ax25	EXPORT_SYMBOL	
++0xb557512b	arizona_lhpf_coeff_put	sound/soc/codecs/snd-soc-arizona	EXPORT_SYMBOL_GPL	
++0x5ec654ed	snd_soc_dpcm_be_can_update	sound/soc/snd-soc-core	EXPORT_SYMBOL_GPL	
++0x8e05e376	snd_soc_dpcm_fe_can_update	sound/soc/snd-soc-core	EXPORT_SYMBOL_GPL	
++0x0973469d	snd_dmaengine_pcm_pointer_no_residue	sound/core/snd-pcm-dmaengine	EXPORT_SYMBOL_GPL	
++0xc5c7568a	btbcm_write_pcm_int_params	drivers/bluetooth/btbcm	EXPORT_SYMBOL_GPL	
++0x9290e07a	dm_tm_read_lock	drivers/md/persistent-data/dm-persistent-data	EXPORT_SYMBOL_GPL	
++0x7b6b3af5	dm_bm_read_lock	drivers/md/persistent-data/dm-persistent-data	EXPORT_SYMBOL_GPL	
++0xd35c2f73	vb2_core_qbuf	drivers/media/common/videobuf2/videobuf2-common	EXPORT_SYMBOL_GPL	
++0xb9f56e22	drm_format_info_block_width	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0x6b827650	nfc_tm_deactivated	net/nfc/nfc	EXPORT_SYMBOL	
++0xb2734a4b	nft_fib_policy	net/netfilter/nft_fib	EXPORT_SYMBOL	
++0xc93f07e2	snd_tea575x_g_tuner	drivers/media/radio/tea575x	EXPORT_SYMBOL	
++0x8fe1ea1b	tm6000_get_reg	drivers/media/usb/tm6000/tm6000	EXPORT_SYMBOL_GPL	
++0x14642d9e	tm6000_set_reg	drivers/media/usb/tm6000/tm6000	EXPORT_SYMBOL_GPL	
++0x84990d7f	rndis_set_param_medium	drivers/usb/gadget/function/usb_f_rndis	EXPORT_SYMBOL_GPL	
++0x406c7005	_rtl92c_phy_dbm_to_txpwr_idx	drivers/net/wireless/realtek/rtlwifi/rtl8192c/rtl8192c-common	EXPORT_SYMBOL	
++0x248d65a7	rtl_fw_block_write	drivers/net/wireless/realtek/rtlwifi/rtlwifi	EXPORT_SYMBOL_GPL	
++0x0ec446c2	iscsi_host_get_max_scsi_cmds	drivers/scsi/libiscsi	EXPORT_SYMBOL_GPL	
++0x1475f64b	ocfs2_dlm_lvb_valid	fs/ocfs2/ocfs2_stackglue	EXPORT_SYMBOL_GPL	
++0xd0816aa8	ieee802154_xmit_complete	net/mac802154/mac802154	EXPORT_SYMBOL	
++0x183dcd3b	ieee80211_get_key_rx_seq	net/mac80211/mac80211	EXPORT_SYMBOL	
++0x63b0c22d	dm_bitset_flush	drivers/md/persistent-data/dm-persistent-data	EXPORT_SYMBOL_GPL	
++0x4a173012	vb2_ioctl_streamoff	drivers/media/common/videobuf2/videobuf2-v4l2	EXPORT_SYMBOL_GPL	
++0xb310fe96	fuse_abort_conn	fs/fuse/fuse	EXPORT_SYMBOL_GPL	
++0x22fc13c3	nf_tproxy_handle_time_wait6	net/ipv6/netfilter/nf_tproxy_ipv6	EXPORT_SYMBOL_GPL	
++0xd215d7a6	nf_tproxy_handle_time_wait4	net/ipv4/netfilter/nf_tproxy_ipv4	EXPORT_SYMBOL_GPL	
++0xb2e5ae4a	snd_lookup_minor_data	sound/core/snd	EXPORT_SYMBOL	
++0x48fa922e	iio_triggered_buffer_setup	drivers/iio/buffer/industrialio-triggered-buffer	EXPORT_SYMBOL	
++0xe1bdae47	dm_cache_policy_create	drivers/md/dm-cache	EXPORT_SYMBOL_GPL	
++0x31c59bf8	fsg_show_removable	drivers/usb/gadget/function/usb_f_mass_storage	EXPORT_SYMBOL_GPL	
++0x8f0c56b6	mt76_stop_tx_queues	drivers/net/wireless/mediatek/mt76/mt76	EXPORT_SYMBOL_GPL	
++0x5f85ec21	drm_sched_stop	drivers/gpu/drm/scheduler/gpu-sched	EXPORT_SYMBOL	
++0xa709c835	fib6_info_destroy_rcu	net/ipv6/ipv6	EXPORT_SYMBOL_GPL	
++0xf1fb8bc5	arizona_of_get_audio_pdata	sound/soc/codecs/snd-soc-arizona	EXPORT_SYMBOL_GPL	
++0xaae44d66	iio_write_channel_attribute	drivers/iio/industrialio	EXPORT_SYMBOL_GPL	
++0xae449aa5	ata_cable_40wire	drivers/ata/libata	EXPORT_SYMBOL_GPL	
++0x8b7f4c59	i2400m_reset	drivers/net/wimax/i2400m/i2400m	EXPORT_SYMBOL_GPL	
++0x53a028f9	rtl92c_bt_rssi_state_change	drivers/net/wireless/realtek/rtlwifi/rtl8192c/rtl8192c-common	EXPORT_SYMBOL	
++0xba858b94	drm_fb_helper_set_par	drivers/gpu/drm/drm_kms_helper	EXPORT_SYMBOL	
++0xacef80a5	nf_log_dump_tcp_header	net/netfilter/nf_log_common	EXPORT_SYMBOL_GPL	
++0xdd913d2b	nf_log_dump_udp_header	net/netfilter/nf_log_common	EXPORT_SYMBOL_GPL	
++0x82e289c5	ata_cable_unknown	drivers/ata/libata	EXPORT_SYMBOL_GPL	
++0x4839762f	v4l2_calc_timeperframe	drivers/media/v4l2-core/v4l2-dv-timings	EXPORT_SYMBOL_GPL	
++0x50fa1dd0	mt76x2_mac_stop	drivers/net/wireless/mediatek/mt76/mt76x2/mt76x2-common	EXPORT_SYMBOL_GPL	
++0x0462ce68	mt76x02_add_rate_power_offset	drivers/net/wireless/mediatek/mt76/mt76x02-lib	EXPORT_SYMBOL_GPL	
++0xeaa84fd7	drm_atomic_helper_commit_planes_on_crtc	drivers/gpu/drm/drm_kms_helper	EXPORT_SYMBOL	
++0x1c0935b9	l2tp_session_get_by_ifname	net/l2tp/l2tp_core	EXPORT_SYMBOL_GPL	
++0xb09175d0	regulatory_hint	net/wireless/cfg80211	EXPORT_SYMBOL	
++0x1b7117aa	wiphy_rfkill_start_polling	net/wireless/cfg80211	EXPORT_SYMBOL	
++0x8f0c2313	snd_soc_dapm_mixer_update_power	sound/soc/snd-soc-core	EXPORT_SYMBOL_GPL	
++0x5828c7ec	snd_dmaengine_pcm_set_config_from_dai_data	sound/core/snd-pcm-dmaengine	EXPORT_SYMBOL_GPL	
++0x37f599a0	videobuf_vmalloc_free	drivers/media/v4l2-core/videobuf-vmalloc	EXPORT_SYMBOL_GPL	
++0x3753bfe4	bt_sock_link	net/bluetooth/bluetooth	EXPORT_SYMBOL	
++0x6968d089	xt_register_target	net/netfilter/x_tables	EXPORT_SYMBOL	
++0x0e53cb27	devm_sigmadsp_init_i2c	sound/soc/codecs/snd-soc-sigmadsp-i2c	EXPORT_SYMBOL_GPL	
++0xaf156616	ata_sas_async_probe	drivers/ata/libata	EXPORT_SYMBOL_GPL	
++0xeecfab93	v4l2_async_notifier_add_devname_subdev	drivers/media/v4l2-core/videodev	EXPORT_SYMBOL_GPL	
++0xc7815d6a	drm_of_lvds_get_dual_link_pixel_order	drivers/gpu/drm/drm	EXPORT_SYMBOL_GPL	
++0x7091c477	drm_any_plane_has_format	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0x511205a2	drm_connector_register	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0x8bcfe0c0	nfc_remove_se	net/nfc/nfc	EXPORT_SYMBOL	
++0x120ebf67	ip_vs_proto_data_get	net/netfilter/ipvs/ip_vs	EXPORT_SYMBOL	
++0x0f625162	nf_nat_inet_register_fn	net/netfilter/nf_nat	EXPORT_SYMBOL_GPL	
++0xeca6f6ae	dvb_unregister_device	drivers/media/dvb-core/dvb-core	EXPORT_SYMBOL	
++0x883b3db9	rndis_command	drivers/net/usb/rndis_host	EXPORT_SYMBOL_GPL	
++0x9ca49dc9	drm_bridge_hpd_enable	drivers/gpu/drm/drm	EXPORT_SYMBOL_GPL	
++0x0a8d3ba2	btmrvl_process_event	drivers/bluetooth/btmrvl	EXPORT_SYMBOL_GPL	
++0x4557b425	dm_bitset_test_bit	drivers/md/persistent-data/dm-persistent-data	EXPORT_SYMBOL_GPL	
++0x75fe31db	i2400m_post_reset	drivers/net/wimax/i2400m/i2400m	EXPORT_SYMBOL_GPL	
++0x6d7aad4c	drm_connector_has_possible_encoder	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0x6366bb34	drm_atomic_helper_wait_for_fences	drivers/gpu/drm/drm_kms_helper	EXPORT_SYMBOL	
++0xc9ce496a	nfc_se_connectivity	net/nfc/nfc	EXPORT_SYMBOL	
++0xce9f1c69	wiphy_apply_custom_regulatory	net/wireless/cfg80211	EXPORT_SYMBOL	
++0x6ead8899	dm_table_get_md	drivers/md/dm-mod	EXPORT_SYMBOL	
++0x8bf102db	cx24113_agc_callback	drivers/media/dvb-frontends/cx24113	EXPORT_SYMBOL	
++0x182e73aa	rtl92c_fill_h2c_cmd	drivers/net/wireless/realtek/rtlwifi/rtl8192c/rtl8192c-common	EXPORT_SYMBOL	
++0x0504a180	brcmu_pktq_init	drivers/net/wireless/broadcom/brcm80211/brcmutil/brcmutil	EXPORT_SYMBOL	
++0x1b88a6c6	ct_sip_parse_header_uri	net/netfilter/nf_conntrack_sip	EXPORT_SYMBOL_GPL	
++0x800f76b0	gameport_set_phys	drivers/input/gameport/gameport	EXPORT_SYMBOL	
++0x209909d3	drm_dp_mst_dump_topology	drivers/gpu/drm/drm_kms_helper	EXPORT_SYMBOL	
++0x1d63448e	tpm_pm_suspend	drivers/char/tpm/tpm	EXPORT_SYMBOL_GPL	
++0x97b66534	vsock_add_pending	net/vmw_vsock/vsock	EXPORT_SYMBOL_GPL	
++0x8f2168ed	vsock_remove_sock	net/vmw_vsock/vsock	EXPORT_SYMBOL_GPL	
++0x16244fe5	v4l2_prio_check	drivers/media/v4l2-core/videodev	EXPORT_SYMBOL	
++0x70388867	ocfs2_kset	fs/ocfs2/ocfs2_stackglue	EXPORT_SYMBOL_GPL	
++0x7baf9630	nf_ct_expect_alloc	net/netfilter/nf_conntrack	EXPORT_SYMBOL_GPL	
++0x390f9bb0	wm8804_pm	sound/soc/codecs/snd-soc-wm8804	EXPORT_SYMBOL_GPL	
++0xb0eb638c	lgdt3306a_attach	drivers/media/dvb-frontends/lgdt3306a	EXPORT_SYMBOL	
++0x63ea6ba0	ath9k_hw_intrpend	drivers/net/wireless/ath/ath9k/ath9k_hw	EXPORT_SYMBOL	
++0x4c0766b3	drm_fb_helper_deferred_io	drivers/gpu/drm/drm_kms_helper	EXPORT_SYMBOL	
++0x539c24d5	drm_kms_helper_poll_init	drivers/gpu/drm/drm_kms_helper	EXPORT_SYMBOL	
++0x6b2c0b5e	tpm_chip_start	drivers/char/tpm/tpm	EXPORT_SYMBOL_GPL	
++0xef2cf4ed	arizona_init_spk	sound/soc/codecs/snd-soc-arizona	EXPORT_SYMBOL_GPL	
++0xc9ac5391	fbtft_write_reg16_bus16	drivers/staging/fbtft/fbtft	EXPORT_SYMBOL	
++0x267546af	cx24120_attach	drivers/media/dvb-frontends/cx24120	EXPORT_SYMBOL	
++0x6e122b3b	can_rx_offload_irq_offload_fifo	drivers/net/can/dev/can-dev	EXPORT_SYMBOL_GPL	
++0x3b6cfafa	p54_init_common	drivers/net/wireless/intersil/p54/p54common	EXPORT_SYMBOL_GPL	
++0x1a7b55b9	drm_calc_timestamping_constants	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0xebe4602b	drm_fb_helper_cfb_imageblit	drivers/gpu/drm/drm_kms_helper	EXPORT_SYMBOL	
++0x1b89c6ee	o2hb_fill_node_map	fs/ocfs2/cluster/ocfs2_nodemanager	EXPORT_SYMBOL_GPL	
++0xc5196999	ocfs2_dlm_unlock	fs/ocfs2/ocfs2_stackglue	EXPORT_SYMBOL_GPL	
++0xc3cdd0b4	snd_soc_dapm_sync_unlocked	sound/soc/snd-soc-core	EXPORT_SYMBOL_GPL	
++0xeb37a723	snd_timer_global_free	sound/core/snd-timer	EXPORT_SYMBOL	
++0xe818b32b	ata_bmdma_interrupt	drivers/ata/libata	EXPORT_SYMBOL_GPL	
++0xa0011457	vchiq_mmal_component_finalise	drivers/staging/vc04_services/vchiq-mmal/bcm2835-mmal-vchiq	EXPORT_SYMBOL_GPL	
++0x76e51d40	smscore_register_client	drivers/media/common/siano/smsmdtv	EXPORT_SYMBOL_GPL	
++0xc4e18a47	usb_ftdi_elan_edset_flush	drivers/usb/misc/ftdi-elan	EXPORT_SYMBOL_GPL	
++0x279be432	ZSTD_copyCCtx	lib/zstd/zstd_compress	EXPORT_SYMBOL	
++0xef371e73	cfg80211_rx_control_port	net/wireless/cfg80211	EXPORT_SYMBOL	
++0xd04445b1	usbip_alloc_iso_desc_pdu	drivers/usb/usbip/usbip-core	EXPORT_SYMBOL_GPL	
++0x87243fc3	__nf_ct_expect_find	net/netfilter/nf_conntrack	EXPORT_SYMBOL_GPL	
++0x62689211	garp_init_applicant	net/802/garp	EXPORT_SYMBOL_GPL	
++0x6687db3a	fbtft_read_spi	drivers/staging/fbtft/fbtft	EXPORT_SYMBOL	
++0xab6c68ac	fsg_config_from_params	drivers/usb/gadget/function/usb_f_mass_storage	EXPORT_SYMBOL_GPL	
++0xaee8c48d	usbnet_generic_cdc_bind	drivers/net/usb/cdc_ether	EXPORT_SYMBOL_GPL	
++0x6adbd1b5	drm_atomic_helper_commit_tail	drivers/gpu/drm/drm_kms_helper	EXPORT_SYMBOL	
++0xd8e09da4	ieee80211_set_key_rx_seq	net/mac80211/mac80211	EXPORT_SYMBOL_GPL	
++0xfef779fa	xt_find_jump_offset	net/netfilter/x_tables	EXPORT_SYMBOL	
++0x95f0bcca	dev_attr_em_message	drivers/ata/libata	EXPORT_SYMBOL_GPL	
++0x2f09dd36	media_entity_find_link	drivers/media/mc/mc	EXPORT_SYMBOL_GPL	
++0xc33a1f97	media_create_pad_links	drivers/media/mc/mc	EXPORT_SYMBOL_GPL	
++0xb335982f	tm6000_register_extension	drivers/media/usb/tm6000/tm6000	EXPORT_SYMBOL	
++0x2933ee1d	fsg_ss_bulk_in_desc	drivers/usb/gadget/function/usb_f_mass_storage	EXPORT_SYMBOL_GPL	
++0x95cffb3e	fsg_hs_bulk_in_desc	drivers/usb/gadget/function/usb_f_mass_storage	EXPORT_SYMBOL_GPL	
++0xb54d0d95	fsg_fs_bulk_in_desc	drivers/usb/gadget/function/usb_f_mass_storage	EXPORT_SYMBOL_GPL	
++0x6335268b	mt76_sta_state	drivers/net/wireless/mediatek/mt76/mt76	EXPORT_SYMBOL_GPL	
++0x18014b28	ipv6_dev_find	net/ipv6/ipv6	EXPORT_SYMBOL	
++0xe783a484	ipv6_chk_addr_and_flags	net/ipv6/ipv6	EXPORT_SYMBOL	
++0xda1a6864	snd_fasync_helper	sound/core/snd	EXPORT_SYMBOL_GPL	
++0x4403a9c3	drm_mode_get_hv_timing	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0x4457c9c4	nf_ct_bridge_register	net/netfilter/nf_conntrack	EXPORT_SYMBOL_GPL	
++0x706e2063	md_flush_request	drivers/md/md-mod	EXPORT_SYMBOL	
++0x8cf36cf2	dvb_ringbuffer_free	drivers/media/dvb-core/dvb-core	EXPORT_SYMBOL	
++0xd4b8061f	dvb_dmxdev_init	drivers/media/dvb-core/dvb-core	EXPORT_SYMBOL	
++0xc35edd3f	mt76_tx_status_skb_add	drivers/net/wireless/mediatek/mt76/mt76	EXPORT_SYMBOL_GPL	
++0x021f3700	poly1305_core_blocks	lib/crypto/libpoly1305	EXPORT_SYMBOL	
++0x6b006143	btbcm_read_pcm_int_params	drivers/bluetooth/btbcm	EXPORT_SYMBOL_GPL	
++0x009d9d3c	ubi_is_mapped	drivers/mtd/ubi/ubi	EXPORT_SYMBOL_GPL	
++0xebbd70c9	fbtft_write_buf_dc	drivers/staging/fbtft/fbtft	EXPORT_SYMBOL	
++0xa0442e44	v4l2_subdev_alloc_pad_config	drivers/media/v4l2-core/videodev	EXPORT_SYMBOL_GPL	
++0xe3f5f571	drm_atomic_get_old_bridge_state	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0xcec122d7	chacha_crypt_generic	lib/crypto/libchacha	EXPORT_SYMBOL	
++0x57732e13	ata_bmdma_port_ops	drivers/ata/libata	EXPORT_SYMBOL_GPL	
++0xc5cf1892	ata_host_alloc	drivers/ata/libata	EXPORT_SYMBOL_GPL	
++0xfc781c47	__media_entity_enum_init	drivers/media/mc/mc	EXPORT_SYMBOL_GPL	
++0x51f241e1	rtl_is_special_data	drivers/net/wireless/realtek/rtlwifi/rtlwifi	EXPORT_SYMBOL_GPL	
++0xc1444946	ax25cmp	net/ax25/ax25	EXPORT_SYMBOL	
++0x1bfa58d0	snd_soc_dapm_mux_update_power	sound/soc/snd-soc-core	EXPORT_SYMBOL_GPL	
++0xc9fd634a	usb_role_switch_put	drivers/usb/roles/roles	EXPORT_SYMBOL_GPL	
++0xb5a77c5c	rt2800_mcu_request	drivers/net/wireless/ralink/rt2x00/rt2800lib	EXPORT_SYMBOL_GPL	
++0xf97f7d13	mt76_pci_disable_aspm	drivers/net/wireless/mediatek/mt76/mt76	EXPORT_SYMBOL_GPL	
++0xd2bee524	iscsi_conn_bind	drivers/scsi/libiscsi	EXPORT_SYMBOL_GPL	
++0x2c296cf8	drm_vblank_work_schedule	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0xfe9f72f3	drm_display_mode_to_videomode	drivers/gpu/drm/drm	EXPORT_SYMBOL_GPL	
++0xf689ad25	drm_dp_downstream_420_passthrough	drivers/gpu/drm/drm_kms_helper	EXPORT_SYMBOL	
++0xfb52fe13	asoc_simple_shutdown	sound/soc/generic/snd-soc-simple-card-utils	EXPORT_SYMBOL_GPL	
++0x5c89e0d8	snd_ctl_free_one	sound/core/snd	EXPORT_SYMBOL	
++0xfd189eef	spk_get_var	drivers/accessibility/speakup/speakup	EXPORT_SYMBOL_GPL	
++0x534bc4a6	spk_ttyio_synth_probe	drivers/accessibility/speakup/speakup	EXPORT_SYMBOL_GPL	
++0xfe9dfb20	v4l2_fh_open	drivers/media/v4l2-core/videodev	EXPORT_SYMBOL_GPL	
++0xf696a4db	go7007_register_encoder	drivers/media/usb/go7007/go7007	EXPORT_SYMBOL	
++0xaa4045f1	unregister_candev	drivers/net/can/dev/can-dev	EXPORT_SYMBOL_GPL	
++0x5b25dd7b	dlm_print_one_lock	fs/ocfs2/dlm/ocfs2_dlm	EXPORT_SYMBOL_GPL	
++0xefe4f679	ZSTD_CCtxWorkspaceBound	lib/zstd/zstd_compress	EXPORT_SYMBOL	
++0xb87457e2	__ieee80211_schedule_txq	net/mac80211/mac80211	EXPORT_SYMBOL	
++0x74b159f2	cfg80211_del_sta_sinfo	net/wireless/cfg80211	EXPORT_SYMBOL	
++0x6a178150	inet_diag_msg_attrs_fill	net/ipv4/inet_diag	EXPORT_SYMBOL_GPL	
++0x3f41188a	nf_ct_helper_expectfn_register	net/netfilter/nf_conntrack	EXPORT_SYMBOL_GPL	
++0x87987b90	vhost_log_access_ok	drivers/vhost/vhost	EXPORT_SYMBOL_GPL	
++0x7ec5c410	videobuf_stop	drivers/media/v4l2-core/videobuf-core	EXPORT_SYMBOL_GPL	
++0x552b822b	_rtl92c_phy_bb8192c_config_parafile	drivers/net/wireless/realtek/rtlwifi/rtl8192c/rtl8192c-common	EXPORT_SYMBOL	
++0xdbe6bce3	snd_soc_dapm_force_bias_level	sound/soc/snd-soc-core	EXPORT_SYMBOL_GPL	
++0xa83588eb	dm_rh_recovery_end	drivers/md/dm-region-hash	EXPORT_SYMBOL_GPL	
++0x7cc4f83c	mt76_get_survey	drivers/net/wireless/mediatek/mt76/mt76	EXPORT_SYMBOL_GPL	
++0xef7e6bee	drm_connector_init	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0xb83c850d	__v4l2_ctrl_modify_range	drivers/media/v4l2-core/videodev	EXPORT_SYMBOL	
++0x4734d527	v4l2_device_put	drivers/media/v4l2-core/videodev	EXPORT_SYMBOL_GPL	
++0xea770240	cx231xx_send_usb_command	drivers/media/usb/cx231xx/cx231xx	EXPORT_SYMBOL_GPL	
++0x10b2ccf9	ieee80211_get_channel_khz	net/wireless/cfg80211	EXPORT_SYMBOL	
++0x7a0943ae	__serio_register_driver	drivers/input/serio/serio	EXPORT_SYMBOL	
++0xbf77355b	gserial_suspend	drivers/usb/gadget/function/u_serial	EXPORT_SYMBOL_GPL	
++0x1959bb7c	mt76x02u_tx_prepare_skb	drivers/net/wireless/mediatek/mt76/mt76x02-usb	EXPORT_SYMBOL_GPL	
++0x43d68cac	ath_gen_timer_isr	drivers/net/wireless/ath/ath9k/ath9k_hw	EXPORT_SYMBOL	
++0x378d597a	cfg80211_rx_assoc_resp	net/wireless/cfg80211	EXPORT_SYMBOL	
++0xb9638db4	snd_pcm_rate_to_rate_bit	sound/core/snd-pcm	EXPORT_SYMBOL	
++0xc4a0e590	br_multicast_has_querier_anywhere	net/bridge/bridge	EXPORT_SYMBOL_GPL	
++0xc9c29637	arizona_mixer_tlv	sound/soc/codecs/snd-soc-arizona	EXPORT_SYMBOL_GPL	
++0x1544b397	snd_pcm_set_managed_buffer	sound/core/snd-pcm	EXPORT_SYMBOL	
++0x66011ab6	ubi_get_device_info	drivers/mtd/ubi/ubi	EXPORT_SYMBOL_GPL	
++0x9886af36	v4l2_async_notifier_init	drivers/media/v4l2-core/videodev	EXPORT_SYMBOL	
++0xb6d8a040	rndis_unbind	drivers/net/usb/rndis_host	EXPORT_SYMBOL_GPL	
++0xaab2164d	mt76x0_chip_onoff	drivers/net/wireless/mediatek/mt76/mt76x0/mt76x0-common	EXPORT_SYMBOL_GPL	
++0x107742a9	drm_get_subpixel_order_name	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0x0712e21d	drm_edid_get_monitor_name	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0x2f38cc26	drm_gem_lock_reservations	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0x9939eba0	backlight_unregister_notifier	drivers/video/backlight/backlight	EXPORT_SYMBOL	
++0x25a60185	vb2_queue_release	drivers/media/common/videobuf2/videobuf2-v4l2	EXPORT_SYMBOL_GPL	
++0xac53a91b	charlcd_unregister	drivers/auxdisplay/charlcd	EXPORT_SYMBOL_GPL	
++0x596a445e	drm_mode_put_tile_group	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0x0012b0c9	tpm_chip_register	drivers/char/tpm/tpm	EXPORT_SYMBOL_GPL	
++0xf39f5240	poly1305_final_arch	arch/arm64/crypto/poly1305-neon	EXPORT_SYMBOL	
++0x9bdffc40	lowpan_unregister_netdevice	net/6lowpan/6lowpan	EXPORT_SYMBOL	
++0x2c026f04	cfg80211_rx_unexpected_4addr_frame	net/wireless/cfg80211	EXPORT_SYMBOL	
++0x4cfa5e70	ip6_tnl_rcv	net/ipv6/ip6_tunnel	EXPORT_SYMBOL	
++0x68238e01	ipv6_chk_addr	net/ipv6/ipv6	EXPORT_SYMBOL	
++0x47f5eab7	nf_tproxy_laddr6	net/ipv6/netfilter/nf_tproxy_ipv6	EXPORT_SYMBOL_GPL	
++0x85165db9	v4l2_ctrl_g_ctrl_int64	drivers/media/v4l2-core/videodev	EXPORT_SYMBOL	
++0x6df09373	vb2_vmalloc_memops	drivers/media/common/videobuf2/videobuf2-vmalloc	EXPORT_SYMBOL_GPL	
++0xa879427b	rtl_p2p_info	drivers/net/wireless/realtek/rtlwifi/rtlwifi	EXPORT_SYMBOL_GPL	
++0x38747e4f	rpisense_block_write	drivers/mfd/rpisense-core	EXPORT_SYMBOL_GPL	
++0x0e6a3d2d	nf_connlabels_get	net/netfilter/nf_conntrack	EXPORT_SYMBOL_GPL	
++0xacc955e2	mtd_read_fact_prot_reg	drivers/mtd/mtd	EXPORT_SYMBOL_GPL	
++0x3bb271d5	ata_bmdma_qc_issue	drivers/ata/libata	EXPORT_SYMBOL_GPL	
++0xf92b8a3d	dm_rh_get_region_size	drivers/md/dm-region-hash	EXPORT_SYMBOL_GPL	
++0x9441b862	dib7000m_pid_filter	drivers/media/dvb-frontends/dib7000m	EXPORT_SYMBOL	
++0x88fec1ee	dvb_usbv2_suspend	drivers/media/usb/dvb-usb-v2/dvb_usb_v2	EXPORT_SYMBOL	
++0x8e8878ab	rndis_set_param_dev	drivers/usb/gadget/function/usb_f_rndis	EXPORT_SYMBOL_GPL	
++0xacc4f4ef	snd_soc_jack_get_type	sound/soc/snd-soc-core	EXPORT_SYMBOL_GPL	
++0x8ba4948d	snd_soc_of_get_dai_link_codecs	sound/soc/snd-soc-core	EXPORT_SYMBOL_GPL	
++0x1feed02b	btintel_hw_error	drivers/bluetooth/btintel	EXPORT_SYMBOL_GPL	
++0x9a49ff14	cfg80211_michael_mic_failure	net/wireless/cfg80211	EXPORT_SYMBOL	
++0x8ff65c5e	udp_sock_create4	net/ipv4/udp_tunnel	EXPORT_SYMBOL	
++0xb4325ded	ipt_do_table	net/ipv4/netfilter/ip_tables	EXPORT_SYMBOL	
++0x05b41aee	snd_soc_dai_compr_get_params	sound/soc/snd-soc-core	EXPORT_SYMBOL_GPL	
++0x6500991e	snd_soc_dai_compr_set_params	sound/soc/snd-soc-core	EXPORT_SYMBOL_GPL	
++0xe934da1d	snd_seq_dump_var_event	sound/core/seq/snd-seq	EXPORT_SYMBOL	
++0x9312faff	v4l2_m2m_ioctl_try_decoder_cmd	drivers/media/v4l2-core/v4l2-mem2mem	EXPORT_SYMBOL_GPL	
++0xe3011961	vb2_ioctl_reqbufs	drivers/media/common/videobuf2/videobuf2-v4l2	EXPORT_SYMBOL_GPL	
++0xb5f3c795	snd_hwparams_to_dma_slave_config	sound/core/snd-pcm-dmaengine	EXPORT_SYMBOL_GPL	
++0x6f7dcff4	rtl_bb_delay	drivers/net/wireless/realtek/rtlwifi/rtlwifi	EXPORT_SYMBOL	
++0x29c9dd31	ath6kl_core_rx_complete	drivers/net/wireless/ath/ath6kl/ath6kl_core	EXPORT_SYMBOL	
++0xe2f3aa5b	ath6kl_core_tx_complete	drivers/net/wireless/ath/ath6kl/ath6kl_core	EXPORT_SYMBOL	
++0xfe0753e8	drm_mode_object_find	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0xb0b05ff5	drm_clflush_sg	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0x6376ab94	nf_connlabels_replace	net/netfilter/nf_conntrack	EXPORT_SYMBOL_GPL	
++0x89783bda	dm_array_cursor_end	drivers/md/persistent-data/dm-persistent-data	EXPORT_SYMBOL_GPL	
++0x68a686b2	ath9k_cmn_process_rssi	drivers/net/wireless/ath/ath9k/ath9k_common	EXPORT_SYMBOL	
++0xab625391	spi_bitbang_init	drivers/spi/spi-bitbang	EXPORT_SYMBOL_GPL	
++0x715a5a37	drm_atomic_helper_plane_destroy_state	drivers/gpu/drm/drm_kms_helper	EXPORT_SYMBOL	
++0x9f767858	nfc_alloc_recv_skb	net/nfc/nfc	EXPORT_SYMBOL	
++0x5917b682	cfg80211_reg_can_beacon	net/wireless/cfg80211	EXPORT_SYMBOL	
++0xa281c383	ip_tunnel_ctl	net/ipv4/ip_tunnel	EXPORT_SYMBOL_GPL	
++0xed1be28e	r5c_journal_mode_set	drivers/md/raid456	EXPORT_SYMBOL	
++0x1ab369d0	rndis_rm_hdr	drivers/usb/gadget/function/usb_f_rndis	EXPORT_SYMBOL_GPL	
++0x52e3e4a5	snd_pcm_hw_param_value	sound/core/snd-pcm	EXPORT_SYMBOL	
++0x998594cc	mt76x02_phy_set_bw	drivers/net/wireless/mediatek/mt76/mt76x02-lib	EXPORT_SYMBOL_GPL	
++0x216f027b	drm_sched_start	drivers/gpu/drm/scheduler/gpu-sched	EXPORT_SYMBOL	
++0x9b522c6b	drm_panel_get_modes	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0x2ceb0720	__drm_atomic_helper_private_obj_duplicate_state	drivers/gpu/drm/drm_kms_helper	EXPORT_SYMBOL	
++0xa233d943	nf_nat_follow_master	net/netfilter/nf_nat	EXPORT_SYMBOL	
++0x3bb0194c	iio_channel_release_all	drivers/iio/industrialio	EXPORT_SYMBOL_GPL	
++0xf8f3a0fb	ata_ratelimit	drivers/ata/libata	EXPORT_SYMBOL_GPL	
++0x660ef4d6	drm_modeset_lock_single_interruptible	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0xaadaa853	ocfs2_stack_glue_register	fs/ocfs2/ocfs2_stackglue	EXPORT_SYMBOL_GPL	
++0x6c1ae7e5	fuse_dev_release	fs/fuse/fuse	EXPORT_SYMBOL_GPL	
++0x6174d9b5	p9_client_symlink	net/9p/9pnet	EXPORT_SYMBOL	
++0x3061c52d	snd_use_lock_sync_helper	sound/core/seq/snd-seq	EXPORT_SYMBOL	
++0x07d6f165	snd_jack_new	sound/core/snd	EXPORT_SYMBOL	
++0xd96a2a20	ieee80211_get_unsol_bcast_probe_resp_tmpl	net/mac80211/mac80211	EXPORT_SYMBOL	
++0x772b0638	lib80211_crypt_delayed_deinit	net/wireless/lib80211	EXPORT_SYMBOL	
++0xa490a6a1	nft_obj_lookup	net/netfilter/nf_tables	EXPORT_SYMBOL_GPL	
++0x6ba9d4c9	snd_dmaengine_pcm_unregister	sound/soc/snd-soc-core	EXPORT_SYMBOL_GPL	
++0x152432e9	snd_soc_dapm_nc_pin_unlocked	sound/soc/snd-soc-core	EXPORT_SYMBOL_GPL	
++0xe8fec0eb	rdev_clear_badblocks	drivers/md/md-mod	EXPORT_SYMBOL_GPL	
++0x0bc497fc	mt76x02u_exit_beacon_config	drivers/net/wireless/mediatek/mt76/mt76x02-usb	EXPORT_SYMBOL_GPL	
++0xa8d91888	mwifiex_prepare_fw_dump_info	drivers/net/wireless/marvell/mwifiex/mwifiex	EXPORT_SYMBOL_GPL	
++0x0f50c159	to_drm_sched_fence	drivers/gpu/drm/scheduler/gpu-sched	EXPORT_SYMBOL	
++0x816fa207	drm_self_refresh_helper_cleanup	drivers/gpu/drm/drm_kms_helper	EXPORT_SYMBOL	
++0x57d2591e	xt_register_targets	net/netfilter/x_tables	EXPORT_SYMBOL	
++0x2e9178f8	mt76_set_channel	drivers/net/wireless/mediatek/mt76/mt76	EXPORT_SYMBOL_GPL	
++0xabec9cbc	snd_timer_pause	sound/core/snd-timer	EXPORT_SYMBOL	
++0xc68839fc	vhost_chr_poll	drivers/vhost/vhost	EXPORT_SYMBOL	
++0x7890d535	dm_cache_policy_get_name	drivers/md/dm-cache	EXPORT_SYMBOL_GPL	
++0xeda9cf7a	dib9000_attach	drivers/media/dvb-frontends/dib9000	EXPORT_SYMBOL	
++0xde49b371	dib8000_attach	drivers/media/dvb-frontends/dib8000	EXPORT_SYMBOL	
++0xe9d00980	mt76x02_conf_tx	drivers/net/wireless/mediatek/mt76/mt76x02-lib	EXPORT_SYMBOL_GPL	
++0x5b6c00e6	xor_blocks	crypto/xor	EXPORT_SYMBOL	
++0x7384ef6f	af_alg_free_resources	crypto/af_alg	EXPORT_SYMBOL_GPL	
++0xda220b76	cfg80211_bss_flush	net/wireless/cfg80211	EXPORT_SYMBOL	
++0x756f1752	nf_nat_pptp_hook_outbound	net/netfilter/nf_conntrack_pptp	EXPORT_SYMBOL_GPL	
++0xbfd96c36	free_candev	drivers/net/can/dev/can-dev	EXPORT_SYMBOL_GPL	
++0x29f078d1	drm_mode_legacy_fb_format	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0x1c3214a0	_rtl_dbg_print_data	drivers/net/wireless/realtek/rtlwifi/rtlwifi	EXPORT_SYMBOL_GPL	
++0x38246d2a	drm_atomic_get_private_obj_state	drivers/gpu/drm/drm	EXPORT_SYMBOL	
++0xae268524	drm_dp_mst_topology_state_funcs	drivers/gpu/drm/drm_kms_helper	EXPORT_SYMBOL	
++0xed622195	udp6_seq_ops	net/ipv6/ipv6	EXPORT_SYMBOL	
++0xb0785872	flow_offload_free	net/netfilter/nf_flow_table	EXPORT_SYMBOL_GPL	
++0xbbcc4984	nat_t120_hook	net/netfilter/nf_conntrack_h323	EXPORT_SYMBOL_GPL	
++0x265ab1c2	arizona_in_vi_ramp	sound/soc/codecs/snd-soc-arizona	EXPORT_SYMBOL_GPL	
++0x478dd002	arizona_in_vd_ramp	sound/soc/codecs/snd-soc-arizona	EXPORT_SYMBOL_GPL	
++0xb8f23e9d	vchiq_mmal_component_enable	drivers/staging/vc04_services/vchiq-mmal/bcm2835-mmal-vchiq	EXPORT_SYMBOL_GPL	
++0x6e1e3821	dm_array_walk	drivers/md/persistent-data/dm-persistent-data	EXPORT_SYMBOL_GPL	
++0x4f4d78c5	LZ4_compress_default	lib/lz4/lz4_compress	EXPORT_SYMBOL	
++0x887cb765	inet_sk_diag_fill	net/ipv4/inet_diag	EXPORT_SYMBOL_GPL	
++0xf38951bb	arpt_unregister_table	net/ipv4/netfilter/arp_tables	EXPORT_SYMBOL	
++0xc7395434	stv0367ddb_attach	drivers/media/dvb-frontends/stv0367	EXPORT_SYMBOL	
++0xb1066175	stv0367cab_attach	drivers/media/dvb-frontends/stv0367	EXPORT_SYMBOL	
++0xbfd7e1e6	stv0367ter_attach	drivers/media/dvb-frontends/stv0367	EXPORT_SYMBOL	
++0xd4e288db	rc_map_af9005_table_size	drivers/media/usb/dvb-usb/dvb-usb-af9005-remote	EXPORT_SYMBOL	
++0x21a04699	gether_setup_name_default	drivers/usb/gadget/function/u_ether	EXPORT_SYMBOL_GPL	
diff --git a/arch/Kconfig b/arch/Kconfig
index f6d455c5a897..aa0ea1c2f046 100644
--- a/arch/Kconfig
+++ b/arch/Kconfig
@@ -50,6 +50,7 @@ config OPROFILE
 	tristate "OProfile system profiling"
 	depends on PROFILING
 	depends on HAVE_OPROFILE
+	depends on !PREEMPT_RT
 	select RING_BUFFER
 	select RING_BUFFER_ALLOW_SWAP
 	help
@@ -683,6 +684,12 @@ config HAVE_TIF_NOHZ
 config HAVE_VIRT_CPU_ACCOUNTING
 	bool
 
+config HAVE_VIRT_CPU_ACCOUNTING_IDLE
+	bool
+	help
+	  Architecture has its own way to account idle CPU time and therefore
+	  doesn't implement vtime_account_idle().
+
 config ARCH_HAS_SCALED_CPUTIME
 	bool
 
@@ -697,7 +704,6 @@ config HAVE_VIRT_CPU_ACCOUNTING_GEN
 	  some 32-bit arches may require multiple accesses, so proper
 	  locking is needed to protect against concurrent accesses.
 
-
 config HAVE_IRQ_TIME_ACCOUNTING
 	bool
 	help
diff --git a/arch/alpha/include/asm/kmap_types.h b/arch/alpha/include/asm/kmap_types.h
deleted file mode 100644
index 651714b45729..000000000000
--- a/arch/alpha/include/asm/kmap_types.h
+++ /dev/null
@@ -1,15 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-#ifndef _ASM_KMAP_TYPES_H
-#define _ASM_KMAP_TYPES_H
-
-/* Dummy header just to define km_type. */
-
-#ifdef CONFIG_DEBUG_HIGHMEM
-#define  __WITH_KM_FENCE
-#endif
-
-#include <asm-generic/kmap_types.h>
-
-#undef __WITH_KM_FENCE
-
-#endif
diff --git a/arch/alpha/include/asm/spinlock_types.h b/arch/alpha/include/asm/spinlock_types.h
index 1d5716bc060b..6883bc952d22 100644
--- a/arch/alpha/include/asm/spinlock_types.h
+++ b/arch/alpha/include/asm/spinlock_types.h
@@ -2,10 +2,6 @@
 #ifndef _ALPHA_SPINLOCK_TYPES_H
 #define _ALPHA_SPINLOCK_TYPES_H
 
-#ifndef __LINUX_SPINLOCK_TYPES_H
-# error "please don't include this file directly"
-#endif
-
 typedef struct {
 	volatile unsigned int lock;
 } arch_spinlock_t;
diff --git a/arch/arc/Kconfig b/arch/arc/Kconfig
index 0a89cc9def65..d8804001d550 100644
--- a/arch/arc/Kconfig
+++ b/arch/arc/Kconfig
@@ -507,6 +507,7 @@ config LINUX_RAM_BASE
 config HIGHMEM
 	bool "High Memory Support"
 	select ARCH_DISCONTIGMEM_ENABLE
+	select KMAP_LOCAL
 	help
 	  With ARC 2G:2G address split, only upper 2G is directly addressable by
 	  kernel. Enable this to potentially allow access to rest of 2G and PAE
diff --git a/arch/arc/include/asm/highmem.h b/arch/arc/include/asm/highmem.h
index 6e5eafb3afdd..a6b8e2c352c4 100644
--- a/arch/arc/include/asm/highmem.h
+++ b/arch/arc/include/asm/highmem.h
@@ -9,17 +9,29 @@
 #ifdef CONFIG_HIGHMEM
 
 #include <uapi/asm/page.h>
-#include <asm/kmap_types.h>
+#include <asm/kmap_size.h>
+
+#define FIXMAP_SIZE		PGDIR_SIZE
+#define PKMAP_SIZE		PGDIR_SIZE
 
 /* start after vmalloc area */
 #define FIXMAP_BASE		(PAGE_OFFSET - FIXMAP_SIZE - PKMAP_SIZE)
-#define FIXMAP_SIZE		PGDIR_SIZE	/* only 1 PGD worth */
-#define KM_TYPE_NR		((FIXMAP_SIZE >> PAGE_SHIFT)/NR_CPUS)
-#define FIXMAP_ADDR(nr)		(FIXMAP_BASE + ((nr) << PAGE_SHIFT))
+
+#define FIX_KMAP_SLOTS		(KM_MAX_IDX * NR_CPUS)
+#define FIX_KMAP_BEGIN		(0UL)
+#define FIX_KMAP_END		((FIX_KMAP_BEGIN + FIX_KMAP_SLOTS) - 1)
+
+#define FIXADDR_TOP		(FIXMAP_BASE + (FIX_KMAP_END << PAGE_SHIFT))
+
+/*
+ * This should be converted to the asm-generic version, but of course this
+ * is needlessly different from all other architectures. Sigh - tglx
+ */
+#define __fix_to_virt(x)	(FIXADDR_TOP - ((x) << PAGE_SHIFT))
+#define __virt_to_fix(x)	(((FIXADDR_TOP - ((x) & PAGE_MASK))) >> PAGE_SHIFT)
 
 /* start after fixmap area */
 #define PKMAP_BASE		(FIXMAP_BASE + FIXMAP_SIZE)
-#define PKMAP_SIZE		PGDIR_SIZE
 #define LAST_PKMAP		(PKMAP_SIZE >> PAGE_SHIFT)
 #define LAST_PKMAP_MASK		(LAST_PKMAP - 1)
 #define PKMAP_ADDR(nr)		(PKMAP_BASE + ((nr) << PAGE_SHIFT))
@@ -29,11 +41,13 @@
 
 extern void kmap_init(void);
 
+#define arch_kmap_local_post_unmap(vaddr)			\
+	local_flush_tlb_kernel_range(vaddr, vaddr + PAGE_SIZE)
+
 static inline void flush_cache_kmaps(void)
 {
 	flush_cache_all();
 }
-
 #endif
 
 #endif
diff --git a/arch/arc/include/asm/kmap_types.h b/arch/arc/include/asm/kmap_types.h
deleted file mode 100644
index fecf7851ec32..000000000000
--- a/arch/arc/include/asm/kmap_types.h
+++ /dev/null
@@ -1,14 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0-only */
-/*
- * Copyright (C) 2015 Synopsys, Inc. (www.synopsys.com)
- */
-
-#ifndef _ASM_KMAP_TYPES_H
-#define _ASM_KMAP_TYPES_H
-
-/*
- * We primarily need to define KM_TYPE_NR here but that in turn
- * is a function of PGDIR_SIZE etc.
- * To avoid circular deps issue, put everything in asm/highmem.h
- */
-#endif
diff --git a/arch/arc/mm/highmem.c b/arch/arc/mm/highmem.c
index 1b9f473c6369..c79912a6b196 100644
--- a/arch/arc/mm/highmem.c
+++ b/arch/arc/mm/highmem.c
@@ -36,9 +36,8 @@
  *   This means each only has 1 PGDIR_SIZE worth of kvaddr mappings, which means
  *   2M of kvaddr space for typical config (8K page and 11:8:13 traversal split)
  *
- * - fixmap anyhow needs a limited number of mappings. So 2M kvaddr == 256 PTE
- *   slots across NR_CPUS would be more than sufficient (generic code defines
- *   KM_TYPE_NR as 20).
+ * - The fixed KMAP slots for kmap_local/atomic() require KM_MAX_IDX slots per
+ *   CPU. So the number of CPUs sharing a single PTE page is limited.
  *
  * - pkmap being preemptible, in theory could do with more than 256 concurrent
  *   mappings. However, generic pkmap code: map_new_virtual(), doesn't traverse
@@ -47,48 +46,6 @@
  */
 
 extern pte_t * pkmap_page_table;
-static pte_t * fixmap_page_table;
-
-void *kmap_atomic_high_prot(struct page *page, pgprot_t prot)
-{
-	int idx, cpu_idx;
-	unsigned long vaddr;
-
-	cpu_idx = kmap_atomic_idx_push();
-	idx = cpu_idx + KM_TYPE_NR * smp_processor_id();
-	vaddr = FIXMAP_ADDR(idx);
-
-	set_pte_at(&init_mm, vaddr, fixmap_page_table + idx,
-		   mk_pte(page, prot));
-
-	return (void *)vaddr;
-}
-EXPORT_SYMBOL(kmap_atomic_high_prot);
-
-void kunmap_atomic_high(void *kv)
-{
-	unsigned long kvaddr = (unsigned long)kv;
-
-	if (kvaddr >= FIXMAP_BASE && kvaddr < (FIXMAP_BASE + FIXMAP_SIZE)) {
-
-		/*
-		 * Because preemption is disabled, this vaddr can be associated
-		 * with the current allocated index.
-		 * But in case of multiple live kmap_atomic(), it still relies on
-		 * callers to unmap in right order.
-		 */
-		int cpu_idx = kmap_atomic_idx();
-		int idx = cpu_idx + KM_TYPE_NR * smp_processor_id();
-
-		WARN_ON(kvaddr != FIXMAP_ADDR(idx));
-
-		pte_clear(&init_mm, kvaddr, fixmap_page_table + idx);
-		local_flush_tlb_kernel_range(kvaddr, kvaddr + PAGE_SIZE);
-
-		kmap_atomic_idx_pop();
-	}
-}
-EXPORT_SYMBOL(kunmap_atomic_high);
 
 static noinline pte_t * __init alloc_kmap_pgtable(unsigned long kvaddr)
 {
@@ -108,10 +65,9 @@ void __init kmap_init(void)
 {
 	/* Due to recursive include hell, we can't do this in processor.h */
 	BUILD_BUG_ON(PAGE_OFFSET < (VMALLOC_END + FIXMAP_SIZE + PKMAP_SIZE));
+	BUILD_BUG_ON(LAST_PKMAP > PTRS_PER_PTE);
+	BUILD_BUG_ON(FIX_KMAP_SLOTS > PTRS_PER_PTE);
 
-	BUILD_BUG_ON(KM_TYPE_NR > PTRS_PER_PTE);
 	pkmap_page_table = alloc_kmap_pgtable(PKMAP_BASE);
-
-	BUILD_BUG_ON(LAST_PKMAP > PTRS_PER_PTE);
-	fixmap_page_table = alloc_kmap_pgtable(FIXMAP_BASE);
+	alloc_kmap_pgtable(FIXMAP_BASE);
 }
diff --git a/arch/arm/Kconfig b/arch/arm/Kconfig
index 9096aa34e482..9457b01b63ef 100644
--- a/arch/arm/Kconfig
+++ b/arch/arm/Kconfig
@@ -31,6 +31,7 @@ config ARM
 	select ARCH_OPTIONAL_KERNEL_RWX if ARCH_HAS_STRICT_KERNEL_RWX
 	select ARCH_OPTIONAL_KERNEL_RWX_DEFAULT if CPU_V7
 	select ARCH_SUPPORTS_ATOMIC_RMW
+	select ARCH_SUPPORTS_RT if HAVE_POSIX_CPU_TIMERS_TASK_WORK
 	select ARCH_USE_BUILTIN_BSWAP
 	select ARCH_USE_CMPXCHG_LOCKREF
 	select ARCH_WANT_DEFAULT_TOPDOWN_MMAP_LAYOUT if MMU
@@ -66,7 +67,7 @@ config ARM
 	select HARDIRQS_SW_RESEND
 	select HAVE_ARCH_AUDITSYSCALL if AEABI && !OABI_COMPAT
 	select HAVE_ARCH_BITREVERSE if (CPU_32v7M || CPU_32v7) && !CPU_32v6
-	select HAVE_ARCH_JUMP_LABEL if !XIP_KERNEL && !CPU_ENDIAN_BE32 && MMU
+	select HAVE_ARCH_JUMP_LABEL if !XIP_KERNEL && !CPU_ENDIAN_BE32 && MMU && !PREEMPT_RT
 	select HAVE_ARCH_KFENCE if MMU
 	select HAVE_ARCH_KGDB if !CPU_ENDIAN_BE32 && MMU
 	select HAVE_ARCH_KASAN if MMU && !XIP_KERNEL
@@ -109,6 +110,7 @@ config ARM
 	select HAVE_PERF_EVENTS
 	select HAVE_PERF_REGS
 	select HAVE_PERF_USER_STACK_DUMP
+	select HAVE_PREEMPT_LAZY
 	select MMU_GATHER_RCU_TABLE_FREE if SMP && ARM_LPAE
 	select HAVE_REGS_AND_STACK_ACCESS_API
 	select HAVE_RSEQ
@@ -124,6 +126,7 @@ config ARM
 	select OLD_SIGSUSPEND3
 	select PCI_SYSCALL if PCI
 	select PERF_USE_VMALLOC
+	select HAVE_POSIX_CPU_TIMERS_TASK_WORK if !KVM
 	select RTC_LIB
 	select SET_FS
 	select SYS_SUPPORTS_APM_EMULATION
@@ -1509,6 +1512,7 @@ config HAVE_ARCH_PFN_VALID
 config HIGHMEM
 	bool "High Memory Support"
 	depends on MMU
+	select KMAP_LOCAL
 	help
 	  The address space of ARM processors is only 4 Gigabytes large
 	  and it has to accommodate user address space, kernel address
diff --git a/arch/arm/include/asm/fixmap.h b/arch/arm/include/asm/fixmap.h
index 9575b404019c..707068f852c2 100644
--- a/arch/arm/include/asm/fixmap.h
+++ b/arch/arm/include/asm/fixmap.h
@@ -7,14 +7,14 @@
 #define FIXADDR_TOP		(FIXADDR_END - PAGE_SIZE)
 
 #include <linux/pgtable.h>
-#include <asm/kmap_types.h>
+#include <asm/kmap_size.h>
 
 enum fixed_addresses {
 	FIX_EARLYCON_MEM_BASE,
 	__end_of_permanent_fixed_addresses,
 
 	FIX_KMAP_BEGIN = __end_of_permanent_fixed_addresses,
-	FIX_KMAP_END = FIX_KMAP_BEGIN + (KM_TYPE_NR * NR_CPUS) - 1,
+	FIX_KMAP_END = FIX_KMAP_BEGIN + (KM_MAX_IDX * NR_CPUS) - 1,
 
 	/* Support writing RO kernel text via kprobes, jump labels, etc. */
 	FIX_TEXT_POKE0,
diff --git a/arch/arm/include/asm/hardirq.h b/arch/arm/include/asm/hardirq.h
index b95848ed2bc7..706efafbf972 100644
--- a/arch/arm/include/asm/hardirq.h
+++ b/arch/arm/include/asm/hardirq.h
@@ -2,16 +2,11 @@
 #ifndef __ASM_HARDIRQ_H
 #define __ASM_HARDIRQ_H
 
-#include <linux/cache.h>
-#include <linux/threads.h>
 #include <asm/irq.h>
 
-typedef struct {
-	unsigned int __softirq_pending;
-} ____cacheline_aligned irq_cpustat_t;
-
-#include <linux/irq_cpustat.h>	/* Standard mappings for irq_cpustat_t above */
-
 #define __ARCH_IRQ_EXIT_IRQS_DISABLED	1
+#define ack_bad_irq ack_bad_irq
+
+#include <asm-generic/hardirq.h>
 
 #endif /* __ASM_HARDIRQ_H */
diff --git a/arch/arm/include/asm/highmem.h b/arch/arm/include/asm/highmem.h
index 31811be38d78..b22dffa8c7eb 100644
--- a/arch/arm/include/asm/highmem.h
+++ b/arch/arm/include/asm/highmem.h
@@ -2,7 +2,8 @@
 #ifndef _ASM_HIGHMEM_H
 #define _ASM_HIGHMEM_H
 
-#include <asm/kmap_types.h>
+#include <asm/kmap_size.h>
+#include <asm/fixmap.h>
 
 #define PKMAP_BASE		(PAGE_OFFSET - PMD_SIZE)
 #define LAST_PKMAP		PTRS_PER_PTE
@@ -46,19 +47,32 @@ extern pte_t *pkmap_page_table;
 
 #ifdef ARCH_NEEDS_KMAP_HIGH_GET
 extern void *kmap_high_get(struct page *page);
-#else
+
+static inline void *arch_kmap_local_high_get(struct page *page)
+{
+	if (IS_ENABLED(CONFIG_DEBUG_HIGHMEM) && !cache_is_vivt())
+		return NULL;
+	return kmap_high_get(page);
+}
+#define arch_kmap_local_high_get arch_kmap_local_high_get
+
+#else /* ARCH_NEEDS_KMAP_HIGH_GET */
 static inline void *kmap_high_get(struct page *page)
 {
 	return NULL;
 }
-#endif
+#endif /* !ARCH_NEEDS_KMAP_HIGH_GET */
 
-/*
- * The following functions are already defined by <linux/highmem.h>
- * when CONFIG_HIGHMEM is not set.
- */
-#ifdef CONFIG_HIGHMEM
-extern void *kmap_atomic_pfn(unsigned long pfn);
-#endif
+#define arch_kmap_local_post_map(vaddr, pteval)				\
+	local_flush_tlb_kernel_page(vaddr)
+
+#define arch_kmap_local_pre_unmap(vaddr)				\
+do {									\
+	if (cache_is_vivt())						\
+		__cpuc_flush_dcache_area((void *)vaddr, PAGE_SIZE);	\
+} while (0)
+
+#define arch_kmap_local_post_unmap(vaddr)				\
+	local_flush_tlb_kernel_page(vaddr)
 
 #endif
diff --git a/arch/arm/include/asm/irq.h b/arch/arm/include/asm/irq.h
index 54b0180c8aeb..36d040c68163 100644
--- a/arch/arm/include/asm/irq.h
+++ b/arch/arm/include/asm/irq.h
@@ -31,6 +31,8 @@ void handle_IRQ(unsigned int, struct pt_regs *);
 void init_IRQ(void);
 
 #ifdef CONFIG_SMP
+#include <linux/cpumask.h>
+
 extern bool arch_trigger_cpumask_backtrace(const cpumask_t *mask,
 					   bool exclude_self);
 #define arch_trigger_cpumask_backtrace arch_trigger_cpumask_backtrace
diff --git a/arch/arm/include/asm/kmap_types.h b/arch/arm/include/asm/kmap_types.h
deleted file mode 100644
index 5590940ee43d..000000000000
--- a/arch/arm/include/asm/kmap_types.h
+++ /dev/null
@@ -1,10 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-#ifndef __ARM_KMAP_TYPES_H
-#define __ARM_KMAP_TYPES_H
-
-/*
- * This is the "bare minimum".  AIO seems to require this.
- */
-#define KM_TYPE_NR 16
-
-#endif
diff --git a/arch/arm/include/asm/spinlock_types.h b/arch/arm/include/asm/spinlock_types.h
index 5976958647fe..a37c0803954b 100644
--- a/arch/arm/include/asm/spinlock_types.h
+++ b/arch/arm/include/asm/spinlock_types.h
@@ -2,10 +2,6 @@
 #ifndef __ASM_SPINLOCK_TYPES_H
 #define __ASM_SPINLOCK_TYPES_H
 
-#ifndef __LINUX_SPINLOCK_TYPES_H
-# error "please don't include this file directly"
-#endif
-
 #define TICKET_SHIFT	16
 
 typedef struct {
diff --git a/arch/arm/include/asm/thread_info.h b/arch/arm/include/asm/thread_info.h
index 9f7ca79cc76a..0bf67b7f09c0 100644
--- a/arch/arm/include/asm/thread_info.h
+++ b/arch/arm/include/asm/thread_info.h
@@ -55,6 +55,7 @@ struct cpu_context_save {
 struct thread_info {
 	unsigned long		flags;		/* low level flags */
 	int			preempt_count;	/* 0 => preemptable, <0 => bug */
+	int			preempt_lazy_count; /* 0 => preemptable, <0 => bug */
 	mm_segment_t		addr_limit;	/* address limit */
 	struct task_struct	*task;		/* main task structure */
 	__u32			cpu;		/* cpu */
@@ -145,8 +146,9 @@ extern int vfp_restore_user_hwstate(struct user_vfp *,
 #define TIF_SYSCALL_TRACE	4	/* syscall trace active */
 #define TIF_SYSCALL_AUDIT	5	/* syscall auditing active */
 #define TIF_SYSCALL_TRACEPOINT	6	/* syscall tracepoint instrumentation */
-#define TIF_SECCOMP		7	/* seccomp syscall filtering active */
-#define TIF_PATCH_PENDING	8	/* pending live patching update */
+#define TIF_NEED_RESCHED_LAZY	7
+#define TIF_SECCOMP		8	/* seccomp syscall filtering active */
+#define TIF_PATCH_PENDING	9	/* pending live patching update */
 
 #define TIF_USING_IWMMXT	17
 #define TIF_MEMDIE		18	/* is terminating due to OOM killer */
@@ -155,6 +157,7 @@ extern int vfp_restore_user_hwstate(struct user_vfp *,
 #define _TIF_SIGPENDING		(1 << TIF_SIGPENDING)
 #define _TIF_NEED_RESCHED	(1 << TIF_NEED_RESCHED)
 #define _TIF_NOTIFY_RESUME	(1 << TIF_NOTIFY_RESUME)
+#define _TIF_NEED_RESCHED_LAZY	(1 << TIF_NEED_RESCHED_LAZY)
 #define _TIF_UPROBE		(1 << TIF_UPROBE)
 #define _TIF_SYSCALL_TRACE	(1 << TIF_SYSCALL_TRACE)
 #define _TIF_SYSCALL_AUDIT	(1 << TIF_SYSCALL_AUDIT)
@@ -171,7 +174,8 @@ extern int vfp_restore_user_hwstate(struct user_vfp *,
  * Change these and you break ASM code in entry-common.S
  */
 #define _TIF_WORK_MASK		(_TIF_NEED_RESCHED | _TIF_SIGPENDING | \
-				 _TIF_NOTIFY_RESUME | _TIF_UPROBE)
+				 _TIF_NOTIFY_RESUME | _TIF_UPROBE | \
+				 _TIF_NEED_RESCHED_LAZY)
 
 #endif /* __KERNEL__ */
 #endif /* __ASM_ARM_THREAD_INFO_H */
diff --git a/arch/arm/kernel/asm-offsets.c b/arch/arm/kernel/asm-offsets.c
index 70993af22d80..024c65c3a0f2 100644
--- a/arch/arm/kernel/asm-offsets.c
+++ b/arch/arm/kernel/asm-offsets.c
@@ -43,6 +43,7 @@ int main(void)
   BLANK();
   DEFINE(TI_FLAGS,		offsetof(struct thread_info, flags));
   DEFINE(TI_PREEMPT,		offsetof(struct thread_info, preempt_count));
+  DEFINE(TI_PREEMPT_LAZY,	offsetof(struct thread_info, preempt_lazy_count));
   DEFINE(TI_ADDR_LIMIT,		offsetof(struct thread_info, addr_limit));
   DEFINE(TI_TASK,		offsetof(struct thread_info, task));
   DEFINE(TI_CPU,		offsetof(struct thread_info, cpu));
diff --git a/arch/arm/kernel/entry-armv.S b/arch/arm/kernel/entry-armv.S
index 4332e5950042..efb2d0755ce7 100644
--- a/arch/arm/kernel/entry-armv.S
+++ b/arch/arm/kernel/entry-armv.S
@@ -207,11 +207,18 @@ __irq_svc:
 
 #ifdef CONFIG_PREEMPTION
 	ldr	r8, [tsk, #TI_PREEMPT]		@ get preempt count
-	ldr	r0, [tsk, #TI_FLAGS]		@ get flags
 	teq	r8, #0				@ if preempt count != 0
+	bne	1f				@ return from exeption
+	ldr	r0, [tsk, #TI_FLAGS]		@ get flags
+	tst	r0, #_TIF_NEED_RESCHED		@ if NEED_RESCHED is set
+	blne	svc_preempt			@ preempt!
+
+	ldr	r8, [tsk, #TI_PREEMPT_LAZY]	@ get preempt lazy count
+	teq	r8, #0				@ if preempt lazy count != 0
 	movne	r0, #0				@ force flags to 0
-	tst	r0, #_TIF_NEED_RESCHED
+	tst	r0, #_TIF_NEED_RESCHED_LAZY
 	blne	svc_preempt
+1:
 #endif
 
 	svc_exit r5, irq = 1			@ return from exception
@@ -226,8 +233,14 @@ svc_preempt:
 1:	bl	preempt_schedule_irq		@ irq en/disable is done inside
 	ldr	r0, [tsk, #TI_FLAGS]		@ get new tasks TI_FLAGS
 	tst	r0, #_TIF_NEED_RESCHED
+	bne	1b
+	tst	r0, #_TIF_NEED_RESCHED_LAZY
 	reteq	r8				@ go again
-	b	1b
+	ldr	r0, [tsk, #TI_PREEMPT_LAZY]	@ get preempt lazy count
+	teq	r0, #0				@ if preempt lazy count != 0
+	beq	1b
+	ret	r8				@ go again
+
 #endif
 
 __und_fault:
diff --git a/arch/arm/kernel/entry-common.S b/arch/arm/kernel/entry-common.S
index 7a2e63dfb4d9..02fae4a70c8c 100644
--- a/arch/arm/kernel/entry-common.S
+++ b/arch/arm/kernel/entry-common.S
@@ -54,7 +54,9 @@ __ret_fast_syscall:
 	cmp	r2, r1
 	blne	addr_limit_check_failed
 	ldr	r1, [tsk, #TI_FLAGS]		@ re-check for syscall tracing
-	tst	r1, #_TIF_SYSCALL_WORK | _TIF_WORK_MASK
+	tst	r1, #((_TIF_SYSCALL_WORK | _TIF_WORK_MASK) & ~_TIF_SECCOMP)
+	bne	fast_work_pending
+	tst	r1, #_TIF_SECCOMP
 	bne	fast_work_pending
 
 
@@ -92,8 +94,11 @@ __ret_fast_syscall:
 	cmp     r2, r1
 	blne	addr_limit_check_failed
 	ldr	r1, [tsk, #TI_FLAGS]		@ re-check for syscall tracing
-	tst	r1, #_TIF_SYSCALL_WORK | _TIF_WORK_MASK
+	tst	r1, #((_TIF_SYSCALL_WORK | _TIF_WORK_MASK) & ~_TIF_SECCOMP)
+	bne	do_slower_path
+	tst	r1, #_TIF_SECCOMP
 	beq	no_work_pending
+do_slower_path:
  UNWIND(.fnend		)
 ENDPROC(ret_fast_syscall)
 
diff --git a/arch/arm/kernel/signal.c b/arch/arm/kernel/signal.c
index 2f81d3af5f9a..6e69f7b3d581 100644
--- a/arch/arm/kernel/signal.c
+++ b/arch/arm/kernel/signal.c
@@ -649,7 +649,8 @@ do_work_pending(struct pt_regs *regs, unsigned int thread_flags, int syscall)
 	 */
 	trace_hardirqs_off();
 	do {
-		if (likely(thread_flags & _TIF_NEED_RESCHED)) {
+		if (likely(thread_flags & (_TIF_NEED_RESCHED |
+					   _TIF_NEED_RESCHED_LAZY))) {
 			schedule();
 		} else {
 			if (unlikely(!user_mode(regs)))
diff --git a/arch/arm/kernel/smp.c b/arch/arm/kernel/smp.c
index d94e39a21698..44383bfbf98b 100644
--- a/arch/arm/kernel/smp.c
+++ b/arch/arm/kernel/smp.c
@@ -671,9 +671,7 @@ static void do_handle_IPI(int ipinr)
 		break;
 
 	case IPI_CPU_BACKTRACE:
-		printk_nmi_enter();
 		nmi_cpu_backtrace(get_irq_regs());
-		printk_nmi_exit();
 		break;
 
 	default:
diff --git a/arch/arm/mm/Makefile b/arch/arm/mm/Makefile
index 4536159bc8fa..3510503bc5e6 100644
--- a/arch/arm/mm/Makefile
+++ b/arch/arm/mm/Makefile
@@ -21,7 +21,6 @@ KASAN_SANITIZE_physaddr.o	:= n
 obj-$(CONFIG_DEBUG_VIRTUAL)	+= physaddr.o
 
 obj-$(CONFIG_ALIGNMENT_TRAP)	+= alignment.o
-obj-$(CONFIG_HIGHMEM)		+= highmem.o
 obj-$(CONFIG_HUGETLB_PAGE)	+= hugetlbpage.o
 obj-$(CONFIG_ARM_PV_FIXUP)	+= pv-fixup-asm.o
 
diff --git a/arch/arm/mm/cache-feroceon-l2.c b/arch/arm/mm/cache-feroceon-l2.c
index 10f909744d5e..fd9e3e740b3d 100644
--- a/arch/arm/mm/cache-feroceon-l2.c
+++ b/arch/arm/mm/cache-feroceon-l2.c
@@ -49,9 +49,9 @@ static inline unsigned long l2_get_va(unsigned long paddr)
 	 * we simply install a virtual mapping for it only for the
 	 * TLB lookup to occur, hence no need to flush the untouched
 	 * memory mapping afterwards (note: a cache flush may happen
-	 * in some circumstances depending on the path taken in kunmap_atomic).
+	 * in some circumstances depending on the path taken in kunmap_local).
 	 */
-	void *vaddr = kmap_atomic_pfn(paddr >> PAGE_SHIFT);
+	void *vaddr = kmap_local_pfn(paddr >> PAGE_SHIFT);
 	return (unsigned long)vaddr + (paddr & ~PAGE_MASK);
 #else
 	return __phys_to_virt(paddr);
@@ -61,7 +61,7 @@ static inline unsigned long l2_get_va(unsigned long paddr)
 static inline void l2_put_va(unsigned long vaddr)
 {
 #ifdef CONFIG_HIGHMEM
-	kunmap_atomic((void *)vaddr);
+	kunmap_local((void *)vaddr);
 #endif
 }
 
diff --git a/arch/arm/mm/cache-xsc3l2.c b/arch/arm/mm/cache-xsc3l2.c
index 5814731653d9..f34845da3522 100644
--- a/arch/arm/mm/cache-xsc3l2.c
+++ b/arch/arm/mm/cache-xsc3l2.c
@@ -59,7 +59,7 @@ static inline void l2_unmap_va(unsigned long va)
 {
 #ifdef CONFIG_HIGHMEM
 	if (va != -1)
-		kunmap_atomic((void *)va);
+		kunmap_local((void *)va);
 #endif
 }
 
@@ -75,7 +75,7 @@ static inline unsigned long l2_map_va(unsigned long pa, unsigned long prev_va)
 		 * in place for it.
 		 */
 		l2_unmap_va(prev_va);
-		va = (unsigned long)kmap_atomic_pfn(pa >> PAGE_SHIFT);
+		va = (unsigned long)kmap_local_pfn(pa >> PAGE_SHIFT);
 	}
 	return va + (pa_offset >> (32 - PAGE_SHIFT));
 #else
diff --git a/arch/arm/mm/fault.c b/arch/arm/mm/fault.c
index 91965fb043de..d34166682b7f 100644
--- a/arch/arm/mm/fault.c
+++ b/arch/arm/mm/fault.c
@@ -430,6 +430,9 @@ do_translation_fault(unsigned long addr, unsigned int fsr,
 	if (addr < TASK_SIZE)
 		return do_page_fault(addr, fsr, regs);
 
+	if (interrupts_enabled(regs))
+		local_irq_enable();
+
 	if (user_mode(regs))
 		goto bad_area;
 
diff --git a/arch/arm/mm/highmem.c b/arch/arm/mm/highmem.c
deleted file mode 100644
index 187fab227b50..000000000000
--- a/arch/arm/mm/highmem.c
+++ /dev/null
@@ -1,121 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0-only
-/*
- * arch/arm/mm/highmem.c -- ARM highmem support
- *
- * Author:	Nicolas Pitre
- * Created:	september 8, 2008
- * Copyright:	Marvell Semiconductors Inc.
- */
-
-#include <linux/module.h>
-#include <linux/highmem.h>
-#include <linux/interrupt.h>
-#include <asm/fixmap.h>
-#include <asm/cacheflush.h>
-#include <asm/tlbflush.h>
-#include "mm.h"
-
-static inline void set_fixmap_pte(int idx, pte_t pte)
-{
-	unsigned long vaddr = __fix_to_virt(idx);
-	pte_t *ptep = virt_to_kpte(vaddr);
-
-	set_pte_ext(ptep, pte, 0);
-	local_flush_tlb_kernel_page(vaddr);
-}
-
-static inline pte_t get_fixmap_pte(unsigned long vaddr)
-{
-	pte_t *ptep = virt_to_kpte(vaddr);
-
-	return *ptep;
-}
-
-void *kmap_atomic_high_prot(struct page *page, pgprot_t prot)
-{
-	unsigned int idx;
-	unsigned long vaddr;
-	void *kmap;
-	int type;
-
-#ifdef CONFIG_DEBUG_HIGHMEM
-	/*
-	 * There is no cache coherency issue when non VIVT, so force the
-	 * dedicated kmap usage for better debugging purposes in that case.
-	 */
-	if (!cache_is_vivt())
-		kmap = NULL;
-	else
-#endif
-		kmap = kmap_high_get(page);
-	if (kmap)
-		return kmap;
-
-	type = kmap_atomic_idx_push();
-
-	idx = FIX_KMAP_BEGIN + type + KM_TYPE_NR * smp_processor_id();
-	vaddr = __fix_to_virt(idx);
-#ifdef CONFIG_DEBUG_HIGHMEM
-	/*
-	 * With debugging enabled, kunmap_atomic forces that entry to 0.
-	 * Make sure it was indeed properly unmapped.
-	 */
-	BUG_ON(!pte_none(get_fixmap_pte(vaddr)));
-#endif
-	/*
-	 * When debugging is off, kunmap_atomic leaves the previous mapping
-	 * in place, so the contained TLB flush ensures the TLB is updated
-	 * with the new mapping.
-	 */
-	set_fixmap_pte(idx, mk_pte(page, prot));
-
-	return (void *)vaddr;
-}
-EXPORT_SYMBOL(kmap_atomic_high_prot);
-
-void kunmap_atomic_high(void *kvaddr)
-{
-	unsigned long vaddr = (unsigned long) kvaddr & PAGE_MASK;
-	int idx, type;
-
-	if (kvaddr >= (void *)FIXADDR_START) {
-		type = kmap_atomic_idx();
-		idx = FIX_KMAP_BEGIN + type + KM_TYPE_NR * smp_processor_id();
-
-		if (cache_is_vivt())
-			__cpuc_flush_dcache_area((void *)vaddr, PAGE_SIZE);
-#ifdef CONFIG_DEBUG_HIGHMEM
-		BUG_ON(vaddr != __fix_to_virt(idx));
-		set_fixmap_pte(idx, __pte(0));
-#else
-		(void) idx;  /* to kill a warning */
-#endif
-		kmap_atomic_idx_pop();
-	} else if (vaddr >= PKMAP_ADDR(0) && vaddr < PKMAP_ADDR(LAST_PKMAP)) {
-		/* this address was obtained through kmap_high_get() */
-		kunmap_high(pte_page(pkmap_page_table[PKMAP_NR(vaddr)]));
-	}
-}
-EXPORT_SYMBOL(kunmap_atomic_high);
-
-void *kmap_atomic_pfn(unsigned long pfn)
-{
-	unsigned long vaddr;
-	int idx, type;
-	struct page *page = pfn_to_page(pfn);
-
-	preempt_disable();
-	pagefault_disable();
-	if (!PageHighMem(page))
-		return page_address(page);
-
-	type = kmap_atomic_idx_push();
-	idx = FIX_KMAP_BEGIN + type + KM_TYPE_NR * smp_processor_id();
-	vaddr = __fix_to_virt(idx);
-#ifdef CONFIG_DEBUG_HIGHMEM
-	BUG_ON(!pte_none(get_fixmap_pte(vaddr)));
-#endif
-	set_fixmap_pte(idx, pfn_pte(pfn, kmap_prot));
-
-	return (void *)vaddr;
-}
diff --git a/arch/arm64/Kconfig b/arch/arm64/Kconfig
index a0bba8e5426a..65437236a00f 100644
--- a/arch/arm64/Kconfig
+++ b/arch/arm64/Kconfig
@@ -78,6 +78,7 @@ config ARM64
 	select ARCH_SUPPORTS_ATOMIC_RMW
 	select ARCH_SUPPORTS_INT128 if CC_HAS_INT128 && (GCC_VERSION >= 50000 || CC_IS_CLANG)
 	select ARCH_SUPPORTS_NUMA_BALANCING
+	select ARCH_SUPPORTS_RT if HAVE_POSIX_CPU_TIMERS_TASK_WORK
 	select ARCH_WANT_COMPAT_IPC_PARSE_VERSION if COMPAT
 	select ARCH_WANT_DEFAULT_BPF_JIT
 	select ARCH_WANT_DEFAULT_TOPDOWN_MMAP_LAYOUT
@@ -182,6 +183,7 @@ config ARM64
 	select HAVE_PERF_EVENTS
 	select HAVE_PERF_REGS
 	select HAVE_PERF_USER_STACK_DUMP
+	select HAVE_PREEMPT_LAZY
 	select HAVE_REGS_AND_STACK_ACCESS_API
 	select HAVE_FUNCTION_ARG_ACCESS_API
 	select HAVE_FUTEX_CMPXCHG if FUTEX
@@ -205,6 +207,7 @@ config ARM64
 	select PCI_DOMAINS_GENERIC if PCI
 	select PCI_ECAM if (ACPI && PCI)
 	select PCI_SYSCALL if PCI
+	select HAVE_POSIX_CPU_TIMERS_TASK_WORK if !KVM	
 	select POWER_RESET
 	select POWER_SUPPLY
 	select SPARSE_IRQ
diff --git a/arch/arm64/include/asm/hardirq.h b/arch/arm64/include/asm/hardirq.h
index 5ffa4bacdad3..cbfa7b6f2e09 100644
--- a/arch/arm64/include/asm/hardirq.h
+++ b/arch/arm64/include/asm/hardirq.h
@@ -13,11 +13,8 @@
 #include <asm/kvm_arm.h>
 #include <asm/sysreg.h>
 
-typedef struct {
-	unsigned int __softirq_pending;
-} ____cacheline_aligned irq_cpustat_t;
-
-#include <linux/irq_cpustat.h>	/* Standard mappings for irq_cpustat_t above */
+#define ack_bad_irq ack_bad_irq
+#include <asm-generic/hardirq.h>
 
 #define __ARCH_IRQ_EXIT_IRQS_DISABLED	1
 
diff --git a/arch/arm64/include/asm/preempt.h b/arch/arm64/include/asm/preempt.h
index e83f0982b99c..7a5770d825b9 100644
--- a/arch/arm64/include/asm/preempt.h
+++ b/arch/arm64/include/asm/preempt.h
@@ -70,17 +70,43 @@ static inline bool __preempt_count_dec_and_test(void)
 	 * interrupt occurring between the non-atomic READ_ONCE/WRITE_ONCE
 	 * pair.
 	 */
-	return !pc || !READ_ONCE(ti->preempt_count);
+	if (!pc || !READ_ONCE(ti->preempt_count))
+		return true;
+#ifdef CONFIG_PREEMPT_LAZY
+	if ((pc & ~PREEMPT_NEED_RESCHED))
+		return false;
+	if (current_thread_info()->preempt_lazy_count)
+		return false;
+	return test_thread_flag(TIF_NEED_RESCHED_LAZY);
+#else
+	return false;
+#endif
 }
 
 static inline bool should_resched(int preempt_offset)
 {
+#ifdef CONFIG_PREEMPT_LAZY
+	u64 pc = READ_ONCE(current_thread_info()->preempt_count);
+	if (pc == preempt_offset)
+		return true;
+
+	if ((pc & ~PREEMPT_NEED_RESCHED) != preempt_offset)
+		return false;
+
+	if (current_thread_info()->preempt_lazy_count)
+		return false;
+	return test_thread_flag(TIF_NEED_RESCHED_LAZY);
+#else
 	u64 pc = READ_ONCE(current_thread_info()->preempt_count);
 	return pc == preempt_offset;
+#endif
 }
 
 #ifdef CONFIG_PREEMPTION
 void preempt_schedule(void);
+#ifdef CONFIG_PREEMPT_RT
+void preempt_schedule_lock(void);
+#endif
 #define __preempt_schedule() preempt_schedule()
 void preempt_schedule_notrace(void);
 #define __preempt_schedule_notrace() preempt_schedule_notrace()
diff --git a/arch/arm64/include/asm/spinlock_types.h b/arch/arm64/include/asm/spinlock_types.h
index 18782f0c4721..6672b05350b4 100644
--- a/arch/arm64/include/asm/spinlock_types.h
+++ b/arch/arm64/include/asm/spinlock_types.h
@@ -5,10 +5,6 @@
 #ifndef __ASM_SPINLOCK_TYPES_H
 #define __ASM_SPINLOCK_TYPES_H
 
-#if !defined(__LINUX_SPINLOCK_TYPES_H) && !defined(__ASM_SPINLOCK_H)
-# error "please don't include this file directly"
-#endif
-
 #include <asm-generic/qspinlock_types.h>
 #include <asm-generic/qrwlock_types.h>
 
diff --git a/arch/arm64/include/asm/thread_info.h b/arch/arm64/include/asm/thread_info.h
index af49b6190aee..f8ba7a6ec79d 100644
--- a/arch/arm64/include/asm/thread_info.h
+++ b/arch/arm64/include/asm/thread_info.h
@@ -27,6 +27,7 @@ struct thread_info {
 #ifdef CONFIG_ARM64_SW_TTBR0_PAN
 	u64			ttbr0;		/* saved TTBR0_EL1 */
 #endif
+	int			preempt_lazy_count;	/* 0 => preemptable, <0 => bug */
 	union {
 		u64		preempt_count;	/* 0 => preemptible, <0 => bug */
 		struct {
@@ -69,6 +70,7 @@ void arch_release_task_struct(struct task_struct *tsk);
 #define TIF_FOREIGN_FPSTATE	3	/* CPU's FP state is not current's */
 #define TIF_UPROBE		4	/* uprobe breakpoint or singlestep */
 #define TIF_MTE_ASYNC_FAULT	5	/* MTE Asynchronous Tag Check Fault */
+#define TIF_NEED_RESCHED_LAZY	6
 #define TIF_SYSCALL_TRACE	8	/* syscall trace active */
 #define TIF_SYSCALL_AUDIT	9	/* syscall auditing */
 #define TIF_SYSCALL_TRACEPOINT	10	/* syscall tracepoint for ftrace */
@@ -101,14 +103,17 @@ void arch_release_task_struct(struct task_struct *tsk);
 #define _TIF_32BIT		(1 << TIF_32BIT)
 #define _TIF_SVE		(1 << TIF_SVE)
 #define _TIF_MTE_ASYNC_FAULT	(1 << TIF_MTE_ASYNC_FAULT)
+#define _TIF_NEED_RESCHED_LAZY	(1 << TIF_NEED_RESCHED_LAZY)
 #define _TIF_32BIT_AARCH64	(1 << TIF_32BIT_AARCH64)
 #define _TIF_PATCH_PENDING	(1 << TIF_PATCH_PENDING)
 #define _TIF_POLLING_NRFLAG	(1 << TIF_POLLING_NRFLAG)
 
 #define _TIF_WORK_MASK		(_TIF_NEED_RESCHED | _TIF_SIGPENDING | \
 				 _TIF_NOTIFY_RESUME | _TIF_FOREIGN_FPSTATE | \
-				 _TIF_UPROBE | _TIF_MTE_ASYNC_FAULT)
+				 _TIF_UPROBE | _TIF_MTE_ASYNC_FAULT | \
+				 _TIF_NEED_RESCHED_LAZY)
 
+#define _TIF_NEED_RESCHED_MASK	(_TIF_NEED_RESCHED | _TIF_NEED_RESCHED_LAZY)
 #define _TIF_SYSCALL_WORK	(_TIF_SYSCALL_TRACE | _TIF_SYSCALL_AUDIT | \
 				 _TIF_SYSCALL_TRACEPOINT | _TIF_SECCOMP | \
 				 _TIF_SYSCALL_EMU)
diff --git a/arch/arm64/kernel/asm-offsets.c b/arch/arm64/kernel/asm-offsets.c
index 5f59e24c95d3..d8d41b5f905b 100644
--- a/arch/arm64/kernel/asm-offsets.c
+++ b/arch/arm64/kernel/asm-offsets.c
@@ -31,6 +31,7 @@ int main(void)
   DEFINE(TSK_TI_CPU,		offsetof(struct task_struct, thread_info.cpu));
   DEFINE(TSK_TI_FLAGS,		offsetof(struct task_struct, thread_info.flags));
   DEFINE(TSK_TI_PREEMPT,	offsetof(struct task_struct, thread_info.preempt_count));
+  DEFINE(TSK_TI_PREEMPT_LAZY,	offsetof(struct task_struct, thread_info.preempt_lazy_count));  
 #ifdef CONFIG_ARM64_SW_TTBR0_PAN
   DEFINE(TSK_TI_TTBR0,		offsetof(struct task_struct, thread_info.ttbr0));
 #endif
diff --git a/arch/arm64/kernel/entry.S b/arch/arm64/kernel/entry.S
index 64145bfab48f..70abdfd6f138 100644
--- a/arch/arm64/kernel/entry.S
+++ b/arch/arm64/kernel/entry.S
@@ -521,9 +521,18 @@ alternative_if ARM64_HAS_IRQ_PRIO_MASKING
 	orr	x24, x24, x0
 alternative_else_nop_endif
 #endif
-	cbnz	x24, 1f				// preempt count != 0 || NMI return path
-	bl	arm64_preempt_schedule_irq	// irq en/disable is done inside
+
+	cbz     x24, 1f                                 // (need_resched + count) == 0
+	cbnz    w24, 2f                                 // count != 0
+
+	ldr     w24, [tsk, #TSK_TI_PREEMPT_LAZY]        // get preempt lazy count
+	cbnz    w24, 2f                                 // preempt lazy count != 0
+
+	ldr     x0, [tsk, #TSK_TI_FLAGS]                // get flags
+	tbz     x0, #TIF_NEED_RESCHED_LAZY, 2f          // needs rescheduling?
 1:
+	bl      arm64_preempt_schedule_irq              // irq en/disable is done inside
+2:
 #endif
 
 	mov	x0, sp
diff --git a/arch/arm64/kernel/fpsimd.c b/arch/arm64/kernel/fpsimd.c
index 5335a6bd1a0d..aa631771e0dc 100644
--- a/arch/arm64/kernel/fpsimd.c
+++ b/arch/arm64/kernel/fpsimd.c
@@ -180,7 +180,7 @@ static void __get_cpu_fpsimd_context(void)
  */
 static void get_cpu_fpsimd_context(void)
 {
-	local_bh_disable();
+	preempt_disable();
 	__get_cpu_fpsimd_context();
 }
 
@@ -201,7 +201,7 @@ static void __put_cpu_fpsimd_context(void)
 static void put_cpu_fpsimd_context(void)
 {
 	__put_cpu_fpsimd_context();
-	local_bh_enable();
+	preempt_enable();
 }
 
 static bool have_cpu_fpsimd_context(void)
@@ -226,6 +226,16 @@ static void sve_free(struct task_struct *task)
 	__sve_free(task);
 }
 
+static void *sve_free_atomic(struct task_struct *task)
+{
+	void *sve_state = task->thread.sve_state;
+
+	WARN_ON(test_tsk_thread_flag(task, TIF_SVE));
+
+	task->thread.sve_state = NULL;
+	return sve_state;
+}
+
 /*
  * TIF_SVE controls whether a task can use SVE without trapping while
  * in userspace, and also the way a task's FPSIMD/SVE state is stored
@@ -1022,6 +1032,7 @@ void fpsimd_thread_switch(struct task_struct *next)
 void fpsimd_flush_thread(void)
 {
 	int vl, supported_vl;
+	void *mem = NULL;
 
 	if (!system_supports_fpsimd())
 		return;
@@ -1034,7 +1045,7 @@ void fpsimd_flush_thread(void)
 
 	if (system_supports_sve()) {
 		clear_thread_flag(TIF_SVE);
-		sve_free(current);
+		mem = sve_free_atomic(current);
 
 		/*
 		 * Reset the task vector length as required.
@@ -1068,6 +1079,7 @@ void fpsimd_flush_thread(void)
 	}
 
 	put_cpu_fpsimd_context();
+	kfree(mem);
 }
 
 /*
diff --git a/arch/arm64/kernel/ipi_nmi.c b/arch/arm64/kernel/ipi_nmi.c
index 9a8f7c256117..c0753dcdb22a 100644
--- a/arch/arm64/kernel/ipi_nmi.c
+++ b/arch/arm64/kernel/ipi_nmi.c
@@ -35,9 +35,7 @@ void arm64_send_nmi(cpumask_t *mask)
 
 static void ipi_cpu_backtrace(void *info)
 {
-	printk_safe_enter();
 	nmi_cpu_backtrace(get_irq_regs());
-	printk_safe_exit();
 }
 
 static DEFINE_PER_CPU(call_single_data_t, cpu_backtrace_csd) =
diff --git a/arch/arm64/kernel/signal.c b/arch/arm64/kernel/signal.c
index e5e2f1e888a2..c5fd06d5285b 100644
--- a/arch/arm64/kernel/signal.c
+++ b/arch/arm64/kernel/signal.c
@@ -694,7 +694,7 @@ asmlinkage void do_notify_resume(struct pt_regs *regs,
 				 unsigned long thread_flags)
 {
 	do {
-		if (thread_flags & _TIF_NEED_RESCHED) {
+		if (thread_flags & _TIF_NEED_RESCHED_MASK) {
 			/* Unmask Debug and SError for the next task */
 			local_daif_restore(DAIF_PROCCTX_NOIRQ);
 
diff --git a/arch/arm64/kvm/arm.c b/arch/arm64/kvm/arm.c
index 7527ac19332f..7d4b7d6d097d 100644
--- a/arch/arm64/kvm/arm.c
+++ b/arch/arm64/kvm/arm.c
@@ -860,7 +860,7 @@ int kvm_arch_vcpu_ioctl_run(struct kvm_vcpu *vcpu)
 		 * involves poking the GIC, which must be done in a
 		 * non-preemptible context.
 		 */
-		preempt_disable();
+		migrate_disable();
 
 		kvm_pmu_flush_hwstate(vcpu);
 
@@ -884,7 +884,7 @@ int kvm_arch_vcpu_ioctl_run(struct kvm_vcpu *vcpu)
 				kvm_timer_sync_user(vcpu);
 			kvm_vgic_sync_hwstate(vcpu);
 			local_irq_enable();
-			preempt_enable();
+			migrate_enable();
 			continue;
 		}
 
@@ -963,7 +963,7 @@ int kvm_arch_vcpu_ioctl_run(struct kvm_vcpu *vcpu)
 		/* Exit types that need handling before we can be preempted */
 		handle_exit_early(vcpu, ret);
 
-		preempt_enable();
+		migrate_enable();
 
 		/*
 		 * The ARMv8 architecture doesn't give the hypervisor
diff --git a/arch/csky/Kconfig b/arch/csky/Kconfig
index 7bf0a617e94c..c9f2533cc53d 100644
--- a/arch/csky/Kconfig
+++ b/arch/csky/Kconfig
@@ -286,6 +286,7 @@ config NR_CPUS
 config HIGHMEM
 	bool "High Memory Support"
 	depends on !CPU_CK610
+	select KMAP_LOCAL
 	default y
 
 config FORCE_MAX_ZONEORDER
diff --git a/arch/csky/include/asm/fixmap.h b/arch/csky/include/asm/fixmap.h
index 81f9477d5330..4b589cc20900 100644
--- a/arch/csky/include/asm/fixmap.h
+++ b/arch/csky/include/asm/fixmap.h
@@ -8,7 +8,7 @@
 #include <asm/memory.h>
 #ifdef CONFIG_HIGHMEM
 #include <linux/threads.h>
-#include <asm/kmap_types.h>
+#include <asm/kmap_size.h>
 #endif
 
 enum fixed_addresses {
@@ -17,7 +17,7 @@ enum fixed_addresses {
 #endif
 #ifdef CONFIG_HIGHMEM
 	FIX_KMAP_BEGIN,
-	FIX_KMAP_END = FIX_KMAP_BEGIN + (KM_TYPE_NR * NR_CPUS) - 1,
+	FIX_KMAP_END = FIX_KMAP_BEGIN + (KM_MAX_IDX * NR_CPUS) - 1,
 #endif
 	__end_of_fixed_addresses
 };
diff --git a/arch/csky/include/asm/highmem.h b/arch/csky/include/asm/highmem.h
index 14645e3d5cd5..1f4ed3f4c0d9 100644
--- a/arch/csky/include/asm/highmem.h
+++ b/arch/csky/include/asm/highmem.h
@@ -9,7 +9,7 @@
 #include <linux/init.h>
 #include <linux/interrupt.h>
 #include <linux/uaccess.h>
-#include <asm/kmap_types.h>
+#include <asm/kmap_size.h>
 #include <asm/cache.h>
 
 /* undef for production */
@@ -32,10 +32,12 @@ extern pte_t *pkmap_page_table;
 
 #define ARCH_HAS_KMAP_FLUSH_TLB
 extern void kmap_flush_tlb(unsigned long addr);
-extern void *kmap_atomic_pfn(unsigned long pfn);
 
 #define flush_cache_kmaps() do {} while (0)
 
+#define arch_kmap_local_post_map(vaddr, pteval)	kmap_flush_tlb(vaddr)
+#define arch_kmap_local_post_unmap(vaddr)	kmap_flush_tlb(vaddr)
+
 extern void kmap_init(void);
 
 #endif /* __KERNEL__ */
diff --git a/arch/csky/mm/highmem.c b/arch/csky/mm/highmem.c
index 89c10800a002..4161df3c6c15 100644
--- a/arch/csky/mm/highmem.c
+++ b/arch/csky/mm/highmem.c
@@ -9,8 +9,6 @@
 #include <asm/tlbflush.h>
 #include <asm/cacheflush.h>
 
-static pte_t *kmap_pte;
-
 unsigned long highstart_pfn, highend_pfn;
 
 void kmap_flush_tlb(unsigned long addr)
@@ -19,67 +17,7 @@ void kmap_flush_tlb(unsigned long addr)
 }
 EXPORT_SYMBOL(kmap_flush_tlb);
 
-void *kmap_atomic_high_prot(struct page *page, pgprot_t prot)
-{
-	unsigned long vaddr;
-	int idx, type;
-
-	type = kmap_atomic_idx_push();
-	idx = type + KM_TYPE_NR*smp_processor_id();
-	vaddr = __fix_to_virt(FIX_KMAP_BEGIN + idx);
-#ifdef CONFIG_DEBUG_HIGHMEM
-	BUG_ON(!pte_none(*(kmap_pte - idx)));
-#endif
-	set_pte(kmap_pte-idx, mk_pte(page, prot));
-	flush_tlb_one((unsigned long)vaddr);
-
-	return (void *)vaddr;
-}
-EXPORT_SYMBOL(kmap_atomic_high_prot);
-
-void kunmap_atomic_high(void *kvaddr)
-{
-	unsigned long vaddr = (unsigned long) kvaddr & PAGE_MASK;
-	int idx;
-
-	if (vaddr < FIXADDR_START)
-		return;
-
-#ifdef CONFIG_DEBUG_HIGHMEM
-	idx = KM_TYPE_NR*smp_processor_id() + kmap_atomic_idx();
-
-	BUG_ON(vaddr != __fix_to_virt(FIX_KMAP_BEGIN + idx));
-
-	pte_clear(&init_mm, vaddr, kmap_pte - idx);
-	flush_tlb_one(vaddr);
-#else
-	(void) idx; /* to kill a warning */
-#endif
-	kmap_atomic_idx_pop();
-}
-EXPORT_SYMBOL(kunmap_atomic_high);
-
-/*
- * This is the same as kmap_atomic() but can map memory that doesn't
- * have a struct page associated with it.
- */
-void *kmap_atomic_pfn(unsigned long pfn)
-{
-	unsigned long vaddr;
-	int idx, type;
-
-	pagefault_disable();
-
-	type = kmap_atomic_idx_push();
-	idx = type + KM_TYPE_NR*smp_processor_id();
-	vaddr = __fix_to_virt(FIX_KMAP_BEGIN + idx);
-	set_pte(kmap_pte-idx, pfn_pte(pfn, PAGE_KERNEL));
-	flush_tlb_one(vaddr);
-
-	return (void *) vaddr;
-}
-
-static void __init kmap_pages_init(void)
+void __init kmap_init(void)
 {
 	unsigned long vaddr;
 	pgd_t *pgd;
@@ -96,14 +34,3 @@ static void __init kmap_pages_init(void)
 	pte = pte_offset_kernel(pmd, vaddr);
 	pkmap_page_table = pte;
 }
-
-void __init kmap_init(void)
-{
-	unsigned long vaddr;
-
-	kmap_pages_init();
-
-	vaddr = __fix_to_virt(FIX_KMAP_BEGIN);
-
-	kmap_pte = pte_offset_kernel((pmd_t *)pgd_offset_k(vaddr), vaddr);
-}
diff --git a/arch/hexagon/include/asm/spinlock_types.h b/arch/hexagon/include/asm/spinlock_types.h
index 19d233497ba5..de72fb23016d 100644
--- a/arch/hexagon/include/asm/spinlock_types.h
+++ b/arch/hexagon/include/asm/spinlock_types.h
@@ -8,10 +8,6 @@
 #ifndef _ASM_SPINLOCK_TYPES_H
 #define _ASM_SPINLOCK_TYPES_H
 
-#ifndef __LINUX_SPINLOCK_TYPES_H
-# error "please don't include this file directly"
-#endif
-
 typedef struct {
 	volatile unsigned int lock;
 } arch_spinlock_t;
diff --git a/arch/ia64/include/asm/kmap_types.h b/arch/ia64/include/asm/kmap_types.h
deleted file mode 100644
index 5c268cf7c2bd..000000000000
--- a/arch/ia64/include/asm/kmap_types.h
+++ /dev/null
@@ -1,13 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-#ifndef _ASM_IA64_KMAP_TYPES_H
-#define _ASM_IA64_KMAP_TYPES_H
-
-#ifdef CONFIG_DEBUG_HIGHMEM
-#define  __WITH_KM_FENCE
-#endif
-
-#include <asm-generic/kmap_types.h>
-
-#undef __WITH_KM_FENCE
-
-#endif /* _ASM_IA64_KMAP_TYPES_H */
diff --git a/arch/ia64/include/asm/spinlock_types.h b/arch/ia64/include/asm/spinlock_types.h
index 6e345fefcdca..681408d6816f 100644
--- a/arch/ia64/include/asm/spinlock_types.h
+++ b/arch/ia64/include/asm/spinlock_types.h
@@ -2,10 +2,6 @@
 #ifndef _ASM_IA64_SPINLOCK_TYPES_H
 #define _ASM_IA64_SPINLOCK_TYPES_H
 
-#ifndef __LINUX_SPINLOCK_TYPES_H
-# error "please don't include this file directly"
-#endif
-
 typedef struct {
 	volatile unsigned int lock;
 } arch_spinlock_t;
diff --git a/arch/ia64/kernel/time.c b/arch/ia64/kernel/time.c
index 7abc5f37bfaf..733e0e3324b8 100644
--- a/arch/ia64/kernel/time.c
+++ b/arch/ia64/kernel/time.c
@@ -138,12 +138,8 @@ void vtime_account_kernel(struct task_struct *tsk)
 	struct thread_info *ti = task_thread_info(tsk);
 	__u64 stime = vtime_delta(tsk);
 
-	if ((tsk->flags & PF_VCPU) && !irq_count())
+	if (tsk->flags & PF_VCPU)
 		ti->gtime += stime;
-	else if (hardirq_count())
-		ti->hardirq_time += stime;
-	else if (in_serving_softirq())
-		ti->softirq_time += stime;
 	else
 		ti->stime += stime;
 }
@@ -156,6 +152,20 @@ void vtime_account_idle(struct task_struct *tsk)
 	ti->idle_time += vtime_delta(tsk);
 }
 
+void vtime_account_softirq(struct task_struct *tsk)
+{
+	struct thread_info *ti = task_thread_info(tsk);
+
+	ti->softirq_time += vtime_delta(tsk);
+}
+
+void vtime_account_hardirq(struct task_struct *tsk)
+{
+	struct thread_info *ti = task_thread_info(tsk);
+
+	ti->hardirq_time += vtime_delta(tsk);
+}
+
 #endif /* CONFIG_VIRT_CPU_ACCOUNTING_NATIVE */
 
 static irqreturn_t
diff --git a/arch/microblaze/Kconfig b/arch/microblaze/Kconfig
index 33925ffed68f..7f6ca0ab4f81 100644
--- a/arch/microblaze/Kconfig
+++ b/arch/microblaze/Kconfig
@@ -155,6 +155,7 @@ config XILINX_UNCACHED_SHADOW
 config HIGHMEM
 	bool "High memory support"
 	depends on MMU
+	select KMAP_LOCAL
 	help
 	  The address space of Microblaze processors is only 4 Gigabytes large
 	  and it has to accommodate user address space, kernel address
diff --git a/arch/microblaze/include/asm/fixmap.h b/arch/microblaze/include/asm/fixmap.h
index 0379ce5229e3..e6e9288bff76 100644
--- a/arch/microblaze/include/asm/fixmap.h
+++ b/arch/microblaze/include/asm/fixmap.h
@@ -20,7 +20,7 @@
 #include <asm/page.h>
 #ifdef CONFIG_HIGHMEM
 #include <linux/threads.h>
-#include <asm/kmap_types.h>
+#include <asm/kmap_size.h>
 #endif
 
 #define FIXADDR_TOP	((unsigned long)(-PAGE_SIZE))
@@ -47,7 +47,7 @@ enum fixed_addresses {
 	FIX_HOLE,
 #ifdef CONFIG_HIGHMEM
 	FIX_KMAP_BEGIN,	/* reserved pte's for temporary kernel mappings */
-	FIX_KMAP_END = FIX_KMAP_BEGIN + (KM_TYPE_NR * num_possible_cpus()) - 1,
+	FIX_KMAP_END = FIX_KMAP_BEGIN + (KM_MAX_IDX * num_possible_cpus()) - 1,
 #endif
 	__end_of_fixed_addresses
 };
diff --git a/arch/microblaze/include/asm/highmem.h b/arch/microblaze/include/asm/highmem.h
index 284ca8fb54c1..4418633fb163 100644
--- a/arch/microblaze/include/asm/highmem.h
+++ b/arch/microblaze/include/asm/highmem.h
@@ -25,7 +25,6 @@
 #include <linux/uaccess.h>
 #include <asm/fixmap.h>
 
-extern pte_t *kmap_pte;
 extern pte_t *pkmap_page_table;
 
 /*
@@ -52,6 +51,11 @@ extern pte_t *pkmap_page_table;
 
 #define flush_cache_kmaps()	{ flush_icache(); flush_dcache(); }
 
+#define arch_kmap_local_post_map(vaddr, pteval)	\
+	local_flush_tlb_page(NULL, vaddr);
+#define arch_kmap_local_post_unmap(vaddr)	\
+	local_flush_tlb_page(NULL, vaddr);
+
 #endif /* __KERNEL__ */
 
 #endif /* _ASM_HIGHMEM_H */
diff --git a/arch/microblaze/mm/Makefile b/arch/microblaze/mm/Makefile
index 1b16875cea70..8ced71100047 100644
--- a/arch/microblaze/mm/Makefile
+++ b/arch/microblaze/mm/Makefile
@@ -6,4 +6,3 @@
 obj-y := consistent.o init.o
 
 obj-$(CONFIG_MMU) += pgtable.o mmu_context.o fault.o
-obj-$(CONFIG_HIGHMEM) += highmem.o
diff --git a/arch/microblaze/mm/highmem.c b/arch/microblaze/mm/highmem.c
deleted file mode 100644
index 92e0890416c9..000000000000
--- a/arch/microblaze/mm/highmem.c
+++ /dev/null
@@ -1,78 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- * highmem.c: virtual kernel memory mappings for high memory
- *
- * PowerPC version, stolen from the i386 version.
- *
- * Used in CONFIG_HIGHMEM systems for memory pages which
- * are not addressable by direct kernel virtual addresses.
- *
- * Copyright (C) 1999 Gerhard Wichert, Siemens AG
- *		      Gerhard.Wichert@pdb.siemens.de
- *
- *
- * Redesigned the x86 32-bit VM architecture to deal with
- * up to 16 Terrabyte physical memory. With current x86 CPUs
- * we now support up to 64 Gigabytes physical RAM.
- *
- * Copyright (C) 1999 Ingo Molnar <mingo@redhat.com>
- *
- * Reworked for PowerPC by various contributors. Moved from
- * highmem.h by Benjamin Herrenschmidt (c) 2009 IBM Corp.
- */
-
-#include <linux/export.h>
-#include <linux/highmem.h>
-
-/*
- * The use of kmap_atomic/kunmap_atomic is discouraged - kmap/kunmap
- * gives a more generic (and caching) interface. But kmap_atomic can
- * be used in IRQ contexts, so in some (very limited) cases we need
- * it.
- */
-#include <asm/tlbflush.h>
-
-void *kmap_atomic_high_prot(struct page *page, pgprot_t prot)
-{
-
-	unsigned long vaddr;
-	int idx, type;
-
-	type = kmap_atomic_idx_push();
-	idx = type + KM_TYPE_NR*smp_processor_id();
-	vaddr = __fix_to_virt(FIX_KMAP_BEGIN + idx);
-#ifdef CONFIG_DEBUG_HIGHMEM
-	BUG_ON(!pte_none(*(kmap_pte-idx)));
-#endif
-	set_pte_at(&init_mm, vaddr, kmap_pte-idx, mk_pte(page, prot));
-	local_flush_tlb_page(NULL, vaddr);
-
-	return (void *) vaddr;
-}
-EXPORT_SYMBOL(kmap_atomic_high_prot);
-
-void kunmap_atomic_high(void *kvaddr)
-{
-	unsigned long vaddr = (unsigned long) kvaddr & PAGE_MASK;
-	int type;
-	unsigned int idx;
-
-	if (vaddr < __fix_to_virt(FIX_KMAP_END))
-		return;
-
-	type = kmap_atomic_idx();
-
-	idx = type + KM_TYPE_NR * smp_processor_id();
-#ifdef CONFIG_DEBUG_HIGHMEM
-	BUG_ON(vaddr != __fix_to_virt(FIX_KMAP_BEGIN + idx));
-#endif
-	/*
-	 * force other mappings to Oops if they'll try to access
-	 * this pte without first remap it
-	 */
-	pte_clear(&init_mm, vaddr, kmap_pte-idx);
-	local_flush_tlb_page(NULL, vaddr);
-
-	kmap_atomic_idx_pop();
-}
-EXPORT_SYMBOL(kunmap_atomic_high);
diff --git a/arch/microblaze/mm/init.c b/arch/microblaze/mm/init.c
index 4a0c30ced72b..498eaa4d3978 100644
--- a/arch/microblaze/mm/init.c
+++ b/arch/microblaze/mm/init.c
@@ -49,17 +49,11 @@ unsigned long lowmem_size;
 EXPORT_SYMBOL(min_low_pfn);
 EXPORT_SYMBOL(max_low_pfn);
 
-#ifdef CONFIG_HIGHMEM
-pte_t *kmap_pte;
-EXPORT_SYMBOL(kmap_pte);
-
 static void __init highmem_init(void)
 {
 	pr_debug("%x\n", (u32)PKMAP_BASE);
 	map_page(PKMAP_BASE, 0, 0);	/* XXX gross */
 	pkmap_page_table = virt_to_kpte(PKMAP_BASE);
-
-	kmap_pte = virt_to_kpte(__fix_to_virt(FIX_KMAP_BEGIN));
 }
 
 static void highmem_setup(void)
diff --git a/arch/mips/Kconfig b/arch/mips/Kconfig
index 896a29df1a6d..1b3593d53978 100644
--- a/arch/mips/Kconfig
+++ b/arch/mips/Kconfig
@@ -2727,6 +2727,7 @@ config WAR_MIPS34K_MISSED_ITLB
 config HIGHMEM
 	bool "High Memory Support"
 	depends on 32BIT && CPU_SUPPORTS_HIGHMEM && SYS_SUPPORTS_HIGHMEM && !CPU_MIPS32_3_5_EVA
+	select KMAP_LOCAL
 
 config CPU_SUPPORTS_HIGHMEM
 	bool
diff --git a/arch/mips/include/asm/fixmap.h b/arch/mips/include/asm/fixmap.h
index 743535be7528..beea14761cef 100644
--- a/arch/mips/include/asm/fixmap.h
+++ b/arch/mips/include/asm/fixmap.h
@@ -17,7 +17,7 @@
 #include <spaces.h>
 #ifdef CONFIG_HIGHMEM
 #include <linux/threads.h>
-#include <asm/kmap_types.h>
+#include <asm/kmap_size.h>
 #endif
 
 /*
@@ -52,7 +52,7 @@ enum fixed_addresses {
 #ifdef CONFIG_HIGHMEM
 	/* reserved pte's for temporary kernel mappings */
 	FIX_KMAP_BEGIN = FIX_CMAP_END + 1,
-	FIX_KMAP_END = FIX_KMAP_BEGIN+(KM_TYPE_NR*NR_CPUS)-1,
+	FIX_KMAP_END = FIX_KMAP_BEGIN + (KM_MAX_IDX * NR_CPUS) - 1,
 #endif
 	__end_of_fixed_addresses
 };
diff --git a/arch/mips/include/asm/highmem.h b/arch/mips/include/asm/highmem.h
index 9f021cf51aa7..1716181ea66d 100644
--- a/arch/mips/include/asm/highmem.h
+++ b/arch/mips/include/asm/highmem.h
@@ -24,7 +24,7 @@
 #include <linux/interrupt.h>
 #include <linux/uaccess.h>
 #include <asm/cpu-features.h>
-#include <asm/kmap_types.h>
+#include <asm/kmap_size.h>
 
 /* declarations for highmem.c */
 extern unsigned long highstart_pfn, highend_pfn;
@@ -48,11 +48,11 @@ extern pte_t *pkmap_page_table;
 
 #define ARCH_HAS_KMAP_FLUSH_TLB
 extern void kmap_flush_tlb(unsigned long addr);
-extern void *kmap_atomic_pfn(unsigned long pfn);
 
 #define flush_cache_kmaps()	BUG_ON(cpu_has_dc_aliases)
 
-extern void kmap_init(void);
+#define arch_kmap_local_post_map(vaddr, pteval)	local_flush_tlb_one(vaddr)
+#define arch_kmap_local_post_unmap(vaddr)	local_flush_tlb_one(vaddr)
 
 #endif /* __KERNEL__ */
 
diff --git a/arch/mips/include/asm/kmap_types.h b/arch/mips/include/asm/kmap_types.h
deleted file mode 100644
index 16665dc2431b..000000000000
--- a/arch/mips/include/asm/kmap_types.h
+++ /dev/null
@@ -1,13 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-#ifndef _ASM_KMAP_TYPES_H
-#define _ASM_KMAP_TYPES_H
-
-#ifdef CONFIG_DEBUG_HIGHMEM
-#define	 __WITH_KM_FENCE
-#endif
-
-#include <asm-generic/kmap_types.h>
-
-#undef __WITH_KM_FENCE
-
-#endif
diff --git a/arch/mips/kernel/crash_dump.c b/arch/mips/kernel/crash_dump.c
index 01b2bd95ba1f..9aba83e1eeb4 100644
--- a/arch/mips/kernel/crash_dump.c
+++ b/arch/mips/kernel/crash_dump.c
@@ -5,8 +5,6 @@
 #include <linux/uaccess.h>
 #include <linux/slab.h>
 
-static void *kdump_buf_page;
-
 /**
  * copy_oldmem_page - copy one page from "oldmem"
  * @pfn: page frame number to be copied
@@ -17,51 +15,25 @@ static void *kdump_buf_page;
  * @userbuf: if set, @buf is in user address space, use copy_to_user(),
  *	otherwise @buf is in kernel address space, use memcpy().
  *
- * Copy a page from "oldmem". For this page, there is no pte mapped
+ * Copy a page from "oldmem". For this page, there might be no pte mapped
  * in the current kernel.
- *
- * Calling copy_to_user() in atomic context is not desirable. Hence first
- * copying the data to a pre-allocated kernel page and then copying to user
- * space in non-atomic context.
  */
-ssize_t copy_oldmem_page(unsigned long pfn, char *buf,
-			 size_t csize, unsigned long offset, int userbuf)
+ssize_t copy_oldmem_page(unsigned long pfn, char *buf, size_t csize,
+			 unsigned long offset, int userbuf)
 {
 	void  *vaddr;
 
 	if (!csize)
 		return 0;
 
-	vaddr = kmap_atomic_pfn(pfn);
+	vaddr = kmap_local_pfn(pfn);
 
 	if (!userbuf) {
-		memcpy(buf, (vaddr + offset), csize);
-		kunmap_atomic(vaddr);
+		memcpy(buf, vaddr + offset, csize);
 	} else {
-		if (!kdump_buf_page) {
-			pr_warn("Kdump: Kdump buffer page not allocated\n");
-
-			return -EFAULT;
-		}
-		copy_page(kdump_buf_page, vaddr);
-		kunmap_atomic(vaddr);
-		if (copy_to_user(buf, (kdump_buf_page + offset), csize))
-			return -EFAULT;
+		if (copy_to_user(buf, vaddr + offset, csize))
+			csize = -EFAULT;
 	}
 
 	return csize;
 }
-
-static int __init kdump_buf_page_init(void)
-{
-	int ret = 0;
-
-	kdump_buf_page = kmalloc(PAGE_SIZE, GFP_KERNEL);
-	if (!kdump_buf_page) {
-		pr_warn("Kdump: Failed to allocate kdump buffer page\n");
-		ret = -ENOMEM;
-	}
-
-	return ret;
-}
-arch_initcall(kdump_buf_page_init);
diff --git a/arch/mips/mm/highmem.c b/arch/mips/mm/highmem.c
index 5fec7f45d79a..57e2f08f00d0 100644
--- a/arch/mips/mm/highmem.c
+++ b/arch/mips/mm/highmem.c
@@ -8,8 +8,6 @@
 #include <asm/fixmap.h>
 #include <asm/tlbflush.h>
 
-static pte_t *kmap_pte;
-
 unsigned long highstart_pfn, highend_pfn;
 
 void kmap_flush_tlb(unsigned long addr)
@@ -17,78 +15,3 @@ void kmap_flush_tlb(unsigned long addr)
 	flush_tlb_one(addr);
 }
 EXPORT_SYMBOL(kmap_flush_tlb);
-
-void *kmap_atomic_high_prot(struct page *page, pgprot_t prot)
-{
-	unsigned long vaddr;
-	int idx, type;
-
-	type = kmap_atomic_idx_push();
-	idx = type + KM_TYPE_NR*smp_processor_id();
-	vaddr = __fix_to_virt(FIX_KMAP_BEGIN + idx);
-#ifdef CONFIG_DEBUG_HIGHMEM
-	BUG_ON(!pte_none(*(kmap_pte - idx)));
-#endif
-	set_pte(kmap_pte-idx, mk_pte(page, prot));
-	local_flush_tlb_one((unsigned long)vaddr);
-
-	return (void*) vaddr;
-}
-EXPORT_SYMBOL(kmap_atomic_high_prot);
-
-void kunmap_atomic_high(void *kvaddr)
-{
-	unsigned long vaddr = (unsigned long) kvaddr & PAGE_MASK;
-	int type __maybe_unused;
-
-	if (vaddr < FIXADDR_START)
-		return;
-
-	type = kmap_atomic_idx();
-#ifdef CONFIG_DEBUG_HIGHMEM
-	{
-		int idx = type + KM_TYPE_NR * smp_processor_id();
-
-		BUG_ON(vaddr != __fix_to_virt(FIX_KMAP_BEGIN + idx));
-
-		/*
-		 * force other mappings to Oops if they'll try to access
-		 * this pte without first remap it
-		 */
-		pte_clear(&init_mm, vaddr, kmap_pte-idx);
-		local_flush_tlb_one(vaddr);
-	}
-#endif
-	kmap_atomic_idx_pop();
-}
-EXPORT_SYMBOL(kunmap_atomic_high);
-
-/*
- * This is the same as kmap_atomic() but can map memory that doesn't
- * have a struct page associated with it.
- */
-void *kmap_atomic_pfn(unsigned long pfn)
-{
-	unsigned long vaddr;
-	int idx, type;
-
-	preempt_disable();
-	pagefault_disable();
-
-	type = kmap_atomic_idx_push();
-	idx = type + KM_TYPE_NR*smp_processor_id();
-	vaddr = __fix_to_virt(FIX_KMAP_BEGIN + idx);
-	set_pte(kmap_pte-idx, pfn_pte(pfn, PAGE_KERNEL));
-	flush_tlb_one(vaddr);
-
-	return (void*) vaddr;
-}
-
-void __init kmap_init(void)
-{
-	unsigned long kmap_vstart;
-
-	/* cache the first kmap pte */
-	kmap_vstart = __fix_to_virt(FIX_KMAP_BEGIN);
-	kmap_pte = virt_to_kpte(kmap_vstart);
-}
diff --git a/arch/mips/mm/init.c b/arch/mips/mm/init.c
index 07e84a774938..bc80893e5c0f 100644
--- a/arch/mips/mm/init.c
+++ b/arch/mips/mm/init.c
@@ -36,7 +36,6 @@
 #include <asm/cachectl.h>
 #include <asm/cpu.h>
 #include <asm/dma.h>
-#include <asm/kmap_types.h>
 #include <asm/maar.h>
 #include <asm/mmu_context.h>
 #include <asm/sections.h>
@@ -402,9 +401,6 @@ void __init paging_init(void)
 
 	pagetable_init();
 
-#ifdef CONFIG_HIGHMEM
-	kmap_init();
-#endif
 #ifdef CONFIG_ZONE_DMA
 	max_zone_pfns[ZONE_DMA] = MAX_DMA_PFN;
 #endif
diff --git a/arch/nds32/Kconfig.cpu b/arch/nds32/Kconfig.cpu
index f88a12fdf0f3..c10759952485 100644
--- a/arch/nds32/Kconfig.cpu
+++ b/arch/nds32/Kconfig.cpu
@@ -157,6 +157,7 @@ config HW_SUPPORT_UNALIGNMENT_ACCESS
 config HIGHMEM
 	bool "High Memory Support"
 	depends on MMU && !CPU_CACHE_ALIASING
+	select KMAP_LOCAL
 	help
 	  The address space of Andes processors is only 4 Gigabytes large
 	  and it has to accommodate user address space, kernel address
diff --git a/arch/nds32/include/asm/fixmap.h b/arch/nds32/include/asm/fixmap.h
index 5a4bf11e5800..2fa09a2de428 100644
--- a/arch/nds32/include/asm/fixmap.h
+++ b/arch/nds32/include/asm/fixmap.h
@@ -6,7 +6,7 @@
 
 #ifdef CONFIG_HIGHMEM
 #include <linux/threads.h>
-#include <asm/kmap_types.h>
+#include <asm/kmap_size.h>
 #endif
 
 enum fixed_addresses {
@@ -14,7 +14,7 @@ enum fixed_addresses {
 	FIX_KMAP_RESERVED,
 	FIX_KMAP_BEGIN,
 #ifdef CONFIG_HIGHMEM
-	FIX_KMAP_END = FIX_KMAP_BEGIN + (KM_TYPE_NR * NR_CPUS),
+	FIX_KMAP_END = FIX_KMAP_BEGIN + (KM_MAX_IDX * NR_CPUS) - 1,
 #endif
 	FIX_EARLYCON_MEM_BASE,
 	__end_of_fixed_addresses
diff --git a/arch/nds32/include/asm/highmem.h b/arch/nds32/include/asm/highmem.h
index fe986d0e6e3f..16159a8716f2 100644
--- a/arch/nds32/include/asm/highmem.h
+++ b/arch/nds32/include/asm/highmem.h
@@ -5,7 +5,6 @@
 #define _ASM_HIGHMEM_H
 
 #include <asm/proc-fns.h>
-#include <asm/kmap_types.h>
 #include <asm/fixmap.h>
 
 /*
@@ -45,11 +44,22 @@ extern pte_t *pkmap_page_table;
 extern void kmap_init(void);
 
 /*
- * The following functions are already defined by <linux/highmem.h>
- * when CONFIG_HIGHMEM is not set.
+ * FIXME: The below looks broken vs. a kmap_atomic() in task context which
+ * is interupted and another kmap_atomic() happens in interrupt context.
+ * But what do I know about nds32. -- tglx
  */
-#ifdef CONFIG_HIGHMEM
-extern void *kmap_atomic_pfn(unsigned long pfn);
-#endif
+#define arch_kmap_local_post_map(vaddr, pteval)			\
+	do {							\
+		__nds32__tlbop_inv(vaddr);			\
+		__nds32__mtsr_dsb(vaddr, NDS32_SR_TLB_VPN);	\
+		__nds32__tlbop_rwr(pteval);			\
+		__nds32__isb();					\
+	} while (0)
+
+#define arch_kmap_local_pre_unmap(vaddr)			\
+	do {							\
+		__nds32__tlbop_inv(vaddr);			\
+		__nds32__isb();					\
+	} while (0)
 
 #endif
diff --git a/arch/nds32/mm/Makefile b/arch/nds32/mm/Makefile
index 897ecaf5cf54..14fb2e8eb036 100644
--- a/arch/nds32/mm/Makefile
+++ b/arch/nds32/mm/Makefile
@@ -3,7 +3,6 @@ obj-y				:= extable.o tlb.o fault.o init.o mmap.o \
                                    mm-nds32.o cacheflush.o proc.o
 
 obj-$(CONFIG_ALIGNMENT_TRAP)	+= alignment.o
-obj-$(CONFIG_HIGHMEM)           += highmem.o
 
 ifdef CONFIG_FUNCTION_TRACER
 CFLAGS_REMOVE_proc.o     = $(CC_FLAGS_FTRACE)
diff --git a/arch/nds32/mm/highmem.c b/arch/nds32/mm/highmem.c
deleted file mode 100644
index 4284cd59e21a..000000000000
--- a/arch/nds32/mm/highmem.c
+++ /dev/null
@@ -1,48 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-// Copyright (C) 2005-2017 Andes Technology Corporation
-
-#include <linux/export.h>
-#include <linux/highmem.h>
-#include <linux/sched.h>
-#include <linux/smp.h>
-#include <linux/interrupt.h>
-#include <linux/memblock.h>
-#include <asm/fixmap.h>
-#include <asm/tlbflush.h>
-
-void *kmap_atomic_high_prot(struct page *page, pgprot_t prot)
-{
-	unsigned int idx;
-	unsigned long vaddr, pte;
-	int type;
-	pte_t *ptep;
-
-	type = kmap_atomic_idx_push();
-
-	idx = type + KM_TYPE_NR * smp_processor_id();
-	vaddr = __fix_to_virt(FIX_KMAP_BEGIN + idx);
-	pte = (page_to_pfn(page) << PAGE_SHIFT) | prot;
-	ptep = pte_offset_kernel(pmd_off_k(vaddr), vaddr);
-	set_pte(ptep, pte);
-
-	__nds32__tlbop_inv(vaddr);
-	__nds32__mtsr_dsb(vaddr, NDS32_SR_TLB_VPN);
-	__nds32__tlbop_rwr(pte);
-	__nds32__isb();
-	return (void *)vaddr;
-}
-EXPORT_SYMBOL(kmap_atomic_high_prot);
-
-void kunmap_atomic_high(void *kvaddr)
-{
-	if (kvaddr >= (void *)FIXADDR_START) {
-		unsigned long vaddr = (unsigned long)kvaddr;
-		pte_t *ptep;
-		kmap_atomic_idx_pop();
-		__nds32__tlbop_inv(vaddr);
-		__nds32__isb();
-		ptep = pte_offset_kernel(pmd_off_k(vaddr), vaddr);
-		set_pte(ptep, 0);
-	}
-}
-EXPORT_SYMBOL(kunmap_atomic_high);
diff --git a/arch/openrisc/mm/init.c b/arch/openrisc/mm/init.c
index 5e88c351e6a4..f3fa02b8838a 100644
--- a/arch/openrisc/mm/init.c
+++ b/arch/openrisc/mm/init.c
@@ -33,7 +33,6 @@
 #include <asm/io.h>
 #include <asm/tlb.h>
 #include <asm/mmu_context.h>
-#include <asm/kmap_types.h>
 #include <asm/fixmap.h>
 #include <asm/tlbflush.h>
 #include <asm/sections.h>
diff --git a/arch/openrisc/mm/ioremap.c b/arch/openrisc/mm/ioremap.c
index a978590d802d..5aed97a18bac 100644
--- a/arch/openrisc/mm/ioremap.c
+++ b/arch/openrisc/mm/ioremap.c
@@ -15,7 +15,6 @@
 #include <linux/io.h>
 #include <linux/pgtable.h>
 #include <asm/pgalloc.h>
-#include <asm/kmap_types.h>
 #include <asm/fixmap.h>
 #include <asm/bug.h>
 #include <linux/sched.h>
diff --git a/arch/parisc/include/asm/hardirq.h b/arch/parisc/include/asm/hardirq.h
index 7f7039516e53..fad29aa6f45f 100644
--- a/arch/parisc/include/asm/hardirq.h
+++ b/arch/parisc/include/asm/hardirq.h
@@ -32,7 +32,6 @@ typedef struct {
 DECLARE_PER_CPU_SHARED_ALIGNED(irq_cpustat_t, irq_stat);
 
 #define __ARCH_IRQ_STAT
-#define __IRQ_STAT(cpu, member) (irq_stat[cpu].member)
 #define inc_irq_stat(member)	this_cpu_inc(irq_stat.member)
 #define __inc_irq_stat(member)	__this_cpu_inc(irq_stat.member)
 #define ack_bad_irq(irq) WARN(1, "unexpected IRQ trap at vector %02x\n", irq)
diff --git a/arch/parisc/include/asm/kmap_types.h b/arch/parisc/include/asm/kmap_types.h
deleted file mode 100644
index 3e70b5cd1123..000000000000
--- a/arch/parisc/include/asm/kmap_types.h
+++ /dev/null
@@ -1,13 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-#ifndef _ASM_KMAP_TYPES_H
-#define _ASM_KMAP_TYPES_H
-
-#ifdef CONFIG_DEBUG_HIGHMEM
-#define  __WITH_KM_FENCE
-#endif
-
-#include <asm-generic/kmap_types.h>
-
-#undef __WITH_KM_FENCE
-
-#endif
diff --git a/arch/powerpc/Kconfig b/arch/powerpc/Kconfig
index ed06e0c32727..a0cf63581f24 100644
--- a/arch/powerpc/Kconfig
+++ b/arch/powerpc/Kconfig
@@ -146,6 +146,7 @@ config PPC
 	select ARCH_MIGHT_HAVE_PC_SERIO
 	select ARCH_OPTIONAL_KERNEL_RWX		if ARCH_HAS_STRICT_KERNEL_RWX
 	select ARCH_SUPPORTS_ATOMIC_RMW
+	select ARCH_SUPPORTS_RT if HAVE_POSIX_CPU_TIMERS_TASK_WORK
 	select ARCH_USE_BUILTIN_BSWAP
 	select ARCH_USE_CMPXCHG_LOCKREF		if PPC64
 	select ARCH_USE_QUEUED_RWLOCKS		if PPC_QUEUED_SPINLOCKS
@@ -234,6 +235,7 @@ config PPC
 	select HAVE_HARDLOCKUP_DETECTOR_PERF	if PERF_EVENTS && HAVE_PERF_EVENTS_NMI && !HAVE_HARDLOCKUP_DETECTOR_ARCH
 	select HAVE_PERF_REGS
 	select HAVE_PERF_USER_STACK_DUMP
+	select HAVE_PREEMPT_LAZY
 	select MMU_GATHER_RCU_TABLE_FREE
 	select MMU_GATHER_PAGE_SIZE
 	select HAVE_REGS_AND_STACK_ACCESS_API
@@ -241,6 +243,7 @@ config PPC
 	select HAVE_SYSCALL_TRACEPOINTS
 	select HAVE_VIRT_CPU_ACCOUNTING
 	select HAVE_IRQ_TIME_ACCOUNTING
+	select HAVE_POSIX_CPU_TIMERS_TASK_WORK  if !KVM
 	select HAVE_RSEQ
 	select IOMMU_HELPER			if PPC64
 	select IRQ_DOMAIN
@@ -414,6 +417,7 @@ menu "Kernel options"
 config HIGHMEM
 	bool "High memory support"
 	depends on PPC32
+	select KMAP_LOCAL
 
 source "kernel/Kconfig.hz"
 
diff --git a/arch/powerpc/include/asm/cmpxchg.h b/arch/powerpc/include/asm/cmpxchg.h
index cf091c4c22e5..7371f7e23c35 100644
--- a/arch/powerpc/include/asm/cmpxchg.h
+++ b/arch/powerpc/include/asm/cmpxchg.h
@@ -5,7 +5,7 @@
 #ifdef __KERNEL__
 #include <linux/compiler.h>
 #include <asm/synch.h>
-#include <linux/bug.h>
+#include <linux/bits.h>
 
 #ifdef __BIG_ENDIAN
 #define BITOFF_CAL(size, off)	((sizeof(u32) - size - off) * BITS_PER_BYTE)
diff --git a/arch/powerpc/include/asm/fixmap.h b/arch/powerpc/include/asm/fixmap.h
index 897cc68758d4..a832aeafe560 100644
--- a/arch/powerpc/include/asm/fixmap.h
+++ b/arch/powerpc/include/asm/fixmap.h
@@ -20,7 +20,7 @@
 #include <asm/page.h>
 #ifdef CONFIG_HIGHMEM
 #include <linux/threads.h>
-#include <asm/kmap_types.h>
+#include <asm/kmap_size.h>
 #endif
 
 #ifdef CONFIG_PPC64
@@ -61,7 +61,7 @@ enum fixed_addresses {
 	FIX_EARLY_DEBUG_BASE = FIX_EARLY_DEBUG_TOP+(ALIGN(SZ_128K, PAGE_SIZE)/PAGE_SIZE)-1,
 #ifdef CONFIG_HIGHMEM
 	FIX_KMAP_BEGIN,	/* reserved pte's for temporary kernel mappings */
-	FIX_KMAP_END = FIX_KMAP_BEGIN+(KM_TYPE_NR*NR_CPUS)-1,
+	FIX_KMAP_END = FIX_KMAP_BEGIN + (KM_MAX_IDX * NR_CPUS) - 1,
 #endif
 #ifdef CONFIG_PPC_8xx
 	/* For IMMR we need an aligned 512K area */
diff --git a/arch/powerpc/include/asm/highmem.h b/arch/powerpc/include/asm/highmem.h
index 104026f7d6bc..80a5ae771c65 100644
--- a/arch/powerpc/include/asm/highmem.h
+++ b/arch/powerpc/include/asm/highmem.h
@@ -24,12 +24,10 @@
 #ifdef __KERNEL__
 
 #include <linux/interrupt.h>
-#include <asm/kmap_types.h>
 #include <asm/cacheflush.h>
 #include <asm/page.h>
 #include <asm/fixmap.h>
 
-extern pte_t *kmap_pte;
 extern pte_t *pkmap_page_table;
 
 /*
@@ -60,6 +58,11 @@ extern pte_t *pkmap_page_table;
 
 #define flush_cache_kmaps()	flush_cache_all()
 
+#define arch_kmap_local_post_map(vaddr, pteval)	\
+	local_flush_tlb_page(NULL, vaddr)
+#define arch_kmap_local_post_unmap(vaddr)	\
+	local_flush_tlb_page(NULL, vaddr)
+
 #endif /* __KERNEL__ */
 
 #endif /* _ASM_HIGHMEM_H */
diff --git a/arch/powerpc/include/asm/kmap_types.h b/arch/powerpc/include/asm/kmap_types.h
deleted file mode 100644
index c8fa182d48c8..000000000000
--- a/arch/powerpc/include/asm/kmap_types.h
+++ /dev/null
@@ -1,13 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0-or-later */
-#ifndef _ASM_POWERPC_KMAP_TYPES_H
-#define _ASM_POWERPC_KMAP_TYPES_H
-
-#ifdef __KERNEL__
-
-/*
- */
-
-#define KM_TYPE_NR 16
-
-#endif	/* __KERNEL__ */
-#endif	/* _ASM_POWERPC_KMAP_TYPES_H */
diff --git a/arch/powerpc/include/asm/simple_spinlock_types.h b/arch/powerpc/include/asm/simple_spinlock_types.h
index 0f3cdd8faa95..d45561e9e6ba 100644
--- a/arch/powerpc/include/asm/simple_spinlock_types.h
+++ b/arch/powerpc/include/asm/simple_spinlock_types.h
@@ -2,7 +2,7 @@
 #ifndef _ASM_POWERPC_SIMPLE_SPINLOCK_TYPES_H
 #define _ASM_POWERPC_SIMPLE_SPINLOCK_TYPES_H
 
-#ifndef __LINUX_SPINLOCK_TYPES_H
+#if !defined(__LINUX_SPINLOCK_TYPES_H) && !defined(__LINUX_RT_MUTEX_H)
 # error "please don't include this file directly"
 #endif
 
diff --git a/arch/powerpc/include/asm/spinlock_types.h b/arch/powerpc/include/asm/spinlock_types.h
index c5d742f18021..cc6922a011ba 100644
--- a/arch/powerpc/include/asm/spinlock_types.h
+++ b/arch/powerpc/include/asm/spinlock_types.h
@@ -2,10 +2,6 @@
 #ifndef _ASM_POWERPC_SPINLOCK_TYPES_H
 #define _ASM_POWERPC_SPINLOCK_TYPES_H
 
-#ifndef __LINUX_SPINLOCK_TYPES_H
-# error "please don't include this file directly"
-#endif
-
 #ifdef CONFIG_PPC_QUEUED_SPINLOCKS
 #include <asm-generic/qspinlock_types.h>
 #include <asm-generic/qrwlock_types.h>
diff --git a/arch/powerpc/include/asm/stackprotector.h b/arch/powerpc/include/asm/stackprotector.h
index 1c8460e23583..b1653c160bab 100644
--- a/arch/powerpc/include/asm/stackprotector.h
+++ b/arch/powerpc/include/asm/stackprotector.h
@@ -24,7 +24,11 @@ static __always_inline void boot_init_stack_canary(void)
 	unsigned long canary;
 
 	/* Try to get a semi random initial value. */
+#ifdef CONFIG_PREEMPT_RT
+	canary = (unsigned long)&canary;
+#else
 	canary = get_random_canary();
+#endif
 	canary ^= mftb();
 	canary ^= LINUX_VERSION_CODE;
 	canary &= CANARY_MASK;
diff --git a/arch/powerpc/include/asm/thread_info.h b/arch/powerpc/include/asm/thread_info.h
index 7480fbc4d79d..7eb0963e42b8 100644
--- a/arch/powerpc/include/asm/thread_info.h
+++ b/arch/powerpc/include/asm/thread_info.h
@@ -54,6 +54,8 @@
 struct thread_info {
 	int		preempt_count;		/* 0 => preemptable,
 						   <0 => BUG */
+	int		preempt_lazy_count;	/* 0 => preemptable,
+						   <0 => BUG */						   
 #ifdef CONFIG_SMP
 	unsigned int	cpu;
 #endif
@@ -106,11 +108,12 @@ void arch_setup_new_exec(void);
 #define TIF_SINGLESTEP		8	/* singlestepping active */
 #define TIF_NOHZ		9	/* in adaptive nohz mode */
 #define TIF_SECCOMP		10	/* secure computing */
-#define TIF_RESTOREALL		11	/* Restore all regs (implies NOERROR) */
-#define TIF_NOERROR		12	/* Force successful syscall return */
+
+#define TIF_NEED_RESCHED_LAZY	11	/* lazy rescheduling necessary */
+#define TIF_SYSCALL_TRACEPOINT	12	/* syscall tracepoint instrumentation */
+
 #define TIF_NOTIFY_RESUME	13	/* callback before returning to user */
 #define TIF_UPROBE		14	/* breakpointed or single-stepping */
-#define TIF_SYSCALL_TRACEPOINT	15	/* syscall tracepoint instrumentation */
 #define TIF_EMULATE_STACK_STORE	16	/* Is an instruction emulation
 						for stack store? */
 #define TIF_MEMDIE		17	/* is terminating due to OOM killer */
@@ -119,6 +122,9 @@ void arch_setup_new_exec(void);
 #endif
 #define TIF_POLLING_NRFLAG	19	/* true if poll_idle() is polling TIF_NEED_RESCHED */
 #define TIF_32BIT		20	/* 32 bit binary */
+#define TIF_RESTOREALL		21	/* Restore all regs (implies NOERROR) */
+#define TIF_NOERROR		22	/* Force successful syscall return */
+
 
 /* as above, but as bit values */
 #define _TIF_SYSCALL_TRACE	(1<<TIF_SYSCALL_TRACE)
@@ -138,6 +144,7 @@ void arch_setup_new_exec(void);
 #define _TIF_SYSCALL_TRACEPOINT	(1<<TIF_SYSCALL_TRACEPOINT)
 #define _TIF_EMULATE_STACK_STORE	(1<<TIF_EMULATE_STACK_STORE)
 #define _TIF_NOHZ		(1<<TIF_NOHZ)
+#define _TIF_NEED_RESCHED_LAZY	(1<<TIF_NEED_RESCHED_LAZY)
 #define _TIF_SYSCALL_EMU	(1<<TIF_SYSCALL_EMU)
 #define _TIF_SYSCALL_DOTRACE	(_TIF_SYSCALL_TRACE | _TIF_SYSCALL_AUDIT | \
 				 _TIF_SECCOMP | _TIF_SYSCALL_TRACEPOINT | \
@@ -145,8 +152,10 @@ void arch_setup_new_exec(void);
 
 #define _TIF_USER_WORK_MASK	(_TIF_SIGPENDING | _TIF_NEED_RESCHED | \
 				 _TIF_NOTIFY_RESUME | _TIF_UPROBE | \
-				 _TIF_RESTORE_TM | _TIF_PATCH_PENDING)
+				 _TIF_RESTORE_TM | _TIF_PATCH_PENDING | \
+				 _TIF_NEED_RESCHED_LAZY)
 #define _TIF_PERSYSCALL_MASK	(_TIF_RESTOREALL|_TIF_NOERROR)
+#define _TIF_NEED_RESCHED_MASK	(_TIF_NEED_RESCHED | _TIF_NEED_RESCHED_LAZY)
 
 /* Bits in local_flags */
 /* Don't move TLF_NAPPING without adjusting the code in entry_32.S */
diff --git a/arch/powerpc/kernel/asm-offsets.c b/arch/powerpc/kernel/asm-offsets.c
index 760f656efcf6..0a351a99d090 100644
--- a/arch/powerpc/kernel/asm-offsets.c
+++ b/arch/powerpc/kernel/asm-offsets.c
@@ -187,6 +187,7 @@ int main(void)
 	OFFSET(TI_FLAGS, thread_info, flags);
 	OFFSET(TI_LOCAL_FLAGS, thread_info, local_flags);
 	OFFSET(TI_PREEMPT, thread_info, preempt_count);
+	OFFSET(TI_PREEMPT_LAZY, thread_info, preempt_lazy_count);
 
 #ifdef CONFIG_PPC64
 	OFFSET(DCACHEL1BLOCKSIZE, ppc64_caches, l1d.block_size);
diff --git a/arch/powerpc/kernel/entry_32.S b/arch/powerpc/kernel/entry_32.S
index 459f5d00b990..fc9517a97640 100644
--- a/arch/powerpc/kernel/entry_32.S
+++ b/arch/powerpc/kernel/entry_32.S
@@ -414,7 +414,9 @@ ret_from_syscall:
 	mtmsr	r10
 	lwz	r9,TI_FLAGS(r2)
 	li	r8,-MAX_ERRNO
-	andi.	r0,r9,(_TIF_SYSCALL_DOTRACE|_TIF_SINGLESTEP|_TIF_USER_WORK_MASK|_TIF_PERSYSCALL_MASK)
+	lis	r0,(_TIF_SYSCALL_DOTRACE|_TIF_SINGLESTEP|_TIF_USER_WORK_MASK|_TIF_PERSYSCALL_MASK)@h
+	ori	r0,r0, (_TIF_SYSCALL_DOTRACE|_TIF_SINGLESTEP|_TIF_USER_WORK_MASK|_TIF_PERSYSCALL_MASK)@l
+	and.	r0,r9,r0
 	bne-	syscall_exit_work
 	cmplw	0,r3,r8
 	blt+	syscall_exit_cont
@@ -530,13 +532,13 @@ syscall_dotrace:
 	b	syscall_dotrace_cont
 
 syscall_exit_work:
-	andi.	r0,r9,_TIF_RESTOREALL
+	andis.	r0,r9,_TIF_RESTOREALL@h
 	beq+	0f
 	REST_NVGPRS(r1)
 	b	2f
 0:	cmplw	0,r3,r8
 	blt+	1f
-	andi.	r0,r9,_TIF_NOERROR
+	andis.	r0,r9,_TIF_NOERROR@h
 	bne-	1f
 	lwz	r11,_CCR(r1)			/* Load CR */
 	neg	r3,r3
@@ -545,12 +547,12 @@ syscall_exit_work:
 
 1:	stw	r6,RESULT(r1)	/* Save result */
 	stw	r3,GPR3(r1)	/* Update return value */
-2:	andi.	r0,r9,(_TIF_PERSYSCALL_MASK)
+2:	andis.	r0,r9,(_TIF_PERSYSCALL_MASK)@h
 	beq	4f
 
 	/* Clear per-syscall TIF flags if any are set.  */
 
-	li	r11,_TIF_PERSYSCALL_MASK
+	lis	r11,(_TIF_PERSYSCALL_MASK)@h
 	addi	r12,r2,TI_FLAGS
 3:	lwarx	r8,0,r12
 	andc	r8,r8,r11
@@ -927,7 +929,14 @@ resume_kernel:
 	cmpwi	0,r0,0		/* if non-zero, just restore regs and return */
 	bne	restore_kuap
 	andi.	r8,r8,_TIF_NEED_RESCHED
+	bne+	1f
+	lwz	r0,TI_PREEMPT_LAZY(r2)
+	cmpwi	0,r0,0          /* if non-zero, just restore regs and return */
+	bne	restore_kuap
+	lwz	r0,TI_FLAGS(r2)
+	andi.	r0,r0,_TIF_NEED_RESCHED_LAZY
 	beq+	restore_kuap
+1:
 	lwz	r3,_MSR(r1)
 	andi.	r0,r3,MSR_EE	/* interrupts off? */
 	beq	restore_kuap	/* don't schedule if so */
@@ -1248,7 +1257,7 @@ global_dbcr0:
 #endif /* !(CONFIG_4xx || CONFIG_BOOKE) */
 
 do_work:			/* r10 contains MSR_KERNEL here */
-	andi.	r0,r9,_TIF_NEED_RESCHED
+	andi.	r0,r9,_TIF_NEED_RESCHED_MASK
 	beq	do_user_signal
 
 do_resched:			/* r10 contains MSR_KERNEL here */
@@ -1267,7 +1276,7 @@ recheck:
 	LOAD_REG_IMMEDIATE(r10,MSR_KERNEL)
 	mtmsr	r10		/* disable interrupts */
 	lwz	r9,TI_FLAGS(r2)
-	andi.	r0,r9,_TIF_NEED_RESCHED
+	andi.	r0,r9,_TIF_NEED_RESCHED_MASK
 	bne-	do_resched
 	andi.	r0,r9,_TIF_USER_WORK_MASK
 	beq	restore_user
diff --git a/arch/powerpc/kernel/exceptions-64e.S b/arch/powerpc/kernel/exceptions-64e.S
index e91d3ba1e208..5ce64cfe69d4 100644
--- a/arch/powerpc/kernel/exceptions-64e.S
+++ b/arch/powerpc/kernel/exceptions-64e.S
@@ -1080,7 +1080,7 @@ _GLOBAL(ret_from_except_lite)
 	li	r10, -1
 	mtspr	SPRN_DBSR,r10
 	b	restore
-1:	andi.	r0,r4,_TIF_NEED_RESCHED
+1:	andi.	r0,r4,_TIF_NEED_RESCHED_MASK
 	beq	2f
 	bl	restore_interrupts
 	SCHEDULE_USER
@@ -1132,12 +1132,20 @@ resume_kernel:
 	bne-	0b
 1:
 
-#ifdef CONFIG_PREEMPT
+#ifdef CONFIG_PREEMPTION
 	/* Check if we need to preempt */
+	lwz	r8,TI_PREEMPT(r9)
+	cmpwi	0,r8,0		/* if non-zero, just restore regs and return */
+	bne	restore
 	andi.	r0,r4,_TIF_NEED_RESCHED
+	bne+	check_count
+
+	andi.	r0,r4,_TIF_NEED_RESCHED_LAZY
 	beq+	restore
+	lwz	r8,TI_PREEMPT_LAZY(r9)
+
 	/* Check that preempt_count() == 0 and interrupts are enabled */
-	lwz	r8,TI_PREEMPT(r9)
+check_count:
 	cmpwi	cr0,r8,0
 	bne	restore
 	ld	r0,SOFTE(r1)
@@ -1158,7 +1166,7 @@ resume_kernel:
 	 * interrupted after loading SRR0/1.
 	 */
 	wrteei	0
-#endif /* CONFIG_PREEMPT */
+#endif /* CONFIG_PREEMPTION */
 
 restore:
 	/*
diff --git a/arch/powerpc/kernel/irq.c b/arch/powerpc/kernel/irq.c
index e8a548447dd6..5ad4f27cba10 100644
--- a/arch/powerpc/kernel/irq.c
+++ b/arch/powerpc/kernel/irq.c
@@ -753,10 +753,12 @@ void *mcheckirq_ctx[NR_CPUS] __read_mostly;
 void *softirq_ctx[NR_CPUS] __read_mostly;
 void *hardirq_ctx[NR_CPUS] __read_mostly;
 
+#ifndef CONFIG_PREEMPT_RT
 void do_softirq_own_stack(void)
 {
 	call_do_softirq(softirq_ctx[smp_processor_id()]);
 }
+#endif
 
 irq_hw_number_t virq_to_hw(unsigned int virq)
 {
diff --git a/arch/powerpc/kernel/misc_32.S b/arch/powerpc/kernel/misc_32.S
index 717e658b90fd..08ee95ad6593 100644
--- a/arch/powerpc/kernel/misc_32.S
+++ b/arch/powerpc/kernel/misc_32.S
@@ -31,6 +31,7 @@
  * We store the saved ksp_limit in the unused part
  * of the STACK_FRAME_OVERHEAD
  */
+#ifndef CONFIG_PREEMPT_RT
 _GLOBAL(call_do_softirq)
 	mflr	r0
 	stw	r0,4(r1)
@@ -46,6 +47,7 @@ _GLOBAL(call_do_softirq)
 	stw	r10,THREAD+KSP_LIMIT(r2)
 	mtlr	r0
 	blr
+#endif
 
 /*
  * void call_do_irq(struct pt_regs *regs, void *sp);
diff --git a/arch/powerpc/kernel/misc_64.S b/arch/powerpc/kernel/misc_64.S
index 070465825c21..a6b33f7b3264 100644
--- a/arch/powerpc/kernel/misc_64.S
+++ b/arch/powerpc/kernel/misc_64.S
@@ -27,6 +27,7 @@
 
 	.text
 
+#ifndef CONFIG_PREEMPT_RT
 _GLOBAL(call_do_softirq)
 	mflr	r0
 	std	r0,16(r1)
@@ -37,6 +38,7 @@ _GLOBAL(call_do_softirq)
 	ld	r0,16(r1)
 	mtlr	r0
 	blr
+#endif
 
 _GLOBAL(call_do_irq)
 	mflr	r0
diff --git a/arch/powerpc/kernel/nvram_64.c b/arch/powerpc/kernel/nvram_64.c
index 532f22637783..1ef55f4b389a 100644
--- a/arch/powerpc/kernel/nvram_64.c
+++ b/arch/powerpc/kernel/nvram_64.c
@@ -73,7 +73,8 @@ static const char *nvram_os_partitions[] = {
 };
 
 static void oops_to_nvram(struct kmsg_dumper *dumper,
-			  enum kmsg_dump_reason reason);
+			  enum kmsg_dump_reason reason,
+			  struct kmsg_dumper_iter *iter);
 
 static struct kmsg_dumper nvram_kmsg_dumper = {
 	.dump = oops_to_nvram
@@ -643,7 +644,8 @@ void __init nvram_init_oops_partition(int rtas_partition_exists)
  * partition.  If that's too much, go back and capture uncompressed text.
  */
 static void oops_to_nvram(struct kmsg_dumper *dumper,
-			  enum kmsg_dump_reason reason)
+			  enum kmsg_dump_reason reason,
+			  struct kmsg_dumper_iter *iter)
 {
 	struct oops_log_info *oops_hdr = (struct oops_log_info *)oops_buf;
 	static unsigned int oops_count = 0;
@@ -681,13 +683,13 @@ static void oops_to_nvram(struct kmsg_dumper *dumper,
 		return;
 
 	if (big_oops_buf) {
-		kmsg_dump_get_buffer(dumper, false,
+		kmsg_dump_get_buffer(iter, false,
 				     big_oops_buf, big_oops_buf_sz, &text_len);
 		rc = zip_oops(text_len);
 	}
 	if (rc != 0) {
-		kmsg_dump_rewind(dumper);
-		kmsg_dump_get_buffer(dumper, false,
+		kmsg_dump_rewind(iter);
+		kmsg_dump_get_buffer(iter, false,
 				     oops_data, oops_data_sz, &text_len);
 		err_type = ERR_TYPE_KERNEL_PANIC;
 		oops_hdr->version = cpu_to_be16(OOPS_HDR_VERSION);
diff --git a/arch/powerpc/kernel/syscall_64.c b/arch/powerpc/kernel/syscall_64.c
index 310bcd768cd5..ae3212dcf562 100644
--- a/arch/powerpc/kernel/syscall_64.c
+++ b/arch/powerpc/kernel/syscall_64.c
@@ -193,7 +193,7 @@ notrace unsigned long syscall_exit_prepare(unsigned long r3,
 	ti_flags = READ_ONCE(*ti_flagsp);
 	while (unlikely(ti_flags & (_TIF_USER_WORK_MASK & ~_TIF_RESTORE_TM))) {
 		local_irq_enable();
-		if (ti_flags & _TIF_NEED_RESCHED) {
+		if (ti_flags & _TIF_NEED_RESCHED_MASK) {
 			schedule();
 		} else {
 			/*
@@ -277,7 +277,7 @@ notrace unsigned long interrupt_exit_user_prepare(struct pt_regs *regs, unsigned
 	ti_flags = READ_ONCE(*ti_flagsp);
 	while (unlikely(ti_flags & (_TIF_USER_WORK_MASK & ~_TIF_RESTORE_TM))) {
 		local_irq_enable(); /* returning to user: may enable */
-		if (ti_flags & _TIF_NEED_RESCHED) {
+		if (ti_flags & _TIF_NEED_RESCHED_MASK) {
 			schedule();
 		} else {
 			if (ti_flags & _TIF_SIGPENDING)
@@ -361,11 +361,15 @@ notrace unsigned long interrupt_exit_kernel_prepare(struct pt_regs *regs, unsign
 		/* Returning to a kernel context with local irqs enabled. */
 		WARN_ON_ONCE(!(regs->msr & MSR_EE));
 again:
-		if (IS_ENABLED(CONFIG_PREEMPT)) {
+		if (IS_ENABLED(CONFIG_PREEMPTION)) {
 			/* Return to preemptible kernel context */
 			if (unlikely(*ti_flagsp & _TIF_NEED_RESCHED)) {
 				if (preempt_count() == 0)
 					preempt_schedule_irq();
+			} else if (unlikely(*ti_flagsp & _TIF_NEED_RESCHED_LAZY)) {
+				if ((preempt_count() == 0) &&
+				    (current_thread_info()->preempt_lazy_count == 0))
+					preempt_schedule_irq();
 			}
 		}
 
diff --git a/arch/powerpc/kernel/time.c b/arch/powerpc/kernel/time.c
index 1d20f0f77a92..7e0a497a36ee 100644
--- a/arch/powerpc/kernel/time.c
+++ b/arch/powerpc/kernel/time.c
@@ -312,12 +312,11 @@ static unsigned long vtime_delta_scaled(struct cpu_accounting_data *acct,
 	return stime_scaled;
 }
 
-static unsigned long vtime_delta(struct task_struct *tsk,
+static unsigned long vtime_delta(struct cpu_accounting_data *acct,
 				 unsigned long *stime_scaled,
 				 unsigned long *steal_time)
 {
 	unsigned long now, stime;
-	struct cpu_accounting_data *acct = get_accounting(tsk);
 
 	WARN_ON_ONCE(!irqs_disabled());
 
@@ -332,29 +331,30 @@ static unsigned long vtime_delta(struct task_struct *tsk,
 	return stime;
 }
 
+static void vtime_delta_kernel(struct cpu_accounting_data *acct,
+			       unsigned long *stime, unsigned long *stime_scaled)
+{
+	unsigned long steal_time;
+
+	*stime = vtime_delta(acct, stime_scaled, &steal_time);
+	*stime -= min(*stime, steal_time);
+	acct->steal_time += steal_time;
+}
+
 void vtime_account_kernel(struct task_struct *tsk)
 {
-	unsigned long stime, stime_scaled, steal_time;
 	struct cpu_accounting_data *acct = get_accounting(tsk);
+	unsigned long stime, stime_scaled;
 
-	stime = vtime_delta(tsk, &stime_scaled, &steal_time);
-
-	stime -= min(stime, steal_time);
-	acct->steal_time += steal_time;
+	vtime_delta_kernel(acct, &stime, &stime_scaled);
 
-	if ((tsk->flags & PF_VCPU) && !irq_count()) {
+	if (tsk->flags & PF_VCPU) {
 		acct->gtime += stime;
 #ifdef CONFIG_ARCH_HAS_SCALED_CPUTIME
 		acct->utime_scaled += stime_scaled;
 #endif
 	} else {
-		if (hardirq_count())
-			acct->hardirq_time += stime;
-		else if (in_serving_softirq())
-			acct->softirq_time += stime;
-		else
-			acct->stime += stime;
-
+		acct->stime += stime;
 #ifdef CONFIG_ARCH_HAS_SCALED_CPUTIME
 		acct->stime_scaled += stime_scaled;
 #endif
@@ -367,10 +367,34 @@ void vtime_account_idle(struct task_struct *tsk)
 	unsigned long stime, stime_scaled, steal_time;
 	struct cpu_accounting_data *acct = get_accounting(tsk);
 
-	stime = vtime_delta(tsk, &stime_scaled, &steal_time);
+	stime = vtime_delta(acct, &stime_scaled, &steal_time);
 	acct->idle_time += stime + steal_time;
 }
 
+static void vtime_account_irq_field(struct cpu_accounting_data *acct,
+				    unsigned long *field)
+{
+	unsigned long stime, stime_scaled;
+
+	vtime_delta_kernel(acct, &stime, &stime_scaled);
+	*field += stime;
+#ifdef CONFIG_ARCH_HAS_SCALED_CPUTIME
+	acct->stime_scaled += stime_scaled;
+#endif
+}
+
+void vtime_account_softirq(struct task_struct *tsk)
+{
+	struct cpu_accounting_data *acct = get_accounting(tsk);
+	vtime_account_irq_field(acct, &acct->softirq_time);
+}
+
+void vtime_account_hardirq(struct task_struct *tsk)
+{
+	struct cpu_accounting_data *acct = get_accounting(tsk);
+	vtime_account_irq_field(acct, &acct->hardirq_time);
+}
+
 static void vtime_flush_scaled(struct task_struct *tsk,
 			       struct cpu_accounting_data *acct)
 {
diff --git a/arch/powerpc/kernel/traps.c b/arch/powerpc/kernel/traps.c
index d2f6b2e30b6a..6a028453f587 100644
--- a/arch/powerpc/kernel/traps.c
+++ b/arch/powerpc/kernel/traps.c
@@ -173,7 +173,6 @@ extern void panic_flush_kmsg_start(void)
 
 extern void panic_flush_kmsg_end(void)
 {
-	printk_safe_flush_on_panic();
 	kmsg_dump(KMSG_DUMP_PANIC);
 	bust_spinlocks(0);
 	debug_locks_off();
@@ -263,12 +262,17 @@ static char *get_mmu_str(void)
 
 static int __die(const char *str, struct pt_regs *regs, long err)
 {
+	const char *pr = "";
+
 	printk("Oops: %s, sig: %ld [#%d]\n", str, err, ++die_counter);
 
+	if (IS_ENABLED(CONFIG_PREEMPTION))
+		pr = IS_ENABLED(CONFIG_PREEMPT_RT) ? " PREEMPT_RT" : " PREEMPT";
+
 	printk("%s PAGE_SIZE=%luK%s%s%s%s%s%s %s\n",
 	       IS_ENABLED(CONFIG_CPU_LITTLE_ENDIAN) ? "LE" : "BE",
 	       PAGE_SIZE / 1024, get_mmu_str(),
-	       IS_ENABLED(CONFIG_PREEMPT) ? " PREEMPT" : "",
+	       pr,
 	       IS_ENABLED(CONFIG_SMP) ? " SMP" : "",
 	       IS_ENABLED(CONFIG_SMP) ? (" NR_CPUS=" __stringify(NR_CPUS)) : "",
 	       debug_pagealloc_enabled() ? " DEBUG_PAGEALLOC" : "",
diff --git a/arch/powerpc/kernel/watchdog.c b/arch/powerpc/kernel/watchdog.c
index 75b2a6c4db5a..db40e20d0c54 100644
--- a/arch/powerpc/kernel/watchdog.c
+++ b/arch/powerpc/kernel/watchdog.c
@@ -185,11 +185,6 @@ static void watchdog_smp_panic(int cpu, u64 tb)
 
 	wd_smp_unlock(&flags);
 
-	printk_safe_flush();
-	/*
-	 * printk_safe_flush() seems to require another print
-	 * before anything actually goes out to console.
-	 */
 	if (sysctl_hardlockup_all_cpu_backtrace)
 		trigger_allbutself_cpu_backtrace();
 
diff --git a/arch/powerpc/kexec/crash.c b/arch/powerpc/kexec/crash.c
index c9a889880214..d488311efab1 100644
--- a/arch/powerpc/kexec/crash.c
+++ b/arch/powerpc/kexec/crash.c
@@ -311,9 +311,6 @@ void default_machine_crash_shutdown(struct pt_regs *regs)
 	unsigned int i;
 	int (*old_handler)(struct pt_regs *regs);
 
-	/* Avoid hardlocking with irresponsive CPU holding logbuf_lock */
-	printk_nmi_enter();
-
 	/*
 	 * This function is only called after the system
 	 * has panicked or is otherwise in a critical state.
diff --git a/arch/powerpc/kvm/Kconfig b/arch/powerpc/kvm/Kconfig
index 549591d9aaa2..efb5bfe93f70 100644
--- a/arch/powerpc/kvm/Kconfig
+++ b/arch/powerpc/kvm/Kconfig
@@ -178,6 +178,7 @@ config KVM_E500MC
 config KVM_MPIC
 	bool "KVM in-kernel MPIC emulation"
 	depends on KVM && E500
+	depends on !PREEMPT_RT
 	select HAVE_KVM_IRQCHIP
 	select HAVE_KVM_IRQFD
 	select HAVE_KVM_IRQ_ROUTING
diff --git a/arch/powerpc/mm/Makefile b/arch/powerpc/mm/Makefile
index 55b4a8bd408a..3b4e9e4e25ea 100644
--- a/arch/powerpc/mm/Makefile
+++ b/arch/powerpc/mm/Makefile
@@ -16,7 +16,6 @@ obj-$(CONFIG_NEED_MULTIPLE_NODES) += numa.o
 obj-$(CONFIG_PPC_MM_SLICES)	+= slice.o
 obj-$(CONFIG_HUGETLB_PAGE)	+= hugetlbpage.o
 obj-$(CONFIG_NOT_COHERENT_CACHE) += dma-noncoherent.o
-obj-$(CONFIG_HIGHMEM)		+= highmem.o
 obj-$(CONFIG_PPC_COPRO_BASE)	+= copro_fault.o
 obj-$(CONFIG_PPC_PTDUMP)	+= ptdump/
 obj-$(CONFIG_KASAN)		+= kasan/
diff --git a/arch/powerpc/mm/highmem.c b/arch/powerpc/mm/highmem.c
deleted file mode 100644
index 624b4438aff9..000000000000
--- a/arch/powerpc/mm/highmem.c
+++ /dev/null
@@ -1,67 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- * highmem.c: virtual kernel memory mappings for high memory
- *
- * PowerPC version, stolen from the i386 version.
- *
- * Used in CONFIG_HIGHMEM systems for memory pages which
- * are not addressable by direct kernel virtual addresses.
- *
- * Copyright (C) 1999 Gerhard Wichert, Siemens AG
- *		      Gerhard.Wichert@pdb.siemens.de
- *
- *
- * Redesigned the x86 32-bit VM architecture to deal with
- * up to 16 Terrabyte physical memory. With current x86 CPUs
- * we now support up to 64 Gigabytes physical RAM.
- *
- * Copyright (C) 1999 Ingo Molnar <mingo@redhat.com>
- *
- * Reworked for PowerPC by various contributors. Moved from
- * highmem.h by Benjamin Herrenschmidt (c) 2009 IBM Corp.
- */
-
-#include <linux/highmem.h>
-#include <linux/module.h>
-
-void *kmap_atomic_high_prot(struct page *page, pgprot_t prot)
-{
-	unsigned long vaddr;
-	int idx, type;
-
-	type = kmap_atomic_idx_push();
-	idx = type + KM_TYPE_NR*smp_processor_id();
-	vaddr = __fix_to_virt(FIX_KMAP_BEGIN + idx);
-	WARN_ON(IS_ENABLED(CONFIG_DEBUG_HIGHMEM) && !pte_none(*(kmap_pte - idx)));
-	__set_pte_at(&init_mm, vaddr, kmap_pte-idx, mk_pte(page, prot), 1);
-	local_flush_tlb_page(NULL, vaddr);
-
-	return (void*) vaddr;
-}
-EXPORT_SYMBOL(kmap_atomic_high_prot);
-
-void kunmap_atomic_high(void *kvaddr)
-{
-	unsigned long vaddr = (unsigned long) kvaddr & PAGE_MASK;
-
-	if (vaddr < __fix_to_virt(FIX_KMAP_END))
-		return;
-
-	if (IS_ENABLED(CONFIG_DEBUG_HIGHMEM)) {
-		int type = kmap_atomic_idx();
-		unsigned int idx;
-
-		idx = type + KM_TYPE_NR * smp_processor_id();
-		WARN_ON(vaddr != __fix_to_virt(FIX_KMAP_BEGIN + idx));
-
-		/*
-		 * force other mappings to Oops if they'll try to access
-		 * this pte without first remap it
-		 */
-		pte_clear(&init_mm, vaddr, kmap_pte-idx);
-		local_flush_tlb_page(NULL, vaddr);
-	}
-
-	kmap_atomic_idx_pop();
-}
-EXPORT_SYMBOL(kunmap_atomic_high);
diff --git a/arch/powerpc/mm/mem.c b/arch/powerpc/mm/mem.c
index 1ed276d2305f..ae7c136ed188 100644
--- a/arch/powerpc/mm/mem.c
+++ b/arch/powerpc/mm/mem.c
@@ -63,11 +63,6 @@
 unsigned long long memory_limit;
 bool init_mem_is_free;
 
-#ifdef CONFIG_HIGHMEM
-pte_t *kmap_pte;
-EXPORT_SYMBOL(kmap_pte);
-#endif
-
 pgprot_t phys_mem_access_prot(struct file *file, unsigned long pfn,
 			      unsigned long size, pgprot_t vma_prot)
 {
@@ -237,8 +232,6 @@ void __init paging_init(void)
 
 	map_kernel_page(PKMAP_BASE, 0, __pgprot(0));	/* XXX gross */
 	pkmap_page_table = virt_to_kpte(PKMAP_BASE);
-
-	kmap_pte = virt_to_kpte(__fix_to_virt(FIX_KMAP_BEGIN));
 #endif /* CONFIG_HIGHMEM */
 
 	printk(KERN_DEBUG "Top of RAM: 0x%llx, Total RAM: 0x%llx\n",
diff --git a/arch/powerpc/platforms/powernv/opal-kmsg.c b/arch/powerpc/platforms/powernv/opal-kmsg.c
index 6c3bc4b4da98..ec862846bc82 100644
--- a/arch/powerpc/platforms/powernv/opal-kmsg.c
+++ b/arch/powerpc/platforms/powernv/opal-kmsg.c
@@ -20,7 +20,8 @@
  * message, it just ensures that OPAL completely flushes the console buffer.
  */
 static void kmsg_dump_opal_console_flush(struct kmsg_dumper *dumper,
-				     enum kmsg_dump_reason reason)
+					 enum kmsg_dump_reason reason,
+					 struct kmsg_dumper_iter *iter)
 {
 	/*
 	 * Outside of a panic context the pollers will continue to run,
diff --git a/arch/powerpc/platforms/pseries/iommu.c b/arch/powerpc/platforms/pseries/iommu.c
index 245f1f8df656..f05555dde8e7 100644
--- a/arch/powerpc/platforms/pseries/iommu.c
+++ b/arch/powerpc/platforms/pseries/iommu.c
@@ -24,6 +24,7 @@
 #include <linux/of.h>
 #include <linux/iommu.h>
 #include <linux/rculist.h>
+#include <linux/local_lock.h>
 #include <asm/io.h>
 #include <asm/prom.h>
 #include <asm/rtas.h>
@@ -190,7 +191,13 @@ static int tce_build_pSeriesLP(unsigned long liobn, long tcenum, long tceshift,
 	return ret;
 }
 
-static DEFINE_PER_CPU(__be64 *, tce_page);
+struct tce_page {
+	__be64 * page;
+	local_lock_t lock;
+};
+static DEFINE_PER_CPU(struct tce_page, tce_page) = {
+	.lock = INIT_LOCAL_LOCK(lock),
+};
 
 static int tce_buildmulti_pSeriesLP(struct iommu_table *tbl, long tcenum,
 				     long npages, unsigned long uaddr,
@@ -212,9 +219,10 @@ static int tce_buildmulti_pSeriesLP(struct iommu_table *tbl, long tcenum,
 		                           direction, attrs);
 	}
 
-	local_irq_save(flags);	/* to protect tcep and the page behind it */
+	/* to protect tcep and the page behind it */
+	local_lock_irqsave(&tce_page.lock, flags);
 
-	tcep = __this_cpu_read(tce_page);
+	tcep = __this_cpu_read(tce_page.page);
 
 	/* This is safe to do since interrupts are off when we're called
 	 * from iommu_alloc{,_sg}()
@@ -223,12 +231,12 @@ static int tce_buildmulti_pSeriesLP(struct iommu_table *tbl, long tcenum,
 		tcep = (__be64 *)__get_free_page(GFP_ATOMIC);
 		/* If allocation fails, fall back to the loop implementation */
 		if (!tcep) {
-			local_irq_restore(flags);
+			local_unlock_irqrestore(&tce_page.lock, flags);
 			return tce_build_pSeriesLP(tbl->it_index, tcenum,
 					tbl->it_page_shift,
 					npages, uaddr, direction, attrs);
 		}
-		__this_cpu_write(tce_page, tcep);
+		__this_cpu_write(tce_page.page, tcep);
 	}
 
 	rpn = __pa(uaddr) >> TCE_SHIFT;
@@ -258,7 +266,7 @@ static int tce_buildmulti_pSeriesLP(struct iommu_table *tbl, long tcenum,
 		tcenum += limit;
 	} while (npages > 0 && !rc);
 
-	local_irq_restore(flags);
+	local_unlock_irqrestore(&tce_page.lock, flags);
 
 	if (unlikely(rc == H_NOT_ENOUGH_RESOURCES)) {
 		ret = (int)rc;
@@ -429,16 +437,17 @@ static int tce_setrange_multi_pSeriesLP(unsigned long start_pfn,
 				DMA_BIDIRECTIONAL, 0);
 	}
 
-	local_irq_disable();	/* to protect tcep and the page behind it */
-	tcep = __this_cpu_read(tce_page);
+	/* to protect tcep and the page behind it */
+	local_lock_irq(&tce_page.lock);
+	tcep = __this_cpu_read(tce_page.page);
 
 	if (!tcep) {
 		tcep = (__be64 *)__get_free_page(GFP_ATOMIC);
 		if (!tcep) {
-			local_irq_enable();
+			local_unlock_irq(&tce_page.lock);
 			return -ENOMEM;
 		}
-		__this_cpu_write(tce_page, tcep);
+		__this_cpu_write(tce_page.page, tcep);
 	}
 
 	proto_tce = TCE_PCI_READ | TCE_PCI_WRITE;
@@ -481,7 +490,7 @@ static int tce_setrange_multi_pSeriesLP(unsigned long start_pfn,
 
 	/* error cleanup: caller will clear whole range */
 
-	local_irq_enable();
+	local_unlock_irq(&tce_page.lock);
 	return rc;
 }
 
diff --git a/arch/powerpc/xmon/xmon.c b/arch/powerpc/xmon/xmon.c
index 5559edf36756..d62b8e053d4c 100644
--- a/arch/powerpc/xmon/xmon.c
+++ b/arch/powerpc/xmon/xmon.c
@@ -3005,7 +3005,7 @@ print_address(unsigned long addr)
 static void
 dump_log_buf(void)
 {
-	struct kmsg_dumper dumper = { .active = 1 };
+	struct kmsg_dumper_iter iter = { .active = 1 };
 	unsigned char buf[128];
 	size_t len;
 
@@ -3017,9 +3017,9 @@ dump_log_buf(void)
 	catch_memory_errors = 1;
 	sync();
 
-	kmsg_dump_rewind_nolock(&dumper);
+	kmsg_dump_rewind(&iter);
 	xmon_start_pagination();
-	while (kmsg_dump_get_line_nolock(&dumper, false, buf, sizeof(buf), &len)) {
+	while (kmsg_dump_get_line(&iter, false, buf, sizeof(buf), &len)) {
 		buf[len] = '\0';
 		printf("%s", buf);
 	}
diff --git a/arch/s390/Kconfig b/arch/s390/Kconfig
index 7461318e10fb..517cbf60335f 100644
--- a/arch/s390/Kconfig
+++ b/arch/s390/Kconfig
@@ -183,6 +183,7 @@ config S390
 	select HAVE_RSEQ
 	select HAVE_SYSCALL_TRACEPOINTS
 	select HAVE_VIRT_CPU_ACCOUNTING
+	select HAVE_VIRT_CPU_ACCOUNTING_IDLE
 	select IOMMU_HELPER		if PCI
 	select IOMMU_SUPPORT		if PCI
 	select MODULES_USE_ELF_RELA
diff --git a/arch/s390/include/asm/spinlock_types.h b/arch/s390/include/asm/spinlock_types.h
index cfed272e4fd5..8e28e8176ec8 100644
--- a/arch/s390/include/asm/spinlock_types.h
+++ b/arch/s390/include/asm/spinlock_types.h
@@ -2,10 +2,6 @@
 #ifndef __ASM_SPINLOCK_TYPES_H
 #define __ASM_SPINLOCK_TYPES_H
 
-#ifndef __LINUX_SPINLOCK_TYPES_H
-# error "please don't include this file directly"
-#endif
-
 typedef struct {
 	int lock;
 } __attribute__ ((aligned (4))) arch_spinlock_t;
diff --git a/arch/s390/include/asm/vtime.h b/arch/s390/include/asm/vtime.h
index 3622d4ebc73a..fac6a67988eb 100644
--- a/arch/s390/include/asm/vtime.h
+++ b/arch/s390/include/asm/vtime.h
@@ -2,7 +2,6 @@
 #ifndef _S390_VTIME_H
 #define _S390_VTIME_H
 
-#define __ARCH_HAS_VTIME_ACCOUNT
 #define __ARCH_HAS_VTIME_TASK_SWITCH
 
 #endif /* _S390_VTIME_H */
diff --git a/arch/s390/kernel/vtime.c b/arch/s390/kernel/vtime.c
index 579ec3a8c816..9b3c5978b668 100644
--- a/arch/s390/kernel/vtime.c
+++ b/arch/s390/kernel/vtime.c
@@ -223,35 +223,50 @@ void vtime_flush(struct task_struct *tsk)
 	S390_lowcore.avg_steal_timer = avg_steal;
 }
 
+static u64 vtime_delta(void)
+{
+	u64 timer = S390_lowcore.last_update_timer;
+
+	S390_lowcore.last_update_timer = get_vtimer();
+
+	return timer - S390_lowcore.last_update_timer;
+}
+
 /*
  * Update process times based on virtual cpu times stored by entry.S
  * to the lowcore fields user_timer, system_timer & steal_clock.
  */
-void vtime_account_irq_enter(struct task_struct *tsk)
+void vtime_account_kernel(struct task_struct *tsk)
 {
-	u64 timer;
-
-	timer = S390_lowcore.last_update_timer;
-	S390_lowcore.last_update_timer = get_vtimer();
-	timer -= S390_lowcore.last_update_timer;
+	u64 delta = vtime_delta();
 
-	if ((tsk->flags & PF_VCPU) && (irq_count() == 0))
-		S390_lowcore.guest_timer += timer;
-	else if (hardirq_count())
-		S390_lowcore.hardirq_timer += timer;
-	else if (in_serving_softirq())
-		S390_lowcore.softirq_timer += timer;
+	if (tsk->flags & PF_VCPU)
+		S390_lowcore.guest_timer += delta;
 	else
-		S390_lowcore.system_timer += timer;
+		S390_lowcore.system_timer += delta;
 
-	virt_timer_forward(timer);
+	virt_timer_forward(delta);
 }
-EXPORT_SYMBOL_GPL(vtime_account_irq_enter);
-
-void vtime_account_kernel(struct task_struct *tsk)
-__attribute__((alias("vtime_account_irq_enter")));
 EXPORT_SYMBOL_GPL(vtime_account_kernel);
 
+void vtime_account_softirq(struct task_struct *tsk)
+{
+	u64 delta = vtime_delta();
+
+	S390_lowcore.softirq_timer += delta;
+
+	virt_timer_forward(delta);
+}
+
+void vtime_account_hardirq(struct task_struct *tsk)
+{
+	u64 delta = vtime_delta();
+
+	S390_lowcore.hardirq_timer += delta;
+
+	virt_timer_forward(delta);
+}
+
 /*
  * Sorted add to a list. List is linear searched until first bigger
  * element is found.
diff --git a/arch/sh/include/asm/fixmap.h b/arch/sh/include/asm/fixmap.h
index f38adc189b83..b07fbc7f7bc6 100644
--- a/arch/sh/include/asm/fixmap.h
+++ b/arch/sh/include/asm/fixmap.h
@@ -13,9 +13,6 @@
 #include <linux/kernel.h>
 #include <linux/threads.h>
 #include <asm/page.h>
-#ifdef CONFIG_HIGHMEM
-#include <asm/kmap_types.h>
-#endif
 
 /*
  * Here we define all the compile-time 'special' virtual
@@ -53,11 +50,6 @@ enum fixed_addresses {
 	FIX_CMAP_BEGIN,
 	FIX_CMAP_END = FIX_CMAP_BEGIN + (FIX_N_COLOURS * NR_CPUS) - 1,
 
-#ifdef CONFIG_HIGHMEM
-	FIX_KMAP_BEGIN,	/* reserved pte's for temporary kernel mappings */
-	FIX_KMAP_END = FIX_KMAP_BEGIN + (KM_TYPE_NR * NR_CPUS) - 1,
-#endif
-
 #ifdef CONFIG_IOREMAP_FIXED
 	/*
 	 * FIX_IOREMAP entries are useful for mapping physical address
diff --git a/arch/sh/include/asm/hardirq.h b/arch/sh/include/asm/hardirq.h
index edaea3559a23..9fe4495a8e90 100644
--- a/arch/sh/include/asm/hardirq.h
+++ b/arch/sh/include/asm/hardirq.h
@@ -2,16 +2,10 @@
 #ifndef __ASM_SH_HARDIRQ_H
 #define __ASM_SH_HARDIRQ_H
 
-#include <linux/threads.h>
-#include <linux/irq.h>
-
-typedef struct {
-	unsigned int __softirq_pending;
-	unsigned int __nmi_count;		/* arch dependent */
-} ____cacheline_aligned irq_cpustat_t;
-
-#include <linux/irq_cpustat.h>	/* Standard mappings for irq_cpustat_t above */
-
 extern void ack_bad_irq(unsigned int irq);
+#define ack_bad_irq ack_bad_irq
+#define ARCH_WANTS_NMI_IRQSTAT
+
+#include <asm-generic/hardirq.h>
 
 #endif /* __ASM_SH_HARDIRQ_H */
diff --git a/arch/sh/include/asm/kmap_types.h b/arch/sh/include/asm/kmap_types.h
deleted file mode 100644
index b78107f923dd..000000000000
--- a/arch/sh/include/asm/kmap_types.h
+++ /dev/null
@@ -1,15 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-#ifndef __SH_KMAP_TYPES_H
-#define __SH_KMAP_TYPES_H
-
-/* Dummy header just to define km_type. */
-
-#ifdef CONFIG_DEBUG_HIGHMEM
-#define  __WITH_KM_FENCE
-#endif
-
-#include <asm-generic/kmap_types.h>
-
-#undef __WITH_KM_FENCE
-
-#endif
diff --git a/arch/sh/include/asm/spinlock_types.h b/arch/sh/include/asm/spinlock_types.h
index e82369f286a2..22ca9a98bbb8 100644
--- a/arch/sh/include/asm/spinlock_types.h
+++ b/arch/sh/include/asm/spinlock_types.h
@@ -2,10 +2,6 @@
 #ifndef __ASM_SH_SPINLOCK_TYPES_H
 #define __ASM_SH_SPINLOCK_TYPES_H
 
-#ifndef __LINUX_SPINLOCK_TYPES_H
-# error "please don't include this file directly"
-#endif
-
 typedef struct {
 	volatile unsigned int lock;
 } arch_spinlock_t;
diff --git a/arch/sh/kernel/irq.c b/arch/sh/kernel/irq.c
index 5717c7cbdd97..5db7af565dec 100644
--- a/arch/sh/kernel/irq.c
+++ b/arch/sh/kernel/irq.c
@@ -44,7 +44,7 @@ int arch_show_interrupts(struct seq_file *p, int prec)
 
 	seq_printf(p, "%*s: ", prec, "NMI");
 	for_each_online_cpu(j)
-		seq_printf(p, "%10u ", nmi_count(j));
+		seq_printf(p, "%10u ", per_cpu(irq_stat.__nmi_count, j));
 	seq_printf(p, "  Non-maskable interrupts\n");
 
 	seq_printf(p, "%*s: %10u\n", prec, "ERR", atomic_read(&irq_err_count));
@@ -148,6 +148,7 @@ void irq_ctx_exit(int cpu)
 	hardirq_ctx[cpu] = NULL;
 }
 
+#ifndef CONFIG_PREEMPT_RT
 void do_softirq_own_stack(void)
 {
 	struct thread_info *curctx;
@@ -175,6 +176,7 @@ void do_softirq_own_stack(void)
 		  "r5", "r6", "r7", "r8", "r9", "r15", "t", "pr"
 	);
 }
+#endif
 #else
 static inline void handle_one_irq(unsigned int irq)
 {
diff --git a/arch/sh/kernel/traps.c b/arch/sh/kernel/traps.c
index 9c3d32b80038..f5beecdac693 100644
--- a/arch/sh/kernel/traps.c
+++ b/arch/sh/kernel/traps.c
@@ -186,7 +186,7 @@ BUILD_TRAP_HANDLER(nmi)
 	arch_ftrace_nmi_enter();
 
 	nmi_enter();
-	nmi_count(cpu)++;
+	this_cpu_inc(irq_stat.__nmi_count);
 
 	switch (notify_die(DIE_NMI, "NMI", regs, 0, vec & 0xff, SIGINT)) {
 	case NOTIFY_OK:
diff --git a/arch/sh/mm/init.c b/arch/sh/mm/init.c
index 3348e0c4d769..0db6919af8d3 100644
--- a/arch/sh/mm/init.c
+++ b/arch/sh/mm/init.c
@@ -362,9 +362,6 @@ void __init mem_init(void)
 	mem_init_print_info(NULL);
 	pr_info("virtual kernel memory layout:\n"
 		"    fixmap  : 0x%08lx - 0x%08lx   (%4ld kB)\n"
-#ifdef CONFIG_HIGHMEM
-		"    pkmap   : 0x%08lx - 0x%08lx   (%4ld kB)\n"
-#endif
 		"    vmalloc : 0x%08lx - 0x%08lx   (%4ld MB)\n"
 		"    lowmem  : 0x%08lx - 0x%08lx   (%4ld MB) (cached)\n"
 #ifdef CONFIG_UNCACHED_MAPPING
@@ -376,11 +373,6 @@ void __init mem_init(void)
 		FIXADDR_START, FIXADDR_TOP,
 		(FIXADDR_TOP - FIXADDR_START) >> 10,
 
-#ifdef CONFIG_HIGHMEM
-		PKMAP_BASE, PKMAP_BASE+LAST_PKMAP*PAGE_SIZE,
-		(LAST_PKMAP*PAGE_SIZE) >> 10,
-#endif
-
 		(unsigned long)VMALLOC_START, VMALLOC_END,
 		(VMALLOC_END - VMALLOC_START) >> 20,
 
diff --git a/arch/sparc/Kconfig b/arch/sparc/Kconfig
index 530b7ec5d3ca..a38d00d8b783 100644
--- a/arch/sparc/Kconfig
+++ b/arch/sparc/Kconfig
@@ -139,6 +139,7 @@ config MMU
 config HIGHMEM
 	bool
 	default y if SPARC32
+	select KMAP_LOCAL
 
 config ZONE_DMA
 	bool
diff --git a/arch/sparc/include/asm/highmem.h b/arch/sparc/include/asm/highmem.h
index 6c35f0d27ee1..875116209ec1 100644
--- a/arch/sparc/include/asm/highmem.h
+++ b/arch/sparc/include/asm/highmem.h
@@ -24,7 +24,6 @@
 #include <linux/interrupt.h>
 #include <linux/pgtable.h>
 #include <asm/vaddrs.h>
-#include <asm/kmap_types.h>
 #include <asm/pgtsrmmu.h>
 
 /* declarations for highmem.c */
@@ -33,8 +32,6 @@ extern unsigned long highstart_pfn, highend_pfn;
 #define kmap_prot __pgprot(SRMMU_ET_PTE | SRMMU_PRIV | SRMMU_CACHE)
 extern pte_t *pkmap_page_table;
 
-void kmap_init(void) __init;
-
 /*
  * Right now we initialize only a single pte table. It can be extended
  * easily, subsequent pte tables have to be allocated in one physical
@@ -53,6 +50,11 @@ void kmap_init(void) __init;
 
 #define flush_cache_kmaps()	flush_cache_all()
 
+/* FIXME: Use __flush_tlb_one(vaddr) instead of flush_cache_all() -- Anton */
+#define arch_kmap_local_post_map(vaddr, pteval)	flush_cache_all()
+#define arch_kmap_local_post_unmap(vaddr)	flush_cache_all()
+
+
 #endif /* __KERNEL__ */
 
 #endif /* _ASM_HIGHMEM_H */
diff --git a/arch/sparc/include/asm/kmap_types.h b/arch/sparc/include/asm/kmap_types.h
deleted file mode 100644
index 55a99b6bd91e..000000000000
--- a/arch/sparc/include/asm/kmap_types.h
+++ /dev/null
@@ -1,11 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-#ifndef _ASM_KMAP_TYPES_H
-#define _ASM_KMAP_TYPES_H
-
-/* Dummy header just to define km_type.  None of this
- * is actually used on sparc.  -DaveM
- */
-
-#include <asm-generic/kmap_types.h>
-
-#endif
diff --git a/arch/sparc/include/asm/vaddrs.h b/arch/sparc/include/asm/vaddrs.h
index 84d054b07a6f..4fec0341e2a8 100644
--- a/arch/sparc/include/asm/vaddrs.h
+++ b/arch/sparc/include/asm/vaddrs.h
@@ -32,13 +32,13 @@
 #define SRMMU_NOCACHE_ALCRATIO	64	/* 256 pages per 64MB of system RAM */
 
 #ifndef __ASSEMBLY__
-#include <asm/kmap_types.h>
+#include <asm/kmap_size.h>
 
 enum fixed_addresses {
 	FIX_HOLE,
 #ifdef CONFIG_HIGHMEM
 	FIX_KMAP_BEGIN,
-	FIX_KMAP_END = (KM_TYPE_NR * NR_CPUS),
+	FIX_KMAP_END = (KM_MAX_IDX * NR_CPUS),
 #endif
 	__end_of_fixed_addresses
 };
diff --git a/arch/sparc/kernel/irq_64.c b/arch/sparc/kernel/irq_64.c
index 3ec9f1402aad..eb21682abfcb 100644
--- a/arch/sparc/kernel/irq_64.c
+++ b/arch/sparc/kernel/irq_64.c
@@ -854,6 +854,7 @@ void __irq_entry handler_irq(int pil, struct pt_regs *regs)
 	set_irq_regs(old_regs);
 }
 
+#ifndef CONFIG_PREEMPT_RT
 void do_softirq_own_stack(void)
 {
 	void *orig_sp, *sp = softirq_stack[smp_processor_id()];
@@ -868,6 +869,7 @@ void do_softirq_own_stack(void)
 	__asm__ __volatile__("mov %0, %%sp"
 			     : : "r" (orig_sp));
 }
+#endif
 
 #ifdef CONFIG_HOTPLUG_CPU
 void fixup_irqs(void)
diff --git a/arch/sparc/mm/Makefile b/arch/sparc/mm/Makefile
index b078205b70e0..68db1f859b02 100644
--- a/arch/sparc/mm/Makefile
+++ b/arch/sparc/mm/Makefile
@@ -15,6 +15,3 @@ obj-$(CONFIG_SPARC32)   += leon_mm.o
 
 # Only used by sparc64
 obj-$(CONFIG_HUGETLB_PAGE) += hugetlbpage.o
-
-# Only used by sparc32
-obj-$(CONFIG_HIGHMEM)   += highmem.o
diff --git a/arch/sparc/mm/highmem.c b/arch/sparc/mm/highmem.c
deleted file mode 100644
index 8f2a2afb048a..000000000000
--- a/arch/sparc/mm/highmem.c
+++ /dev/null
@@ -1,115 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- *  highmem.c: virtual kernel memory mappings for high memory
- *
- *  Provides kernel-static versions of atomic kmap functions originally
- *  found as inlines in include/asm-sparc/highmem.h.  These became
- *  needed as kmap_atomic() and kunmap_atomic() started getting
- *  called from within modules.
- *  -- Tomas Szepe <szepe@pinerecords.com>, September 2002
- *
- *  But kmap_atomic() and kunmap_atomic() cannot be inlined in
- *  modules because they are loaded with btfixup-ped functions.
- */
-
-/*
- * The use of kmap_atomic/kunmap_atomic is discouraged - kmap/kunmap
- * gives a more generic (and caching) interface. But kmap_atomic can
- * be used in IRQ contexts, so in some (very limited) cases we need it.
- *
- * XXX This is an old text. Actually, it's good to use atomic kmaps,
- * provided you remember that they are atomic and not try to sleep
- * with a kmap taken, much like a spinlock. Non-atomic kmaps are
- * shared by CPUs, and so precious, and establishing them requires IPI.
- * Atomic kmaps are lightweight and we may have NCPUS more of them.
- */
-#include <linux/highmem.h>
-#include <linux/export.h>
-#include <linux/mm.h>
-
-#include <asm/cacheflush.h>
-#include <asm/tlbflush.h>
-#include <asm/vaddrs.h>
-
-static pte_t *kmap_pte;
-
-void __init kmap_init(void)
-{
-	unsigned long address = __fix_to_virt(FIX_KMAP_BEGIN);
-
-        /* cache the first kmap pte */
-        kmap_pte = virt_to_kpte(address);
-}
-
-void *kmap_atomic_high_prot(struct page *page, pgprot_t prot)
-{
-	unsigned long vaddr;
-	long idx, type;
-
-	type = kmap_atomic_idx_push();
-	idx = type + KM_TYPE_NR*smp_processor_id();
-	vaddr = __fix_to_virt(FIX_KMAP_BEGIN + idx);
-
-/* XXX Fix - Anton */
-#if 0
-	__flush_cache_one(vaddr);
-#else
-	flush_cache_all();
-#endif
-
-#ifdef CONFIG_DEBUG_HIGHMEM
-	BUG_ON(!pte_none(*(kmap_pte-idx)));
-#endif
-	set_pte(kmap_pte-idx, mk_pte(page, prot));
-/* XXX Fix - Anton */
-#if 0
-	__flush_tlb_one(vaddr);
-#else
-	flush_tlb_all();
-#endif
-
-	return (void*) vaddr;
-}
-EXPORT_SYMBOL(kmap_atomic_high_prot);
-
-void kunmap_atomic_high(void *kvaddr)
-{
-	unsigned long vaddr = (unsigned long) kvaddr & PAGE_MASK;
-	int type;
-
-	if (vaddr < FIXADDR_START)
-		return;
-
-	type = kmap_atomic_idx();
-
-#ifdef CONFIG_DEBUG_HIGHMEM
-	{
-		unsigned long idx;
-
-		idx = type + KM_TYPE_NR * smp_processor_id();
-		BUG_ON(vaddr != __fix_to_virt(FIX_KMAP_BEGIN+idx));
-
-		/* XXX Fix - Anton */
-#if 0
-		__flush_cache_one(vaddr);
-#else
-		flush_cache_all();
-#endif
-
-		/*
-		 * force other mappings to Oops if they'll try to access
-		 * this pte without first remap it
-		 */
-		pte_clear(&init_mm, vaddr, kmap_pte-idx);
-		/* XXX Fix - Anton */
-#if 0
-		__flush_tlb_one(vaddr);
-#else
-		flush_tlb_all();
-#endif
-	}
-#endif
-
-	kmap_atomic_idx_pop();
-}
-EXPORT_SYMBOL(kunmap_atomic_high);
diff --git a/arch/sparc/mm/srmmu.c b/arch/sparc/mm/srmmu.c
index 0070f8b9a753..a03caa5f6628 100644
--- a/arch/sparc/mm/srmmu.c
+++ b/arch/sparc/mm/srmmu.c
@@ -971,8 +971,6 @@ void __init srmmu_paging_init(void)
 
 	sparc_context_init(num_contexts);
 
-	kmap_init();
-
 	{
 		unsigned long max_zone_pfn[MAX_NR_ZONES] = { 0 };
 
diff --git a/arch/um/include/asm/fixmap.h b/arch/um/include/asm/fixmap.h
index 2c697a145ac1..2efac5827188 100644
--- a/arch/um/include/asm/fixmap.h
+++ b/arch/um/include/asm/fixmap.h
@@ -3,7 +3,6 @@
 #define __UM_FIXMAP_H
 
 #include <asm/processor.h>
-#include <asm/kmap_types.h>
 #include <asm/archparam.h>
 #include <asm/page.h>
 #include <linux/threads.h>
diff --git a/arch/um/include/asm/hardirq.h b/arch/um/include/asm/hardirq.h
index b426796d26fd..52e2c36267a9 100644
--- a/arch/um/include/asm/hardirq.h
+++ b/arch/um/include/asm/hardirq.h
@@ -2,22 +2,7 @@
 #ifndef __ASM_UM_HARDIRQ_H
 #define __ASM_UM_HARDIRQ_H
 
-#include <linux/cache.h>
-#include <linux/threads.h>
-
-typedef struct {
-	unsigned int __softirq_pending;
-} ____cacheline_aligned irq_cpustat_t;
-
-#include <linux/irq_cpustat.h>	/* Standard mappings for irq_cpustat_t above */
-#include <linux/irq.h>
-
-#ifndef ack_bad_irq
-static inline void ack_bad_irq(unsigned int irq)
-{
-	printk(KERN_CRIT "unexpected IRQ trap at vector %02x\n", irq);
-}
-#endif
+#include <asm-generic/hardirq.h>
 
 #define __ARCH_IRQ_EXIT_IRQS_DISABLED 1
 
diff --git a/arch/um/include/asm/kmap_types.h b/arch/um/include/asm/kmap_types.h
deleted file mode 100644
index b0bd12de1d23..000000000000
--- a/arch/um/include/asm/kmap_types.h
+++ /dev/null
@@ -1,13 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-/* 
- * Copyright (C) 2002 Jeff Dike (jdike@karaya.com)
- */
-
-#ifndef __UM_KMAP_TYPES_H
-#define __UM_KMAP_TYPES_H
-
-/* No more #include "asm/arch/kmap_types.h" ! */
-
-#define KM_TYPE_NR 14
-
-#endif
diff --git a/arch/um/kernel/kmsg_dump.c b/arch/um/kernel/kmsg_dump.c
index e4abac6c9727..173999422ed8 100644
--- a/arch/um/kernel/kmsg_dump.c
+++ b/arch/um/kernel/kmsg_dump.c
@@ -1,15 +1,19 @@
 // SPDX-License-Identifier: GPL-2.0
 #include <linux/kmsg_dump.h>
+#include <linux/spinlock.h>
 #include <linux/console.h>
 #include <shared/init.h>
 #include <shared/kern.h>
 #include <os.h>
 
 static void kmsg_dumper_stdout(struct kmsg_dumper *dumper,
-				enum kmsg_dump_reason reason)
+				enum kmsg_dump_reason reason,
+				struct kmsg_dumper_iter *iter)
 {
+	static DEFINE_SPINLOCK(lock);
 	static char line[1024];
 	struct console *con;
+	unsigned long flags;
 	size_t len = 0;
 
 	/* only dump kmsg when no console is available */
@@ -24,11 +28,16 @@ static void kmsg_dumper_stdout(struct kmsg_dumper *dumper,
 	if (con)
 		return;
 
+	if (!spin_trylock_irqsave(&lock, flags))
+		return;
+
 	printf("kmsg_dump:\n");
-	while (kmsg_dump_get_line(dumper, true, line, sizeof(line), &len)) {
+	while (kmsg_dump_get_line(iter, true, line, sizeof(line), &len)) {
 		line[len] = '\0';
 		printf("%s", line);
 	}
+
+	spin_unlock_irqrestore(&lock, flags);
 }
 
 static struct kmsg_dumper kmsg_dumper = {
diff --git a/arch/x86/Kconfig b/arch/x86/Kconfig
index 7e53f43447b4..521c550aa7d7 100644
--- a/arch/x86/Kconfig
+++ b/arch/x86/Kconfig
@@ -16,6 +16,7 @@ config X86_32
 	select CLKSRC_I8253
 	select CLONE_BACKWARDS
 	select HAVE_DEBUG_STACKOVERFLOW
+	select KMAP_LOCAL
 	select MODULES_USE_ELF_REL
 	select OLD_SIGACTION
 	select GENERIC_VDSO_32
@@ -95,6 +96,7 @@ config X86
 	select ARCH_SUPPORTS_ACPI
 	select ARCH_SUPPORTS_ATOMIC_RMW
 	select ARCH_SUPPORTS_NUMA_BALANCING	if X86_64
+	select ARCH_SUPPORTS_RT
 	select ARCH_USE_BUILTIN_BSWAP
 	select ARCH_USE_QUEUED_RWLOCKS
 	select ARCH_USE_QUEUED_SPINLOCKS
@@ -219,6 +221,7 @@ config X86
 	select HAVE_PCI
 	select HAVE_PERF_REGS
 	select HAVE_PERF_USER_STACK_DUMP
+	select HAVE_PREEMPT_LAZY
 	select MMU_GATHER_RCU_TABLE_FREE		if PARAVIRT
 	select HAVE_POSIX_CPU_TIMERS_TASK_WORK
 	select HAVE_REGS_AND_STACK_ACCESS_API
diff --git a/arch/x86/crypto/aesni-intel_glue.c b/arch/x86/crypto/aesni-intel_glue.c
index be891fdf8d17..29c716ed103f 100644
--- a/arch/x86/crypto/aesni-intel_glue.c
+++ b/arch/x86/crypto/aesni-intel_glue.c
@@ -379,14 +379,14 @@ static int ecb_encrypt(struct skcipher_request *req)
 
 	err = skcipher_walk_virt(&walk, req, true);
 
-	kernel_fpu_begin();
 	while ((nbytes = walk.nbytes)) {
+		kernel_fpu_begin();
 		aesni_ecb_enc(ctx, walk.dst.virt.addr, walk.src.virt.addr,
 			      nbytes & AES_BLOCK_MASK);
+		kernel_fpu_end();
 		nbytes &= AES_BLOCK_SIZE - 1;
 		err = skcipher_walk_done(&walk, nbytes);
 	}
-	kernel_fpu_end();
 
 	return err;
 }
@@ -401,14 +401,14 @@ static int ecb_decrypt(struct skcipher_request *req)
 
 	err = skcipher_walk_virt(&walk, req, true);
 
-	kernel_fpu_begin();
 	while ((nbytes = walk.nbytes)) {
+		kernel_fpu_begin();
 		aesni_ecb_dec(ctx, walk.dst.virt.addr, walk.src.virt.addr,
 			      nbytes & AES_BLOCK_MASK);
+		kernel_fpu_end();
 		nbytes &= AES_BLOCK_SIZE - 1;
 		err = skcipher_walk_done(&walk, nbytes);
 	}
-	kernel_fpu_end();
 
 	return err;
 }
@@ -423,14 +423,14 @@ static int cbc_encrypt(struct skcipher_request *req)
 
 	err = skcipher_walk_virt(&walk, req, true);
 
-	kernel_fpu_begin();
 	while ((nbytes = walk.nbytes)) {
+		kernel_fpu_begin();
 		aesni_cbc_enc(ctx, walk.dst.virt.addr, walk.src.virt.addr,
 			      nbytes & AES_BLOCK_MASK, walk.iv);
+		kernel_fpu_end();
 		nbytes &= AES_BLOCK_SIZE - 1;
 		err = skcipher_walk_done(&walk, nbytes);
 	}
-	kernel_fpu_end();
 
 	return err;
 }
@@ -445,14 +445,14 @@ static int cbc_decrypt(struct skcipher_request *req)
 
 	err = skcipher_walk_virt(&walk, req, true);
 
-	kernel_fpu_begin();
 	while ((nbytes = walk.nbytes)) {
+		kernel_fpu_begin();
 		aesni_cbc_dec(ctx, walk.dst.virt.addr, walk.src.virt.addr,
 			      nbytes & AES_BLOCK_MASK, walk.iv);
+		kernel_fpu_end();
 		nbytes &= AES_BLOCK_SIZE - 1;
 		err = skcipher_walk_done(&walk, nbytes);
 	}
-	kernel_fpu_end();
 
 	return err;
 }
@@ -500,18 +500,20 @@ static int ctr_crypt(struct skcipher_request *req)
 
 	err = skcipher_walk_virt(&walk, req, true);
 
-	kernel_fpu_begin();
 	while ((nbytes = walk.nbytes) >= AES_BLOCK_SIZE) {
+		kernel_fpu_begin();
 		aesni_ctr_enc_tfm(ctx, walk.dst.virt.addr, walk.src.virt.addr,
 			              nbytes & AES_BLOCK_MASK, walk.iv);
+		kernel_fpu_end();
 		nbytes &= AES_BLOCK_SIZE - 1;
 		err = skcipher_walk_done(&walk, nbytes);
 	}
 	if (walk.nbytes) {
+		kernel_fpu_begin();
 		ctr_crypt_final(ctx, &walk);
+		kernel_fpu_end();
 		err = skcipher_walk_done(&walk, 0);
 	}
-	kernel_fpu_end();
 
 	return err;
 }
diff --git a/arch/x86/crypto/cast5_avx_glue.c b/arch/x86/crypto/cast5_avx_glue.c
index 384ccb00f9e1..2f8df8ef8644 100644
--- a/arch/x86/crypto/cast5_avx_glue.c
+++ b/arch/x86/crypto/cast5_avx_glue.c
@@ -46,7 +46,7 @@ static inline void cast5_fpu_end(bool fpu_enabled)
 
 static int ecb_crypt(struct skcipher_request *req, bool enc)
 {
-	bool fpu_enabled = false;
+	bool fpu_enabled;
 	struct crypto_skcipher *tfm = crypto_skcipher_reqtfm(req);
 	struct cast5_ctx *ctx = crypto_skcipher_ctx(tfm);
 	struct skcipher_walk walk;
@@ -61,7 +61,7 @@ static int ecb_crypt(struct skcipher_request *req, bool enc)
 		u8 *wsrc = walk.src.virt.addr;
 		u8 *wdst = walk.dst.virt.addr;
 
-		fpu_enabled = cast5_fpu_begin(fpu_enabled, &walk, nbytes);
+		fpu_enabled = cast5_fpu_begin(false, &walk, nbytes);
 
 		/* Process multi-block batch */
 		if (nbytes >= bsize * CAST5_PARALLEL_BLOCKS) {
@@ -90,10 +90,9 @@ static int ecb_crypt(struct skcipher_request *req, bool enc)
 		} while (nbytes >= bsize);
 
 done:
+		cast5_fpu_end(fpu_enabled);
 		err = skcipher_walk_done(&walk, nbytes);
 	}
-
-	cast5_fpu_end(fpu_enabled);
 	return err;
 }
 
@@ -197,7 +196,7 @@ static int cbc_decrypt(struct skcipher_request *req)
 {
 	struct crypto_skcipher *tfm = crypto_skcipher_reqtfm(req);
 	struct cast5_ctx *ctx = crypto_skcipher_ctx(tfm);
-	bool fpu_enabled = false;
+	bool fpu_enabled;
 	struct skcipher_walk walk;
 	unsigned int nbytes;
 	int err;
@@ -205,12 +204,11 @@ static int cbc_decrypt(struct skcipher_request *req)
 	err = skcipher_walk_virt(&walk, req, false);
 
 	while ((nbytes = walk.nbytes)) {
-		fpu_enabled = cast5_fpu_begin(fpu_enabled, &walk, nbytes);
+		fpu_enabled = cast5_fpu_begin(false, &walk, nbytes);
 		nbytes = __cbc_decrypt(ctx, &walk);
+		cast5_fpu_end(fpu_enabled);
 		err = skcipher_walk_done(&walk, nbytes);
 	}
-
-	cast5_fpu_end(fpu_enabled);
 	return err;
 }
 
@@ -277,7 +275,7 @@ static int ctr_crypt(struct skcipher_request *req)
 {
 	struct crypto_skcipher *tfm = crypto_skcipher_reqtfm(req);
 	struct cast5_ctx *ctx = crypto_skcipher_ctx(tfm);
-	bool fpu_enabled = false;
+	bool fpu_enabled;
 	struct skcipher_walk walk;
 	unsigned int nbytes;
 	int err;
@@ -285,13 +283,12 @@ static int ctr_crypt(struct skcipher_request *req)
 	err = skcipher_walk_virt(&walk, req, false);
 
 	while ((nbytes = walk.nbytes) >= CAST5_BLOCK_SIZE) {
-		fpu_enabled = cast5_fpu_begin(fpu_enabled, &walk, nbytes);
+		fpu_enabled = cast5_fpu_begin(false, &walk, nbytes);
 		nbytes = __ctr_crypt(&walk, ctx);
+		cast5_fpu_end(fpu_enabled);
 		err = skcipher_walk_done(&walk, nbytes);
 	}
 
-	cast5_fpu_end(fpu_enabled);
-
 	if (walk.nbytes) {
 		ctr_crypt_final(&walk, ctx);
 		err = skcipher_walk_done(&walk, 0);
diff --git a/arch/x86/crypto/glue_helper.c b/arch/x86/crypto/glue_helper.c
index d3d91a0abf88..6d0774721514 100644
--- a/arch/x86/crypto/glue_helper.c
+++ b/arch/x86/crypto/glue_helper.c
@@ -24,7 +24,7 @@ int glue_ecb_req_128bit(const struct common_glue_ctx *gctx,
 	void *ctx = crypto_skcipher_ctx(crypto_skcipher_reqtfm(req));
 	const unsigned int bsize = 128 / 8;
 	struct skcipher_walk walk;
-	bool fpu_enabled = false;
+	bool fpu_enabled;
 	unsigned int nbytes;
 	int err;
 
@@ -37,7 +37,7 @@ int glue_ecb_req_128bit(const struct common_glue_ctx *gctx,
 		unsigned int i;
 
 		fpu_enabled = glue_fpu_begin(bsize, gctx->fpu_blocks_limit,
-					     &walk, fpu_enabled, nbytes);
+					     &walk, false, nbytes);
 		for (i = 0; i < gctx->num_funcs; i++) {
 			func_bytes = bsize * gctx->funcs[i].num_blocks;
 
@@ -55,10 +55,9 @@ int glue_ecb_req_128bit(const struct common_glue_ctx *gctx,
 			if (nbytes < bsize)
 				break;
 		}
+		glue_fpu_end(fpu_enabled);
 		err = skcipher_walk_done(&walk, nbytes);
 	}
-
-	glue_fpu_end(fpu_enabled);
 	return err;
 }
 EXPORT_SYMBOL_GPL(glue_ecb_req_128bit);
@@ -101,7 +100,7 @@ int glue_cbc_decrypt_req_128bit(const struct common_glue_ctx *gctx,
 	void *ctx = crypto_skcipher_ctx(crypto_skcipher_reqtfm(req));
 	const unsigned int bsize = 128 / 8;
 	struct skcipher_walk walk;
-	bool fpu_enabled = false;
+	bool fpu_enabled;
 	unsigned int nbytes;
 	int err;
 
@@ -115,7 +114,7 @@ int glue_cbc_decrypt_req_128bit(const struct common_glue_ctx *gctx,
 		u128 last_iv;
 
 		fpu_enabled = glue_fpu_begin(bsize, gctx->fpu_blocks_limit,
-					     &walk, fpu_enabled, nbytes);
+					     &walk, false, nbytes);
 		/* Start of the last block. */
 		src += nbytes / bsize - 1;
 		dst += nbytes / bsize - 1;
@@ -148,10 +147,10 @@ int glue_cbc_decrypt_req_128bit(const struct common_glue_ctx *gctx,
 done:
 		u128_xor(dst, dst, (u128 *)walk.iv);
 		*(u128 *)walk.iv = last_iv;
+		glue_fpu_end(fpu_enabled);
 		err = skcipher_walk_done(&walk, nbytes);
 	}
 
-	glue_fpu_end(fpu_enabled);
 	return err;
 }
 EXPORT_SYMBOL_GPL(glue_cbc_decrypt_req_128bit);
@@ -162,7 +161,7 @@ int glue_ctr_req_128bit(const struct common_glue_ctx *gctx,
 	void *ctx = crypto_skcipher_ctx(crypto_skcipher_reqtfm(req));
 	const unsigned int bsize = 128 / 8;
 	struct skcipher_walk walk;
-	bool fpu_enabled = false;
+	bool fpu_enabled;
 	unsigned int nbytes;
 	int err;
 
@@ -176,7 +175,7 @@ int glue_ctr_req_128bit(const struct common_glue_ctx *gctx,
 		le128 ctrblk;
 
 		fpu_enabled = glue_fpu_begin(bsize, gctx->fpu_blocks_limit,
-					     &walk, fpu_enabled, nbytes);
+					     &walk, false, nbytes);
 
 		be128_to_le128(&ctrblk, (be128 *)walk.iv);
 
@@ -202,11 +201,10 @@ int glue_ctr_req_128bit(const struct common_glue_ctx *gctx,
 		}
 
 		le128_to_be128((be128 *)walk.iv, &ctrblk);
+		glue_fpu_end(fpu_enabled);
 		err = skcipher_walk_done(&walk, nbytes);
 	}
 
-	glue_fpu_end(fpu_enabled);
-
 	if (nbytes) {
 		le128 ctrblk;
 		u128 tmp;
@@ -306,8 +304,14 @@ int glue_xts_req_128bit(const struct common_glue_ctx *gctx,
 	tweak_fn(tweak_ctx, walk.iv, walk.iv);
 
 	while (nbytes) {
+		fpu_enabled = glue_fpu_begin(bsize, gctx->fpu_blocks_limit,
+					     &walk, fpu_enabled,
+					     nbytes < bsize ? bsize : nbytes);
 		nbytes = __glue_xts_req_128bit(gctx, crypt_ctx, &walk);
 
+		glue_fpu_end(fpu_enabled);
+		fpu_enabled = false;
+
 		err = skcipher_walk_done(&walk, nbytes);
 		nbytes = walk.nbytes;
 	}
diff --git a/arch/x86/include/asm/fixmap.h b/arch/x86/include/asm/fixmap.h
index 77217bd292bd..8eba66a33e39 100644
--- a/arch/x86/include/asm/fixmap.h
+++ b/arch/x86/include/asm/fixmap.h
@@ -31,7 +31,7 @@
 #include <asm/pgtable_types.h>
 #ifdef CONFIG_X86_32
 #include <linux/threads.h>
-#include <asm/kmap_types.h>
+#include <asm/kmap_size.h>
 #else
 #include <uapi/asm/vsyscall.h>
 #endif
@@ -94,7 +94,7 @@ enum fixed_addresses {
 #endif
 #ifdef CONFIG_X86_32
 	FIX_KMAP_BEGIN,	/* reserved pte's for temporary kernel mappings */
-	FIX_KMAP_END = FIX_KMAP_BEGIN+(KM_TYPE_NR*NR_CPUS)-1,
+	FIX_KMAP_END = FIX_KMAP_BEGIN + (KM_MAX_IDX * NR_CPUS) - 1,
 #ifdef CONFIG_PCI_MMCONFIG
 	FIX_PCIE_MCFG,
 #endif
@@ -151,7 +151,6 @@ extern void reserve_top_address(unsigned long reserve);
 
 extern int fixmaps_set;
 
-extern pte_t *kmap_pte;
 extern pte_t *pkmap_page_table;
 
 void __native_set_fixmap(enum fixed_addresses idx, pte_t pte);
diff --git a/arch/x86/include/asm/fpu/api.h b/arch/x86/include/asm/fpu/api.h
index 1b37f1d3ab8b..373872d38231 100644
--- a/arch/x86/include/asm/fpu/api.h
+++ b/arch/x86/include/asm/fpu/api.h
@@ -30,6 +30,7 @@ extern void kernel_fpu_begin_mask(unsigned int kfpu_mask);
 extern void kernel_fpu_end(void);
 extern bool irq_fpu_usable(void);
 extern void fpregs_mark_activate(void);
+extern void kernel_fpu_resched(void);
 
 /* Code that is unaware of kernel_fpu_begin_mask() can use this */
 static inline void kernel_fpu_begin(void)
@@ -45,14 +46,18 @@ static inline void kernel_fpu_begin(void)
  */
 static inline void fpregs_lock(void)
 {
-	preempt_disable();
-	local_bh_disable();
+	if (!IS_ENABLED(CONFIG_PREEMPT_RT))
+		local_bh_disable();
+	else
+		preempt_disable();
 }
 
 static inline void fpregs_unlock(void)
 {
-	local_bh_enable();
-	preempt_enable();
+	if (!IS_ENABLED(CONFIG_PREEMPT_RT))
+		local_bh_enable();
+	else
+		preempt_enable();
 }
 
 #ifdef CONFIG_X86_DEBUG_FPU
diff --git a/arch/x86/include/asm/highmem.h b/arch/x86/include/asm/highmem.h
index 0f420b24e0fc..032e020853aa 100644
--- a/arch/x86/include/asm/highmem.h
+++ b/arch/x86/include/asm/highmem.h
@@ -23,7 +23,6 @@
 
 #include <linux/interrupt.h>
 #include <linux/threads.h>
-#include <asm/kmap_types.h>
 #include <asm/tlbflush.h>
 #include <asm/paravirt.h>
 #include <asm/fixmap.h>
@@ -58,11 +57,17 @@ extern unsigned long highstart_pfn, highend_pfn;
 #define PKMAP_NR(virt)  ((virt-PKMAP_BASE) >> PAGE_SHIFT)
 #define PKMAP_ADDR(nr)  (PKMAP_BASE + ((nr) << PAGE_SHIFT))
 
-void *kmap_atomic_pfn(unsigned long pfn);
-void *kmap_atomic_prot_pfn(unsigned long pfn, pgprot_t prot);
-
 #define flush_cache_kmaps()	do { } while (0)
 
+#define	arch_kmap_local_post_map(vaddr, pteval)		\
+	arch_flush_lazy_mmu_mode()
+
+#define	arch_kmap_local_post_unmap(vaddr)		\
+	do {						\
+		flush_tlb_one_kernel((vaddr));		\
+		arch_flush_lazy_mmu_mode();		\
+	} while (0)
+
 extern void add_highpages_with_active_regions(int nid, unsigned long start_pfn,
 					unsigned long end_pfn);
 
diff --git a/arch/x86/include/asm/iomap.h b/arch/x86/include/asm/iomap.h
index bacf68c4d70e..e2de092fc38c 100644
--- a/arch/x86/include/asm/iomap.h
+++ b/arch/x86/include/asm/iomap.h
@@ -9,19 +9,14 @@
 #include <linux/fs.h>
 #include <linux/mm.h>
 #include <linux/uaccess.h>
+#include <linux/highmem.h>
 #include <asm/cacheflush.h>
 #include <asm/tlbflush.h>
 
-void __iomem *
-iomap_atomic_prot_pfn(unsigned long pfn, pgprot_t prot);
+void __iomem *__iomap_local_pfn_prot(unsigned long pfn, pgprot_t prot);
 
-void
-iounmap_atomic(void __iomem *kvaddr);
+int iomap_create_wc(resource_size_t base, unsigned long size, pgprot_t *prot);
 
-int
-iomap_create_wc(resource_size_t base, unsigned long size, pgprot_t *prot);
-
-void
-iomap_free(resource_size_t base, unsigned long size);
+void iomap_free(resource_size_t base, unsigned long size);
 
 #endif /* _ASM_X86_IOMAP_H */
diff --git a/arch/x86/include/asm/kmap_types.h b/arch/x86/include/asm/kmap_types.h
deleted file mode 100644
index 04ab8266e347..000000000000
--- a/arch/x86/include/asm/kmap_types.h
+++ /dev/null
@@ -1,13 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-#ifndef _ASM_X86_KMAP_TYPES_H
-#define _ASM_X86_KMAP_TYPES_H
-
-#if defined(CONFIG_X86_32) && defined(CONFIG_DEBUG_HIGHMEM)
-#define  __WITH_KM_FENCE
-#endif
-
-#include <asm-generic/kmap_types.h>
-
-#undef __WITH_KM_FENCE
-
-#endif /* _ASM_X86_KMAP_TYPES_H */
diff --git a/arch/x86/include/asm/paravirt_types.h b/arch/x86/include/asm/paravirt_types.h
index b30b56d47619..9632218bfd41 100644
--- a/arch/x86/include/asm/paravirt_types.h
+++ b/arch/x86/include/asm/paravirt_types.h
@@ -43,7 +43,6 @@
 #ifndef __ASSEMBLY__
 
 #include <asm/desc_defs.h>
-#include <asm/kmap_types.h>
 #include <asm/pgtable_types.h>
 #include <asm/nospec-branch.h>
 
diff --git a/arch/x86/include/asm/preempt.h b/arch/x86/include/asm/preempt.h
index 2380df419a82..aacfaad6c284 100644
--- a/arch/x86/include/asm/preempt.h
+++ b/arch/x86/include/asm/preempt.h
@@ -90,21 +90,54 @@ static __always_inline void __preempt_count_sub(int val)
  * a decrement which hits zero means we have no preempt_count and should
  * reschedule.
  */
-static __always_inline bool __preempt_count_dec_and_test(void)
+static __always_inline bool ____preempt_count_dec_and_test(void)
 {
 	return GEN_UNARY_RMWcc("decl", __preempt_count, e, __percpu_arg([var]));
 }
 
+static __always_inline bool __preempt_count_dec_and_test(void)
+{
+	if (____preempt_count_dec_and_test())
+		return true;
+#ifdef CONFIG_PREEMPT_LAZY
+	if (preempt_count())
+		return false;
+	if (current_thread_info()->preempt_lazy_count)
+		return false;
+	return test_thread_flag(TIF_NEED_RESCHED_LAZY);
+#else
+	return false;
+#endif
+}
+
 /*
  * Returns true when we need to resched and can (barring IRQ state).
  */
 static __always_inline bool should_resched(int preempt_offset)
 {
+#ifdef CONFIG_PREEMPT_LAZY
+	u32 tmp;
+	tmp = raw_cpu_read_4(__preempt_count);
+	if (tmp == preempt_offset)
+		return true;
+
+	/* preempt count == 0 ? */
+	tmp &= ~PREEMPT_NEED_RESCHED;
+	if (tmp != preempt_offset)
+		return false;
+	/* XXX PREEMPT_LOCK_OFFSET */
+	if (current_thread_info()->preempt_lazy_count)
+		return false;
+	return test_thread_flag(TIF_NEED_RESCHED_LAZY);
+#else
 	return unlikely(raw_cpu_read_4(__preempt_count) == preempt_offset);
+#endif
 }
 
 #ifdef CONFIG_PREEMPTION
-
+#ifdef CONFIG_PREEMPT_RT
+  extern void preempt_schedule_lock(void);
+#endif
 extern asmlinkage void preempt_schedule(void);
 extern asmlinkage void preempt_schedule_thunk(void);
 
diff --git a/arch/x86/include/asm/signal.h b/arch/x86/include/asm/signal.h
index 6fd8410a3910..f3bf2f515edb 100644
--- a/arch/x86/include/asm/signal.h
+++ b/arch/x86/include/asm/signal.h
@@ -28,6 +28,19 @@ typedef struct {
 #define SA_IA32_ABI	0x02000000u
 #define SA_X32_ABI	0x01000000u
 
+/*
+ * Because some traps use the IST stack, we must keep preemption
+ * disabled while calling do_trap(), but do_trap() may call
+ * force_sig_info() which will grab the signal spin_locks for the
+ * task, which in PREEMPT_RT are mutexes.  By defining
+ * ARCH_RT_DELAYS_SIGNAL_SEND the force_sig_info() will set
+ * TIF_NOTIFY_RESUME and set up the signal to be sent on exit of the
+ * trap.
+ */
+#if defined(CONFIG_PREEMPT_RT)
+#define ARCH_RT_DELAYS_SIGNAL_SEND
+#endif
+
 #ifndef CONFIG_COMPAT
 typedef sigset_t compat_sigset_t;
 #endif
diff --git a/arch/x86/include/asm/stackprotector.h b/arch/x86/include/asm/stackprotector.h
index 7fb482f0f25b..3df0a95c9e13 100644
--- a/arch/x86/include/asm/stackprotector.h
+++ b/arch/x86/include/asm/stackprotector.h
@@ -65,7 +65,7 @@
  */
 static __always_inline void boot_init_stack_canary(void)
 {
-	u64 canary;
+	u64 canary = 0;
 	u64 tsc;
 
 #ifdef CONFIG_X86_64
@@ -76,8 +76,14 @@ static __always_inline void boot_init_stack_canary(void)
 	 * of randomness. The TSC only matters for very early init,
 	 * there it already has some randomness on most systems. Later
 	 * on during the bootup the random pool has true entropy too.
+	 * For preempt-rt we need to weaken the randomness a bit, as
+	 * we can't call into the random generator from atomic context
+	 * due to locking constraints. We just leave canary
+	 * uninitialized and use the TSC based randomness on top of it.
 	 */
+#ifndef CONFIG_PREEMPT_RT
 	get_random_bytes(&canary, sizeof(canary));
+#endif
 	tsc = rdtsc();
 	canary += tsc + (tsc << 32UL);
 	canary &= CANARY_MASK;
diff --git a/arch/x86/include/asm/thread_info.h b/arch/x86/include/asm/thread_info.h
index a225c6e2ca6d..ad34b468abe0 100644
--- a/arch/x86/include/asm/thread_info.h
+++ b/arch/x86/include/asm/thread_info.h
@@ -60,6 +60,8 @@ struct thread_info {
 #ifdef CONFIG_SMP
 	u32			cpu;		/* current CPU */
 #endif
+	int			preempt_lazy_count;	/* 0 => lazy preemptable
+							  <0 => BUG */
 	KABI_RESERVE(1)
 	KABI_RESERVE(2)
 };
@@ -67,12 +69,17 @@ struct thread_info {
 #define INIT_THREAD_INFO(tsk)			\
 {						\
 	.flags		= 0,			\
+	.preempt_lazy_count = 0,		\
 }
 
 #else /* !__ASSEMBLY__ */
 
 #include <asm/asm-offsets.h>
 
+#define GET_THREAD_INFO(reg) \
+	_ASM_MOV PER_CPU_VAR(cpu_current_top_of_stack),reg ; \
+	_ASM_SUB $(THREAD_SIZE),reg ;
+
 #endif
 
 /*
@@ -99,6 +106,7 @@ struct thread_info {
 #define TIF_NOTSC		16	/* TSC is not accessible in userland */
 #define TIF_IA32		17	/* IA32 compatibility process */
 #define TIF_SLD			18	/* Restore split lock detection on context switch */
+#define TIF_NEED_RESCHED_LAZY	19	/* lazy rescheduling necessary */
 #define TIF_MEMDIE		20	/* is terminating due to OOM killer */
 #define TIF_POLLING_NRFLAG	21	/* idle is polling for TIF_NEED_RESCHED */
 #define TIF_IO_BITMAP		22	/* uses I/O bitmap */
@@ -128,6 +136,7 @@ struct thread_info {
 #define _TIF_NOTSC		(1 << TIF_NOTSC)
 #define _TIF_IA32		(1 << TIF_IA32)
 #define _TIF_SLD		(1 << TIF_SLD)
+#define _TIF_NEED_RESCHED_LAZY	(1 << TIF_NEED_RESCHED_LAZY)
 #define _TIF_POLLING_NRFLAG	(1 << TIF_POLLING_NRFLAG)
 #define _TIF_IO_BITMAP		(1 << TIF_IO_BITMAP)
 #define _TIF_FORCED_TF		(1 << TIF_FORCED_TF)
@@ -160,6 +169,8 @@ struct thread_info {
 
 #define _TIF_WORK_CTXSW_NEXT	(_TIF_WORK_CTXSW)
 
+#define _TIF_NEED_RESCHED_MASK	(_TIF_NEED_RESCHED | _TIF_NEED_RESCHED_LAZY)
+
 #define STACK_WARN		(THREAD_SIZE/8)
 
 /*
diff --git a/arch/x86/kernel/crash_dump_32.c b/arch/x86/kernel/crash_dump_32.c
index 33ee47670b99..5fcac46aaf6b 100644
--- a/arch/x86/kernel/crash_dump_32.c
+++ b/arch/x86/kernel/crash_dump_32.c
@@ -13,8 +13,6 @@
 
 #include <linux/uaccess.h>
 
-static void *kdump_buf_page;
-
 static inline bool is_crashed_pfn_valid(unsigned long pfn)
 {
 #ifndef CONFIG_X86_PAE
@@ -41,15 +39,11 @@ static inline bool is_crashed_pfn_valid(unsigned long pfn)
  * @userbuf: if set, @buf is in user address space, use copy_to_user(),
  *	otherwise @buf is in kernel address space, use memcpy().
  *
- * Copy a page from "oldmem". For this page, there is no pte mapped
- * in the current kernel. We stitch up a pte, similar to kmap_atomic.
- *
- * Calling copy_to_user() in atomic context is not desirable. Hence first
- * copying the data to a pre-allocated kernel page and then copying to user
- * space in non-atomic context.
+ * Copy a page from "oldmem". For this page, there might be no pte mapped
+ * in the current kernel.
  */
-ssize_t copy_oldmem_page(unsigned long pfn, char *buf,
-                               size_t csize, unsigned long offset, int userbuf)
+ssize_t copy_oldmem_page(unsigned long pfn, char *buf, size_t csize,
+			 unsigned long offset, int userbuf)
 {
 	void  *vaddr;
 
@@ -59,38 +53,16 @@ ssize_t copy_oldmem_page(unsigned long pfn, char *buf,
 	if (!is_crashed_pfn_valid(pfn))
 		return -EFAULT;
 
-	vaddr = kmap_atomic_pfn(pfn);
+	vaddr = kmap_local_pfn(pfn);
 
 	if (!userbuf) {
-		memcpy(buf, (vaddr + offset), csize);
-		kunmap_atomic(vaddr);
+		memcpy(buf, vaddr + offset, csize);
 	} else {
-		if (!kdump_buf_page) {
-			printk(KERN_WARNING "Kdump: Kdump buffer page not"
-				" allocated\n");
-			kunmap_atomic(vaddr);
-			return -EFAULT;
-		}
-		copy_page(kdump_buf_page, vaddr);
-		kunmap_atomic(vaddr);
-		if (copy_to_user(buf, (kdump_buf_page + offset), csize))
-			return -EFAULT;
+		if (copy_to_user(buf, vaddr + offset, csize))
+			csize = -EFAULT;
 	}
 
-	return csize;
-}
+	kunmap_local(vaddr);
 
-static int __init kdump_buf_page_init(void)
-{
-	int ret = 0;
-
-	kdump_buf_page = kmalloc(PAGE_SIZE, GFP_KERNEL);
-	if (!kdump_buf_page) {
-		printk(KERN_WARNING "Kdump: Failed to allocate kdump buffer"
-			 " page\n");
-		ret = -ENOMEM;
-	}
-
-	return ret;
+	return csize;
 }
-arch_initcall(kdump_buf_page_init);
diff --git a/arch/x86/kernel/fpu/core.c b/arch/x86/kernel/fpu/core.c
index 69b5581d4469..43569fb1e6ad 100644
--- a/arch/x86/kernel/fpu/core.c
+++ b/arch/x86/kernel/fpu/core.c
@@ -434,6 +434,19 @@ void kernel_fpu_end(void)
 }
 EXPORT_SYMBOL_GPL(kernel_fpu_end);
 
+void kernel_fpu_resched(void)
+{
+	WARN_ON_FPU(!this_cpu_read(in_kernel_fpu));
+
+	if (should_resched(PREEMPT_OFFSET)) {
+		kernel_fpu_end();
+		cond_resched();
+		kernel_fpu_begin();
+	}
+}
+EXPORT_SYMBOL_GPL(kernel_fpu_resched);
+
+
 /*
  * Sync the FPU register state to current's memory register state when the
  * current task owns the FPU. The hardware register state is preserved.
diff --git a/arch/x86/kernel/irq_32.c b/arch/x86/kernel/irq_32.c
index 0b79efc87be5..93c6b88b382a 100644
--- a/arch/x86/kernel/irq_32.c
+++ b/arch/x86/kernel/irq_32.c
@@ -131,6 +131,7 @@ int irq_init_percpu_irqstack(unsigned int cpu)
 	return 0;
 }
 
+#ifndef CONFIG_PREEMPT_RT
 void do_softirq_own_stack(void)
 {
 	struct irq_stack *irqstk;
@@ -147,6 +148,7 @@ void do_softirq_own_stack(void)
 
 	call_on_stack(__do_softirq, isp);
 }
+#endif
 
 void __handle_irq(struct irq_desc *desc, struct pt_regs *regs)
 {
diff --git a/arch/x86/kernel/irq_64.c b/arch/x86/kernel/irq_64.c
index 440eed558558..7cfc4e6b7c94 100644
--- a/arch/x86/kernel/irq_64.c
+++ b/arch/x86/kernel/irq_64.c
@@ -72,7 +72,9 @@ int irq_init_percpu_irqstack(unsigned int cpu)
 	return map_irq_stack(cpu);
 }
 
+#ifndef CONFIG_PREEMPT_RT
 void do_softirq_own_stack(void)
 {
 	run_on_irqstack_cond(__do_softirq, NULL);
 }
+#endif
diff --git a/arch/x86/kvm/x86.c b/arch/x86/kvm/x86.c
index bdc7b9c1f82a..790af801a0c2 100644
--- a/arch/x86/kvm/x86.c
+++ b/arch/x86/kvm/x86.c
@@ -8228,6 +8228,13 @@ int kvm_arch_init(void *opaque)
 		r = -EOPNOTSUPP;
 		goto out;
 	}
+#ifdef CONFIG_PREEMPT_RT
+	if (!boot_cpu_has(X86_FEATURE_CONSTANT_TSC)) {
+		pr_err("RT requires X86_FEATURE_CONSTANT_TSC\n");
+		r = -EOPNOTSUPP;
+		goto out;
+	}
+#endif
 
 	r = -ENOMEM;
 
diff --git a/arch/x86/mm/highmem_32.c b/arch/x86/mm/highmem_32.c
index 075fe51317b0..2c54b76d8f84 100644
--- a/arch/x86/mm/highmem_32.c
+++ b/arch/x86/mm/highmem_32.c
@@ -4,65 +4,6 @@
 #include <linux/swap.h> /* for totalram_pages */
 #include <linux/memblock.h>
 
-void *kmap_atomic_high_prot(struct page *page, pgprot_t prot)
-{
-	unsigned long vaddr;
-	int idx, type;
-
-	type = kmap_atomic_idx_push();
-	idx = type + KM_TYPE_NR*smp_processor_id();
-	vaddr = __fix_to_virt(FIX_KMAP_BEGIN + idx);
-	BUG_ON(!pte_none(*(kmap_pte-idx)));
-	set_pte(kmap_pte-idx, mk_pte(page, prot));
-	arch_flush_lazy_mmu_mode();
-
-	return (void *)vaddr;
-}
-EXPORT_SYMBOL(kmap_atomic_high_prot);
-
-/*
- * This is the same as kmap_atomic() but can map memory that doesn't
- * have a struct page associated with it.
- */
-void *kmap_atomic_pfn(unsigned long pfn)
-{
-	return kmap_atomic_prot_pfn(pfn, kmap_prot);
-}
-EXPORT_SYMBOL_GPL(kmap_atomic_pfn);
-
-void kunmap_atomic_high(void *kvaddr)
-{
-	unsigned long vaddr = (unsigned long) kvaddr & PAGE_MASK;
-
-	if (vaddr >= __fix_to_virt(FIX_KMAP_END) &&
-	    vaddr <= __fix_to_virt(FIX_KMAP_BEGIN)) {
-		int idx, type;
-
-		type = kmap_atomic_idx();
-		idx = type + KM_TYPE_NR * smp_processor_id();
-
-#ifdef CONFIG_DEBUG_HIGHMEM
-		WARN_ON_ONCE(vaddr != __fix_to_virt(FIX_KMAP_BEGIN + idx));
-#endif
-		/*
-		 * Force other mappings to Oops if they'll try to access this
-		 * pte without first remap it.  Keeping stale mappings around
-		 * is a bad idea also, in case the page changes cacheability
-		 * attributes or becomes a protected page in a hypervisor.
-		 */
-		kpte_clear_flush(kmap_pte-idx, vaddr);
-		kmap_atomic_idx_pop();
-		arch_flush_lazy_mmu_mode();
-	}
-#ifdef CONFIG_DEBUG_HIGHMEM
-	else {
-		BUG_ON(vaddr < PAGE_OFFSET);
-		BUG_ON(vaddr >= (unsigned long)high_memory);
-	}
-#endif
-}
-EXPORT_SYMBOL(kunmap_atomic_high);
-
 void __init set_highmem_pages_init(void)
 {
 	struct zone *zone;
diff --git a/arch/x86/mm/init_32.c b/arch/x86/mm/init_32.c
index 7c055259de3a..da31c2635ee4 100644
--- a/arch/x86/mm/init_32.c
+++ b/arch/x86/mm/init_32.c
@@ -394,19 +394,6 @@ kernel_physical_mapping_init(unsigned long start,
 	return last_map_addr;
 }
 
-pte_t *kmap_pte;
-
-static void __init kmap_init(void)
-{
-	unsigned long kmap_vstart;
-
-	/*
-	 * Cache the first kmap pte:
-	 */
-	kmap_vstart = __fix_to_virt(FIX_KMAP_BEGIN);
-	kmap_pte = virt_to_kpte(kmap_vstart);
-}
-
 #ifdef CONFIG_HIGHMEM
 static void __init permanent_kmaps_init(pgd_t *pgd_base)
 {
@@ -712,8 +699,6 @@ void __init paging_init(void)
 
 	__flush_tlb_all();
 
-	kmap_init();
-
 	/*
 	 * NOTE: at this point the bootmem allocator is fully available.
 	 */
diff --git a/arch/x86/mm/iomap_32.c b/arch/x86/mm/iomap_32.c
index f60398aeb644..9aaa756ddf21 100644
--- a/arch/x86/mm/iomap_32.c
+++ b/arch/x86/mm/iomap_32.c
@@ -44,28 +44,7 @@ void iomap_free(resource_size_t base, unsigned long size)
 }
 EXPORT_SYMBOL_GPL(iomap_free);
 
-void *kmap_atomic_prot_pfn(unsigned long pfn, pgprot_t prot)
-{
-	unsigned long vaddr;
-	int idx, type;
-
-	preempt_disable();
-	pagefault_disable();
-
-	type = kmap_atomic_idx_push();
-	idx = type + KM_TYPE_NR * smp_processor_id();
-	vaddr = __fix_to_virt(FIX_KMAP_BEGIN + idx);
-	set_pte(kmap_pte - idx, pfn_pte(pfn, prot));
-	arch_flush_lazy_mmu_mode();
-
-	return (void *)vaddr;
-}
-
-/*
- * Map 'pfn' using protections 'prot'
- */
-void __iomem *
-iomap_atomic_prot_pfn(unsigned long pfn, pgprot_t prot)
+void __iomem *__iomap_local_pfn_prot(unsigned long pfn, pgprot_t prot)
 {
 	/*
 	 * For non-PAT systems, translate non-WB request to UC- just in
@@ -81,36 +60,6 @@ iomap_atomic_prot_pfn(unsigned long pfn, pgprot_t prot)
 	/* Filter out unsupported __PAGE_KERNEL* bits: */
 	pgprot_val(prot) &= __default_kernel_pte_mask;
 
-	return (void __force __iomem *) kmap_atomic_prot_pfn(pfn, prot);
-}
-EXPORT_SYMBOL_GPL(iomap_atomic_prot_pfn);
-
-void
-iounmap_atomic(void __iomem *kvaddr)
-{
-	unsigned long vaddr = (unsigned long) kvaddr & PAGE_MASK;
-
-	if (vaddr >= __fix_to_virt(FIX_KMAP_END) &&
-	    vaddr <= __fix_to_virt(FIX_KMAP_BEGIN)) {
-		int idx, type;
-
-		type = kmap_atomic_idx();
-		idx = type + KM_TYPE_NR * smp_processor_id();
-
-#ifdef CONFIG_DEBUG_HIGHMEM
-		WARN_ON_ONCE(vaddr != __fix_to_virt(FIX_KMAP_BEGIN + idx));
-#endif
-		/*
-		 * Force other mappings to Oops if they'll try to access this
-		 * pte without first remap it.  Keeping stale mappings around
-		 * is a bad idea also, in case the page changes cacheability
-		 * attributes or becomes a protected page in a hypervisor.
-		 */
-		kpte_clear_flush(kmap_pte-idx, vaddr);
-		kmap_atomic_idx_pop();
-	}
-
-	pagefault_enable();
-	preempt_enable();
+	return (void __force __iomem *)__kmap_local_pfn_prot(pfn, prot);
 }
-EXPORT_SYMBOL_GPL(iounmap_atomic);
+EXPORT_SYMBOL_GPL(__iomap_local_pfn_prot);
diff --git a/arch/xtensa/Kconfig b/arch/xtensa/Kconfig
index 87e08ad38ea7..03cbf6b53622 100644
--- a/arch/xtensa/Kconfig
+++ b/arch/xtensa/Kconfig
@@ -666,6 +666,7 @@ endchoice
 config HIGHMEM
 	bool "High Memory Support"
 	depends on MMU
+	select KMAP_LOCAL
 	help
 	  Linux can use the full amount of RAM in the system by
 	  default. However, the default MMUv2 setup only maps the
diff --git a/arch/xtensa/include/asm/fixmap.h b/arch/xtensa/include/asm/fixmap.h
index a06ffb0c61c7..92049b61c351 100644
--- a/arch/xtensa/include/asm/fixmap.h
+++ b/arch/xtensa/include/asm/fixmap.h
@@ -16,7 +16,7 @@
 #ifdef CONFIG_HIGHMEM
 #include <linux/threads.h>
 #include <linux/pgtable.h>
-#include <asm/kmap_types.h>
+#include <asm/kmap_size.h>
 #endif
 
 /*
@@ -39,7 +39,7 @@ enum fixed_addresses {
 	/* reserved pte's for temporary kernel mappings */
 	FIX_KMAP_BEGIN,
 	FIX_KMAP_END = FIX_KMAP_BEGIN +
-		(KM_TYPE_NR * NR_CPUS * DCACHE_N_COLORS) - 1,
+		(KM_MAX_IDX * NR_CPUS * DCACHE_N_COLORS) - 1,
 #endif
 	__end_of_fixed_addresses
 };
diff --git a/arch/xtensa/include/asm/highmem.h b/arch/xtensa/include/asm/highmem.h
index eac503215f17..0fc3b1cebc56 100644
--- a/arch/xtensa/include/asm/highmem.h
+++ b/arch/xtensa/include/asm/highmem.h
@@ -16,9 +16,8 @@
 #include <linux/pgtable.h>
 #include <asm/cacheflush.h>
 #include <asm/fixmap.h>
-#include <asm/kmap_types.h>
 
-#define PKMAP_BASE		((FIXADDR_START - \
+#define PKMAP_BASE		((FIXADDR_START -			\
 				  (LAST_PKMAP + 1) * PAGE_SIZE) & PMD_MASK)
 #define LAST_PKMAP		(PTRS_PER_PTE * DCACHE_N_COLORS)
 #define LAST_PKMAP_MASK		(LAST_PKMAP - 1)
@@ -68,6 +67,15 @@ static inline void flush_cache_kmaps(void)
 	flush_cache_all();
 }
 
+enum fixed_addresses kmap_local_map_idx(int type, unsigned long pfn);
+#define arch_kmap_local_map_idx		kmap_local_map_idx
+
+enum fixed_addresses kmap_local_unmap_idx(int type, unsigned long addr);
+#define arch_kmap_local_unmap_idx	kmap_local_unmap_idx
+
+#define arch_kmap_local_post_unmap(vaddr)	\
+	local_flush_tlb_kernel_range(vaddr, vaddr + PAGE_SIZE)
+
 void kmap_init(void);
 
 #endif
diff --git a/arch/xtensa/include/asm/spinlock_types.h b/arch/xtensa/include/asm/spinlock_types.h
index 64c9389254f1..dc846323b1cd 100644
--- a/arch/xtensa/include/asm/spinlock_types.h
+++ b/arch/xtensa/include/asm/spinlock_types.h
@@ -2,10 +2,6 @@
 #ifndef __ASM_SPINLOCK_TYPES_H
 #define __ASM_SPINLOCK_TYPES_H
 
-#if !defined(__LINUX_SPINLOCK_TYPES_H) && !defined(__ASM_SPINLOCK_H)
-# error "please don't include this file directly"
-#endif
-
 #include <asm-generic/qspinlock_types.h>
 #include <asm-generic/qrwlock_types.h>
 
diff --git a/arch/xtensa/mm/highmem.c b/arch/xtensa/mm/highmem.c
index 673196fe862e..0735ca5e8f86 100644
--- a/arch/xtensa/mm/highmem.c
+++ b/arch/xtensa/mm/highmem.c
@@ -12,8 +12,6 @@
 #include <linux/highmem.h>
 #include <asm/tlbflush.h>
 
-static pte_t *kmap_pte;
-
 #if DCACHE_WAY_SIZE > PAGE_SIZE
 unsigned int last_pkmap_nr_arr[DCACHE_N_COLORS];
 wait_queue_head_t pkmap_map_wait_arr[DCACHE_N_COLORS];
@@ -33,59 +31,25 @@ static inline void kmap_waitqueues_init(void)
 
 static inline enum fixed_addresses kmap_idx(int type, unsigned long color)
 {
-	return (type + KM_TYPE_NR * smp_processor_id()) * DCACHE_N_COLORS +
+	return (type + KM_MAX_IDX * smp_processor_id()) * DCACHE_N_COLORS +
 		color;
 }
 
-void *kmap_atomic_high_prot(struct page *page, pgprot_t prot)
+enum fixed_addresses kmap_local_map_idx(int type, unsigned long pfn)
 {
-	enum fixed_addresses idx;
-	unsigned long vaddr;
-
-	idx = kmap_idx(kmap_atomic_idx_push(),
-		       DCACHE_ALIAS(page_to_phys(page)));
-	vaddr = __fix_to_virt(FIX_KMAP_BEGIN + idx);
-#ifdef CONFIG_DEBUG_HIGHMEM
-	BUG_ON(!pte_none(*(kmap_pte + idx)));
-#endif
-	set_pte(kmap_pte + idx, mk_pte(page, prot));
-
-	return (void *)vaddr;
+	return kmap_idx(type, DCACHE_ALIAS(pfn << PAGE_SHIFT));
 }
-EXPORT_SYMBOL(kmap_atomic_high_prot);
 
-void kunmap_atomic_high(void *kvaddr)
+enum fixed_addresses kmap_local_unmap_idx(int type, unsigned long addr)
 {
-	if (kvaddr >= (void *)FIXADDR_START &&
-	    kvaddr < (void *)FIXADDR_TOP) {
-		int idx = kmap_idx(kmap_atomic_idx(),
-				   DCACHE_ALIAS((unsigned long)kvaddr));
-
-		/*
-		 * Force other mappings to Oops if they'll try to access this
-		 * pte without first remap it.  Keeping stale mappings around
-		 * is a bad idea also, in case the page changes cacheability
-		 * attributes or becomes a protected page in a hypervisor.
-		 */
-		pte_clear(&init_mm, kvaddr, kmap_pte + idx);
-		local_flush_tlb_kernel_range((unsigned long)kvaddr,
-					     (unsigned long)kvaddr + PAGE_SIZE);
-
-		kmap_atomic_idx_pop();
-	}
+	return kmap_idx(type, DCACHE_ALIAS(addr));
 }
-EXPORT_SYMBOL(kunmap_atomic_high);
 
 void __init kmap_init(void)
 {
-	unsigned long kmap_vstart;
-
 	/* Check if this memory layout is broken because PKMAP overlaps
 	 * page table.
 	 */
 	BUILD_BUG_ON(PKMAP_BASE < TLBTEMP_BASE_1 + TLBTEMP_SIZE);
-	/* cache the first kmap pte */
-	kmap_vstart = __fix_to_virt(FIX_KMAP_BEGIN);
-	kmap_pte = virt_to_kpte(kmap_vstart);
 	kmap_waitqueues_init();
 }
diff --git a/block/blk-mq.c b/block/blk-mq.c
index 1c4a4e197e65..9ad95c7dfa05 100644
--- a/block/blk-mq.c
+++ b/block/blk-mq.c
@@ -44,7 +44,7 @@
 bool mq_unfair_dtag = true;
 module_param_named(unfair_dtag, mq_unfair_dtag, bool, 0444);
 
-static DEFINE_PER_CPU(struct list_head, blk_cpu_done);
+static DEFINE_PER_CPU(struct llist_head, blk_cpu_done);
 
 static void blk_mq_poll_stats_start(struct request_queue *q);
 static void blk_mq_poll_stats_fn(struct blk_stat_callback *cb);
@@ -657,80 +657,29 @@ void blk_mq_end_request(struct request *rq, blk_status_t error)
 }
 EXPORT_SYMBOL(blk_mq_end_request);
 
-/*
- * Softirq action handler - move entries to local list and loop over them
- * while passing them to the queue registered handler.
- */
-static __latent_entropy void blk_done_softirq(struct softirq_action *h)
+static void blk_complete_reqs(struct llist_head *list)
 {
-	struct list_head *cpu_list, local_list;
-
-	local_irq_disable();
-	cpu_list = this_cpu_ptr(&blk_cpu_done);
-	list_replace_init(cpu_list, &local_list);
-	local_irq_enable();
-
-	while (!list_empty(&local_list)) {
-		struct request *rq;
+	struct llist_node *entry = llist_reverse_order(llist_del_all(list));
+	struct request *rq, *next;
 
-		rq = list_entry(local_list.next, struct request, ipi_list);
-		list_del_init(&rq->ipi_list);
+	llist_for_each_entry_safe(rq, next, entry, ipi_list)
 		rq->q->mq_ops->complete(rq);
-	}
 }
 
-static void blk_mq_trigger_softirq(struct request *rq)
+static __latent_entropy void blk_done_softirq(struct softirq_action *h)
 {
-	struct list_head *list;
-	unsigned long flags;
-
-	local_irq_save(flags);
-	list = this_cpu_ptr(&blk_cpu_done);
-	list_add_tail(&rq->ipi_list, list);
-
-	/*
-	 * If the list only contains our just added request, signal a raise of
-	 * the softirq.  If there are already entries there, someone already
-	 * raised the irq but it hasn't run yet.
-	 */
-	if (list->next == &rq->ipi_list)
-		raise_softirq_irqoff(BLOCK_SOFTIRQ);
-	local_irq_restore(flags);
+	blk_complete_reqs(this_cpu_ptr(&blk_cpu_done));
 }
 
 static int blk_softirq_cpu_dead(unsigned int cpu)
 {
-	/*
-	 * If a CPU goes away, splice its entries to the current CPU
-	 * and trigger a run of the softirq
-	 */
-	local_irq_disable();
-	list_splice_init(&per_cpu(blk_cpu_done, cpu),
-			 this_cpu_ptr(&blk_cpu_done));
-	raise_softirq_irqoff(BLOCK_SOFTIRQ);
-	local_irq_enable();
-
+	blk_complete_reqs(&per_cpu(blk_cpu_done, cpu));
 	return 0;
 }
 
-
 static void __blk_mq_complete_request_remote(void *data)
 {
-	struct request *rq = data;
-
-	/*
-	 * For most of single queue controllers, there is only one irq vector
-	 * for handling I/O completion, and the only irq's affinity is set
-	 * to all possible CPUs.  On most of ARCHs, this affinity means the irq
-	 * is handled on one specific CPU.
-	 *
-	 * So complete I/O requests in softirq context in case of single queue
-	 * devices to avoid degrading I/O performance due to irqsoff latency.
-	 */
-	if (rq->q->nr_hw_queues == 1)
-		blk_mq_trigger_softirq(rq);
-	else
-		rq->q->mq_ops->complete(rq);
+	__raise_softirq_irqoff(BLOCK_SOFTIRQ);
 }
 
 static inline bool blk_mq_complete_need_ipi(struct request *rq)
@@ -740,6 +689,14 @@ static inline bool blk_mq_complete_need_ipi(struct request *rq)
 	if (!IS_ENABLED(CONFIG_SMP) ||
 	    !test_bit(QUEUE_FLAG_SAME_COMP, &rq->q->queue_flags))
 		return false;
+	/*
+	 * With force threaded interrupts enabled, raising softirq from an SMP
+	 * function call will always result in waking the ksoftirqd thread.
+	 * This is probably worse than completing the request on a different
+	 * cache domain.
+	 */
+	if (force_irqthreads)
+		return false;
 
 	/* same CPU or cache domain?  Complete locally */
 	if (cpu == rq->mq_ctx->cpu ||
@@ -751,6 +708,31 @@ static inline bool blk_mq_complete_need_ipi(struct request *rq)
 	return cpu_online(rq->mq_ctx->cpu);
 }
 
+static void blk_mq_complete_send_ipi(struct request *rq)
+{
+	struct llist_head *list;
+	unsigned int cpu;
+
+	cpu = rq->mq_ctx->cpu;
+	list = &per_cpu(blk_cpu_done, cpu);
+	if (llist_add(&rq->ipi_list, list)) {
+		rq->csd.func = __blk_mq_complete_request_remote;
+		rq->csd.info = rq;
+		smp_call_function_single_async(cpu, &rq->csd);
+	}
+}
+
+static void blk_mq_raise_softirq(struct request *rq)
+{
+	struct llist_head *list;
+
+	preempt_disable();
+	list = this_cpu_ptr(&blk_cpu_done);
+	if (llist_add(&rq->ipi_list, list))
+		raise_softirq(BLOCK_SOFTIRQ);
+	preempt_enable();
+}
+
 bool blk_mq_complete_request_remote(struct request *rq)
 {
 	WRITE_ONCE(rq->state, MQ_RQ_COMPLETE);
@@ -763,15 +745,15 @@ bool blk_mq_complete_request_remote(struct request *rq)
 		return false;
 
 	if (blk_mq_complete_need_ipi(rq)) {
-		INIT_CSD(&rq->csd, __blk_mq_complete_request_remote, rq);
-		smp_call_function_single_async(rq->mq_ctx->cpu, &rq->csd);
-	} else {
-		if (rq->q->nr_hw_queues > 1)
-			return false;
-		blk_mq_trigger_softirq(rq);
+		blk_mq_complete_send_ipi(rq);
+		return true;
 	}
 
-	return true;
+	if (rq->q->nr_hw_queues == 1) {
+		blk_mq_raise_softirq(rq);
+		return true;
+	}
+	return false;
 }
 EXPORT_SYMBOL_GPL(blk_mq_complete_request_remote);
 
@@ -1686,14 +1668,14 @@ static void __blk_mq_delay_run_hw_queue(struct blk_mq_hw_ctx *hctx, bool async,
 		return;
 
 	if (!async && !(hctx->flags & BLK_MQ_F_BLOCKING)) {
-		int cpu = get_cpu();
+		int cpu = get_cpu_light();
 		if (cpumask_test_cpu(cpu, hctx->cpumask)) {
 			__blk_mq_run_hw_queue(hctx);
-			put_cpu();
+			put_cpu_light();
 			return;
 		}
 
-		put_cpu();
+		put_cpu_light();
 	}
 
 	/*
@@ -4222,7 +4204,7 @@ static int __init blk_mq_init(void)
 	int i;
 
 	for_each_possible_cpu(i)
-		INIT_LIST_HEAD(&per_cpu(blk_cpu_done, i));
+		init_llist_head(&per_cpu(blk_cpu_done, i));
 	open_softirq(BLOCK_SOFTIRQ, blk_done_softirq);
 
 	cpuhp_setup_state_nocalls(CPUHP_BLOCK_SOFTIRQ_DEAD,
diff --git a/crypto/cryptd.c b/crypto/cryptd.c
index 668095eca0fa..d46645d5b8dd 100644
--- a/crypto/cryptd.c
+++ b/crypto/cryptd.c
@@ -36,6 +36,7 @@ static struct workqueue_struct *cryptd_wq;
 struct cryptd_cpu_queue {
 	struct crypto_queue queue;
 	struct work_struct work;
+	spinlock_t qlock;
 };
 
 struct cryptd_queue {
@@ -109,6 +110,7 @@ static int cryptd_init_queue(struct cryptd_queue *queue,
 		cpu_queue = per_cpu_ptr(queue->cpu_queue, cpu);
 		crypto_init_queue(&cpu_queue->queue, max_cpu_qlen);
 		INIT_WORK(&cpu_queue->work, cryptd_queue_worker);
+		spin_lock_init(&cpu_queue->qlock);
 	}
 	pr_info("cryptd: max_cpu_qlen set to %d\n", max_cpu_qlen);
 	return 0;
@@ -133,8 +135,8 @@ static int cryptd_enqueue_request(struct cryptd_queue *queue,
 	struct cryptd_cpu_queue *cpu_queue;
 	refcount_t *refcnt;
 
-	local_bh_disable();
-	cpu_queue = this_cpu_ptr(queue->cpu_queue);
+	cpu_queue = raw_cpu_ptr(queue->cpu_queue);
+	spin_lock_bh(&cpu_queue->qlock);
 	err = crypto_enqueue_request(&cpu_queue->queue, request);
 
 	refcnt = crypto_tfm_ctx(request->tfm);
@@ -150,7 +152,7 @@ static int cryptd_enqueue_request(struct cryptd_queue *queue,
 	refcount_inc(refcnt);
 
 out:
-	local_bh_enable();
+	spin_unlock_bh(&cpu_queue->qlock);
 
 	return err;
 }
@@ -167,10 +169,10 @@ static void cryptd_queue_worker(struct work_struct *work)
 	/*
 	 * Only handle one request at a time to avoid hogging crypto workqueue.
 	 */
-	local_bh_disable();
+	spin_lock_bh(&cpu_queue->qlock);
 	backlog = crypto_get_backlog(&cpu_queue->queue);
 	req = crypto_dequeue_request(&cpu_queue->queue);
-	local_bh_enable();
+	spin_unlock_bh(&cpu_queue->qlock);
 
 	if (!req)
 		return;
diff --git a/drivers/atm/eni.c b/drivers/atm/eni.c
index 9fcc49be499f..a31ffe16e626 100644
--- a/drivers/atm/eni.c
+++ b/drivers/atm/eni.c
@@ -2056,7 +2056,7 @@ static int eni_send(struct atm_vcc *vcc,struct sk_buff *skb)
 	}
 	submitted++;
 	ATM_SKB(skb)->vcc = vcc;
-	tasklet_disable(&ENI_DEV(vcc->dev)->task);
+	tasklet_disable_in_atomic(&ENI_DEV(vcc->dev)->task);
 	res = do_tx(skb);
 	tasklet_enable(&ENI_DEV(vcc->dev)->task);
 	if (res == enq_ok) return 0;
diff --git a/drivers/block/zram/zram_drv.c b/drivers/block/zram/zram_drv.c
index 0636df6b67db..1a7523cefbe9 100644
--- a/drivers/block/zram/zram_drv.c
+++ b/drivers/block/zram/zram_drv.c
@@ -59,6 +59,40 @@ static void zram_free_page(struct zram *zram, size_t index);
 static int zram_bvec_read(struct zram *zram, struct bio_vec *bvec,
 				u32 index, int offset, struct bio *bio);
 
+#ifdef CONFIG_PREEMPT_RT
+static void zram_meta_init_table_locks(struct zram *zram, size_t num_pages)
+{
+	size_t index;
+
+	for (index = 0; index < num_pages; index++)
+		spin_lock_init(&zram->table[index].lock);
+}
+
+static int zram_slot_trylock(struct zram *zram, u32 index)
+{
+	int ret;
+
+	ret = spin_trylock(&zram->table[index].lock);
+	if (ret)
+		__set_bit(ZRAM_LOCK, &zram->table[index].flags);
+	return ret;
+}
+
+static void zram_slot_lock(struct zram *zram, u32 index)
+{
+	spin_lock(&zram->table[index].lock);
+	__set_bit(ZRAM_LOCK, &zram->table[index].flags);
+}
+
+static void zram_slot_unlock(struct zram *zram, u32 index)
+{
+	__clear_bit(ZRAM_LOCK, &zram->table[index].flags);
+	spin_unlock(&zram->table[index].lock);
+}
+
+#else
+
+static void zram_meta_init_table_locks(struct zram *zram, size_t num_pages) { }
 
 static int zram_slot_trylock(struct zram *zram, u32 index)
 {
@@ -74,6 +108,7 @@ static void zram_slot_unlock(struct zram *zram, u32 index)
 {
 	bit_spin_unlock(ZRAM_LOCK, &zram->table[index].flags);
 }
+#endif
 
 static inline bool init_done(struct zram *zram)
 {
@@ -1165,6 +1200,7 @@ static bool zram_meta_alloc(struct zram *zram, u64 disksize)
 
 	if (!huge_class_size)
 		huge_class_size = zs_huge_class_size(zram->mem_pool);
+	zram_meta_init_table_locks(zram, num_pages);
 	return true;
 }
 
diff --git a/drivers/block/zram/zram_drv.h b/drivers/block/zram/zram_drv.h
index f2fd46daa760..7e4dd447e1dd 100644
--- a/drivers/block/zram/zram_drv.h
+++ b/drivers/block/zram/zram_drv.h
@@ -63,6 +63,7 @@ struct zram_table_entry {
 		unsigned long element;
 	};
 	unsigned long flags;
+	spinlock_t lock;
 #ifdef CONFIG_ZRAM_MEMORY_TRACKING
 	ktime_t ac_time;
 #endif
diff --git a/drivers/char/tpm/tpm-dev-common.c b/drivers/char/tpm/tpm-dev-common.c
index b99e1941c52c..dc4c0a0a5129 100644
--- a/drivers/char/tpm/tpm-dev-common.c
+++ b/drivers/char/tpm/tpm-dev-common.c
@@ -20,7 +20,6 @@
 #include "tpm-dev.h"
 
 static struct workqueue_struct *tpm_dev_wq;
-static DEFINE_MUTEX(tpm_dev_wq_lock);
 
 static ssize_t tpm_dev_transmit(struct tpm_chip *chip, struct tpm_space *space,
 				u8 *buf, size_t bufsiz)
diff --git a/drivers/char/tpm/tpm_tis.c b/drivers/char/tpm/tpm_tis.c
index 4ed6e660273a..c2bd0d40b5fc 100644
--- a/drivers/char/tpm/tpm_tis.c
+++ b/drivers/char/tpm/tpm_tis.c
@@ -50,6 +50,31 @@ static inline struct tpm_tis_tcg_phy *to_tpm_tis_tcg_phy(struct tpm_tis_data *da
 	return container_of(data, struct tpm_tis_tcg_phy, priv);
 }
 
+#ifdef CONFIG_PREEMPT_RT
+/*
+ * Flushes previous write operations to chip so that a subsequent
+ * ioread*()s won't stall a cpu.
+ */
+static inline void tpm_tis_flush(void __iomem *iobase)
+{
+	ioread8(iobase + TPM_ACCESS(0));
+}
+#else
+#define tpm_tis_flush(iobase) do { } while (0)
+#endif
+
+static inline void tpm_tis_iowrite8(u8 b, void __iomem *iobase, u32 addr)
+{
+	iowrite8(b, iobase + addr);
+	tpm_tis_flush(iobase);
+}
+
+static inline void tpm_tis_iowrite32(u32 b, void __iomem *iobase, u32 addr)
+{
+	iowrite32(b, iobase + addr);
+	tpm_tis_flush(iobase);
+}
+
 static int interrupts = -1;
 module_param(interrupts, int, 0444);
 MODULE_PARM_DESC(interrupts, "Enable interrupts");
@@ -169,7 +194,7 @@ static int tpm_tcg_write_bytes(struct tpm_tis_data *data, u32 addr, u16 len,
 	struct tpm_tis_tcg_phy *phy = to_tpm_tis_tcg_phy(data);
 
 	while (len--)
-		iowrite8(*value++, phy->iobase + addr);
+		tpm_tis_iowrite8(*value++, phy->iobase, addr);
 
 	return 0;
 }
@@ -196,7 +221,7 @@ static int tpm_tcg_write32(struct tpm_tis_data *data, u32 addr, u32 value)
 {
 	struct tpm_tis_tcg_phy *phy = to_tpm_tis_tcg_phy(data);
 
-	iowrite32(value, phy->iobase + addr);
+	tpm_tis_iowrite32(value, phy->iobase, addr);
 
 	return 0;
 }
diff --git a/drivers/firewire/ohci.c b/drivers/firewire/ohci.c
index 9811c40956e5..17c9d825188b 100644
--- a/drivers/firewire/ohci.c
+++ b/drivers/firewire/ohci.c
@@ -2545,7 +2545,7 @@ static int ohci_cancel_packet(struct fw_card *card, struct fw_packet *packet)
 	struct driver_data *driver_data = packet->driver_data;
 	int ret = -ENOENT;
 
-	tasklet_disable(&ctx->tasklet);
+	tasklet_disable_in_atomic(&ctx->tasklet);
 
 	if (packet->ack != 0)
 		goto out;
@@ -3465,7 +3465,7 @@ static int ohci_flush_iso_completions(struct fw_iso_context *base)
 	struct iso_context *ctx = container_of(base, struct iso_context, base);
 	int ret = 0;
 
-	tasklet_disable(&ctx->context.tasklet);
+	tasklet_disable_in_atomic(&ctx->context.tasklet);
 
 	if (!test_and_set_bit_lock(0, &ctx->flushing_completions)) {
 		context_tasklet((unsigned long)&ctx->context);
diff --git a/drivers/firmware/efi/efi.c b/drivers/firmware/efi/efi.c
index c406de00883a..7792bca9ee76 100644
--- a/drivers/firmware/efi/efi.c
+++ b/drivers/firmware/efi/efi.c
@@ -66,7 +66,7 @@ struct mm_struct efi_mm = {
 
 struct workqueue_struct *efi_rts_wq;
 
-static bool disable_runtime;
+static bool disable_runtime = IS_ENABLED(CONFIG_PREEMPT_RT);
 static int __init setup_noefi(char *arg)
 {
 	disable_runtime = true;
@@ -97,6 +97,9 @@ static int __init parse_efi_cmdline(char *str)
 	if (parse_option_str(str, "noruntime"))
 		disable_runtime = true;
 
+	if (parse_option_str(str, "runtime"))
+		disable_runtime = false;
+
 	if (parse_option_str(str, "nosoftreserve"))
 		set_bit(EFI_MEM_NO_SOFT_RESERVE, &efi.flags);
 
diff --git a/drivers/gpu/drm/i915/display/intel_sprite.c b/drivers/gpu/drm/i915/display/intel_sprite.c
index 12f7128b777f..a65061e3e1d3 100644
--- a/drivers/gpu/drm/i915/display/intel_sprite.c
+++ b/drivers/gpu/drm/i915/display/intel_sprite.c
@@ -118,7 +118,8 @@ void intel_pipe_update_start(const struct intel_crtc_state *new_crtc_state)
 			"PSR idle timed out 0x%x, atomic update may fail\n",
 			psr_status);
 
-	local_irq_disable();
+	if (!IS_ENABLED(CONFIG_PREEMPT_RT))
+		local_irq_disable();
 
 	crtc->debug.min_vbl = min;
 	crtc->debug.max_vbl = max;
@@ -143,11 +144,13 @@ void intel_pipe_update_start(const struct intel_crtc_state *new_crtc_state)
 			break;
 		}
 
-		local_irq_enable();
+		if (!IS_ENABLED(CONFIG_PREEMPT_RT))
+			local_irq_enable();
 
 		timeout = schedule_timeout(timeout);
 
-		local_irq_disable();
+		if (!IS_ENABLED(CONFIG_PREEMPT_RT))
+			local_irq_disable();
 	}
 
 	finish_wait(wq, &wait);
@@ -180,7 +183,8 @@ void intel_pipe_update_start(const struct intel_crtc_state *new_crtc_state)
 	return;
 
 irq_disable:
-	local_irq_disable();
+	if (!IS_ENABLED(CONFIG_PREEMPT_RT))
+		local_irq_disable();
 }
 
 /**
@@ -218,7 +222,8 @@ void intel_pipe_update_end(struct intel_crtc_state *new_crtc_state)
 		new_crtc_state->uapi.event = NULL;
 	}
 
-	local_irq_enable();
+	if (!IS_ENABLED(CONFIG_PREEMPT_RT))
+		local_irq_enable();
 
 	if (intel_vgpu_active(dev_priv))
 		return;
diff --git a/drivers/gpu/drm/i915/gem/i915_gem_execbuffer.c b/drivers/gpu/drm/i915/gem/i915_gem_execbuffer.c
index 0c083af5a59d..2abf043d3d9d 100644
--- a/drivers/gpu/drm/i915/gem/i915_gem_execbuffer.c
+++ b/drivers/gpu/drm/i915/gem/i915_gem_execbuffer.c
@@ -1080,7 +1080,7 @@ static void reloc_cache_reset(struct reloc_cache *cache, struct i915_execbuffer
 		struct i915_ggtt *ggtt = cache_to_ggtt(cache);
 
 		intel_gt_flush_ggtt_writes(ggtt->vm.gt);
-		io_mapping_unmap_atomic((void __iomem *)vaddr);
+		io_mapping_unmap_local((void __iomem *)vaddr);
 
 		if (drm_mm_node_allocated(&cache->node)) {
 			ggtt->vm.clear_range(&ggtt->vm,
@@ -1146,7 +1146,7 @@ static void *reloc_iomap(struct drm_i915_gem_object *obj,
 
 	if (cache->vaddr) {
 		intel_gt_flush_ggtt_writes(ggtt->vm.gt);
-		io_mapping_unmap_atomic((void __force __iomem *) unmask_page(cache->vaddr));
+		io_mapping_unmap_local((void __force __iomem *) unmask_page(cache->vaddr));
 	} else {
 		struct i915_vma *vma;
 		int err;
@@ -1194,8 +1194,7 @@ static void *reloc_iomap(struct drm_i915_gem_object *obj,
 		offset += page << PAGE_SHIFT;
 	}
 
-	vaddr = (void __force *)io_mapping_map_atomic_wc(&ggtt->iomap,
-							 offset);
+	vaddr = (void __force *)io_mapping_map_local_wc(&ggtt->iomap, offset);
 	cache->page = page;
 	cache->vaddr = (unsigned long)vaddr;
 
diff --git a/drivers/gpu/drm/i915/gt/intel_breadcrumbs.c b/drivers/gpu/drm/i915/gt/intel_breadcrumbs.c
index 0040b4765a54..3f4f854786f2 100644
--- a/drivers/gpu/drm/i915/gt/intel_breadcrumbs.c
+++ b/drivers/gpu/drm/i915/gt/intel_breadcrumbs.c
@@ -342,10 +342,9 @@ void intel_breadcrumbs_park(struct intel_breadcrumbs *b)
 	/* Kick the work once more to drain the signalers */
 	irq_work_sync(&b->irq_work);
 	while (unlikely(READ_ONCE(b->irq_armed))) {
-		local_irq_disable();
-		signal_irq_work(&b->irq_work);
-		local_irq_enable();
+		irq_work_queue(&b->irq_work);
 		cond_resched();
+		irq_work_sync(&b->irq_work);
 	}
 	GEM_BUG_ON(!list_empty(&b->signalers));
 }
diff --git a/drivers/gpu/drm/i915/gt/intel_engine_pm.c b/drivers/gpu/drm/i915/gt/intel_engine_pm.c
index f7b2e07e2229..313d8a28e776 100644
--- a/drivers/gpu/drm/i915/gt/intel_engine_pm.c
+++ b/drivers/gpu/drm/i915/gt/intel_engine_pm.c
@@ -60,9 +60,10 @@ static int __engine_unpark(struct intel_wakeref *wf)
 
 static inline unsigned long __timeline_mark_lock(struct intel_context *ce)
 {
-	unsigned long flags;
+	unsigned long flags = 0;
 
-	local_irq_save(flags);
+	if (!force_irqthreads)
+		local_irq_save(flags);
 	mutex_acquire(&ce->timeline->mutex.dep_map, 2, 0, _THIS_IP_);
 
 	return flags;
@@ -72,7 +73,8 @@ static inline void __timeline_mark_unlock(struct intel_context *ce,
 					  unsigned long flags)
 {
 	mutex_release(&ce->timeline->mutex.dep_map, _THIS_IP_);
-	local_irq_restore(flags);
+	if (!force_irqthreads)
+		local_irq_restore(flags);
 }
 
 #else
diff --git a/drivers/gpu/drm/i915/i915_gem.c b/drivers/gpu/drm/i915/i915_gem.c
index 58276694c848..88944c3b1bc8 100644
--- a/drivers/gpu/drm/i915/i915_gem.c
+++ b/drivers/gpu/drm/i915/i915_gem.c
@@ -355,22 +355,15 @@ gtt_user_read(struct io_mapping *mapping,
 	      char __user *user_data, int length)
 {
 	void __iomem *vaddr;
-	unsigned long unwritten;
+	bool fail = false;
 
 	/* We can use the cpu mem copy function because this is X86. */
-	vaddr = io_mapping_map_atomic_wc(mapping, base);
-	unwritten = __copy_to_user_inatomic(user_data,
-					    (void __force *)vaddr + offset,
-					    length);
-	io_mapping_unmap_atomic(vaddr);
-	if (unwritten) {
-		vaddr = io_mapping_map_wc(mapping, base, PAGE_SIZE);
-		unwritten = copy_to_user(user_data,
-					 (void __force *)vaddr + offset,
-					 length);
-		io_mapping_unmap(vaddr);
-	}
-	return unwritten;
+	vaddr = io_mapping_map_local_wc(mapping, base);
+	if (copy_to_user(user_data, (void __force *)vaddr + offset, length))
+		fail = true;
+	io_mapping_unmap_local(vaddr);
+
+	return fail;
 }
 
 static int
@@ -539,21 +532,14 @@ ggtt_write(struct io_mapping *mapping,
 	   char __user *user_data, int length)
 {
 	void __iomem *vaddr;
-	unsigned long unwritten;
+	bool fail = false;
 
 	/* We can use the cpu mem copy function because this is X86. */
-	vaddr = io_mapping_map_atomic_wc(mapping, base);
-	unwritten = __copy_from_user_inatomic_nocache((void __force *)vaddr + offset,
-						      user_data, length);
-	io_mapping_unmap_atomic(vaddr);
-	if (unwritten) {
-		vaddr = io_mapping_map_wc(mapping, base, PAGE_SIZE);
-		unwritten = copy_from_user((void __force *)vaddr + offset,
-					   user_data, length);
-		io_mapping_unmap(vaddr);
-	}
-
-	return unwritten;
+	vaddr = io_mapping_map_local_wc(mapping, base);
+	if (copy_from_user((void __force *)vaddr + offset, user_data, length))
+		fail = true;
+	io_mapping_unmap_local(vaddr);
+	return fail;
 }
 
 /**
diff --git a/drivers/gpu/drm/i915/i915_irq.c b/drivers/gpu/drm/i915/i915_irq.c
index 759f523c6a6b..7339a42ab2b8 100644
--- a/drivers/gpu/drm/i915/i915_irq.c
+++ b/drivers/gpu/drm/i915/i915_irq.c
@@ -847,6 +847,7 @@ static bool i915_get_crtc_scanoutpos(struct drm_crtc *_crtc,
 	spin_lock_irqsave(&dev_priv->uncore.lock, irqflags);
 
 	/* preempt_disable_rt() should go right here in PREEMPT_RT patchset. */
+	preempt_disable_rt();
 
 	/* Get optional system timestamp before query. */
 	if (stime)
@@ -898,6 +899,7 @@ static bool i915_get_crtc_scanoutpos(struct drm_crtc *_crtc,
 		*etime = ktime_get();
 
 	/* preempt_enable_rt() should go right here in PREEMPT_RT patchset. */
+	preempt_enable_rt();
 
 	spin_unlock_irqrestore(&dev_priv->uncore.lock, irqflags);
 
diff --git a/drivers/gpu/drm/i915/i915_trace.h b/drivers/gpu/drm/i915/i915_trace.h
index a4addcc64978..396b6598694d 100644
--- a/drivers/gpu/drm/i915/i915_trace.h
+++ b/drivers/gpu/drm/i915/i915_trace.h
@@ -2,6 +2,10 @@
 #if !defined(_I915_TRACE_H_) || defined(TRACE_HEADER_MULTI_READ)
 #define _I915_TRACE_H_
 
+#ifdef CONFIG_PREEMPT_RT
+#define NOTRACE
+#endif
+
 #include <linux/stringify.h>
 #include <linux/types.h>
 #include <linux/tracepoint.h>
@@ -778,7 +782,7 @@ DEFINE_EVENT(i915_request, i915_request_add,
 	    TP_ARGS(rq)
 );
 
-#if defined(CONFIG_DRM_I915_LOW_LEVEL_TRACEPOINTS)
+#if defined(CONFIG_DRM_I915_LOW_LEVEL_TRACEPOINTS) && !defined(NOTRACE)
 DEFINE_EVENT(i915_request, i915_request_submit,
 	     TP_PROTO(struct i915_request *rq),
 	     TP_ARGS(rq)
diff --git a/drivers/gpu/drm/i915/selftests/i915_gem.c b/drivers/gpu/drm/i915/selftests/i915_gem.c
index 412e21604a05..432493183d20 100644
--- a/drivers/gpu/drm/i915/selftests/i915_gem.c
+++ b/drivers/gpu/drm/i915/selftests/i915_gem.c
@@ -57,12 +57,12 @@ static void trash_stolen(struct drm_i915_private *i915)
 
 		ggtt->vm.insert_page(&ggtt->vm, dma, slot, I915_CACHE_NONE, 0);
 
-		s = io_mapping_map_atomic_wc(&ggtt->iomap, slot);
+		s = io_mapping_map_local_wc(&ggtt->iomap, slot);
 		for (x = 0; x < PAGE_SIZE / sizeof(u32); x++) {
 			prng = next_pseudo_random32(prng);
 			iowrite32(prng, &s[x]);
 		}
-		io_mapping_unmap_atomic(s);
+		io_mapping_unmap_local(s);
 	}
 
 	ggtt->vm.clear_range(&ggtt->vm, slot, PAGE_SIZE);
diff --git a/drivers/gpu/drm/i915/selftests/i915_gem_gtt.c b/drivers/gpu/drm/i915/selftests/i915_gem_gtt.c
index 65e28c4cd4ce..ca483285f267 100644
--- a/drivers/gpu/drm/i915/selftests/i915_gem_gtt.c
+++ b/drivers/gpu/drm/i915/selftests/i915_gem_gtt.c
@@ -1201,9 +1201,9 @@ static int igt_ggtt_page(void *arg)
 		u64 offset = tmp.start + order[n] * PAGE_SIZE;
 		u32 __iomem *vaddr;
 
-		vaddr = io_mapping_map_atomic_wc(&ggtt->iomap, offset);
+		vaddr = io_mapping_map_local_wc(&ggtt->iomap, offset);
 		iowrite32(n, vaddr + n);
-		io_mapping_unmap_atomic(vaddr);
+		io_mapping_unmap_local(vaddr);
 	}
 	intel_gt_flush_ggtt_writes(ggtt->vm.gt);
 
@@ -1213,9 +1213,9 @@ static int igt_ggtt_page(void *arg)
 		u32 __iomem *vaddr;
 		u32 val;
 
-		vaddr = io_mapping_map_atomic_wc(&ggtt->iomap, offset);
+		vaddr = io_mapping_map_local_wc(&ggtt->iomap, offset);
 		val = ioread32(vaddr + n);
-		io_mapping_unmap_atomic(vaddr);
+		io_mapping_unmap_local(vaddr);
 
 		if (val != n) {
 			pr_err("insert page failed: found %d, expected %d\n",
diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/devinit/fbmem.h b/drivers/gpu/drm/nouveau/nvkm/subdev/devinit/fbmem.h
index 6c5bbff12eb4..411f91ee20fa 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/devinit/fbmem.h
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/devinit/fbmem.h
@@ -60,19 +60,19 @@ fbmem_fini(struct io_mapping *fb)
 static inline u32
 fbmem_peek(struct io_mapping *fb, u32 off)
 {
-	u8 __iomem *p = io_mapping_map_atomic_wc(fb, off & PAGE_MASK);
+	u8 __iomem *p = io_mapping_map_local_wc(fb, off & PAGE_MASK);
 	u32 val = ioread32(p + (off & ~PAGE_MASK));
-	io_mapping_unmap_atomic(p);
+	io_mapping_unmap_local(p);
 	return val;
 }
 
 static inline void
 fbmem_poke(struct io_mapping *fb, u32 off, u32 val)
 {
-	u8 __iomem *p = io_mapping_map_atomic_wc(fb, off & PAGE_MASK);
+	u8 __iomem *p = io_mapping_map_local_wc(fb, off & PAGE_MASK);
 	iowrite32(val, p + (off & ~PAGE_MASK));
 	wmb();
-	io_mapping_unmap_atomic(p);
+	io_mapping_unmap_local(p);
 }
 
 static inline bool
diff --git a/drivers/gpu/drm/qxl/qxl_image.c b/drivers/gpu/drm/qxl/qxl_image.c
index 60ab7151b84d..93f92ccd42e5 100644
--- a/drivers/gpu/drm/qxl/qxl_image.c
+++ b/drivers/gpu/drm/qxl/qxl_image.c
@@ -124,12 +124,12 @@ qxl_image_init_helper(struct qxl_device *qdev,
 				  wrong (check the bitmaps are sent correctly
 				  first) */
 
-	ptr = qxl_bo_kmap_atomic_page(qdev, chunk_bo, 0);
+	ptr = qxl_bo_kmap_local_page(qdev, chunk_bo, 0);
 	chunk = ptr;
 	chunk->data_size = height * chunk_stride;
 	chunk->prev_chunk = 0;
 	chunk->next_chunk = 0;
-	qxl_bo_kunmap_atomic_page(qdev, chunk_bo, ptr);
+	qxl_bo_kunmap_local_page(qdev, chunk_bo, ptr);
 
 	{
 		void *k_data, *i_data;
@@ -143,7 +143,7 @@ qxl_image_init_helper(struct qxl_device *qdev,
 			i_data = (void *)data;
 
 			while (remain > 0) {
-				ptr = qxl_bo_kmap_atomic_page(qdev, chunk_bo, page << PAGE_SHIFT);
+				ptr = qxl_bo_kmap_local_page(qdev, chunk_bo, page << PAGE_SHIFT);
 
 				if (page == 0) {
 					chunk = ptr;
@@ -157,7 +157,7 @@ qxl_image_init_helper(struct qxl_device *qdev,
 
 				memcpy(k_data, i_data, size);
 
-				qxl_bo_kunmap_atomic_page(qdev, chunk_bo, ptr);
+				qxl_bo_kunmap_local_page(qdev, chunk_bo, ptr);
 				i_data += size;
 				remain -= size;
 				page++;
@@ -175,10 +175,10 @@ qxl_image_init_helper(struct qxl_device *qdev,
 					page_offset = offset_in_page(out_offset);
 					size = min((int)(PAGE_SIZE - page_offset), remain);
 
-					ptr = qxl_bo_kmap_atomic_page(qdev, chunk_bo, page_base);
+					ptr = qxl_bo_kmap_local_page(qdev, chunk_bo, page_base);
 					k_data = ptr + page_offset;
 					memcpy(k_data, i_data, size);
-					qxl_bo_kunmap_atomic_page(qdev, chunk_bo, ptr);
+					qxl_bo_kunmap_local_page(qdev, chunk_bo, ptr);
 					remain -= size;
 					i_data += size;
 					out_offset += size;
@@ -189,7 +189,7 @@ qxl_image_init_helper(struct qxl_device *qdev,
 	qxl_bo_kunmap(chunk_bo);
 
 	image_bo = dimage->bo;
-	ptr = qxl_bo_kmap_atomic_page(qdev, image_bo, 0);
+	ptr = qxl_bo_kmap_local_page(qdev, image_bo, 0);
 	image = ptr;
 
 	image->descriptor.id = 0;
@@ -212,7 +212,7 @@ qxl_image_init_helper(struct qxl_device *qdev,
 		break;
 	default:
 		DRM_ERROR("unsupported image bit depth\n");
-		qxl_bo_kunmap_atomic_page(qdev, image_bo, ptr);
+		qxl_bo_kunmap_local_page(qdev, image_bo, ptr);
 		return -EINVAL;
 	}
 	image->u.bitmap.flags = QXL_BITMAP_TOP_DOWN;
@@ -222,7 +222,7 @@ qxl_image_init_helper(struct qxl_device *qdev,
 	image->u.bitmap.palette = 0;
 	image->u.bitmap.data = qxl_bo_physical_address(qdev, chunk_bo, 0);
 
-	qxl_bo_kunmap_atomic_page(qdev, image_bo, ptr);
+	qxl_bo_kunmap_local_page(qdev, image_bo, ptr);
 
 	return 0;
 }
diff --git a/drivers/gpu/drm/qxl/qxl_ioctl.c b/drivers/gpu/drm/qxl/qxl_ioctl.c
index 5cea6eea72ab..785023081b79 100644
--- a/drivers/gpu/drm/qxl/qxl_ioctl.c
+++ b/drivers/gpu/drm/qxl/qxl_ioctl.c
@@ -89,11 +89,11 @@ apply_reloc(struct qxl_device *qdev, struct qxl_reloc_info *info)
 {
 	void *reloc_page;
 
-	reloc_page = qxl_bo_kmap_atomic_page(qdev, info->dst_bo, info->dst_offset & PAGE_MASK);
+	reloc_page = qxl_bo_kmap_local_page(qdev, info->dst_bo, info->dst_offset & PAGE_MASK);
 	*(uint64_t *)(reloc_page + (info->dst_offset & ~PAGE_MASK)) = qxl_bo_physical_address(qdev,
 											      info->src_bo,
 											      info->src_offset);
-	qxl_bo_kunmap_atomic_page(qdev, info->dst_bo, reloc_page);
+	qxl_bo_kunmap_local_page(qdev, info->dst_bo, reloc_page);
 }
 
 static void
@@ -105,9 +105,9 @@ apply_surf_reloc(struct qxl_device *qdev, struct qxl_reloc_info *info)
 	if (info->src_bo && !info->src_bo->is_primary)
 		id = info->src_bo->surface_id;
 
-	reloc_page = qxl_bo_kmap_atomic_page(qdev, info->dst_bo, info->dst_offset & PAGE_MASK);
+	reloc_page = qxl_bo_kmap_local_page(qdev, info->dst_bo, info->dst_offset & PAGE_MASK);
 	*(uint32_t *)(reloc_page + (info->dst_offset & ~PAGE_MASK)) = id;
-	qxl_bo_kunmap_atomic_page(qdev, info->dst_bo, reloc_page);
+	qxl_bo_kunmap_local_page(qdev, info->dst_bo, reloc_page);
 }
 
 /* return holding the reference to this object */
@@ -149,7 +149,6 @@ static int qxl_process_single_command(struct qxl_device *qdev,
 	struct qxl_bo *cmd_bo;
 	void *fb_cmd;
 	int i, ret, num_relocs;
-	int unwritten;
 
 	switch (cmd->type) {
 	case QXL_CMD_DRAW:
@@ -185,21 +184,21 @@ static int qxl_process_single_command(struct qxl_device *qdev,
 		goto out_free_reloc;
 
 	/* TODO copy slow path code from i915 */
-	fb_cmd = qxl_bo_kmap_atomic_page(qdev, cmd_bo, (release->release_offset & PAGE_MASK));
-	unwritten = __copy_from_user_inatomic_nocache
-		(fb_cmd + sizeof(union qxl_release_info) + (release->release_offset & ~PAGE_MASK),
-		 u64_to_user_ptr(cmd->command), cmd->command_size);
+	fb_cmd = qxl_bo_kmap_local_page(qdev, cmd_bo, (release->release_offset & PAGE_MASK));
 
-	{
+	if (copy_from_user(fb_cmd + sizeof(union qxl_release_info) +
+			   (release->release_offset & ~PAGE_MASK),
+			   u64_to_user_ptr(cmd->command), cmd->command_size)) {
+		ret = -EFAULT;
+	} else {
 		struct qxl_drawable *draw = fb_cmd;
 
 		draw->mm_time = qdev->rom->mm_clock;
 	}
 
-	qxl_bo_kunmap_atomic_page(qdev, cmd_bo, fb_cmd);
-	if (unwritten) {
-		DRM_ERROR("got unwritten %d\n", unwritten);
-		ret = -EFAULT;
+	qxl_bo_kunmap_local_page(qdev, cmd_bo, fb_cmd);
+	if (ret) {
+		DRM_ERROR("copy from user failed %d\n", ret);
 		goto out_free_release;
 	}
 
diff --git a/drivers/gpu/drm/qxl/qxl_object.c b/drivers/gpu/drm/qxl/qxl_object.c
index 544a9e4df2a8..5ee5171d46ef 100644
--- a/drivers/gpu/drm/qxl/qxl_object.c
+++ b/drivers/gpu/drm/qxl/qxl_object.c
@@ -173,8 +173,8 @@ int qxl_bo_kmap(struct qxl_bo *bo, void **ptr)
 	return 0;
 }
 
-void *qxl_bo_kmap_atomic_page(struct qxl_device *qdev,
-			      struct qxl_bo *bo, int page_offset)
+void *qxl_bo_kmap_local_page(struct qxl_device *qdev,
+			     struct qxl_bo *bo, int page_offset)
 {
 	unsigned long offset;
 	void *rptr;
@@ -189,7 +189,7 @@ void *qxl_bo_kmap_atomic_page(struct qxl_device *qdev,
 		goto fallback;
 
 	offset = bo->tbo.mem.start << PAGE_SHIFT;
-	return io_mapping_map_atomic_wc(map, offset + page_offset);
+	return io_mapping_map_local_wc(map, offset + page_offset);
 fallback:
 	if (bo->kptr) {
 		rptr = bo->kptr + (page_offset * PAGE_SIZE);
@@ -215,14 +215,14 @@ void qxl_bo_kunmap(struct qxl_bo *bo)
 	ttm_bo_kunmap(&bo->kmap);
 }
 
-void qxl_bo_kunmap_atomic_page(struct qxl_device *qdev,
-			       struct qxl_bo *bo, void *pmap)
+void qxl_bo_kunmap_local_page(struct qxl_device *qdev,
+			      struct qxl_bo *bo, void *pmap)
 {
 	if ((bo->tbo.mem.mem_type != TTM_PL_VRAM) &&
 	    (bo->tbo.mem.mem_type != TTM_PL_PRIV))
 		goto fallback;
 
-	io_mapping_unmap_atomic(pmap);
+	io_mapping_unmap_local(pmap);
 	return;
  fallback:
 	qxl_bo_kunmap(bo);
diff --git a/drivers/gpu/drm/qxl/qxl_object.h b/drivers/gpu/drm/qxl/qxl_object.h
index 5762ea40d047..6ae89b1b36f4 100644
--- a/drivers/gpu/drm/qxl/qxl_object.h
+++ b/drivers/gpu/drm/qxl/qxl_object.h
@@ -89,8 +89,8 @@ extern int qxl_bo_create(struct qxl_device *qdev,
 			 struct qxl_bo **bo_ptr);
 extern int qxl_bo_kmap(struct qxl_bo *bo, void **ptr);
 extern void qxl_bo_kunmap(struct qxl_bo *bo);
-void *qxl_bo_kmap_atomic_page(struct qxl_device *qdev, struct qxl_bo *bo, int page_offset);
-void qxl_bo_kunmap_atomic_page(struct qxl_device *qdev, struct qxl_bo *bo, void *map);
+void *qxl_bo_kmap_local_page(struct qxl_device *qdev, struct qxl_bo *bo, int page_offset);
+void qxl_bo_kunmap_local_page(struct qxl_device *qdev, struct qxl_bo *bo, void *map);
 extern struct qxl_bo *qxl_bo_ref(struct qxl_bo *bo);
 extern void qxl_bo_unref(struct qxl_bo **bo);
 extern int qxl_bo_pin(struct qxl_bo *bo);
diff --git a/drivers/gpu/drm/qxl/qxl_release.c b/drivers/gpu/drm/qxl/qxl_release.c
index b2a475a0ca4a..b665a33b449b 100644
--- a/drivers/gpu/drm/qxl/qxl_release.c
+++ b/drivers/gpu/drm/qxl/qxl_release.c
@@ -414,7 +414,7 @@ union qxl_release_info *qxl_release_map(struct qxl_device *qdev,
 	union qxl_release_info *info;
 	struct qxl_bo *bo = release->release_bo;
 
-	ptr = qxl_bo_kmap_atomic_page(qdev, bo, release->release_offset & PAGE_MASK);
+	ptr = qxl_bo_kmap_local_page(qdev, bo, release->release_offset & PAGE_MASK);
 	if (!ptr)
 		return NULL;
 	info = ptr + (release->release_offset & ~PAGE_MASK);
@@ -429,7 +429,7 @@ void qxl_release_unmap(struct qxl_device *qdev,
 	void *ptr;
 
 	ptr = ((void *)info) - (release->release_offset & ~PAGE_MASK);
-	qxl_bo_kunmap_atomic_page(qdev, bo, ptr);
+	qxl_bo_kunmap_local_page(qdev, bo, ptr);
 }
 
 void qxl_release_fence_buffer_objects(struct qxl_release *release)
diff --git a/drivers/gpu/drm/radeon/radeon_display.c b/drivers/gpu/drm/radeon/radeon_display.c
index 07d23a1e62a0..add8e60440b2 100644
--- a/drivers/gpu/drm/radeon/radeon_display.c
+++ b/drivers/gpu/drm/radeon/radeon_display.c
@@ -1828,6 +1828,7 @@ int radeon_get_crtc_scanoutpos(struct drm_device *dev, unsigned int pipe,
 	struct radeon_device *rdev = dev->dev_private;
 
 	/* preempt_disable_rt() should go right here in PREEMPT_RT patchset. */
+	preempt_disable_rt();
 
 	/* Get optional system timestamp before query. */
 	if (stime)
@@ -1920,6 +1921,7 @@ int radeon_get_crtc_scanoutpos(struct drm_device *dev, unsigned int pipe,
 		*etime = ktime_get();
 
 	/* preempt_enable_rt() should go right here in PREEMPT_RT patchset. */
+	preempt_enable_rt();
 
 	/* Decode into vertical and horizontal scanout position. */
 	*vpos = position & 0x1fff;
diff --git a/drivers/gpu/drm/ttm/ttm_bo_util.c b/drivers/gpu/drm/ttm/ttm_bo_util.c
index 20a5434c6853..17b2df35ef1b 100644
--- a/drivers/gpu/drm/ttm/ttm_bo_util.c
+++ b/drivers/gpu/drm/ttm/ttm_bo_util.c
@@ -181,13 +181,15 @@ static int ttm_copy_io_ttm_page(struct ttm_tt *ttm, void *src,
 		return -ENOMEM;
 
 	src = (void *)((unsigned long)src + (page << PAGE_SHIFT));
-	dst = kmap_atomic_prot(d, prot);
-	if (!dst)
-		return -ENOMEM;
+	/*
+	 * Ensure that a highmem page is mapped with the correct
+	 * pgprot. For non highmem the mapping is already there.
+	 */
+	dst = kmap_local_page_prot(d, prot);
 
 	memcpy_fromio(dst, src, PAGE_SIZE);
 
-	kunmap_atomic(dst);
+	kunmap_local(dst);
 
 	return 0;
 }
@@ -203,13 +205,15 @@ static int ttm_copy_ttm_io_page(struct ttm_tt *ttm, void *dst,
 		return -ENOMEM;
 
 	dst = (void *)((unsigned long)dst + (page << PAGE_SHIFT));
-	src = kmap_atomic_prot(s, prot);
-	if (!src)
-		return -ENOMEM;
+	/*
+	 * Ensure that a highmem page is mapped with the correct
+	 * pgprot. For non highmem the mapping is already there.
+	 */
+	src = kmap_local_page_prot(s, prot);
 
 	memcpy_toio(dst, src, PAGE_SIZE);
 
-	kunmap_atomic(src);
+	kunmap_local(src);
 
 	return 0;
 }
diff --git a/drivers/gpu/drm/vmwgfx/vmwgfx_blit.c b/drivers/gpu/drm/vmwgfx/vmwgfx_blit.c
index e8d66182cd7b..71dba228f68e 100644
--- a/drivers/gpu/drm/vmwgfx/vmwgfx_blit.c
+++ b/drivers/gpu/drm/vmwgfx/vmwgfx_blit.c
@@ -375,12 +375,12 @@ static int vmw_bo_cpu_blit_line(struct vmw_bo_blit_line_data *d,
 		copy_size = min_t(u32, copy_size, PAGE_SIZE - src_page_offset);
 
 		if (unmap_src) {
-			kunmap_atomic(d->src_addr);
+			kunmap_local(d->src_addr);
 			d->src_addr = NULL;
 		}
 
 		if (unmap_dst) {
-			kunmap_atomic(d->dst_addr);
+			kunmap_local(d->dst_addr);
 			d->dst_addr = NULL;
 		}
 
@@ -388,12 +388,8 @@ static int vmw_bo_cpu_blit_line(struct vmw_bo_blit_line_data *d,
 			if (WARN_ON_ONCE(dst_page >= d->dst_num_pages))
 				return -EINVAL;
 
-			d->dst_addr =
-				kmap_atomic_prot(d->dst_pages[dst_page],
-						 d->dst_prot);
-			if (!d->dst_addr)
-				return -ENOMEM;
-
+			d->dst_addr = kmap_local_page_prot(d->dst_pages[dst_page],
+							   d->dst_prot);
 			d->mapped_dst = dst_page;
 		}
 
@@ -401,12 +397,8 @@ static int vmw_bo_cpu_blit_line(struct vmw_bo_blit_line_data *d,
 			if (WARN_ON_ONCE(src_page >= d->src_num_pages))
 				return -EINVAL;
 
-			d->src_addr =
-				kmap_atomic_prot(d->src_pages[src_page],
-						 d->src_prot);
-			if (!d->src_addr)
-				return -ENOMEM;
-
+			d->src_addr = kmap_local_page_prot(d->src_pages[src_page],
+							   d->src_prot);
 			d->mapped_src = src_page;
 		}
 		diff->do_cpy(diff, d->dst_addr + dst_page_offset,
@@ -436,8 +428,10 @@ static int vmw_bo_cpu_blit_line(struct vmw_bo_blit_line_data *d,
  *
  * Performs a CPU blit from one buffer object to another avoiding a full
  * bo vmap which may exhaust- or fragment vmalloc space.
- * On supported architectures (x86), we're using kmap_atomic which avoids
- * cross-processor TLB- and cache flushes and may, on non-HIGHMEM systems
+ *
+ * On supported architectures (x86), we're using kmap_local_prot() which
+ * avoids cross-processor TLB- and cache flushes. kmap_local_prot() will
+ * either map a highmem page with the proper pgprot on HIGHMEM=y systems or
  * reference already set-up mappings.
  *
  * Neither of the buffer objects may be placed in PCI memory
@@ -500,9 +494,9 @@ int vmw_bo_cpu_blit(struct ttm_buffer_object *dst,
 	}
 out:
 	if (d.src_addr)
-		kunmap_atomic(d.src_addr);
+		kunmap_local(d.src_addr);
 	if (d.dst_addr)
-		kunmap_atomic(d.dst_addr);
+		kunmap_local(d.dst_addr);
 
 	return ret;
 }
diff --git a/drivers/hv/hyperv_vmbus.h b/drivers/hv/hyperv_vmbus.h
index 7845fa5de79e..043e058bb27c 100644
--- a/drivers/hv/hyperv_vmbus.h
+++ b/drivers/hv/hyperv_vmbus.h
@@ -19,6 +19,7 @@
 #include <linux/atomic.h>
 #include <linux/hyperv.h>
 #include <linux/interrupt.h>
+#include <linux/irq.h>
 
 #include "hv_trace.h"
 
diff --git a/drivers/hv/vmbus_drv.c b/drivers/hv/vmbus_drv.c
index 5d820037e291..ef5e12364119 100644
--- a/drivers/hv/vmbus_drv.c
+++ b/drivers/hv/vmbus_drv.c
@@ -22,6 +22,7 @@
 #include <linux/clockchips.h>
 #include <linux/cpu.h>
 #include <linux/sched/task_stack.h>
+#include <linux/irq.h>
 
 #include <linux/delay.h>
 #include <linux/notifier.h>
@@ -1307,6 +1308,8 @@ static void vmbus_isr(void)
 	void *page_addr = hv_cpu->synic_event_page;
 	struct hv_message *msg;
 	union hv_synic_event_flags *event;
+	struct pt_regs *regs = get_irq_regs();
+	u64 ip = regs ? instruction_pointer(regs) : 0;
 	bool handled = false;
 
 	if (unlikely(page_addr == NULL))
@@ -1359,7 +1362,8 @@ static void vmbus_isr(void)
  * buffer and call into Hyper-V to transfer the data.
  */
 static void hv_kmsg_dump(struct kmsg_dumper *dumper,
-			 enum kmsg_dump_reason reason)
+			 enum kmsg_dump_reason reason,
+			 struct kmsg_dumper_iter *iter)
 {
 	size_t bytes_written;
 	phys_addr_t panic_pa;
@@ -1374,7 +1378,7 @@ static void hv_kmsg_dump(struct kmsg_dumper *dumper,
 	 * Write dump contents to the page. No need to synchronize; panic should
 	 * be single-threaded.
 	 */
-	kmsg_dump_get_buffer(dumper, false, hv_panic_page, HV_HYP_PAGE_SIZE,
+	kmsg_dump_get_buffer(iter, false, hv_panic_page, HV_HYP_PAGE_SIZE,
 			     &bytes_written);
 	if (bytes_written)
 		hyperv_report_panic_msg(panic_pa, bytes_written);
diff --git a/drivers/leds/trigger/Kconfig b/drivers/leds/trigger/Kconfig
index ce9429ca6dde..29ccbd6acf43 100644
--- a/drivers/leds/trigger/Kconfig
+++ b/drivers/leds/trigger/Kconfig
@@ -64,6 +64,7 @@ config LEDS_TRIGGER_BACKLIGHT
 
 config LEDS_TRIGGER_CPU
 	bool "LED CPU Trigger"
+	depends on !PREEMPT_RT
 	help
 	  This allows LEDs to be controlled by active CPUs. This shows
 	  the active CPUs across an array of LEDs so you can see which
diff --git a/drivers/md/raid5.c b/drivers/md/raid5.c
index 454d90b785b9..61bea746917e 100644
--- a/drivers/md/raid5.c
+++ b/drivers/md/raid5.c
@@ -2217,8 +2217,9 @@ static void raid_run_ops(struct stripe_head *sh, unsigned long ops_request)
 	struct raid5_percpu *percpu;
 	unsigned long cpu;
 
-	cpu = get_cpu();
+	cpu = get_cpu_light();
 	percpu = per_cpu_ptr(conf->percpu, cpu);
+	spin_lock(&percpu->lock);
 	if (test_bit(STRIPE_OP_BIOFILL, &ops_request)) {
 		ops_run_biofill(sh);
 		overlap_clear++;
@@ -2277,7 +2278,8 @@ static void raid_run_ops(struct stripe_head *sh, unsigned long ops_request)
 			if (test_and_clear_bit(R5_Overlap, &dev->flags))
 				wake_up(&sh->raid_conf->wait_for_overlap);
 		}
-	put_cpu();
+	spin_unlock(&percpu->lock);
+	put_cpu_light();
 }
 
 static void free_stripe(struct kmem_cache *sc, struct stripe_head *sh)
@@ -7089,6 +7091,7 @@ static int raid456_cpu_up_prepare(unsigned int cpu, struct hlist_node *node)
 			__func__, cpu);
 		return -ENOMEM;
 	}
+	spin_lock_init(&per_cpu_ptr(conf->percpu, cpu)->lock);
 	return 0;
 }
 
diff --git a/drivers/md/raid5.h b/drivers/md/raid5.h
index 5c05acf20e1f..665fe138ab4f 100644
--- a/drivers/md/raid5.h
+++ b/drivers/md/raid5.h
@@ -635,6 +635,7 @@ struct r5conf {
 	int			recovery_disabled;
 	/* per cpu variables */
 	struct raid5_percpu {
+		spinlock_t	lock;		/* Protection for -RT */
 		struct page	*spare_page; /* Used when checking P/Q in raid6 */
 		void		*scribble;  /* space for constructing buffer
 					     * lists and performing address
diff --git a/drivers/mtd/mtdoops.c b/drivers/mtd/mtdoops.c
index 774970bfcf85..6bc2c728adb7 100644
--- a/drivers/mtd/mtdoops.c
+++ b/drivers/mtd/mtdoops.c
@@ -267,7 +267,8 @@ static void find_next_position(struct mtdoops_context *cxt)
 }
 
 static void mtdoops_do_dump(struct kmsg_dumper *dumper,
-			    enum kmsg_dump_reason reason)
+			    enum kmsg_dump_reason reason,
+			    struct kmsg_dumper_iter *iter)
 {
 	struct mtdoops_context *cxt = container_of(dumper,
 			struct mtdoops_context, dump);
@@ -276,7 +277,7 @@ static void mtdoops_do_dump(struct kmsg_dumper *dumper,
 	if (reason == KMSG_DUMP_OOPS && !dump_oops)
 		return;
 
-	kmsg_dump_get_buffer(dumper, true, cxt->oops_buf + MTDOOPS_HEADER_SIZE,
+	kmsg_dump_get_buffer(iter, true, cxt->oops_buf + MTDOOPS_HEADER_SIZE,
 			     record_size - MTDOOPS_HEADER_SIZE, NULL);
 
 	if (reason != KMSG_DUMP_OOPS) {
diff --git a/drivers/net/arcnet/arc-rimi.c b/drivers/net/arcnet/arc-rimi.c
index 98df38fe553c..12d085405bd0 100644
--- a/drivers/net/arcnet/arc-rimi.c
+++ b/drivers/net/arcnet/arc-rimi.c
@@ -332,7 +332,7 @@ static int __init arc_rimi_init(void)
 		dev->irq = 9;
 
 	if (arcrimi_probe(dev)) {
-		free_netdev(dev);
+		free_arcdev(dev);
 		return -EIO;
 	}
 
@@ -349,7 +349,7 @@ static void __exit arc_rimi_exit(void)
 	iounmap(lp->mem_start);
 	release_mem_region(dev->mem_start, dev->mem_end - dev->mem_start + 1);
 	free_irq(dev->irq, dev);
-	free_netdev(dev);
+	free_arcdev(dev);
 }
 
 #ifndef MODULE
diff --git a/drivers/net/arcnet/arcdevice.h b/drivers/net/arcnet/arcdevice.h
index 22a49c6d7ae6..5d4a4c7efbbf 100644
--- a/drivers/net/arcnet/arcdevice.h
+++ b/drivers/net/arcnet/arcdevice.h
@@ -298,6 +298,10 @@ struct arcnet_local {
 
 	int excnak_pending;    /* We just got an excesive nak interrupt */
 
+	/* RESET flag handling */
+	int reset_in_progress;
+	struct work_struct reset_work;
+
 	struct {
 		uint16_t sequence;	/* sequence number (incs with each packet) */
 		__be16 aborted_seq;
@@ -350,7 +354,9 @@ void arcnet_dump_skb(struct net_device *dev, struct sk_buff *skb, char *desc)
 
 void arcnet_unregister_proto(struct ArcProto *proto);
 irqreturn_t arcnet_interrupt(int irq, void *dev_id);
+
 struct net_device *alloc_arcdev(const char *name);
+void free_arcdev(struct net_device *dev);
 
 int arcnet_open(struct net_device *dev);
 int arcnet_close(struct net_device *dev);
diff --git a/drivers/net/arcnet/arcnet.c b/drivers/net/arcnet/arcnet.c
index e04efc0a5c97..d76dd7d14299 100644
--- a/drivers/net/arcnet/arcnet.c
+++ b/drivers/net/arcnet/arcnet.c
@@ -387,10 +387,44 @@ static void arcnet_timer(struct timer_list *t)
 	struct arcnet_local *lp = from_timer(lp, t, timer);
 	struct net_device *dev = lp->dev;
 
-	if (!netif_carrier_ok(dev)) {
+	spin_lock_irq(&lp->lock);
+
+	if (!lp->reset_in_progress && !netif_carrier_ok(dev)) {
 		netif_carrier_on(dev);
 		netdev_info(dev, "link up\n");
 	}
+
+	spin_unlock_irq(&lp->lock);
+}
+
+static void reset_device_work(struct work_struct *work)
+{
+	struct arcnet_local *lp;
+	struct net_device *dev;
+
+	lp = container_of(work, struct arcnet_local, reset_work);
+	dev = lp->dev;
+
+	/* Do not bring the network interface back up if an ifdown
+	 * was already done.
+	 */
+	if (!netif_running(dev) || !lp->reset_in_progress)
+		return;
+
+	rtnl_lock();
+
+	/* Do another check, in case of an ifdown that was triggered in
+	 * the small race window between the exit condition above and
+	 * acquiring RTNL.
+	 */
+	if (!netif_running(dev) || !lp->reset_in_progress)
+		goto out;
+
+	dev_close(dev);
+	dev_open(dev, NULL);
+
+out:
+	rtnl_unlock();
 }
 
 static void arcnet_reply_tasklet(unsigned long data)
@@ -452,12 +486,25 @@ struct net_device *alloc_arcdev(const char *name)
 		lp->dev = dev;
 		spin_lock_init(&lp->lock);
 		timer_setup(&lp->timer, arcnet_timer, 0);
+		INIT_WORK(&lp->reset_work, reset_device_work);
 	}
 
 	return dev;
 }
 EXPORT_SYMBOL(alloc_arcdev);
 
+void free_arcdev(struct net_device *dev)
+{
+	struct arcnet_local *lp = netdev_priv(dev);
+
+	/* Do not cancel this at ->ndo_close(), as the workqueue itself
+	 * indirectly calls the ifdown path through dev_close().
+	 */
+	cancel_work_sync(&lp->reset_work);
+	free_netdev(dev);
+}
+EXPORT_SYMBOL(free_arcdev);
+
 /* Open/initialize the board.  This is called sometime after booting when
  * the 'ifconfig' program is run.
  *
@@ -587,6 +634,10 @@ int arcnet_close(struct net_device *dev)
 
 	/* shut down the card */
 	lp->hw.close(dev);
+
+	/* reset counters */
+	lp->reset_in_progress = 0;
+
 	module_put(lp->hw.owner);
 	return 0;
 }
@@ -820,6 +871,9 @@ irqreturn_t arcnet_interrupt(int irq, void *dev_id)
 
 	spin_lock_irqsave(&lp->lock, flags);
 
+	if (lp->reset_in_progress)
+		goto out;
+
 	/* RESET flag was enabled - if device is not running, we must
 	 * clear it right away (but nothing else).
 	 */
@@ -852,11 +906,14 @@ irqreturn_t arcnet_interrupt(int irq, void *dev_id)
 		if (status & RESETflag) {
 			arc_printk(D_NORMAL, dev, "spurious reset (status=%Xh)\n",
 				   status);
-			arcnet_close(dev);
-			arcnet_open(dev);
+
+			lp->reset_in_progress = 1;
+			netif_stop_queue(dev);
+			netif_carrier_off(dev);
+			schedule_work(&lp->reset_work);
 
 			/* get out of the interrupt handler! */
-			break;
+			goto out;
 		}
 		/* RX is inhibited - we must have received something.
 		 * Prepare to receive into the next buffer.
@@ -1052,6 +1109,7 @@ irqreturn_t arcnet_interrupt(int irq, void *dev_id)
 	udelay(1);
 	lp->hw.intmask(dev, lp->intmask);
 
+out:
 	spin_unlock_irqrestore(&lp->lock, flags);
 	return retval;
 }
diff --git a/drivers/net/arcnet/com20020-isa.c b/drivers/net/arcnet/com20020-isa.c
index f983c4ce6b07..be618e4b9ed5 100644
--- a/drivers/net/arcnet/com20020-isa.c
+++ b/drivers/net/arcnet/com20020-isa.c
@@ -169,7 +169,7 @@ static int __init com20020_init(void)
 		dev->irq = 9;
 
 	if (com20020isa_probe(dev)) {
-		free_netdev(dev);
+		free_arcdev(dev);
 		return -EIO;
 	}
 
@@ -182,7 +182,7 @@ static void __exit com20020_exit(void)
 	unregister_netdev(my_dev);
 	free_irq(my_dev->irq, my_dev);
 	release_region(my_dev->base_addr, ARCNET_TOTAL_SIZE);
-	free_netdev(my_dev);
+	free_arcdev(my_dev);
 }
 
 #ifndef MODULE
diff --git a/drivers/net/arcnet/com20020-pci.c b/drivers/net/arcnet/com20020-pci.c
index 9f44e2e458df..b4f8798d8c50 100644
--- a/drivers/net/arcnet/com20020-pci.c
+++ b/drivers/net/arcnet/com20020-pci.c
@@ -294,7 +294,7 @@ static void com20020pci_remove(struct pci_dev *pdev)
 
 		unregister_netdev(dev);
 		free_irq(dev->irq, dev);
-		free_netdev(dev);
+		free_arcdev(dev);
 	}
 }
 
diff --git a/drivers/net/arcnet/com20020_cs.c b/drivers/net/arcnet/com20020_cs.c
index cf607ffcf358..9cc5eb6a8e90 100644
--- a/drivers/net/arcnet/com20020_cs.c
+++ b/drivers/net/arcnet/com20020_cs.c
@@ -177,7 +177,7 @@ static void com20020_detach(struct pcmcia_device *link)
 		dev = info->dev;
 		if (dev) {
 			dev_dbg(&link->dev, "kfree...\n");
-			free_netdev(dev);
+			free_arcdev(dev);
 		}
 		dev_dbg(&link->dev, "kfree2...\n");
 		kfree(info);
diff --git a/drivers/net/arcnet/com90io.c b/drivers/net/arcnet/com90io.c
index cf214b730671..3856b447d38e 100644
--- a/drivers/net/arcnet/com90io.c
+++ b/drivers/net/arcnet/com90io.c
@@ -396,7 +396,7 @@ static int __init com90io_init(void)
 	err = com90io_probe(dev);
 
 	if (err) {
-		free_netdev(dev);
+		free_arcdev(dev);
 		return err;
 	}
 
@@ -419,7 +419,7 @@ static void __exit com90io_exit(void)
 
 	free_irq(dev->irq, dev);
 	release_region(dev->base_addr, ARCNET_TOTAL_SIZE);
-	free_netdev(dev);
+	free_arcdev(dev);
 }
 
 module_init(com90io_init)
diff --git a/drivers/net/arcnet/com90xx.c b/drivers/net/arcnet/com90xx.c
index 3dc3d533cb19..d8dfb9ea0de8 100644
--- a/drivers/net/arcnet/com90xx.c
+++ b/drivers/net/arcnet/com90xx.c
@@ -554,7 +554,7 @@ static int __init com90xx_found(int ioaddr, int airq, u_long shmem,
 err_release_mem:
 	release_mem_region(dev->mem_start, dev->mem_end - dev->mem_start + 1);
 err_free_dev:
-	free_netdev(dev);
+	free_arcdev(dev);
 	return -EIO;
 }
 
@@ -672,7 +672,7 @@ static void __exit com90xx_exit(void)
 		release_region(dev->base_addr, ARCNET_TOTAL_SIZE);
 		release_mem_region(dev->mem_start,
 				   dev->mem_end - dev->mem_start + 1);
-		free_netdev(dev);
+		free_arcdev(dev);
 	}
 }
 
diff --git a/drivers/net/ethernet/chelsio/cxgb/common.h b/drivers/net/ethernet/chelsio/cxgb/common.h
index 6475060649e9..0321be77366c 100644
--- a/drivers/net/ethernet/chelsio/cxgb/common.h
+++ b/drivers/net/ethernet/chelsio/cxgb/common.h
@@ -238,7 +238,6 @@ struct adapter {
 	int msg_enable;
 	u32 mmio_len;
 
-	struct work_struct ext_intr_handler_task;
 	struct adapter_params params;
 
 	/* Terminator modules. */
@@ -257,6 +256,7 @@ struct adapter {
 
 	/* guards async operations */
 	spinlock_t async_lock ____cacheline_aligned;
+	u32 pending_thread_intr;
 	u32 slow_intr_mask;
 	int t1powersave;
 };
@@ -334,8 +334,7 @@ void t1_interrupts_enable(adapter_t *adapter);
 void t1_interrupts_disable(adapter_t *adapter);
 void t1_interrupts_clear(adapter_t *adapter);
 int t1_elmer0_ext_intr_handler(adapter_t *adapter);
-void t1_elmer0_ext_intr(adapter_t *adapter);
-int t1_slow_intr_handler(adapter_t *adapter);
+irqreturn_t t1_slow_intr_handler(adapter_t *adapter);
 
 int t1_link_start(struct cphy *phy, struct cmac *mac, struct link_config *lc);
 const struct board_info *t1_get_board_info(unsigned int board_id);
@@ -347,7 +346,6 @@ int t1_get_board_rev(adapter_t *adapter, const struct board_info *bi,
 int t1_init_hw_modules(adapter_t *adapter);
 int t1_init_sw_modules(adapter_t *adapter, const struct board_info *bi);
 void t1_free_sw_modules(adapter_t *adapter);
-void t1_fatal_err(adapter_t *adapter);
 void t1_link_changed(adapter_t *adapter, int port_id);
 void t1_link_negotiated(adapter_t *adapter, int port_id, int link_stat,
 			    int speed, int duplex, int pause);
diff --git a/drivers/net/ethernet/chelsio/cxgb/cxgb2.c b/drivers/net/ethernet/chelsio/cxgb/cxgb2.c
index 1311eac9eef2..c827273c4bd7 100644
--- a/drivers/net/ethernet/chelsio/cxgb/cxgb2.c
+++ b/drivers/net/ethernet/chelsio/cxgb/cxgb2.c
@@ -211,9 +211,10 @@ static int cxgb_up(struct adapter *adapter)
 	t1_interrupts_clear(adapter);
 
 	adapter->params.has_msi = !disable_msi && !pci_enable_msi(adapter->pdev);
-	err = request_irq(adapter->pdev->irq, t1_interrupt,
-			  adapter->params.has_msi ? 0 : IRQF_SHARED,
-			  adapter->name, adapter);
+	err = request_threaded_irq(adapter->pdev->irq, t1_interrupt,
+				   t1_interrupt_thread,
+				   adapter->params.has_msi ? 0 : IRQF_SHARED,
+				   adapter->name, adapter);
 	if (err) {
 		if (adapter->params.has_msi)
 			pci_disable_msi(adapter->pdev);
@@ -924,51 +925,6 @@ static void mac_stats_task(struct work_struct *work)
 	spin_unlock(&adapter->work_lock);
 }
 
-/*
- * Processes elmer0 external interrupts in process context.
- */
-static void ext_intr_task(struct work_struct *work)
-{
-	struct adapter *adapter =
-		container_of(work, struct adapter, ext_intr_handler_task);
-
-	t1_elmer0_ext_intr_handler(adapter);
-
-	/* Now reenable external interrupts */
-	spin_lock_irq(&adapter->async_lock);
-	adapter->slow_intr_mask |= F_PL_INTR_EXT;
-	writel(F_PL_INTR_EXT, adapter->regs + A_PL_CAUSE);
-	writel(adapter->slow_intr_mask | F_PL_INTR_SGE_DATA,
-		   adapter->regs + A_PL_ENABLE);
-	spin_unlock_irq(&adapter->async_lock);
-}
-
-/*
- * Interrupt-context handler for elmer0 external interrupts.
- */
-void t1_elmer0_ext_intr(struct adapter *adapter)
-{
-	/*
-	 * Schedule a task to handle external interrupts as we require
-	 * a process context.  We disable EXT interrupts in the interim
-	 * and let the task reenable them when it's done.
-	 */
-	adapter->slow_intr_mask &= ~F_PL_INTR_EXT;
-	writel(adapter->slow_intr_mask | F_PL_INTR_SGE_DATA,
-		   adapter->regs + A_PL_ENABLE);
-	schedule_work(&adapter->ext_intr_handler_task);
-}
-
-void t1_fatal_err(struct adapter *adapter)
-{
-	if (adapter->flags & FULL_INIT_DONE) {
-		t1_sge_stop(adapter->sge);
-		t1_interrupts_disable(adapter);
-	}
-	pr_alert("%s: encountered fatal error, operation suspended\n",
-		 adapter->name);
-}
-
 static const struct net_device_ops cxgb_netdev_ops = {
 	.ndo_open		= cxgb_open,
 	.ndo_stop		= cxgb_close,
@@ -1070,8 +1026,6 @@ static int init_one(struct pci_dev *pdev, const struct pci_device_id *ent)
 			spin_lock_init(&adapter->async_lock);
 			spin_lock_init(&adapter->mac_lock);
 
-			INIT_WORK(&adapter->ext_intr_handler_task,
-				  ext_intr_task);
 			INIT_DELAYED_WORK(&adapter->stats_update_task,
 					  mac_stats_task);
 
diff --git a/drivers/net/ethernet/chelsio/cxgb/sge.c b/drivers/net/ethernet/chelsio/cxgb/sge.c
index 2d9c2b5a690a..cda01f22c71c 100644
--- a/drivers/net/ethernet/chelsio/cxgb/sge.c
+++ b/drivers/net/ethernet/chelsio/cxgb/sge.c
@@ -940,10 +940,11 @@ void t1_sge_intr_clear(struct sge *sge)
 /*
  * SGE 'Error' interrupt handler
  */
-int t1_sge_intr_error_handler(struct sge *sge)
+bool t1_sge_intr_error_handler(struct sge *sge)
 {
 	struct adapter *adapter = sge->adapter;
 	u32 cause = readl(adapter->regs + A_SG_INT_CAUSE);
+	bool wake = false;
 
 	if (adapter->port[0].dev->hw_features & NETIF_F_TSO)
 		cause &= ~F_PACKET_TOO_BIG;
@@ -967,11 +968,14 @@ int t1_sge_intr_error_handler(struct sge *sge)
 		sge->stats.pkt_mismatch++;
 		pr_alert("%s: SGE packet mismatch\n", adapter->name);
 	}
-	if (cause & SGE_INT_FATAL)
-		t1_fatal_err(adapter);
+	if (cause & SGE_INT_FATAL) {
+		t1_interrupts_disable(adapter);
+		adapter->pending_thread_intr |= F_PL_INTR_SGE_ERR;
+		wake = true;
+	}
 
 	writel(cause, adapter->regs + A_SG_INT_CAUSE);
-	return 0;
+	return wake;
 }
 
 const struct sge_intr_counts *t1_sge_get_intr_counts(const struct sge *sge)
@@ -1619,11 +1623,46 @@ int t1_poll(struct napi_struct *napi, int budget)
 	return work_done;
 }
 
+irqreturn_t t1_interrupt_thread(int irq, void *data)
+{
+	struct adapter *adapter = data;
+	u32 pending_thread_intr;
+
+	spin_lock_irq(&adapter->async_lock);
+	pending_thread_intr = adapter->pending_thread_intr;
+	adapter->pending_thread_intr = 0;
+	spin_unlock_irq(&adapter->async_lock);
+
+	if (!pending_thread_intr)
+		return IRQ_NONE;
+
+	if (pending_thread_intr & F_PL_INTR_EXT)
+		t1_elmer0_ext_intr_handler(adapter);
+
+	/* This error is fatal, interrupts remain off */
+	if (pending_thread_intr & F_PL_INTR_SGE_ERR) {
+		pr_alert("%s: encountered fatal error, operation suspended\n",
+			 adapter->name);
+		t1_sge_stop(adapter->sge);
+		return IRQ_HANDLED;
+	}
+
+	spin_lock_irq(&adapter->async_lock);
+	adapter->slow_intr_mask |= F_PL_INTR_EXT;
+
+	writel(F_PL_INTR_EXT, adapter->regs + A_PL_CAUSE);
+	writel(adapter->slow_intr_mask | F_PL_INTR_SGE_DATA,
+	       adapter->regs + A_PL_ENABLE);
+	spin_unlock_irq(&adapter->async_lock);
+
+	return IRQ_HANDLED;
+}
+
 irqreturn_t t1_interrupt(int irq, void *data)
 {
 	struct adapter *adapter = data;
 	struct sge *sge = adapter->sge;
-	int handled;
+	irqreturn_t handled;
 
 	if (likely(responses_pending(adapter))) {
 		writel(F_PL_INTR_SGE_DATA, adapter->regs + A_PL_CAUSE);
@@ -1645,10 +1684,10 @@ irqreturn_t t1_interrupt(int irq, void *data)
 	handled = t1_slow_intr_handler(adapter);
 	spin_unlock(&adapter->async_lock);
 
-	if (!handled)
+	if (handled == IRQ_NONE)
 		sge->stats.unhandled_irqs++;
 
-	return IRQ_RETVAL(handled != 0);
+	return handled;
 }
 
 /*
diff --git a/drivers/net/ethernet/chelsio/cxgb/sge.h b/drivers/net/ethernet/chelsio/cxgb/sge.h
index a1ba591b3431..716705b96f26 100644
--- a/drivers/net/ethernet/chelsio/cxgb/sge.h
+++ b/drivers/net/ethernet/chelsio/cxgb/sge.h
@@ -74,6 +74,7 @@ struct sge *t1_sge_create(struct adapter *, struct sge_params *);
 int t1_sge_configure(struct sge *, struct sge_params *);
 int t1_sge_set_coalesce_params(struct sge *, struct sge_params *);
 void t1_sge_destroy(struct sge *);
+irqreturn_t t1_interrupt_thread(int irq, void *data);
 irqreturn_t t1_interrupt(int irq, void *cookie);
 int t1_poll(struct napi_struct *, int);
 
@@ -81,7 +82,7 @@ netdev_tx_t t1_start_xmit(struct sk_buff *skb, struct net_device *dev);
 void t1_vlan_mode(struct adapter *adapter, netdev_features_t features);
 void t1_sge_start(struct sge *);
 void t1_sge_stop(struct sge *);
-int t1_sge_intr_error_handler(struct sge *);
+bool t1_sge_intr_error_handler(struct sge *sge);
 void t1_sge_intr_enable(struct sge *);
 void t1_sge_intr_disable(struct sge *);
 void t1_sge_intr_clear(struct sge *);
diff --git a/drivers/net/ethernet/chelsio/cxgb/subr.c b/drivers/net/ethernet/chelsio/cxgb/subr.c
index ea0f8741d7cf..310add28fcf5 100644
--- a/drivers/net/ethernet/chelsio/cxgb/subr.c
+++ b/drivers/net/ethernet/chelsio/cxgb/subr.c
@@ -170,7 +170,7 @@ void t1_link_changed(adapter_t *adapter, int port_id)
 	t1_link_negotiated(adapter, port_id, link_ok, speed, duplex, fc);
 }
 
-static int t1_pci_intr_handler(adapter_t *adapter)
+static bool t1_pci_intr_handler(adapter_t *adapter)
 {
 	u32 pcix_cause;
 
@@ -179,9 +179,13 @@ static int t1_pci_intr_handler(adapter_t *adapter)
 	if (pcix_cause) {
 		pci_write_config_dword(adapter->pdev, A_PCICFG_INTR_CAUSE,
 				       pcix_cause);
-		t1_fatal_err(adapter);    /* PCI errors are fatal */
+		/* PCI errors are fatal */
+		t1_interrupts_disable(adapter);
+		adapter->pending_thread_intr |= F_PL_INTR_SGE_ERR;
+		pr_alert("%s: PCI error encountered.\n", adapter->name);
+		return true;
 	}
-	return 0;
+	return false;
 }
 
 #ifdef CONFIG_CHELSIO_T1_1G
@@ -210,13 +214,16 @@ static int fpga_phy_intr_handler(adapter_t *adapter)
 /*
  * Slow path interrupt handler for FPGAs.
  */
-static int fpga_slow_intr(adapter_t *adapter)
+static irqreturn_t fpga_slow_intr(adapter_t *adapter)
 {
 	u32 cause = readl(adapter->regs + A_PL_CAUSE);
+	irqreturn_t ret = IRQ_NONE;
 
 	cause &= ~F_PL_INTR_SGE_DATA;
-	if (cause & F_PL_INTR_SGE_ERR)
-		t1_sge_intr_error_handler(adapter->sge);
+	if (cause & F_PL_INTR_SGE_ERR) {
+		if (t1_sge_intr_error_handler(adapter->sge))
+			ret = IRQ_WAKE_THREAD;
+	}
 
 	if (cause & FPGA_PCIX_INTERRUPT_GMAC)
 		fpga_phy_intr_handler(adapter);
@@ -231,14 +238,19 @@ static int fpga_slow_intr(adapter_t *adapter)
 		/* Clear TP interrupt */
 		writel(tp_cause, adapter->regs + FPGA_TP_ADDR_INTERRUPT_CAUSE);
 	}
-	if (cause & FPGA_PCIX_INTERRUPT_PCIX)
-		t1_pci_intr_handler(adapter);
+	if (cause & FPGA_PCIX_INTERRUPT_PCIX) {
+		if (t1_pci_intr_handler(adapter))
+			ret = IRQ_WAKE_THREAD;
+	}
 
 	/* Clear the interrupts just processed. */
 	if (cause)
 		writel(cause, adapter->regs + A_PL_CAUSE);
 
-	return cause != 0;
+	if (ret != IRQ_NONE)
+		return ret;
+
+	return cause == 0 ? IRQ_NONE : IRQ_HANDLED;
 }
 #endif
 
@@ -842,31 +854,45 @@ void t1_interrupts_clear(adapter_t* adapter)
 /*
  * Slow path interrupt handler for ASICs.
  */
-static int asic_slow_intr(adapter_t *adapter)
+static irqreturn_t asic_slow_intr(adapter_t *adapter)
 {
 	u32 cause = readl(adapter->regs + A_PL_CAUSE);
+	irqreturn_t ret = IRQ_HANDLED;
 
 	cause &= adapter->slow_intr_mask;
 	if (!cause)
-		return 0;
-	if (cause & F_PL_INTR_SGE_ERR)
-		t1_sge_intr_error_handler(adapter->sge);
+		return IRQ_NONE;
+	if (cause & F_PL_INTR_SGE_ERR) {
+		if (t1_sge_intr_error_handler(adapter->sge))
+			ret = IRQ_WAKE_THREAD;
+	}
 	if (cause & F_PL_INTR_TP)
 		t1_tp_intr_handler(adapter->tp);
 	if (cause & F_PL_INTR_ESPI)
 		t1_espi_intr_handler(adapter->espi);
-	if (cause & F_PL_INTR_PCIX)
-		t1_pci_intr_handler(adapter);
-	if (cause & F_PL_INTR_EXT)
-		t1_elmer0_ext_intr(adapter);
+	if (cause & F_PL_INTR_PCIX) {
+		if (t1_pci_intr_handler(adapter))
+			ret = IRQ_WAKE_THREAD;
+	}
+	if (cause & F_PL_INTR_EXT) {
+		/* Wake the threaded interrupt to handle external interrupts as
+		 * we require a process context. We disable EXT interrupts in
+		 * the interim and let the thread reenable them when it's done.
+		 */
+		adapter->pending_thread_intr |= F_PL_INTR_EXT;
+		adapter->slow_intr_mask &= ~F_PL_INTR_EXT;
+		writel(adapter->slow_intr_mask | F_PL_INTR_SGE_DATA,
+		       adapter->regs + A_PL_ENABLE);
+		ret = IRQ_WAKE_THREAD;
+	}
 
 	/* Clear the interrupts just processed. */
 	writel(cause, adapter->regs + A_PL_CAUSE);
 	readl(adapter->regs + A_PL_CAUSE); /* flush writes */
-	return 1;
+	return ret;
 }
 
-int t1_slow_intr_handler(adapter_t *adapter)
+irqreturn_t t1_slow_intr_handler(adapter_t *adapter)
 {
 #ifdef CONFIG_CHELSIO_T1_1G
 	if (!t1_is_asic(adapter))
diff --git a/drivers/net/ethernet/dlink/sundance.c b/drivers/net/ethernet/dlink/sundance.c
index e3a8858915b3..df0eab479d51 100644
--- a/drivers/net/ethernet/dlink/sundance.c
+++ b/drivers/net/ethernet/dlink/sundance.c
@@ -963,7 +963,7 @@ static void tx_timeout(struct net_device *dev, unsigned int txqueue)
 	unsigned long flag;
 
 	netif_stop_queue(dev);
-	tasklet_disable(&np->tx_tasklet);
+	tasklet_disable_in_atomic(&np->tx_tasklet);
 	iowrite16(0, ioaddr + IntrEnable);
 	printk(KERN_WARNING "%s: Transmit timed out, TxStatus %2.2x "
 		   "TxFrameId %2.2x,"
diff --git a/drivers/net/ethernet/jme.c b/drivers/net/ethernet/jme.c
index 4185ca3dd575..cf5c33d0fbdb 100644
--- a/drivers/net/ethernet/jme.c
+++ b/drivers/net/ethernet/jme.c
@@ -1265,9 +1265,9 @@ jme_stop_shutdown_timer(struct jme_adapter *jme)
 	jwrite32f(jme, JME_APMC, apmc);
 }
 
-static void jme_link_change_tasklet(struct tasklet_struct *t)
+static void jme_link_change_work(struct work_struct *work)
 {
-	struct jme_adapter *jme = from_tasklet(jme, t, linkch_task);
+	struct jme_adapter *jme = container_of(work, struct jme_adapter, linkch_task);
 	struct net_device *netdev = jme->dev;
 	int rc;
 
@@ -1510,7 +1510,7 @@ jme_intr_msi(struct jme_adapter *jme, u32 intrstat)
 		 * all other events are ignored
 		 */
 		jwrite32(jme, JME_IEVE, intrstat);
-		tasklet_schedule(&jme->linkch_task);
+		schedule_work(&jme->linkch_task);
 		goto out_reenable;
 	}
 
@@ -1832,7 +1832,6 @@ jme_open(struct net_device *netdev)
 	jme_clear_pm_disable_wol(jme);
 	JME_NAPI_ENABLE(jme);
 
-	tasklet_setup(&jme->linkch_task, jme_link_change_tasklet);
 	tasklet_setup(&jme->txclean_task, jme_tx_clean_tasklet);
 	tasklet_setup(&jme->rxclean_task, jme_rx_clean_tasklet);
 	tasklet_setup(&jme->rxempty_task, jme_rx_empty_tasklet);
@@ -1920,7 +1919,7 @@ jme_close(struct net_device *netdev)
 
 	JME_NAPI_DISABLE(jme);
 
-	tasklet_kill(&jme->linkch_task);
+	cancel_work_sync(&jme->linkch_task);
 	tasklet_kill(&jme->txclean_task);
 	tasklet_kill(&jme->rxclean_task);
 	tasklet_kill(&jme->rxempty_task);
@@ -3039,6 +3038,7 @@ jme_init_one(struct pci_dev *pdev,
 	atomic_set(&jme->rx_empty, 1);
 
 	tasklet_setup(&jme->pcc_task, jme_pcc_tasklet);
+	INIT_WORK(&jme->linkch_task, jme_link_change_work);
 	jme->dpi.cur = PCC_P1;
 
 	jme->reg_ghc = 0;
diff --git a/drivers/net/ethernet/jme.h b/drivers/net/ethernet/jme.h
index a2c3b00d939d..2af76329b4a2 100644
--- a/drivers/net/ethernet/jme.h
+++ b/drivers/net/ethernet/jme.h
@@ -411,7 +411,7 @@ struct jme_adapter {
 	struct tasklet_struct	rxempty_task;
 	struct tasklet_struct	rxclean_task;
 	struct tasklet_struct	txclean_task;
-	struct tasklet_struct	linkch_task;
+	struct work_struct	linkch_task;
 	struct tasklet_struct	pcc_task;
 	unsigned long		flags;
 	u32			reg_txcs;
diff --git a/drivers/net/wireless/ath/ath9k/beacon.c b/drivers/net/wireless/ath/ath9k/beacon.c
index 71e2ada86793..72e2e71aac0e 100644
--- a/drivers/net/wireless/ath/ath9k/beacon.c
+++ b/drivers/net/wireless/ath/ath9k/beacon.c
@@ -251,7 +251,7 @@ void ath9k_beacon_ensure_primary_slot(struct ath_softc *sc)
 	int first_slot = ATH_BCBUF;
 	int slot;
 
-	tasklet_disable(&sc->bcon_tasklet);
+	tasklet_disable_in_atomic(&sc->bcon_tasklet);
 
 	/* Find first taken slot. */
 	for (slot = 0; slot < ATH_BCBUF; slot++) {
diff --git a/drivers/pci/controller/pci-hyperv.c b/drivers/pci/controller/pci-hyperv.c
index 4353443b89d8..03e2569da934 100644
--- a/drivers/pci/controller/pci-hyperv.c
+++ b/drivers/pci/controller/pci-hyperv.c
@@ -1522,7 +1522,7 @@ static void hv_compose_msi_msg(struct irq_data *data, struct msi_msg *msg)
 	 * Prevents hv_pci_onchannelcallback() from running concurrently
 	 * in the tasklet.
 	 */
-	tasklet_disable(&channel->callback_event);
+	tasklet_disable_in_atomic(&channel->callback_event);
 
 	/*
 	 * Since this function is called with IRQ locks held, can't
diff --git a/drivers/scsi/fcoe/fcoe.c b/drivers/scsi/fcoe/fcoe.c
index 0f9274960dc6..dc97e4f1f4ad 100644
--- a/drivers/scsi/fcoe/fcoe.c
+++ b/drivers/scsi/fcoe/fcoe.c
@@ -1452,11 +1452,11 @@ static int fcoe_rcv(struct sk_buff *skb, struct net_device *netdev,
 static int fcoe_alloc_paged_crc_eof(struct sk_buff *skb, int tlen)
 {
 	struct fcoe_percpu_s *fps;
-	int rc;
+	int rc, cpu = get_cpu_light();
 
-	fps = &get_cpu_var(fcoe_percpu);
+	fps = &per_cpu(fcoe_percpu, cpu);
 	rc = fcoe_get_paged_crc_eof(skb, tlen, fps);
-	put_cpu_var(fcoe_percpu);
+	put_cpu_light();
 
 	return rc;
 }
@@ -1641,11 +1641,11 @@ static inline int fcoe_filter_frames(struct fc_lport *lport,
 		return 0;
 	}
 
-	stats = per_cpu_ptr(lport->stats, get_cpu());
+	stats = per_cpu_ptr(lport->stats, get_cpu_light());
 	stats->InvalidCRCCount++;
 	if (stats->InvalidCRCCount < 5)
 		printk(KERN_WARNING "fcoe: dropping frame with CRC error\n");
-	put_cpu();
+	put_cpu_light();
 	return -EINVAL;
 }
 
@@ -1686,7 +1686,7 @@ static void fcoe_recv_frame(struct sk_buff *skb)
 	 */
 	hp = (struct fcoe_hdr *) skb_network_header(skb);
 
-	stats = per_cpu_ptr(lport->stats, get_cpu());
+	stats = per_cpu_ptr(lport->stats, get_cpu_light());
 	if (unlikely(FC_FCOE_DECAPS_VER(hp) != FC_FCOE_VER)) {
 		if (stats->ErrorFrames < 5)
 			printk(KERN_WARNING "fcoe: FCoE version "
@@ -1718,13 +1718,13 @@ static void fcoe_recv_frame(struct sk_buff *skb)
 		goto drop;
 
 	if (!fcoe_filter_frames(lport, fp)) {
-		put_cpu();
+		put_cpu_light();
 		fc_exch_recv(lport, fp);
 		return;
 	}
 drop:
 	stats->ErrorFrames++;
-	put_cpu();
+	put_cpu_light();
 	kfree_skb(skb);
 }
 
diff --git a/drivers/scsi/fcoe/fcoe_ctlr.c b/drivers/scsi/fcoe/fcoe_ctlr.c
index 5ea426effa60..0d6b9acc7cf8 100644
--- a/drivers/scsi/fcoe/fcoe_ctlr.c
+++ b/drivers/scsi/fcoe/fcoe_ctlr.c
@@ -828,7 +828,7 @@ static unsigned long fcoe_ctlr_age_fcfs(struct fcoe_ctlr *fip)
 
 	INIT_LIST_HEAD(&del_list);
 
-	stats = per_cpu_ptr(fip->lp->stats, get_cpu());
+	stats = per_cpu_ptr(fip->lp->stats, get_cpu_light());
 
 	list_for_each_entry_safe(fcf, next, &fip->fcfs, list) {
 		deadline = fcf->time + fcf->fka_period + fcf->fka_period / 2;
@@ -864,7 +864,7 @@ static unsigned long fcoe_ctlr_age_fcfs(struct fcoe_ctlr *fip)
 				sel_time = fcf->time;
 		}
 	}
-	put_cpu();
+	put_cpu_light();
 
 	list_for_each_entry_safe(fcf, next, &del_list, list) {
 		/* Removes fcf from current list */
diff --git a/drivers/scsi/libfc/fc_exch.c b/drivers/scsi/libfc/fc_exch.c
index 4261380af97b..65160eaaa929 100644
--- a/drivers/scsi/libfc/fc_exch.c
+++ b/drivers/scsi/libfc/fc_exch.c
@@ -826,10 +826,10 @@ static struct fc_exch *fc_exch_em_alloc(struct fc_lport *lport,
 	}
 	memset(ep, 0, sizeof(*ep));
 
-	cpu = get_cpu();
+	cpu = get_cpu_light();
 	pool = per_cpu_ptr(mp->pool, cpu);
 	spin_lock_bh(&pool->lock);
-	put_cpu();
+	put_cpu_light();
 
 	/* peek cache of free slot */
 	if (pool->left != FC_XID_UNKNOWN) {
diff --git a/drivers/tty/serial/8250/8250.h b/drivers/tty/serial/8250/8250.h
index b6dc9003b8c4..d5cf70ead85b 100644
--- a/drivers/tty/serial/8250/8250.h
+++ b/drivers/tty/serial/8250/8250.h
@@ -153,12 +153,55 @@ static inline void serial_dl_write(struct uart_8250_port *up, int value)
 	up->dl_write(up, value);
 }
 
+static inline void serial8250_set_IER(struct uart_8250_port *up,
+				      unsigned char ier)
+{
+	struct uart_port *port = &up->port;
+	unsigned int flags;
+	bool is_console;
+
+	is_console = uart_console(port);
+
+	if (is_console)
+		console_atomic_lock(&flags);
+
+	serial_out(up, UART_IER, ier);
+
+	if (is_console)
+		console_atomic_unlock(flags);
+}
+
+static inline unsigned char serial8250_clear_IER(struct uart_8250_port *up)
+{
+	struct uart_port *port = &up->port;
+	unsigned int clearval = 0;
+	unsigned int prior;
+	unsigned int flags;
+	bool is_console;
+
+	is_console = uart_console(port);
+
+	if (up->capabilities & UART_CAP_UUE)
+		clearval = UART_IER_UUE;
+
+	if (is_console)
+		console_atomic_lock(&flags);
+
+	prior = serial_port_in(port, UART_IER);
+	serial_port_out(port, UART_IER, clearval);
+
+	if (is_console)
+		console_atomic_unlock(flags);
+
+	return prior;
+}
+
 static inline bool serial8250_set_THRI(struct uart_8250_port *up)
 {
 	if (up->ier & UART_IER_THRI)
 		return false;
 	up->ier |= UART_IER_THRI;
-	serial_out(up, UART_IER, up->ier);
+	serial8250_set_IER(up, up->ier);
 	return true;
 }
 
@@ -167,7 +210,7 @@ static inline bool serial8250_clear_THRI(struct uart_8250_port *up)
 	if (!(up->ier & UART_IER_THRI))
 		return false;
 	up->ier &= ~UART_IER_THRI;
-	serial_out(up, UART_IER, up->ier);
+	serial8250_set_IER(up, up->ier);
 	return true;
 }
 
diff --git a/drivers/tty/serial/8250/8250_core.c b/drivers/tty/serial/8250/8250_core.c
index 98ce484f1089..ceba24927c1e 100644
--- a/drivers/tty/serial/8250/8250_core.c
+++ b/drivers/tty/serial/8250/8250_core.c
@@ -275,10 +275,8 @@ static void serial8250_backup_timeout(struct timer_list *t)
 	 * Must disable interrupts or else we risk racing with the interrupt
 	 * based handler.
 	 */
-	if (up->port.irq) {
-		ier = serial_in(up, UART_IER);
-		serial_out(up, UART_IER, 0);
-	}
+	if (up->port.irq)
+		ier = serial8250_clear_IER(up);
 
 	iir = serial_in(up, UART_IIR);
 
@@ -301,7 +299,7 @@ static void serial8250_backup_timeout(struct timer_list *t)
 		serial8250_tx_chars(up);
 
 	if (up->port.irq)
-		serial_out(up, UART_IER, ier);
+		serial8250_set_IER(up, ier);
 
 	spin_unlock_irqrestore(&up->port.lock, flags);
 
@@ -582,6 +580,14 @@ serial8250_register_ports(struct uart_driver *drv, struct device *dev)
 
 #ifdef CONFIG_SERIAL_8250_CONSOLE
 
+static void univ8250_console_write_atomic(struct console *co, const char *s,
+					  unsigned int count)
+{
+	struct uart_8250_port *up = &serial8250_ports[co->index];
+
+	serial8250_console_write_atomic(up, s, count);
+}
+
 static void univ8250_console_write(struct console *co, const char *s,
 				   unsigned int count)
 {
@@ -675,6 +681,7 @@ static int univ8250_console_match(struct console *co, char *name, int idx,
 
 static struct console univ8250_console = {
 	.name		= "ttyS",
+	.write_atomic	= univ8250_console_write_atomic,
 	.write		= univ8250_console_write,
 	.device		= uart_console_device,
 	.setup		= univ8250_console_setup,
diff --git a/drivers/tty/serial/8250/8250_fsl.c b/drivers/tty/serial/8250/8250_fsl.c
index fbcc90c31ca1..b33cb454ce03 100644
--- a/drivers/tty/serial/8250/8250_fsl.c
+++ b/drivers/tty/serial/8250/8250_fsl.c
@@ -60,9 +60,18 @@ int fsl8250_handle_irq(struct uart_port *port)
 
 	/* Stop processing interrupts on input overrun */
 	if ((orig_lsr & UART_LSR_OE) && (up->overrun_backoff_time_ms > 0)) {
+		unsigned int ca_flags;
 		unsigned long delay;
+		bool is_console;
 
+		is_console = uart_console(port);
+
+		if (is_console)
+			console_atomic_lock(&ca_flags);
 		up->ier = port->serial_in(port, UART_IER);
+		if (is_console)
+			console_atomic_unlock(ca_flags);
+
 		if (up->ier & (UART_IER_RLSI | UART_IER_RDI)) {
 			port->ops->stop_rx(port);
 		} else {
diff --git a/drivers/tty/serial/8250/8250_ingenic.c b/drivers/tty/serial/8250/8250_ingenic.c
index 988bf6bcce42..bcd26d672539 100644
--- a/drivers/tty/serial/8250/8250_ingenic.c
+++ b/drivers/tty/serial/8250/8250_ingenic.c
@@ -146,6 +146,8 @@ OF_EARLYCON_DECLARE(x1000_uart, "ingenic,x1000-uart",
 
 static void ingenic_uart_serial_out(struct uart_port *p, int offset, int value)
 {
+	unsigned int flags;
+	bool is_console;
 	int ier;
 
 	switch (offset) {
@@ -167,7 +169,12 @@ static void ingenic_uart_serial_out(struct uart_port *p, int offset, int value)
 		 * If we have enabled modem status IRQs we should enable
 		 * modem mode.
 		 */
+		is_console = uart_console(p);
+		if (is_console)
+			console_atomic_lock(&flags);
 		ier = p->serial_in(p, UART_IER);
+		if (is_console)
+			console_atomic_unlock(flags);
 
 		if (ier & UART_IER_MSI)
 			value |= UART_MCR_MDCE | UART_MCR_FCM;
diff --git a/drivers/tty/serial/8250/8250_mtk.c b/drivers/tty/serial/8250/8250_mtk.c
index de48a58460f4..d246f2755fed 100644
--- a/drivers/tty/serial/8250/8250_mtk.c
+++ b/drivers/tty/serial/8250/8250_mtk.c
@@ -222,12 +222,37 @@ static void mtk8250_shutdown(struct uart_port *port)
 
 static void mtk8250_disable_intrs(struct uart_8250_port *up, int mask)
 {
-	serial_out(up, UART_IER, serial_in(up, UART_IER) & (~mask));
+	struct uart_port *port = &up->port;
+	unsigned int flags;
+	unsigned int ier;
+	bool is_console;
+
+	is_console = uart_console(port);
+
+	if (is_console)
+		console_atomic_lock(&flags);
+
+	ier = serial_in(up, UART_IER);
+	serial_out(up, UART_IER, ier & (~mask));
+
+	if (is_console)
+		console_atomic_unlock(flags);
 }
 
 static void mtk8250_enable_intrs(struct uart_8250_port *up, int mask)
 {
-	serial_out(up, UART_IER, serial_in(up, UART_IER) | mask);
+	struct uart_port *port = &up->port;
+	unsigned int flags;
+	unsigned int ier;
+
+	if (uart_console(port))
+		console_atomic_lock(&flags);
+
+	ier = serial_in(up, UART_IER);
+	serial_out(up, UART_IER, ier | mask);
+
+	if (uart_console(port))
+		console_atomic_unlock(flags);
 }
 
 static void mtk8250_set_flow_ctrl(struct uart_8250_port *up, int mode)
diff --git a/drivers/tty/serial/8250/8250_port.c b/drivers/tty/serial/8250/8250_port.c
index 9d60418e4adb..24b5b18cca9d 100644
--- a/drivers/tty/serial/8250/8250_port.c
+++ b/drivers/tty/serial/8250/8250_port.c
@@ -741,7 +741,7 @@ static void serial8250_set_sleep(struct uart_8250_port *p, int sleep)
 			serial_out(p, UART_EFR, UART_EFR_ECB);
 			serial_out(p, UART_LCR, 0);
 		}
-		serial_out(p, UART_IER, sleep ? UART_IERX_SLEEP : 0);
+		serial8250_set_IER(p, sleep ? UART_IERX_SLEEP : 0);
 		if (p->capabilities & UART_CAP_EFR) {
 			serial_out(p, UART_LCR, UART_LCR_CONF_MODE_B);
 			serial_out(p, UART_EFR, efr);
@@ -1415,7 +1415,7 @@ static void serial8250_stop_rx(struct uart_port *port)
 
 	up->ier &= ~(UART_IER_RLSI | UART_IER_RDI);
 	up->port.read_status_mask &= ~UART_LSR_DR;
-	serial_port_out(port, UART_IER, up->ier);
+	serial8250_set_IER(up, up->ier);
 
 	serial8250_rpm_put(up);
 }
@@ -1445,7 +1445,7 @@ void serial8250_em485_stop_tx(struct uart_8250_port *p)
 		serial8250_clear_and_reinit_fifos(p);
 
 		p->ier |= UART_IER_RLSI | UART_IER_RDI;
-		serial_port_out(&p->port, UART_IER, p->ier);
+		serial8250_set_IER(p, p->ier);
 	}
 }
 EXPORT_SYMBOL_GPL(serial8250_em485_stop_tx);
@@ -1687,7 +1687,7 @@ static void serial8250_disable_ms(struct uart_port *port)
 	mctrl_gpio_disable_ms(up->gpios);
 
 	up->ier &= ~UART_IER_MSI;
-	serial_port_out(port, UART_IER, up->ier);
+	serial8250_set_IER(up, up->ier);
 }
 
 static void serial8250_enable_ms(struct uart_port *port)
@@ -1703,7 +1703,7 @@ static void serial8250_enable_ms(struct uart_port *port)
 	up->ier |= UART_IER_MSI;
 
 	serial8250_rpm_get(up);
-	serial_port_out(port, UART_IER, up->ier);
+	serial8250_set_IER(up, up->ier);
 	serial8250_rpm_put(up);
 }
 
@@ -2121,14 +2121,7 @@ static void serial8250_put_poll_char(struct uart_port *port,
 	struct uart_8250_port *up = up_to_u8250p(port);
 
 	serial8250_rpm_get(up);
-	/*
-	 *	First save the IER then disable the interrupts
-	 */
-	ier = serial_port_in(port, UART_IER);
-	if (up->capabilities & UART_CAP_UUE)
-		serial_port_out(port, UART_IER, UART_IER_UUE);
-	else
-		serial_port_out(port, UART_IER, 0);
+	ier = serial8250_clear_IER(up);
 
 	wait_for_xmitr(up, BOTH_EMPTY);
 	/*
@@ -2141,7 +2134,7 @@ static void serial8250_put_poll_char(struct uart_port *port,
 	 *	and restore the IER
 	 */
 	wait_for_xmitr(up, BOTH_EMPTY);
-	serial_port_out(port, UART_IER, ier);
+	serial8250_set_IER(up, ier);
 	serial8250_rpm_put(up);
 }
 
@@ -2444,7 +2437,7 @@ void serial8250_do_shutdown(struct uart_port *port)
 	 */
 	spin_lock_irqsave(&port->lock, flags);
 	up->ier = 0;
-	serial_port_out(port, UART_IER, 0);
+	serial8250_set_IER(up, 0);
 	spin_unlock_irqrestore(&port->lock, flags);
 
 	synchronize_irq(port->irq);
@@ -2800,7 +2793,7 @@ serial8250_do_set_termios(struct uart_port *port, struct ktermios *termios,
 	if (up->capabilities & UART_CAP_RTOIE)
 		up->ier |= UART_IER_RTOIE;
 
-	serial_port_out(port, UART_IER, up->ier);
+	serial8250_set_IER(up, up->ier);
 
 	if (up->capabilities & UART_CAP_EFR) {
 		unsigned char efr = 0;
@@ -3268,7 +3261,7 @@ EXPORT_SYMBOL_GPL(serial8250_set_defaults);
 
 #ifdef CONFIG_SERIAL_8250_CONSOLE
 
-static void serial8250_console_putchar(struct uart_port *port, int ch)
+static void serial8250_console_putchar_locked(struct uart_port *port, int ch)
 {
 	struct uart_8250_port *up = up_to_u8250p(port);
 
@@ -3276,6 +3269,18 @@ static void serial8250_console_putchar(struct uart_port *port, int ch)
 	serial_port_out(port, UART_TX, ch);
 }
 
+static void serial8250_console_putchar(struct uart_port *port, int ch)
+{
+	struct uart_8250_port *up = up_to_u8250p(port);
+	unsigned int flags;
+
+	wait_for_xmitr(up, UART_LSR_THRE);
+
+	console_atomic_lock(&flags);
+	serial8250_console_putchar_locked(port, ch);
+	console_atomic_unlock(flags);
+}
+
 /*
  *	Restore serial console when h/w power-off detected
  */
@@ -3297,6 +3302,33 @@ static void serial8250_console_restore(struct uart_8250_port *up)
 	serial8250_out_MCR(up, up->mcr | UART_MCR_DTR | UART_MCR_RTS);
 }
 
+void serial8250_console_write_atomic(struct uart_8250_port *up,
+				     const char *s, unsigned int count)
+{
+	struct uart_port *port = &up->port;
+	unsigned int flags;
+	unsigned int ier;
+
+	console_atomic_lock(&flags);
+
+	touch_nmi_watchdog();
+
+	ier = serial8250_clear_IER(up);
+
+	if (atomic_fetch_inc(&up->console_printing)) {
+		uart_console_write(port, "\n", 1,
+				   serial8250_console_putchar_locked);
+	}
+	uart_console_write(port, s, count, serial8250_console_putchar_locked);
+	atomic_dec(&up->console_printing);
+
+	wait_for_xmitr(up, BOTH_EMPTY);
+	serial8250_set_IER(up, ier);
+
+	console_atomic_unlock(flags);
+}
+
+
 /*
  *	Print a string to the serial port trying not to disturb
  *	any possible real use of the port...
@@ -3313,24 +3345,12 @@ void serial8250_console_write(struct uart_8250_port *up, const char *s,
 	struct uart_port *port = &up->port;
 	unsigned long flags;
 	unsigned int ier;
-	int locked = 1;
 
 	touch_nmi_watchdog();
 
-	if (oops_in_progress)
-		locked = spin_trylock_irqsave(&port->lock, flags);
-	else
-		spin_lock_irqsave(&port->lock, flags);
-
-	/*
-	 *	First save the IER then disable the interrupts
-	 */
-	ier = serial_port_in(port, UART_IER);
+	spin_lock_irqsave(&port->lock, flags);
 
-	if (up->capabilities & UART_CAP_UUE)
-		serial_port_out(port, UART_IER, UART_IER_UUE);
-	else
-		serial_port_out(port, UART_IER, 0);
+	ier = serial8250_clear_IER(up);
 
 	/* check scratch reg to see if port powered off during system sleep */
 	if (up->canary && (up->canary != serial_port_in(port, UART_SCR))) {
@@ -3344,7 +3364,9 @@ void serial8250_console_write(struct uart_8250_port *up, const char *s,
 		mdelay(port->rs485.delay_rts_before_send);
 	}
 
+	atomic_inc(&up->console_printing);
 	uart_console_write(port, s, count, serial8250_console_putchar);
+	atomic_dec(&up->console_printing);
 
 	/*
 	 *	Finally, wait for transmitter to become empty
@@ -3357,8 +3379,7 @@ void serial8250_console_write(struct uart_8250_port *up, const char *s,
 		if (em485->tx_stopped)
 			up->rs485_stop_tx(up);
 	}
-
-	serial_port_out(port, UART_IER, ier);
+	serial8250_set_IER(up, ier);
 
 	/*
 	 *	The receive handling will happen properly because the
@@ -3370,8 +3391,7 @@ void serial8250_console_write(struct uart_8250_port *up, const char *s,
 	if (up->msr_saved_flags)
 		serial8250_modem_status(up);
 
-	if (locked)
-		spin_unlock_irqrestore(&port->lock, flags);
+	spin_unlock_irqrestore(&port->lock, flags);
 }
 
 static unsigned int probe_baud(struct uart_port *port)
@@ -3391,6 +3411,7 @@ static unsigned int probe_baud(struct uart_port *port)
 
 int serial8250_console_setup(struct uart_port *port, char *options, bool probe)
 {
+	struct uart_8250_port *up = up_to_u8250p(port);
 	int baud = 9600;
 	int bits = 8;
 	int parity = 'n';
@@ -3400,6 +3421,8 @@ int serial8250_console_setup(struct uart_port *port, char *options, bool probe)
 	if (!port->iobase && !port->membase)
 		return -ENODEV;
 
+	atomic_set(&up->console_printing, 0);
+
 	if (options)
 		uart_parse_options(options, &baud, &parity, &bits, &flow);
 	else if (probe)
diff --git a/drivers/tty/serial/amba-pl011.c b/drivers/tty/serial/amba-pl011.c
index d80e8064b75e..4c24c5197b62 100644
--- a/drivers/tty/serial/amba-pl011.c
+++ b/drivers/tty/serial/amba-pl011.c
@@ -2268,18 +2268,24 @@ pl011_console_write(struct console *co, const char *s, unsigned int count)
 {
 	struct uart_amba_port *uap = amba_ports[co->index];
 	unsigned int old_cr = 0, new_cr;
-	unsigned long flags;
+	unsigned long flags = 0;
 	int locked = 1;
 
 	clk_enable(uap->clk);
 
-	local_irq_save(flags);
+	/*
+	 * local_irq_save(flags);
+	 *
+	 * This local_irq_save() is nonsense. If we come in via sysrq
+	 * handling then interrupts are already disabled. Aside of
+	 * that the port.sysrq check is racy on SMP regardless.
+	*/
 	if (uap->port.sysrq)
 		locked = 0;
 	else if (oops_in_progress)
-		locked = spin_trylock(&uap->port.lock);
+		locked = spin_trylock_irqsave(&uap->port.lock, flags);
 	else
-		spin_lock(&uap->port.lock);
+		spin_lock_irqsave(&uap->port.lock, flags);
 
 	/*
 	 *	First save the CR then disable the interrupts
@@ -2305,8 +2311,7 @@ pl011_console_write(struct console *co, const char *s, unsigned int count)
 		pl011_write(old_cr, uap, REG_CR);
 
 	if (locked)
-		spin_unlock(&uap->port.lock);
-	local_irq_restore(flags);
+		spin_unlock_irqrestore(&uap->port.lock, flags);
 
 	clk_disable(uap->clk);
 }
diff --git a/drivers/tty/serial/omap-serial.c b/drivers/tty/serial/omap-serial.c
index 84e8158088cd..342005ed5ebf 100644
--- a/drivers/tty/serial/omap-serial.c
+++ b/drivers/tty/serial/omap-serial.c
@@ -1311,13 +1311,10 @@ serial_omap_console_write(struct console *co, const char *s,
 
 	pm_runtime_get_sync(up->dev);
 
-	local_irq_save(flags);
-	if (up->port.sysrq)
-		locked = 0;
-	else if (oops_in_progress)
-		locked = spin_trylock(&up->port.lock);
+	if (up->port.sysrq || oops_in_progress)
+		locked = spin_trylock_irqsave(&up->port.lock, flags);
 	else
-		spin_lock(&up->port.lock);
+		spin_lock_irqsave(&up->port.lock, flags);
 
 	/*
 	 * First save the IER then disable the interrupts
@@ -1346,8 +1343,7 @@ serial_omap_console_write(struct console *co, const char *s,
 	pm_runtime_mark_last_busy(up->dev);
 	pm_runtime_put_autosuspend(up->dev);
 	if (locked)
-		spin_unlock(&up->port.lock);
-	local_irq_restore(flags);
+		spin_unlock_irqrestore(&up->port.lock, flags);
 }
 
 static int __init
diff --git a/drivers/tty/tty_buffer.c b/drivers/tty/tty_buffer.c
index c3abcd0439f9..0ab374ec7f3a 100644
--- a/drivers/tty/tty_buffer.c
+++ b/drivers/tty/tty_buffer.c
@@ -172,10 +172,8 @@ static struct tty_buffer *tty_buffer_alloc(struct tty_port *port, size_t size)
 	   have queued and recycle that ? */
 	if (atomic_read(&port->buf.mem_used) > port->buf.mem_limit)
 		return NULL;
-	printk_safe_enter();
 	p = kmalloc(sizeof(struct tty_buffer) + 2 * size,
 			GFP_ATOMIC | __GFP_NOWARN);
-	printk_safe_exit();
 	if (p == NULL)
 		return NULL;
 
diff --git a/fs/afs/dir_silly.c b/fs/afs/dir_silly.c
index dae9a57d7ec0..9a6a0ec4d1fb 100644
--- a/fs/afs/dir_silly.c
+++ b/fs/afs/dir_silly.c
@@ -239,7 +239,7 @@ int afs_silly_iput(struct dentry *dentry, struct inode *inode)
 	struct dentry *alias;
 	int ret;
 
-	DECLARE_WAIT_QUEUE_HEAD_ONSTACK(wq);
+	DECLARE_SWAIT_QUEUE_HEAD_ONSTACK(wq);
 
 	_enter("%p{%pd},%llx", dentry, dentry, vnode->fid.vnode);
 
diff --git a/fs/aio.c b/fs/aio.c
index 5e5333d72c69..cc16ac777f0d 100644
--- a/fs/aio.c
+++ b/fs/aio.c
@@ -43,7 +43,6 @@
 #include <linux/mount.h>
 #include <linux/pseudo_fs.h>
 
-#include <asm/kmap_types.h>
 #include <linux/uaccess.h>
 #include <linux/nospec.h>
 
@@ -1762,7 +1761,7 @@ static int aio_poll_wake(struct wait_queue_entry *wait, unsigned mode, int sync,
 		list_del_init(&req->wait.entry);
 		list_del(&iocb->ki_list);
 		iocb->ki_res.res = mangle_poll(mask);
-		if (iocb->ki_eventfd && eventfd_signal_count()) {
+		if (iocb->ki_eventfd && !eventfd_signal_allowed()) {
 			iocb = NULL;
 			INIT_WORK(&req->work, aio_poll_put_work);
 			schedule_work(&req->work);
diff --git a/fs/btrfs/ctree.h b/fs/btrfs/ctree.h
index bcc6848bb6d6..fabbf6cc45bf 100644
--- a/fs/btrfs/ctree.h
+++ b/fs/btrfs/ctree.h
@@ -17,7 +17,6 @@
 #include <linux/wait.h>
 #include <linux/slab.h>
 #include <trace/events/btrfs.h>
-#include <asm/kmap_types.h>
 #include <asm/unaligned.h>
 #include <linux/pagemap.h>
 #include <linux/btrfs.h>
diff --git a/fs/cifs/readdir.c b/fs/cifs/readdir.c
index 799be3a5d25e..d5165a7da071 100644
--- a/fs/cifs/readdir.c
+++ b/fs/cifs/readdir.c
@@ -81,7 +81,7 @@ cifs_prime_dcache(struct dentry *parent, struct qstr *name,
 	struct inode *inode;
 	struct super_block *sb = parent->d_sb;
 	struct cifs_sb_info *cifs_sb = CIFS_SB(sb);
-	DECLARE_WAIT_QUEUE_HEAD_ONSTACK(wq);
+	DECLARE_SWAIT_QUEUE_HEAD_ONSTACK(wq);
 
 	cifs_dbg(FYI, "%s: for %s\n", __func__, name->name);
 
diff --git a/fs/dcache.c b/fs/dcache.c
index f5b78cc80a00..b2e0d1a07644 100644
--- a/fs/dcache.c
+++ b/fs/dcache.c
@@ -2566,9 +2566,10 @@ EXPORT_SYMBOL(d_rehash);
 static inline unsigned start_dir_add(struct inode *dir)
 {
 
+	preempt_disable_rt();
 	for (;;) {
-		unsigned n = dir->i_dir_seq;
-		if (!(n & 1) && cmpxchg(&dir->i_dir_seq, n, n + 1) == n)
+		unsigned n = dir->__i_dir_seq;
+		if (!(n & 1) && cmpxchg(&dir->__i_dir_seq, n, n + 1) == n)
 			return n;
 		cpu_relax();
 	}
@@ -2576,26 +2577,30 @@ static inline unsigned start_dir_add(struct inode *dir)
 
 static inline void end_dir_add(struct inode *dir, unsigned n)
 {
-	smp_store_release(&dir->i_dir_seq, n + 2);
+	smp_store_release(&dir->__i_dir_seq, n + 2);
+	preempt_enable_rt();
 }
 
 static void d_wait_lookup(struct dentry *dentry)
 {
-	if (d_in_lookup(dentry)) {
-		DECLARE_WAITQUEUE(wait, current);
-		add_wait_queue(dentry->d_wait, &wait);
-		do {
-			set_current_state(TASK_UNINTERRUPTIBLE);
-			spin_unlock(&dentry->d_lock);
-			schedule();
-			spin_lock(&dentry->d_lock);
-		} while (d_in_lookup(dentry));
-	}
+	struct swait_queue __wait;
+
+	if (!d_in_lookup(dentry))
+		return;
+
+	INIT_LIST_HEAD(&__wait.task_list);
+	do {
+		prepare_to_swait_exclusive(dentry->d_wait, &__wait, TASK_UNINTERRUPTIBLE);
+		spin_unlock(&dentry->d_lock);
+		schedule();
+		spin_lock(&dentry->d_lock);
+	} while (d_in_lookup(dentry));
+	finish_swait(dentry->d_wait, &__wait);
 }
 
 struct dentry *d_alloc_parallel(struct dentry *parent,
 				const struct qstr *name,
-				wait_queue_head_t *wq)
+				struct swait_queue_head *wq)
 {
 	unsigned int hash = name->hash;
 	struct hlist_bl_head *b = in_lookup_hash(parent, hash);
@@ -2609,7 +2614,7 @@ struct dentry *d_alloc_parallel(struct dentry *parent,
 
 retry:
 	rcu_read_lock();
-	seq = smp_load_acquire(&parent->d_inode->i_dir_seq);
+	seq = smp_load_acquire(&parent->d_inode->__i_dir_seq);
 	r_seq = read_seqbegin(&rename_lock);
 	dentry = __d_lookup_rcu(parent, name, &d_seq);
 	if (unlikely(dentry)) {
@@ -2637,7 +2642,7 @@ struct dentry *d_alloc_parallel(struct dentry *parent,
 	}
 
 	hlist_bl_lock(b);
-	if (unlikely(READ_ONCE(parent->d_inode->i_dir_seq) != seq)) {
+	if (unlikely(READ_ONCE(parent->d_inode->__i_dir_seq) != seq)) {
 		hlist_bl_unlock(b);
 		rcu_read_unlock();
 		goto retry;
@@ -2710,7 +2715,7 @@ void __d_lookup_done(struct dentry *dentry)
 	hlist_bl_lock(b);
 	dentry->d_flags &= ~DCACHE_PAR_LOOKUP;
 	__hlist_bl_del(&dentry->d_u.d_in_lookup_hash);
-	wake_up_all(dentry->d_wait);
+	swake_up_all(dentry->d_wait);
 	dentry->d_wait = NULL;
 	hlist_bl_unlock(b);
 	INIT_HLIST_NODE(&dentry->d_u.d_alias);
diff --git a/fs/eventfd.c b/fs/eventfd.c
index df466ef81ddd..9035ca60bfcf 100644
--- a/fs/eventfd.c
+++ b/fs/eventfd.c
@@ -25,8 +25,6 @@
 #include <linux/idr.h>
 #include <linux/uio.h>
 
-DEFINE_PER_CPU(int, eventfd_wake_count);
-
 static DEFINE_IDA(eventfd_ida);
 
 struct eventfd_ctx {
@@ -67,21 +65,21 @@ __u64 eventfd_signal(struct eventfd_ctx *ctx, __u64 n)
 	 * Deadlock or stack overflow issues can happen if we recurse here
 	 * through waitqueue wakeup handlers. If the caller users potentially
 	 * nested waitqueues with custom wakeup handlers, then it should
-	 * check eventfd_signal_count() before calling this function. If
-	 * it returns true, the eventfd_signal() call should be deferred to a
+	 * check eventfd_signal_allowed() before calling this function. If
+	 * it returns false, the eventfd_signal() call should be deferred to a
 	 * safe context.
 	 */
-	if (WARN_ON_ONCE(this_cpu_read(eventfd_wake_count)))
+	if (WARN_ON_ONCE(current->in_eventfd_signal))
 		return 0;
 
 	spin_lock_irqsave(&ctx->wqh.lock, flags);
-	this_cpu_inc(eventfd_wake_count);
+	current->in_eventfd_signal = 1;
 	if (ULLONG_MAX - ctx->count < n)
 		n = ULLONG_MAX - ctx->count;
 	ctx->count += n;
 	if (waitqueue_active(&ctx->wqh))
 		wake_up_locked_poll(&ctx->wqh, EPOLLIN);
-	this_cpu_dec(eventfd_wake_count);
+	current->in_eventfd_signal = 0;
 	spin_unlock_irqrestore(&ctx->wqh.lock, flags);
 
 	return n;
diff --git a/fs/fscache/internal.h b/fs/fscache/internal.h
index 64aa552b296d..7dae569dafb9 100644
--- a/fs/fscache/internal.h
+++ b/fs/fscache/internal.h
@@ -95,7 +95,6 @@ extern unsigned fscache_debug;
 extern struct kobject *fscache_root;
 extern struct workqueue_struct *fscache_object_wq;
 extern struct workqueue_struct *fscache_op_wq;
-DECLARE_PER_CPU(wait_queue_head_t, fscache_object_cong_wait);
 
 extern unsigned int fscache_hash(unsigned int salt, unsigned int *data, unsigned int n);
 
diff --git a/fs/fscache/main.c b/fs/fscache/main.c
index 4207f98e405f..85f8cf3a323d 100644
--- a/fs/fscache/main.c
+++ b/fs/fscache/main.c
@@ -41,8 +41,6 @@ struct kobject *fscache_root;
 struct workqueue_struct *fscache_object_wq;
 struct workqueue_struct *fscache_op_wq;
 
-DEFINE_PER_CPU(wait_queue_head_t, fscache_object_cong_wait);
-
 /* these values serve as lower bounds, will be adjusted in fscache_init() */
 static unsigned fscache_object_max_active = 4;
 static unsigned fscache_op_max_active = 2;
@@ -138,7 +136,6 @@ unsigned int fscache_hash(unsigned int salt, unsigned int *data, unsigned int n)
 static int __init fscache_init(void)
 {
 	unsigned int nr_cpus = num_possible_cpus();
-	unsigned int cpu;
 	int ret;
 
 	fscache_object_max_active =
@@ -161,9 +158,6 @@ static int __init fscache_init(void)
 	if (!fscache_op_wq)
 		goto error_op_wq;
 
-	for_each_possible_cpu(cpu)
-		init_waitqueue_head(&per_cpu(fscache_object_cong_wait, cpu));
-
 	ret = fscache_proc_init();
 	if (ret < 0)
 		goto error_proc;
diff --git a/fs/fscache/object.c b/fs/fscache/object.c
index cb2146e02cd5..fb9794dce721 100644
--- a/fs/fscache/object.c
+++ b/fs/fscache/object.c
@@ -807,6 +807,8 @@ void fscache_object_destroy(struct fscache_object *object)
 }
 EXPORT_SYMBOL(fscache_object_destroy);
 
+static DECLARE_WAIT_QUEUE_HEAD(fscache_object_cong_wait);
+
 /*
  * enqueue an object for metadata-type processing
  */
@@ -815,16 +817,12 @@ void fscache_enqueue_object(struct fscache_object *object)
 	_enter("{OBJ%x}", object->debug_id);
 
 	if (fscache_get_object(object, fscache_obj_get_queue) >= 0) {
-		wait_queue_head_t *cong_wq =
-			&get_cpu_var(fscache_object_cong_wait);
 
 		if (queue_work(fscache_object_wq, &object->work)) {
 			if (fscache_object_congested())
-				wake_up(cong_wq);
+				wake_up(&fscache_object_cong_wait);
 		} else
 			fscache_put_object(object, fscache_obj_put_queue);
-
-		put_cpu_var(fscache_object_cong_wait);
 	}
 }
 
@@ -842,16 +840,15 @@ void fscache_enqueue_object(struct fscache_object *object)
  */
 bool fscache_object_sleep_till_congested(signed long *timeoutp)
 {
-	wait_queue_head_t *cong_wq = this_cpu_ptr(&fscache_object_cong_wait);
 	DEFINE_WAIT(wait);
 
 	if (fscache_object_congested())
 		return true;
 
-	add_wait_queue_exclusive(cong_wq, &wait);
+	add_wait_queue_exclusive(&fscache_object_cong_wait, &wait);
 	if (!fscache_object_congested())
 		*timeoutp = schedule_timeout(*timeoutp);
-	finish_wait(cong_wq, &wait);
+	finish_wait(&fscache_object_cong_wait, &wait);
 
 	return fscache_object_congested();
 }
diff --git a/fs/fuse/readdir.c b/fs/fuse/readdir.c
index bc267832310c..3176913fae6c 100644
--- a/fs/fuse/readdir.c
+++ b/fs/fuse/readdir.c
@@ -158,7 +158,7 @@ static int fuse_direntplus_link(struct file *file,
 	struct inode *dir = d_inode(parent);
 	struct fuse_conn *fc;
 	struct inode *inode;
-	DECLARE_WAIT_QUEUE_HEAD_ONSTACK(wq);
+	DECLARE_SWAIT_QUEUE_HEAD_ONSTACK(wq);
 
 	if (!o->nodeid) {
 		/*
diff --git a/fs/inode.c b/fs/inode.c
index 7436a17a20c1..45a821a8cc46 100644
--- a/fs/inode.c
+++ b/fs/inode.c
@@ -158,7 +158,7 @@ int inode_init_always(struct super_block *sb, struct inode *inode)
 	inode->i_bdev = NULL;
 	inode->i_cdev = NULL;
 	inode->i_link = NULL;
-	inode->i_dir_seq = 0;
+	inode->__i_dir_seq = 0;
 	inode->i_rdev = 0;
 	inode->dirtied_when = 0;
 
diff --git a/fs/namei.c b/fs/namei.c
index 07c00ade4c1a..a53e99d66dfa 100644
--- a/fs/namei.c
+++ b/fs/namei.c
@@ -1528,7 +1528,7 @@ static struct dentry *__lookup_slow(const struct qstr *name,
 {
 	struct dentry *dentry, *old;
 	struct inode *inode = dir->d_inode;
-	DECLARE_WAIT_QUEUE_HEAD_ONSTACK(wq);
+	DECLARE_SWAIT_QUEUE_HEAD_ONSTACK(wq);
 
 	/* Don't go there if it's already dead */
 	if (unlikely(IS_DEADDIR(inode)))
@@ -3023,7 +3023,7 @@ static struct dentry *lookup_open(struct nameidata *nd, struct file *file,
 	struct dentry *dentry;
 	int error, create_error = 0;
 	umode_t mode = op->mode;
-	DECLARE_WAIT_QUEUE_HEAD_ONSTACK(wq);
+	DECLARE_SWAIT_QUEUE_HEAD_ONSTACK(wq);
 
 	if (unlikely(IS_DEADDIR(dir_inode)))
 		return ERR_PTR(-ENOENT);
diff --git a/fs/namespace.c b/fs/namespace.c
index 6e76f2a72cfc..dbd1119a539f 100644
--- a/fs/namespace.c
+++ b/fs/namespace.c
@@ -14,6 +14,7 @@
 #include <linux/mnt_namespace.h>
 #include <linux/user_namespace.h>
 #include <linux/namei.h>
+#include <linux/delay.h>
 #include <linux/security.h>
 #include <linux/cred.h>
 #include <linux/idr.h>
@@ -322,8 +323,11 @@ int __mnt_want_write(struct vfsmount *m)
 	 * incremented count after it has set MNT_WRITE_HOLD.
 	 */
 	smp_mb();
-	while (READ_ONCE(mnt->mnt.mnt_flags) & MNT_WRITE_HOLD)
-		cpu_relax();
+	while (READ_ONCE(mnt->mnt.mnt_flags) & MNT_WRITE_HOLD) {
+		preempt_enable();
+		cpu_chill();
+		preempt_disable();
+	}
 	/*
 	 * After the slowpath clears MNT_WRITE_HOLD, mnt_is_readonly will
 	 * be set to match its requirements. So we must not load that until
diff --git a/fs/nfs/dir.c b/fs/nfs/dir.c
index 9f88ca7b2001..bc8a78ecfe1c 100644
--- a/fs/nfs/dir.c
+++ b/fs/nfs/dir.c
@@ -484,7 +484,7 @@ void nfs_prime_dcache(struct dentry *parent, struct nfs_entry *entry,
 		unsigned long dir_verifier)
 {
 	struct qstr filename = QSTR_INIT(entry->name, entry->len);
-	DECLARE_WAIT_QUEUE_HEAD_ONSTACK(wq);
+	DECLARE_SWAIT_QUEUE_HEAD_ONSTACK(wq);
 	struct dentry *dentry;
 	struct dentry *alias;
 	struct inode *inode;
@@ -1660,7 +1660,7 @@ int nfs_atomic_open(struct inode *dir, struct dentry *dentry,
 		    struct file *file, unsigned open_flags,
 		    umode_t mode)
 {
-	DECLARE_WAIT_QUEUE_HEAD_ONSTACK(wq);
+	DECLARE_SWAIT_QUEUE_HEAD_ONSTACK(wq);
 	struct nfs_open_context *ctx;
 	struct dentry *res;
 	struct iattr attr = { .ia_valid = ATTR_OPEN };
diff --git a/fs/nfs/unlink.c b/fs/nfs/unlink.c
index b27ebdccef70..f86c98a7ed04 100644
--- a/fs/nfs/unlink.c
+++ b/fs/nfs/unlink.c
@@ -13,7 +13,7 @@
 #include <linux/sunrpc/clnt.h>
 #include <linux/nfs_fs.h>
 #include <linux/sched.h>
-#include <linux/wait.h>
+#include <linux/swait.h>
 #include <linux/namei.h>
 #include <linux/fsnotify.h>
 
@@ -180,7 +180,7 @@ nfs_async_unlink(struct dentry *dentry, const struct qstr *name)
 
 	data->cred = get_current_cred();
 	data->res.dir_attr = &data->dir_attr;
-	init_waitqueue_head(&data->wq);
+	init_swait_queue_head(&data->wq);
 
 	status = -EBUSY;
 	spin_lock(&dentry->d_lock);
diff --git a/fs/proc/array.c b/fs/proc/array.c
index 18a4588c35be..decaa7768044 100644
--- a/fs/proc/array.c
+++ b/fs/proc/array.c
@@ -384,9 +384,9 @@ static inline void task_context_switch_counts(struct seq_file *m,
 static void task_cpus_allowed(struct seq_file *m, struct task_struct *task)
 {
 	seq_printf(m, "Cpus_allowed:\t%*pb\n",
-		   cpumask_pr_args(task->cpus_ptr));
+		   cpumask_pr_args(&task->cpus_mask));
 	seq_printf(m, "Cpus_allowed_list:\t%*pbl\n",
-		   cpumask_pr_args(task->cpus_ptr));
+		   cpumask_pr_args(&task->cpus_mask));
 }
 
 static inline void task_core_dumping(struct seq_file *m, struct mm_struct *mm)
diff --git a/fs/proc/base.c b/fs/proc/base.c
index 98bfd18e61bc..2a2e16b7fb9e 100644
--- a/fs/proc/base.c
+++ b/fs/proc/base.c
@@ -96,6 +96,7 @@
 #include <linux/posix-timers.h>
 #include <linux/time_namespace.h>
 #include <linux/resctrl.h>
+#include <linux/swait.h>
 #include <linux/share_pool.h>
 #include <trace/events/oom.h>
 #include "internal.h"
@@ -2161,7 +2162,7 @@ bool proc_fill_cache(struct file *file, struct dir_context *ctx,
 
 	child = d_hash_and_lookup(dir, &qname);
 	if (!child) {
-		DECLARE_WAIT_QUEUE_HEAD_ONSTACK(wq);
+		DECLARE_SWAIT_QUEUE_HEAD_ONSTACK(wq);
 		child = d_alloc_parallel(dir, &qname, &wq);
 		if (IS_ERR(child))
 			goto end_instantiate;
diff --git a/fs/proc/proc_sysctl.c b/fs/proc/proc_sysctl.c
index df435cd91a5b..eb19a342909c 100644
--- a/fs/proc/proc_sysctl.c
+++ b/fs/proc/proc_sysctl.c
@@ -684,7 +684,7 @@ static bool proc_sys_fill_cache(struct file *file,
 
 	child = d_lookup(dir, &qname);
 	if (!child) {
-		DECLARE_WAIT_QUEUE_HEAD_ONSTACK(wq);
+		DECLARE_SWAIT_QUEUE_HEAD_ONSTACK(wq);
 		child = d_alloc_parallel(dir, &qname, &wq);
 		if (IS_ERR(child))
 			return false;
diff --git a/fs/pstore/platform.c b/fs/pstore/platform.c
index ce03c3dbb5c3..5c2c14d5f6fc 100644
--- a/fs/pstore/platform.c
+++ b/fs/pstore/platform.c
@@ -384,7 +384,8 @@ void pstore_record_init(struct pstore_record *record,
  * end of the buffer.
  */
 static void pstore_dump(struct kmsg_dumper *dumper,
-			enum kmsg_dump_reason reason)
+			enum kmsg_dump_reason reason,
+			struct kmsg_dumper_iter *iter)
 {
 	unsigned long	total = 0;
 	const char	*why;
@@ -434,7 +435,7 @@ static void pstore_dump(struct kmsg_dumper *dumper,
 		dst_size -= header_size;
 
 		/* Write dump contents. */
-		if (!kmsg_dump_get_buffer(dumper, true, dst + header_size,
+		if (!kmsg_dump_get_buffer(iter, true, dst + header_size,
 					  dst_size, &dump_size))
 			break;
 
diff --git a/include/asm-generic/Kbuild b/include/asm-generic/Kbuild
index d1300c6e0a47..267f6dfb8960 100644
--- a/include/asm-generic/Kbuild
+++ b/include/asm-generic/Kbuild
@@ -30,7 +30,7 @@ mandatory-y += irq.h
 mandatory-y += irq_regs.h
 mandatory-y += irq_work.h
 mandatory-y += kdebug.h
-mandatory-y += kmap_types.h
+mandatory-y += kmap_size.h
 mandatory-y += kprobes.h
 mandatory-y += linkage.h
 mandatory-y += local.h
diff --git a/include/asm-generic/hardirq.h b/include/asm-generic/hardirq.h
index d14214dfc10b..7317e8258b48 100644
--- a/include/asm-generic/hardirq.h
+++ b/include/asm-generic/hardirq.h
@@ -7,9 +7,13 @@
 
 typedef struct {
 	unsigned int __softirq_pending;
+#ifdef ARCH_WANTS_NMI_IRQSTAT
+	unsigned int __nmi_count;
+#endif
 } ____cacheline_aligned irq_cpustat_t;
 
-#include <linux/irq_cpustat.h>	/* Standard mappings for irq_cpustat_t above */
+DECLARE_PER_CPU_ALIGNED(irq_cpustat_t, irq_stat);
+
 #include <linux/irq.h>
 
 #ifndef ack_bad_irq
diff --git a/include/asm-generic/kmap_size.h b/include/asm-generic/kmap_size.h
new file mode 100644
index 000000000000..9d6c7786a645
--- /dev/null
+++ b/include/asm-generic/kmap_size.h
@@ -0,0 +1,12 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+#ifndef _ASM_GENERIC_KMAP_SIZE_H
+#define _ASM_GENERIC_KMAP_SIZE_H
+
+/* For debug this provides guard pages between the maps */
+#ifdef CONFIG_DEBUG_HIGHMEM
+# define KM_MAX_IDX	33
+#else
+# define KM_MAX_IDX	16
+#endif
+
+#endif
diff --git a/include/asm-generic/kmap_types.h b/include/asm-generic/kmap_types.h
deleted file mode 100644
index 9f95b7b63d19..000000000000
--- a/include/asm-generic/kmap_types.h
+++ /dev/null
@@ -1,11 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-#ifndef _ASM_GENERIC_KMAP_TYPES_H
-#define _ASM_GENERIC_KMAP_TYPES_H
-
-#ifdef __WITH_KM_FENCE
-# define KM_TYPE_NR 41
-#else
-# define KM_TYPE_NR 20
-#endif
-
-#endif
diff --git a/include/asm-generic/preempt.h b/include/asm-generic/preempt.h
index b4d43a4af5f7..ac255e889462 100644
--- a/include/asm-generic/preempt.h
+++ b/include/asm-generic/preempt.h
@@ -79,6 +79,9 @@ static __always_inline bool should_resched(int preempt_offset)
 }
 
 #ifdef CONFIG_PREEMPTION
+#ifdef CONFIG_PREEMPT_RT
+extern void preempt_schedule_lock(void);
+#endif
 extern asmlinkage void preempt_schedule(void);
 #define __preempt_schedule() preempt_schedule()
 extern asmlinkage void preempt_schedule_notrace(void);
diff --git a/include/linux/blkdev.h b/include/linux/blkdev.h
index eed319e5d192..3ed38e48126a 100644
--- a/include/linux/blkdev.h
+++ b/include/linux/blkdev.h
@@ -166,7 +166,7 @@ struct request {
 	 */
 	union {
 		struct hlist_node hash;	/* merge hash */
-		struct list_head ipi_list;
+		struct llist_node ipi_list;
 	};
 
 	/*
diff --git a/include/linux/bottom_half.h b/include/linux/bottom_half.h
index a19519f4241d..eed86eb0a1de 100644
--- a/include/linux/bottom_half.h
+++ b/include/linux/bottom_half.h
@@ -4,7 +4,7 @@
 
 #include <linux/preempt.h>
 
-#ifdef CONFIG_TRACE_IRQFLAGS
+#if defined(CONFIG_PREEMPT_RT) || defined(CONFIG_TRACE_IRQFLAGS)
 extern void __local_bh_disable_ip(unsigned long ip, unsigned int cnt);
 #else
 static __always_inline void __local_bh_disable_ip(unsigned long ip, unsigned int cnt)
@@ -32,4 +32,10 @@ static inline void local_bh_enable(void)
 	__local_bh_enable_ip(_THIS_IP_, SOFTIRQ_DISABLE_OFFSET);
 }
 
+#ifdef CONFIG_PREEMPT_RT
+extern bool local_bh_blocked(void);
+#else
+static inline bool local_bh_blocked(void) { return false; }
+#endif
+
 #endif /* _LINUX_BH_H */
diff --git a/include/linux/console.h b/include/linux/console.h
index bc2a749e6f0d..027278792eea 100644
--- a/include/linux/console.h
+++ b/include/linux/console.h
@@ -16,6 +16,7 @@
 
 #include <linux/atomic.h>
 #include <linux/types.h>
+#include <linux/printk.h>
 
 struct vc_data;
 struct console_font_op;
@@ -137,10 +138,12 @@ static inline int con_debug_leave(void)
 #define CON_ANYTIME	(16) /* Safe to call when cpu is offline */
 #define CON_BRL		(32) /* Used for a braille device */
 #define CON_EXTENDED	(64) /* Use the extended output format a la /dev/kmsg */
+#define CON_HANDOVER	(128) /* Device was previously a boot console. */
 
 struct console {
 	char	name[16];
 	void	(*write)(struct console *, const char *, unsigned);
+	void	(*write_atomic)(struct console *co, const char *s, unsigned int count);
 	int	(*read)(struct console *, char *, unsigned);
 	struct tty_driver *(*device)(struct console *, int *);
 	void	(*unblank)(void);
@@ -150,6 +153,11 @@ struct console {
 	short	flags;
 	short	index;
 	int	cflag;
+#ifdef CONFIG_PRINTK
+	char	sync_buf[CONSOLE_LOG_MAX];
+#endif
+	atomic64_t printk_seq;
+	struct task_struct *thread;
 	uint	ispeed;
 	uint	ospeed;
 	void	*data;
@@ -232,4 +240,7 @@ extern void console_init(void);
 void dummycon_register_output_notifier(struct notifier_block *nb);
 void dummycon_unregister_output_notifier(struct notifier_block *nb);
 
+extern void console_atomic_lock(unsigned int *flags);
+extern void console_atomic_unlock(unsigned int flags);
+
 #endif /* _LINUX_CONSOLE_H */
diff --git a/include/linux/cpuhotplug.h b/include/linux/cpuhotplug.h
index b540e5a60ea9..dacf87c92fc1 100644
--- a/include/linux/cpuhotplug.h
+++ b/include/linux/cpuhotplug.h
@@ -159,6 +159,7 @@ enum cpuhp_state {
 	CPUHP_AP_ONLINE,
 	CPUHP_TEARDOWN_CPU,
 	CPUHP_AP_ONLINE_IDLE,
+	CPUHP_AP_SCHED_WAIT_EMPTY,
 	CPUHP_AP_SMPBOOT_THREADS,
 	CPUHP_AP_X86_VDSO_VMA_ONLINE,
 	CPUHP_AP_IRQ_AFFINITY_ONLINE,
diff --git a/include/linux/cpumask.h b/include/linux/cpumask.h
index 0159986ac9ce..c53364c4296d 100644
--- a/include/linux/cpumask.h
+++ b/include/linux/cpumask.h
@@ -199,6 +199,11 @@ static inline int cpumask_any_and_distribute(const struct cpumask *src1p,
 	return cpumask_next_and(-1, src1p, src2p);
 }
 
+static inline int cpumask_any_distribute(const struct cpumask *srcp)
+{
+	return cpumask_first(srcp);
+}
+
 #define for_each_cpu(cpu, mask)			\
 	for ((cpu) = 0; (cpu) < 1; (cpu)++, (void)mask)
 #define for_each_cpu_not(cpu, mask)		\
@@ -252,6 +257,7 @@ int __pure cpumask_any_but(const struct cpumask *mask, unsigned int cpu);
 unsigned int cpumask_local_spread(unsigned int i, int node);
 int cpumask_any_and_distribute(const struct cpumask *src1p,
 			       const struct cpumask *src2p);
+int cpumask_any_distribute(const struct cpumask *srcp);
 
 /**
  * for_each_cpu - iterate over every cpu in a mask
diff --git a/include/linux/dcache.h b/include/linux/dcache.h
index 4bb8b1759438..c5821c04ab88 100644
--- a/include/linux/dcache.h
+++ b/include/linux/dcache.h
@@ -108,7 +108,7 @@ struct dentry {
 
 	union {
 		struct list_head d_lru;		/* LRU list */
-		wait_queue_head_t *d_wait;	/* in-lookup ones only */
+		struct swait_queue_head *d_wait;	/* in-lookup ones only */
 	};
 	struct list_head d_child;	/* child of parent list */
 	struct list_head d_subdirs;	/* our children */
@@ -251,7 +251,7 @@ extern void d_set_d_op(struct dentry *dentry, const struct dentry_operations *op
 extern struct dentry * d_alloc(struct dentry *, const struct qstr *);
 extern struct dentry * d_alloc_anon(struct super_block *);
 extern struct dentry * d_alloc_parallel(struct dentry *, const struct qstr *,
-					wait_queue_head_t *);
+					struct swait_queue_head *);
 extern struct dentry * d_splice_alias(struct inode *, struct dentry *);
 extern struct dentry * d_add_ci(struct dentry *, struct inode *, struct qstr *);
 extern struct dentry * d_exact_alias(struct dentry *, struct inode *);
diff --git a/include/linux/debug_locks.h b/include/linux/debug_locks.h
index edb5c186b0b7..3f49e65169c6 100644
--- a/include/linux/debug_locks.h
+++ b/include/linux/debug_locks.h
@@ -3,8 +3,7 @@
 #define __LINUX_DEBUG_LOCKING_H
 
 #include <linux/atomic.h>
-#include <linux/bug.h>
-#include <linux/printk.h>
+#include <linux/cache.h>
 
 struct task_struct;
 
diff --git a/include/linux/delay.h b/include/linux/delay.h
index e8607992c68a..cd24f34b4ad0 100644
--- a/include/linux/delay.h
+++ b/include/linux/delay.h
@@ -88,4 +88,10 @@ static inline void fsleep(unsigned long usecs)
 		msleep(DIV_ROUND_UP(usecs, 1000));
 }
 
+#ifdef CONFIG_PREEMPT_RT
+extern void cpu_chill(void);
+#else
+# define cpu_chill()	cpu_relax()
+#endif
+
 #endif /* defined(_LINUX_DELAY_H) */
diff --git a/include/linux/entry-common.h b/include/linux/entry-common.h
index d8e1c798dc9d..d2aca09f7027 100644
--- a/include/linux/entry-common.h
+++ b/include/linux/entry-common.h
@@ -70,7 +70,7 @@
 
 #define EXIT_TO_USER_MODE_WORK						\
 	(_TIF_SIGPENDING | _TIF_NOTIFY_RESUME | _TIF_UPROBE |		\
-	 _TIF_NEED_RESCHED | _TIF_PATCH_PENDING |			\
+	 _TIF_NEED_RESCHED_MASK | _TIF_PATCH_PENDING |			\
 	 ARCH_EXIT_TO_USER_MODE_WORK)
 
 /**
diff --git a/include/linux/eventfd.h b/include/linux/eventfd.h
index dc4fd8a6644d..836b4c021a0a 100644
--- a/include/linux/eventfd.h
+++ b/include/linux/eventfd.h
@@ -14,6 +14,7 @@
 #include <linux/err.h>
 #include <linux/percpu-defs.h>
 #include <linux/percpu.h>
+#include <linux/sched.h>
 
 /*
  * CAREFUL: Check include/uapi/asm-generic/fcntl.h when defining
@@ -42,11 +43,9 @@ __u64 eventfd_signal(struct eventfd_ctx *ctx, __u64 n);
 int eventfd_ctx_remove_wait_queue(struct eventfd_ctx *ctx, wait_queue_entry_t *wait,
 				  __u64 *cnt);
 
-DECLARE_PER_CPU(int, eventfd_wake_count);
-
-static inline bool eventfd_signal_count(void)
+static inline bool eventfd_signal_allowed(void)
 {
-	return this_cpu_read(eventfd_wake_count);
+	return !current->in_eventfd_signal;
 }
 
 #else /* CONFIG_EVENTFD */
@@ -77,9 +76,9 @@ static inline int eventfd_ctx_remove_wait_queue(struct eventfd_ctx *ctx,
 	return -ENOSYS;
 }
 
-static inline bool eventfd_signal_count(void)
+static inline bool eventfd_signal_allowed(void)
 {
-	return false;
+	return true;
 }
 
 #endif
diff --git a/include/linux/fs.h b/include/linux/fs.h
index 45ea1243118c..3fb43df18354 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -719,7 +719,7 @@ struct inode {
 		struct block_device	*i_bdev;
 		struct cdev		*i_cdev;
 		char			*i_link;
-		unsigned		i_dir_seq;
+		unsigned		__i_dir_seq;
 	};
 
 	__u32			i_generation;
diff --git a/include/linux/hardirq.h b/include/linux/hardirq.h
index 754f67ac4326..76878b357ffa 100644
--- a/include/linux/hardirq.h
+++ b/include/linux/hardirq.h
@@ -6,6 +6,7 @@
 #include <linux/preempt.h>
 #include <linux/lockdep.h>
 #include <linux/ftrace_irq.h>
+#include <linux/sched.h>
 #include <linux/vtime.h>
 #include <asm/hardirq.h>
 
@@ -32,9 +33,9 @@ static __always_inline void rcu_irq_enter_check_tick(void)
  */
 #define __irq_enter()					\
 	do {						\
-		account_irq_enter_time(current);	\
 		preempt_count_add(HARDIRQ_OFFSET);	\
 		lockdep_hardirq_enter();		\
+		account_hardirq_enter(current);		\
 	} while (0)
 
 /*
@@ -62,8 +63,8 @@ void irq_enter_rcu(void);
  */
 #define __irq_exit()					\
 	do {						\
+		account_hardirq_exit(current);		\
 		lockdep_hardirq_exit();			\
-		account_irq_exit_time(current);		\
 		preempt_count_sub(HARDIRQ_OFFSET);	\
 	} while (0)
 
@@ -115,7 +116,6 @@ extern void rcu_nmi_exit(void);
 	do {							\
 		lockdep_off();					\
 		arch_nmi_enter();				\
-		printk_nmi_enter();				\
 		BUG_ON(in_nmi() == NMI_MASK);			\
 		__preempt_count_add(NMI_OFFSET + HARDIRQ_OFFSET);	\
 	} while (0)
@@ -134,7 +134,6 @@ extern void rcu_nmi_exit(void);
 	do {							\
 		BUG_ON(!in_nmi());				\
 		__preempt_count_sub(NMI_OFFSET + HARDIRQ_OFFSET);	\
-		printk_nmi_exit();				\
 		arch_nmi_exit();				\
 		lockdep_on();					\
 	} while (0)
diff --git a/include/linux/highmem-internal.h b/include/linux/highmem-internal.h
new file mode 100644
index 000000000000..f9bc6acd3679
--- /dev/null
+++ b/include/linux/highmem-internal.h
@@ -0,0 +1,222 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+#ifndef _LINUX_HIGHMEM_INTERNAL_H
+#define _LINUX_HIGHMEM_INTERNAL_H
+
+/*
+ * Outside of CONFIG_HIGHMEM to support X86 32bit iomap_atomic() cruft.
+ */
+#ifdef CONFIG_KMAP_LOCAL
+void *__kmap_local_pfn_prot(unsigned long pfn, pgprot_t prot);
+void *__kmap_local_page_prot(struct page *page, pgprot_t prot);
+void kunmap_local_indexed(void *vaddr);
+void kmap_local_fork(struct task_struct *tsk);
+void __kmap_local_sched_out(void);
+void __kmap_local_sched_in(void);
+static inline void kmap_assert_nomap(void)
+{
+	DEBUG_LOCKS_WARN_ON(current->kmap_ctrl.idx);
+}
+#else
+static inline void kmap_local_fork(struct task_struct *tsk) { }
+static inline void kmap_assert_nomap(void) { }
+#endif
+
+#ifdef CONFIG_HIGHMEM
+#include <asm/highmem.h>
+
+#ifndef ARCH_HAS_KMAP_FLUSH_TLB
+static inline void kmap_flush_tlb(unsigned long addr) { }
+#endif
+
+#ifndef kmap_prot
+#define kmap_prot PAGE_KERNEL
+#endif
+
+void *kmap_high(struct page *page);
+void kunmap_high(struct page *page);
+void __kmap_flush_unused(void);
+struct page *__kmap_to_page(void *addr);
+
+static inline void *kmap(struct page *page)
+{
+	void *addr;
+
+	might_sleep();
+	if (!PageHighMem(page))
+		addr = page_address(page);
+	else
+		addr = kmap_high(page);
+	kmap_flush_tlb((unsigned long)addr);
+	return addr;
+}
+
+static inline void kunmap(struct page *page)
+{
+	might_sleep();
+	if (!PageHighMem(page))
+		return;
+	kunmap_high(page);
+}
+
+static inline struct page *kmap_to_page(void *addr)
+{
+	return __kmap_to_page(addr);
+}
+
+static inline void kmap_flush_unused(void)
+{
+	__kmap_flush_unused();
+}
+
+static inline void *kmap_local_page(struct page *page)
+{
+	return __kmap_local_page_prot(page, kmap_prot);
+}
+
+static inline void *kmap_local_page_prot(struct page *page, pgprot_t prot)
+{
+	return __kmap_local_page_prot(page, prot);
+}
+
+static inline void *kmap_local_pfn(unsigned long pfn)
+{
+	return __kmap_local_pfn_prot(pfn, kmap_prot);
+}
+
+static inline void __kunmap_local(void *vaddr)
+{
+	kunmap_local_indexed(vaddr);
+}
+
+static inline void *kmap_atomic(struct page *page)
+{
+	if (IS_ENABLED(CONFIG_PREEMPT_RT))
+		migrate_disable();
+	else
+		preempt_disable();
+	pagefault_disable();
+	return __kmap_local_page_prot(page, kmap_prot);
+}
+
+static inline void __kunmap_atomic(void *addr)
+{
+	kunmap_local_indexed(addr);
+	pagefault_enable();
+	if (IS_ENABLED(CONFIG_PREEMPT_RT))
+		migrate_enable();
+	else
+		preempt_enable();
+}
+
+unsigned int __nr_free_highpages(void);
+extern atomic_long_t _totalhigh_pages;
+
+static inline unsigned int nr_free_highpages(void)
+{
+	return __nr_free_highpages();
+}
+
+static inline unsigned long totalhigh_pages(void)
+{
+	return (unsigned long)atomic_long_read(&_totalhigh_pages);
+}
+
+static inline void totalhigh_pages_inc(void)
+{
+	atomic_long_inc(&_totalhigh_pages);
+}
+
+static inline void totalhigh_pages_add(long count)
+{
+	atomic_long_add(count, &_totalhigh_pages);
+}
+
+#else /* CONFIG_HIGHMEM */
+
+static inline struct page *kmap_to_page(void *addr)
+{
+	return virt_to_page(addr);
+}
+
+static inline void *kmap(struct page *page)
+{
+	might_sleep();
+	return page_address(page);
+}
+
+static inline void kunmap_high(struct page *page) { }
+static inline void kmap_flush_unused(void) { }
+
+static inline void kunmap(struct page *page)
+{
+#ifdef ARCH_HAS_FLUSH_ON_KUNMAP
+	kunmap_flush_on_unmap(page_address(page));
+#endif
+}
+
+static inline void *kmap_local_page(struct page *page)
+{
+	return page_address(page);
+}
+
+static inline void *kmap_local_page_prot(struct page *page, pgprot_t prot)
+{
+	return kmap_local_page(page);
+}
+
+static inline void *kmap_local_pfn(unsigned long pfn)
+{
+	return kmap_local_page(pfn_to_page(pfn));
+}
+
+static inline void __kunmap_local(void *addr)
+{
+#ifdef ARCH_HAS_FLUSH_ON_KUNMAP
+	kunmap_flush_on_unmap(addr);
+#endif
+}
+
+static inline void *kmap_atomic(struct page *page)
+{
+	if (IS_ENABLED(CONFIG_PREEMPT_RT))
+		migrate_disable();
+	else
+		preempt_disable();
+	pagefault_disable();
+	return page_address(page);
+}
+
+static inline void __kunmap_atomic(void *addr)
+{
+#ifdef ARCH_HAS_FLUSH_ON_KUNMAP
+	kunmap_flush_on_unmap(addr);
+#endif
+	pagefault_enable();
+	if (IS_ENABLED(CONFIG_PREEMPT_RT))
+		migrate_enable();
+	else
+		preempt_enable();
+}
+
+static inline unsigned int nr_free_highpages(void) { return 0; }
+static inline unsigned long totalhigh_pages(void) { return 0UL; }
+
+#endif /* CONFIG_HIGHMEM */
+
+/*
+ * Prevent people trying to call kunmap_atomic() as if it were kunmap()
+ * kunmap_atomic() should get the return value of kmap_atomic, not the page.
+ */
+#define kunmap_atomic(__addr)					\
+do {								\
+	BUILD_BUG_ON(__same_type((__addr), struct page *));	\
+	__kunmap_atomic(__addr);				\
+} while (0)
+
+#define kunmap_local(__addr)					\
+do {								\
+	BUILD_BUG_ON(__same_type((__addr), struct page *));	\
+	__kunmap_local(__addr);					\
+} while (0)
+
+#endif
diff --git a/include/linux/highmem.h b/include/linux/highmem.h
index c3b75b4a8fc1..d12f7a5fc853 100644
--- a/include/linux/highmem.h
+++ b/include/linux/highmem.h
@@ -11,217 +11,137 @@
 
 #include <asm/cacheflush.h>
 
-#ifndef ARCH_HAS_FLUSH_ANON_PAGE
-static inline void flush_anon_page(struct vm_area_struct *vma, struct page *page, unsigned long vmaddr)
-{
-}
-#endif
-
-#ifndef ARCH_HAS_FLUSH_KERNEL_DCACHE_PAGE
-static inline void flush_kernel_dcache_page(struct page *page)
-{
-}
-static inline void flush_kernel_vmap_range(void *vaddr, int size)
-{
-}
-static inline void invalidate_kernel_vmap_range(void *vaddr, int size)
-{
-}
-#endif
-
-#include <asm/kmap_types.h>
-
-#ifdef CONFIG_HIGHMEM
-extern void *kmap_atomic_high_prot(struct page *page, pgprot_t prot);
-extern void kunmap_atomic_high(void *kvaddr);
-#include <asm/highmem.h>
-
-#ifndef ARCH_HAS_KMAP_FLUSH_TLB
-static inline void kmap_flush_tlb(unsigned long addr) { }
-#endif
-
-#ifndef kmap_prot
-#define kmap_prot PAGE_KERNEL
-#endif
-
-void *kmap_high(struct page *page);
-static inline void *kmap(struct page *page)
-{
-	void *addr;
-
-	might_sleep();
-	if (!PageHighMem(page))
-		addr = page_address(page);
-	else
-		addr = kmap_high(page);
-	kmap_flush_tlb((unsigned long)addr);
-	return addr;
-}
-
-void kunmap_high(struct page *page);
-
-static inline void kunmap(struct page *page)
-{
-	might_sleep();
-	if (!PageHighMem(page))
-		return;
-	kunmap_high(page);
-}
+#include "highmem-internal.h"
 
-/*
- * kmap_atomic/kunmap_atomic is significantly faster than kmap/kunmap because
- * no global lock is needed and because the kmap code must perform a global TLB
- * invalidation when the kmap pool wraps.
+/**
+ * kmap - Map a page for long term usage
+ * @page:	Pointer to the page to be mapped
+ *
+ * Returns: The virtual address of the mapping
  *
- * However when holding an atomic kmap it is not legal to sleep, so atomic
- * kmaps are appropriate for short, tight code paths only.
+ * Can only be invoked from preemptible task context because on 32bit
+ * systems with CONFIG_HIGHMEM enabled this function might sleep.
  *
- * The use of kmap_atomic/kunmap_atomic is discouraged - kmap/kunmap
- * gives a more generic (and caching) interface. But kmap_atomic can
- * be used in IRQ contexts, so in some (very limited) cases we need
- * it.
+ * For systems with CONFIG_HIGHMEM=n and for pages in the low memory area
+ * this returns the virtual address of the direct kernel mapping.
+ *
+ * The returned virtual address is globally visible and valid up to the
+ * point where it is unmapped via kunmap(). The pointer can be handed to
+ * other contexts.
+ *
+ * For highmem pages on 32bit systems this can be slow as the mapping space
+ * is limited and protected by a global lock. In case that there is no
+ * mapping slot available the function blocks until a slot is released via
+ * kunmap().
  */
-static inline void *kmap_atomic_prot(struct page *page, pgprot_t prot)
-{
-	preempt_disable();
-	pagefault_disable();
-	if (!PageHighMem(page))
-		return page_address(page);
-	return kmap_atomic_high_prot(page, prot);
-}
-#define kmap_atomic(page)	kmap_atomic_prot(page, kmap_prot)
+static inline void *kmap(struct page *page);
 
-/* declarations for linux/mm/highmem.c */
-unsigned int nr_free_highpages(void);
-extern atomic_long_t _totalhigh_pages;
-static inline unsigned long totalhigh_pages(void)
-{
-	return (unsigned long)atomic_long_read(&_totalhigh_pages);
-}
-
-static inline void totalhigh_pages_inc(void)
-{
-	atomic_long_inc(&_totalhigh_pages);
-}
-
-static inline void totalhigh_pages_dec(void)
-{
-	atomic_long_dec(&_totalhigh_pages);
-}
-
-static inline void totalhigh_pages_add(long count)
-{
-	atomic_long_add(count, &_totalhigh_pages);
-}
-
-static inline void totalhigh_pages_set(long val)
-{
-	atomic_long_set(&_totalhigh_pages, val);
-}
-
-void kmap_flush_unused(void);
-
-struct page *kmap_to_page(void *addr);
-
-#else /* CONFIG_HIGHMEM */
+/**
+ * kunmap - Unmap the virtual address mapped by kmap()
+ * @addr:	Virtual address to be unmapped
+ *
+ * Counterpart to kmap(). A NOOP for CONFIG_HIGHMEM=n and for mappings of
+ * pages in the low memory area.
+ */
+static inline void kunmap(struct page *page);
 
-static inline unsigned int nr_free_highpages(void) { return 0; }
+/**
+ * kmap_to_page - Get the page for a kmap'ed address
+ * @addr:	The address to look up
+ *
+ * Returns: The page which is mapped to @addr.
+ */
+static inline struct page *kmap_to_page(void *addr);
 
-static inline struct page *kmap_to_page(void *addr)
-{
-	return virt_to_page(addr);
-}
+/**
+ * kmap_flush_unused - Flush all unused kmap mappings in order to
+ *		       remove stray mappings
+ */
+static inline void kmap_flush_unused(void);
 
-static inline unsigned long totalhigh_pages(void) { return 0UL; }
+/**
+ * kmap_local_page - Map a page for temporary usage
+ * @page:	Pointer to the page to be mapped
+ *
+ * Returns: The virtual address of the mapping
+ *
+ * Can be invoked from any context.
+ *
+ * Requires careful handling when nesting multiple mappings because the map
+ * management is stack based. The unmap has to be in the reverse order of
+ * the map operation:
+ *
+ * addr1 = kmap_local_page(page1);
+ * addr2 = kmap_local_page(page2);
+ * ...
+ * kunmap_local(addr2);
+ * kunmap_local(addr1);
+ *
+ * Unmapping addr1 before addr2 is invalid and causes malfunction.
+ *
+ * Contrary to kmap() mappings the mapping is only valid in the context of
+ * the caller and cannot be handed to other contexts.
+ *
+ * On CONFIG_HIGHMEM=n kernels and for low memory pages this returns the
+ * virtual address of the direct mapping. Only real highmem pages are
+ * temporarily mapped.
+ *
+ * While it is significantly faster than kmap() for the higmem case it
+ * comes with restrictions about the pointer validity. Only use when really
+ * necessary.
+ *
+ * On HIGHMEM enabled systems mapping a highmem page has the side effect of
+ * disabling migration in order to keep the virtual address stable across
+ * preemption. No caller of kmap_local_page() can rely on this side effect.
+ */
+static inline void *kmap_local_page(struct page *page);
 
-static inline void *kmap(struct page *page)
-{
-	might_sleep();
-	return page_address(page);
-}
+/**
+ * kmap_atomic - Atomically map a page for temporary usage - Deprecated!
+ * @page:	Pointer to the page to be mapped
+ *
+ * Returns: The virtual address of the mapping
+ *
+ * Effectively a wrapper around kmap_local_page() which disables pagefaults
+ * and preemption.
+ *
+ * Do not use in new code. Use kmap_local_page() instead.
+ */
+static inline void *kmap_atomic(struct page *page);
 
-static inline void kunmap_high(struct page *page)
-{
-}
+/**
+ * kunmap_atomic - Unmap the virtual address mapped by kmap_atomic()
+ * @addr:	Virtual address to be unmapped
+ *
+ * Counterpart to kmap_atomic().
+ *
+ * Effectively a wrapper around kunmap_local() which additionally undoes
+ * the side effects of kmap_atomic(), i.e. reenabling pagefaults and
+ * preemption.
+ */
 
-static inline void kunmap(struct page *page)
-{
-#ifdef ARCH_HAS_FLUSH_ON_KUNMAP
-	kunmap_flush_on_unmap(page_address(page));
-#endif
-}
+/* Highmem related interfaces for management code */
+static inline unsigned int nr_free_highpages(void);
+static inline unsigned long totalhigh_pages(void);
 
-static inline void *kmap_atomic(struct page *page)
+#ifndef ARCH_HAS_FLUSH_ANON_PAGE
+static inline void flush_anon_page(struct vm_area_struct *vma, struct page *page, unsigned long vmaddr)
 {
-	preempt_disable();
-	pagefault_disable();
-	return page_address(page);
 }
-#define kmap_atomic_prot(page, prot)	kmap_atomic(page)
-
-static inline void kunmap_atomic_high(void *addr)
-{
-	/*
-	 * Mostly nothing to do in the CONFIG_HIGHMEM=n case as kunmap_atomic()
-	 * handles re-enabling faults + preemption
-	 */
-#ifdef ARCH_HAS_FLUSH_ON_KUNMAP
-	kunmap_flush_on_unmap(addr);
 #endif
-}
-
-#define kmap_atomic_pfn(pfn)	kmap_atomic(pfn_to_page(pfn))
-
-#define kmap_flush_unused()	do {} while(0)
-
-#endif /* CONFIG_HIGHMEM */
 
-#if defined(CONFIG_HIGHMEM) || defined(CONFIG_X86_32)
-
-DECLARE_PER_CPU(int, __kmap_atomic_idx);
-
-static inline int kmap_atomic_idx_push(void)
+#ifndef ARCH_HAS_FLUSH_KERNEL_DCACHE_PAGE
+static inline void flush_kernel_dcache_page(struct page *page)
 {
-	int idx = __this_cpu_inc_return(__kmap_atomic_idx) - 1;
-
-#ifdef CONFIG_DEBUG_HIGHMEM
-	WARN_ON_ONCE(in_irq() && !irqs_disabled());
-	BUG_ON(idx >= KM_TYPE_NR);
-#endif
-	return idx;
 }
-
-static inline int kmap_atomic_idx(void)
+static inline void flush_kernel_vmap_range(void *vaddr, int size)
 {
-	return __this_cpu_read(__kmap_atomic_idx) - 1;
 }
-
-static inline void kmap_atomic_idx_pop(void)
+static inline void invalidate_kernel_vmap_range(void *vaddr, int size)
 {
-#ifdef CONFIG_DEBUG_HIGHMEM
-	int idx = __this_cpu_dec_return(__kmap_atomic_idx);
-
-	BUG_ON(idx < 0);
-#else
-	__this_cpu_dec(__kmap_atomic_idx);
-#endif
 }
-
 #endif
 
-/*
- * Prevent people trying to call kunmap_atomic() as if it were kunmap()
- * kunmap_atomic() should get the return value of kmap_atomic, not the page.
- */
-#define kunmap_atomic(addr)                                     \
-do {                                                            \
-	BUILD_BUG_ON(__same_type((addr), struct page *));       \
-	kunmap_atomic_high(addr);                                  \
-	pagefault_enable();                                     \
-	preempt_enable();                                       \
-} while (0)
-
-
 /* when CONFIG_HIGHMEM is not set these will be plain clear/copy_page */
 #ifndef clear_user_highpage
 static inline void clear_user_highpage(struct page *page, unsigned long vaddr)
diff --git a/include/linux/interrupt.h b/include/linux/interrupt.h
index 22240a8c3a1e..fc162c2525ea 100644
--- a/include/linux/interrupt.h
+++ b/include/linux/interrupt.h
@@ -542,7 +542,7 @@ struct softirq_action
 asmlinkage void do_softirq(void);
 asmlinkage void __do_softirq(void);
 
-#ifdef __ARCH_HAS_DO_SOFTIRQ
+#if defined(__ARCH_HAS_DO_SOFTIRQ) && !defined(CONFIG_PREEMPT_RT)
 void do_softirq_own_stack(void);
 #else
 static inline void do_softirq_own_stack(void)
@@ -637,26 +637,21 @@ enum
 	TASKLET_STATE_RUN	/* Tasklet is running (SMP only) */
 };
 
-#ifdef CONFIG_SMP
+#if defined(CONFIG_SMP) || defined(CONFIG_PREEMPT_RT)
 static inline int tasklet_trylock(struct tasklet_struct *t)
 {
 	return !test_and_set_bit(TASKLET_STATE_RUN, &(t)->state);
 }
 
-static inline void tasklet_unlock(struct tasklet_struct *t)
-{
-	smp_mb__before_atomic();
-	clear_bit(TASKLET_STATE_RUN, &(t)->state);
-}
+void tasklet_unlock(struct tasklet_struct *t);
+void tasklet_unlock_wait(struct tasklet_struct *t);
+void tasklet_unlock_spin_wait(struct tasklet_struct *t);
 
-static inline void tasklet_unlock_wait(struct tasklet_struct *t)
-{
-	while (test_bit(TASKLET_STATE_RUN, &(t)->state)) { barrier(); }
-}
 #else
-#define tasklet_trylock(t) 1
-#define tasklet_unlock_wait(t) do { } while (0)
-#define tasklet_unlock(t) do { } while (0)
+static inline int tasklet_trylock(struct tasklet_struct *t) { return 1; }
+static inline void tasklet_unlock(struct tasklet_struct *t) { }
+static inline void tasklet_unlock_wait(struct tasklet_struct *t) { }
+static inline void tasklet_unlock_spin_wait(struct tasklet_struct *t) { }
 #endif
 
 extern void __tasklet_schedule(struct tasklet_struct *t);
@@ -681,6 +676,17 @@ static inline void tasklet_disable_nosync(struct tasklet_struct *t)
 	smp_mb__after_atomic();
 }
 
+/*
+ * Do not use in new code. Disabling tasklets from atomic contexts is
+ * error prone and should be avoided.
+ */
+static inline void tasklet_disable_in_atomic(struct tasklet_struct *t)
+{
+	tasklet_disable_nosync(t);
+	tasklet_unlock_spin_wait(t);
+	smp_mb();
+}
+
 static inline void tasklet_disable(struct tasklet_struct *t)
 {
 	tasklet_disable_nosync(t);
diff --git a/include/linux/io-mapping.h b/include/linux/io-mapping.h
index c75e4d3d8833..4bb8223f2f82 100644
--- a/include/linux/io-mapping.h
+++ b/include/linux/io-mapping.h
@@ -60,22 +60,20 @@ io_mapping_fini(struct io_mapping *mapping)
 	iomap_free(mapping->base, mapping->size);
 }
 
-/* Atomic map/unmap */
+/* Temporary mappings which are only valid in the current context */
 static inline void __iomem *
-io_mapping_map_atomic_wc(struct io_mapping *mapping,
-			 unsigned long offset)
+io_mapping_map_local_wc(struct io_mapping *mapping, unsigned long offset)
 {
 	resource_size_t phys_addr;
 
 	BUG_ON(offset >= mapping->size);
 	phys_addr = mapping->base + offset;
-	return iomap_atomic_prot_pfn(PHYS_PFN(phys_addr), mapping->prot);
+	return __iomap_local_pfn_prot(PHYS_PFN(phys_addr), mapping->prot);
 }
 
-static inline void
-io_mapping_unmap_atomic(void __iomem *vaddr)
+static inline void io_mapping_unmap_local(void __iomem *vaddr)
 {
-	iounmap_atomic(vaddr);
+	kunmap_local_indexed((void __force *)vaddr);
 }
 
 static inline void __iomem *
@@ -97,7 +95,7 @@ io_mapping_unmap(void __iomem *vaddr)
 	iounmap(vaddr);
 }
 
-#else
+#else  /* HAVE_ATOMIC_IOMAP */
 
 #include <linux/uaccess.h>
 
@@ -144,25 +142,19 @@ io_mapping_unmap(void __iomem *vaddr)
 {
 }
 
-/* Atomic map/unmap */
+/* Temporary mappings which are only valid in the current context */
 static inline void __iomem *
-io_mapping_map_atomic_wc(struct io_mapping *mapping,
-			 unsigned long offset)
+io_mapping_map_local_wc(struct io_mapping *mapping, unsigned long offset)
 {
-	preempt_disable();
-	pagefault_disable();
 	return io_mapping_map_wc(mapping, offset, PAGE_SIZE);
 }
 
-static inline void
-io_mapping_unmap_atomic(void __iomem *vaddr)
+static inline void io_mapping_unmap_local(void __iomem *vaddr)
 {
 	io_mapping_unmap(vaddr);
-	pagefault_enable();
-	preempt_enable();
 }
 
-#endif /* HAVE_ATOMIC_IOMAP */
+#endif /* !HAVE_ATOMIC_IOMAP */
 
 static inline struct io_mapping *
 io_mapping_create_wc(resource_size_t base,
diff --git a/include/linux/irq_cpustat.h b/include/linux/irq_cpustat.h
deleted file mode 100644
index 6e8895cd4d92..000000000000
--- a/include/linux/irq_cpustat.h
+++ /dev/null
@@ -1,28 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-#ifndef __irq_cpustat_h
-#define __irq_cpustat_h
-
-/*
- * Contains default mappings for irq_cpustat_t, used by almost every
- * architecture.  Some arch (like s390) have per cpu hardware pages and
- * they define their own mappings for irq_stat.
- *
- * Keith Owens <kaos@ocs.com.au> July 2000.
- */
-
-
-/*
- * Simple wrappers reducing source bloat.  Define all irq_stat fields
- * here, even ones that are arch dependent.  That way we get common
- * definitions instead of differing sets for each arch.
- */
-
-#ifndef __ARCH_IRQ_STAT
-DECLARE_PER_CPU_ALIGNED(irq_cpustat_t, irq_stat);	/* defined in asm/hardirq.h */
-#define __IRQ_STAT(cpu, member)	(per_cpu(irq_stat.member, cpu))
-#endif
-
-/* arch dependent irq_stat fields */
-#define nmi_count(cpu)		__IRQ_STAT((cpu), __nmi_count)	/* i386 */
-
-#endif	/* __irq_cpustat_h */
diff --git a/include/linux/irq_work.h b/include/linux/irq_work.h
index ec2a47a81e42..255d2dfec894 100644
--- a/include/linux/irq_work.h
+++ b/include/linux/irq_work.h
@@ -3,6 +3,7 @@
 #define _LINUX_IRQ_WORK_H
 
 #include <linux/smp_types.h>
+#include <linux/rcuwait.h>
 
 /*
  * An entry can be in one of four states:
@@ -16,11 +17,13 @@
 struct irq_work {
 	struct __call_single_node node;
 	void (*func)(struct irq_work *);
+	struct rcuwait irqwait;	
 };
 
 #define __IRQ_WORK_INIT(_func, _flags) (struct irq_work){	\
 	.node = { .u_flags = (_flags), },			\
 	.func = (_func),					\
+	.irqwait = __RCUWAIT_INITIALIZER(irqwait),	\
 }
 
 #define IRQ_WORK_INIT(_func) __IRQ_WORK_INIT(_func, 0)
@@ -30,10 +33,15 @@ struct irq_work {
 #define DEFINE_IRQ_WORK(name, _f)				\
 	struct irq_work name = IRQ_WORK_INIT(_f)
 
+#define IRQ_WORK_INIT(_func) __IRQ_WORK_INIT(_func, 0)
+#define IRQ_WORK_INIT_LAZY(_func) __IRQ_WORK_INIT(_func, IRQ_WORK_LAZY)
+#define IRQ_WORK_INIT_HARD(_func) __IRQ_WORK_INIT(_func, IRQ_WORK_HARD_IRQ)
+
 static inline
 void init_irq_work(struct irq_work *work, void (*func)(struct irq_work *))
 {
 	*work = IRQ_WORK_INIT(func);
+	rcuwait_init(&work->irqwait);
 }
 
 static inline bool irq_work_is_pending(struct irq_work *work)
@@ -46,6 +54,11 @@ static inline bool irq_work_is_busy(struct irq_work *work)
 	return atomic_read(&work->node.a_flags) & IRQ_WORK_BUSY;
 }
 
+static inline bool irq_work_is_hard(struct irq_work *work)
+{
+	return atomic_read(&work->node.a_flags) & IRQ_WORK_HARD_IRQ;
+}
+
 bool irq_work_queue(struct irq_work *work);
 bool irq_work_queue_on(struct irq_work *work, int cpu);
 
diff --git a/include/linux/irqdesc.h b/include/linux/irqdesc.h
index dc1b213ae941..9bbcd8cbac50 100644
--- a/include/linux/irqdesc.h
+++ b/include/linux/irqdesc.h
@@ -68,6 +68,7 @@ struct irq_desc {
 	unsigned int		irqs_unhandled;
 	atomic_t		threads_handled;
 	int			threads_handled_last;
+	u64			random_ip;
 	raw_spinlock_t		lock;
 	struct cpumask		*percpu_enabled;
 	const struct cpumask	*percpu_affinity;
diff --git a/include/linux/irqflags.h b/include/linux/irqflags.h
index fef2d43a7a1d..741aa2008a34 100644
--- a/include/linux/irqflags.h
+++ b/include/linux/irqflags.h
@@ -71,14 +71,6 @@ do {						\
 do {						\
 	__this_cpu_dec(hardirq_context);	\
 } while (0)
-# define lockdep_softirq_enter()		\
-do {						\
-	current->softirq_context++;		\
-} while (0)
-# define lockdep_softirq_exit()			\
-do {						\
-	current->softirq_context--;		\
-} while (0)
 
 # define lockdep_hrtimer_enter(__hrtimer)		\
 ({							\
@@ -140,6 +132,21 @@ do {						\
 # define lockdep_irq_work_exit(__work)		do { } while (0)
 #endif
 
+#if defined(CONFIG_TRACE_IRQFLAGS) && !defined(CONFIG_PREEMPT_RT)
+# define lockdep_softirq_enter()		\
+do {						\
+	current->softirq_context++;		\
+} while (0)
+# define lockdep_softirq_exit()			\
+do {						\
+	current->softirq_context--;		\
+} while (0)
+
+#else
+# define lockdep_softirq_enter()		do { } while (0)
+# define lockdep_softirq_exit()			do { } while (0)
+#endif
+
 #if defined(CONFIG_IRQSOFF_TRACER) || \
 	defined(CONFIG_PREEMPT_TRACER)
  extern void stop_critical_timings(void);
diff --git a/include/linux/kernel.h b/include/linux/kernel.h
index 78a0907f0b04..e6270bfa6105 100644
--- a/include/linux/kernel.h
+++ b/include/linux/kernel.h
@@ -220,6 +220,7 @@ static __always_inline void might_resched(void)
 extern void ___might_sleep(const char *file, int line, int preempt_offset);
 extern void __might_sleep(const char *file, int line, int preempt_offset);
 extern void __cant_sleep(const char *file, int line, int preempt_offset);
+extern void __cant_migrate(const char *file, int line);
 
 /**
  * might_sleep - annotation for functions that can sleep
@@ -235,6 +236,10 @@ extern void __cant_sleep(const char *file, int line, int preempt_offset);
  */
 # define might_sleep() \
 	do { __might_sleep(__FILE__, __LINE__, 0); might_resched(); } while (0)
+
+# define might_sleep_no_state_check() \
+	do { ___might_sleep(__FILE__, __LINE__, 0); } while (0)
+
 /**
  * cant_sleep - annotation for functions that cannot sleep
  *
@@ -243,6 +248,18 @@ extern void __cant_sleep(const char *file, int line, int preempt_offset);
 # define cant_sleep() \
 	do { __cant_sleep(__FILE__, __LINE__, 0); } while (0)
 # define sched_annotate_sleep()	(current->task_state_change = 0)
+
+/**
+ * cant_migrate - annotation for functions that cannot migrate
+ *
+ * Will print a stack trace if executed in code which is migratable
+ */
+# define cant_migrate()							\
+	do {								\
+		if (IS_ENABLED(CONFIG_SMP))				\
+			__cant_migrate(__FILE__, __LINE__);		\
+	} while (0)
+
 /**
  * non_block_start - annotate the start of section where sleeping is prohibited
  *
@@ -266,7 +283,9 @@ extern void __cant_sleep(const char *file, int line, int preempt_offset);
   static inline void __might_sleep(const char *file, int line,
 				   int preempt_offset) { }
 # define might_sleep() do { might_resched(); } while (0)
+# define might_sleep_no_state_check() do { might_resched(); } while (0)
 # define cant_sleep() do { } while (0)
+# define cant_migrate()		do { } while (0)
 # define sched_annotate_sleep() do { } while (0)
 # define non_block_start() do { } while (0)
 # define non_block_end() do { } while (0)
@@ -274,13 +293,6 @@ extern void __cant_sleep(const char *file, int line, int preempt_offset);
 
 #define might_sleep_if(cond) do { if (cond) might_sleep(); } while (0)
 
-#ifndef CONFIG_PREEMPT_RT
-# define cant_migrate()		cant_sleep()
-#else
-  /* Placeholder for now */
-# define cant_migrate()		do { } while (0)
-#endif
-
 /**
  * abs - return absolute value of an argument
  * @x: the value.  If it is unsigned type, it is converted to signed type first.
diff --git a/include/linux/kmsg_dump.h b/include/linux/kmsg_dump.h
index 3378bcbe585e..86673930c8ea 100644
--- a/include/linux/kmsg_dump.h
+++ b/include/linux/kmsg_dump.h
@@ -29,6 +29,18 @@ enum kmsg_dump_reason {
 	KMSG_DUMP_MAX
 };
 
+/**
+ * struct kmsg_dumper_iter - iterator for kernel crash message dumper
+ * @active:	Flag that specifies if this is currently dumping
+ * @cur_seq:	Points to the oldest message to dump (private)
+ * @next_seq:	Points after the newest message to dump (private)
+ */
+struct kmsg_dumper_iter {
+	bool	active;
+	u64	cur_seq;
+	u64	next_seq;
+};
+
 /**
  * struct kmsg_dumper - kernel crash message dumper structure
  * @list:	Entry in the dumper list (private)
@@ -39,33 +51,22 @@ enum kmsg_dump_reason {
  */
 struct kmsg_dumper {
 	struct list_head list;
-	void (*dump)(struct kmsg_dumper *dumper, enum kmsg_dump_reason reason);
+	void (*dump)(struct kmsg_dumper *dumper, enum kmsg_dump_reason reason,
+		     struct kmsg_dumper_iter *iter);
 	enum kmsg_dump_reason max_reason;
-	bool active;
 	bool registered;
-
-	/* private state of the kmsg iterator */
-	u32 cur_idx;
-	u32 next_idx;
-	u64 cur_seq;
-	u64 next_seq;
 };
 
 #ifdef CONFIG_PRINTK
 void kmsg_dump(enum kmsg_dump_reason reason);
 
-bool kmsg_dump_get_line_nolock(struct kmsg_dumper *dumper, bool syslog,
-			       char *line, size_t size, size_t *len);
-
-bool kmsg_dump_get_line(struct kmsg_dumper *dumper, bool syslog,
+bool kmsg_dump_get_line(struct kmsg_dumper_iter *iter, bool syslog,
 			char *line, size_t size, size_t *len);
 
-bool kmsg_dump_get_buffer(struct kmsg_dumper *dumper, bool syslog,
-			  char *buf, size_t size, size_t *len);
-
-void kmsg_dump_rewind_nolock(struct kmsg_dumper *dumper);
+bool kmsg_dump_get_buffer(struct kmsg_dumper_iter *iter, bool syslog,
+			  char *buf, size_t size, size_t *len_out);
 
-void kmsg_dump_rewind(struct kmsg_dumper *dumper);
+void kmsg_dump_rewind(struct kmsg_dumper_iter *iter);
 
 int kmsg_dump_register(struct kmsg_dumper *dumper);
 
@@ -77,30 +78,19 @@ static inline void kmsg_dump(enum kmsg_dump_reason reason)
 {
 }
 
-static inline bool kmsg_dump_get_line_nolock(struct kmsg_dumper *dumper,
-					     bool syslog, const char *line,
-					     size_t size, size_t *len)
-{
-	return false;
-}
-
-static inline bool kmsg_dump_get_line(struct kmsg_dumper *dumper, bool syslog,
+static inline bool kmsg_dump_get_line(struct kmsg_dumper_iter *iter, bool syslog,
 				const char *line, size_t size, size_t *len)
 {
 	return false;
 }
 
-static inline bool kmsg_dump_get_buffer(struct kmsg_dumper *dumper, bool syslog,
+static inline bool kmsg_dump_get_buffer(struct kmsg_dumper_iter *iter, bool syslog,
 					char *buf, size_t size, size_t *len)
 {
 	return false;
 }
 
-static inline void kmsg_dump_rewind_nolock(struct kmsg_dumper *dumper)
-{
-}
-
-static inline void kmsg_dump_rewind(struct kmsg_dumper *dumper)
+static inline void kmsg_dump_rewind(struct kmsg_dumper_iter *iter)
 {
 }
 
diff --git a/include/linux/local_lock_internal.h b/include/linux/local_lock_internal.h
index 3f02b818625e..1b8ae034946f 100644
--- a/include/linux/local_lock_internal.h
+++ b/include/linux/local_lock_internal.h
@@ -7,13 +7,39 @@
 #include <linux/lockdep.h>
 
 typedef struct {
-#ifdef CONFIG_DEBUG_LOCK_ALLOC
+#ifdef CONFIG_PREEMPT_RT
+	spinlock_t              lock;
+	struct task_struct      *owner;
+	int                     nestcnt;
+
+#elif defined(CONFIG_DEBUG_LOCK_ALLOC)
 	struct lockdep_map	dep_map;
 	struct task_struct	*owner;
 #endif
 } local_lock_t;
 
-#ifdef CONFIG_DEBUG_LOCK_ALLOC
+#ifdef CONFIG_PREEMPT_RT
+
+#define INIT_LOCAL_LOCK(lockname)	{	\
+	__SPIN_LOCK_UNLOCKED((lockname).lock),	\
+	.owner		= NULL,			\
+	.nestcnt	= 0,			\
+	}
+
+static inline void ___local_lock_init(local_lock_t *l)
+{
+	l->owner = NULL;
+	l->nestcnt = 0;
+}
+
+#define __local_lock_init(l)					\
+do {								\
+	spin_lock_init(&(l)->lock);				\
+	___local_lock_init(l);					\
+} while (0)
+
+#elif defined(CONFIG_DEBUG_LOCK_ALLOC)
+
 # define LOCAL_LOCK_DEBUG_INIT(lockname)		\
 	.dep_map = {					\
 		.name = #lockname,			\
@@ -21,7 +47,33 @@ typedef struct {
 		.lock_type = LD_LOCK_PERCPU,		\
 	},						\
 	.owner = NULL,
+#endif
+
+#ifdef CONFIG_PREEMPT_RT
 
+static inline void local_lock_acquire(local_lock_t *l)
+{
+	if (l->owner != current) {
+		spin_lock(&l->lock);
+		DEBUG_LOCKS_WARN_ON(l->owner);
+		DEBUG_LOCKS_WARN_ON(l->nestcnt);
+		l->owner = current;
+	}
+	l->nestcnt++;
+}
+
+static inline void local_lock_release(local_lock_t *l)
+{
+	DEBUG_LOCKS_WARN_ON(l->nestcnt == 0);
+	DEBUG_LOCKS_WARN_ON(l->owner != current);
+	if (--l->nestcnt)
+		return;
+
+	l->owner = NULL;
+	spin_unlock(&l->lock);
+}
+
+#elif defined(CONFIG_DEBUG_LOCK_ALLOC)
 static inline void local_lock_acquire(local_lock_t *l)
 {
 	lock_map_acquire(&l->dep_map);
@@ -47,6 +99,47 @@ static inline void local_lock_release(local_lock_t *l) { }
 static inline void local_lock_debug_init(local_lock_t *l) { }
 #endif /* !CONFIG_DEBUG_LOCK_ALLOC */
 
+#ifdef CONFIG_PREEMPT_RT
+
+#define __local_lock(lock)					\
+	do {							\
+		migrate_disable();				\
+		local_lock_acquire(this_cpu_ptr(lock));		\
+	} while (0)
+
+#define __local_unlock(lock)					\
+	do {							\
+		local_lock_release(this_cpu_ptr(lock));		\
+		migrate_enable();				\
+	} while (0)
+
+#define __local_lock_irq(lock)					\
+	do {							\
+		migrate_disable();				\
+		local_lock_acquire(this_cpu_ptr(lock));		\
+	} while (0)
+
+#define __local_lock_irqsave(lock, flags)			\
+	do {							\
+		migrate_disable();				\
+		flags = 0;					\
+		local_lock_acquire(this_cpu_ptr(lock));		\
+	} while (0)
+
+#define __local_unlock_irq(lock)				\
+	do {							\
+		local_lock_release(this_cpu_ptr(lock));		\
+		migrate_enable();				\
+	} while (0)
+
+#define __local_unlock_irqrestore(lock, flags)			\
+	do {							\
+		local_lock_release(this_cpu_ptr(lock));		\
+		migrate_enable();				\
+	} while (0)
+
+#else
+
 #define INIT_LOCAL_LOCK(lockname)	{ LOCAL_LOCK_DEBUG_INIT(lockname) }
 
 #define __local_lock_init(lock)					\
@@ -66,6 +159,12 @@ do {								\
 		local_lock_acquire(this_cpu_ptr(lock));		\
 	} while (0)
 
+#define __local_unlock(lock)					\
+	do {							\
+		local_lock_release(this_cpu_ptr(lock));		\
+		preempt_enable();				\
+	} while (0)
+
 #define __local_lock_irq(lock)					\
 	do {							\
 		local_irq_disable();				\
@@ -78,12 +177,6 @@ do {								\
 		local_lock_acquire(this_cpu_ptr(lock));		\
 	} while (0)
 
-#define __local_unlock(lock)					\
-	do {							\
-		local_lock_release(this_cpu_ptr(lock));		\
-		preempt_enable();				\
-	} while (0)
-
 #define __local_unlock_irq(lock)				\
 	do {							\
 		local_lock_release(this_cpu_ptr(lock));		\
@@ -95,3 +188,5 @@ do {								\
 		local_lock_release(this_cpu_ptr(lock));		\
 		local_irq_restore(flags);			\
 	} while (0)
+
+#endif
diff --git a/include/linux/mm_types.h b/include/linux/mm_types.h
index 99ae1f9a9019..11929a9d7d3d 100644
--- a/include/linux/mm_types.h
+++ b/include/linux/mm_types.h
@@ -13,6 +13,7 @@
 #include <linux/completion.h>
 #include <linux/cpumask.h>
 #include <linux/uprobes.h>
+#include <linux/rcupdate.h>
 #include <linux/page-flags-layout.h>
 #include <linux/workqueue.h>
 #include <linux/seqlock.h>
@@ -603,6 +604,9 @@ struct mm_struct {
 		bool tlb_flush_batched;
 #endif
 		struct uprobes_state uprobes_state;
+#ifdef CONFIG_PREEMPT_RT
+		struct rcu_head delayed_drop;
+#endif
 #ifdef CONFIG_HUGETLB_PAGE
 		atomic_long_t hugetlb_usage;
 #endif
diff --git a/include/linux/mutex.h b/include/linux/mutex.h
index 4d671fba3cab..90923d3008fc 100644
--- a/include/linux/mutex.h
+++ b/include/linux/mutex.h
@@ -22,6 +22,20 @@
 
 struct ww_acquire_ctx;
 
+#ifdef CONFIG_DEBUG_LOCK_ALLOC
+# define __DEP_MAP_MUTEX_INITIALIZER(lockname)			\
+		, .dep_map = {					\
+			.name = #lockname,			\
+			.wait_type_inner = LD_WAIT_SLEEP,	\
+		}
+#else
+# define __DEP_MAP_MUTEX_INITIALIZER(lockname)
+#endif
+
+#ifdef CONFIG_PREEMPT_RT
+# include <linux/mutex_rt.h>
+#else
+
 /*
  * Simple, straightforward mutexes with strict semantics:
  *
@@ -68,14 +82,6 @@ struct mutex {
 struct ww_class;
 struct ww_acquire_ctx;
 
-struct ww_mutex {
-	struct mutex base;
-	struct ww_acquire_ctx *ctx;
-#ifdef CONFIG_DEBUG_MUTEXES
-	struct ww_class *ww_class;
-#endif
-};
-
 /*
  * This is the control structure for tasks blocked on mutex,
  * which resides on the blocked task's kernel stack:
@@ -119,16 +125,6 @@ do {									\
 	__mutex_init((mutex), #mutex, &__key);				\
 } while (0)
 
-#ifdef CONFIG_DEBUG_LOCK_ALLOC
-# define __DEP_MAP_MUTEX_INITIALIZER(lockname)			\
-		, .dep_map = {					\
-			.name = #lockname,			\
-			.wait_type_inner = LD_WAIT_SLEEP,	\
-		}
-#else
-# define __DEP_MAP_MUTEX_INITIALIZER(lockname)
-#endif
-
 #define __MUTEX_INITIALIZER(lockname) \
 		{ .owner = ATOMIC_LONG_INIT(0) \
 		, .wait_lock = __SPIN_LOCK_UNLOCKED(lockname.wait_lock) \
@@ -224,4 +220,6 @@ enum mutex_trylock_recursive_enum {
 extern /* __deprecated */ __must_check enum mutex_trylock_recursive_enum
 mutex_trylock_recursive(struct mutex *lock);
 
+#endif /* !PREEMPT_RT */
+
 #endif /* __LINUX_MUTEX_H */
diff --git a/include/linux/mutex_rt.h b/include/linux/mutex_rt.h
new file mode 100644
index 000000000000..f0b2e07cd5c5
--- /dev/null
+++ b/include/linux/mutex_rt.h
@@ -0,0 +1,130 @@
+// SPDX-License-Identifier: GPL-2.0-only
+#ifndef __LINUX_MUTEX_RT_H
+#define __LINUX_MUTEX_RT_H
+
+#ifndef __LINUX_MUTEX_H
+#error "Please include mutex.h"
+#endif
+
+#include <linux/rtmutex.h>
+
+/* FIXME: Just for __lockfunc */
+#include <linux/spinlock.h>
+
+struct mutex {
+	struct rt_mutex		lock;
+#ifdef CONFIG_DEBUG_LOCK_ALLOC
+	struct lockdep_map	dep_map;
+#endif
+};
+
+#define __MUTEX_INITIALIZER(mutexname)					\
+	{								\
+		.lock = __RT_MUTEX_INITIALIZER(mutexname.lock)		\
+		__DEP_MAP_MUTEX_INITIALIZER(mutexname)			\
+	}
+
+#define DEFINE_MUTEX(mutexname)						\
+	struct mutex mutexname = __MUTEX_INITIALIZER(mutexname)
+
+extern void __mutex_do_init(struct mutex *lock, const char *name, struct lock_class_key *key);
+extern void __lockfunc _mutex_lock(struct mutex *lock);
+extern void __lockfunc _mutex_lock_io_nested(struct mutex *lock, int subclass);
+extern int __lockfunc _mutex_lock_interruptible(struct mutex *lock);
+extern int __lockfunc _mutex_lock_killable(struct mutex *lock);
+extern void __lockfunc _mutex_lock_nested(struct mutex *lock, int subclass);
+extern void __lockfunc _mutex_lock_nest_lock(struct mutex *lock, struct lockdep_map *nest_lock);
+extern int __lockfunc _mutex_lock_interruptible_nested(struct mutex *lock, int subclass);
+extern int __lockfunc _mutex_lock_killable_nested(struct mutex *lock, int subclass);
+extern int __lockfunc _mutex_trylock(struct mutex *lock);
+extern void __lockfunc _mutex_unlock(struct mutex *lock);
+
+#define mutex_is_locked(l)		rt_mutex_is_locked(&(l)->lock)
+#define mutex_lock(l)			_mutex_lock(l)
+#define mutex_lock_interruptible(l)	_mutex_lock_interruptible(l)
+#define mutex_lock_killable(l)		_mutex_lock_killable(l)
+#define mutex_trylock(l)		_mutex_trylock(l)
+#define mutex_unlock(l)			_mutex_unlock(l)
+#define mutex_lock_io(l)		_mutex_lock_io_nested(l, 0);
+
+#define __mutex_owner(l)		((l)->lock.owner)
+
+#ifdef CONFIG_DEBUG_MUTEXES
+#define mutex_destroy(l)		rt_mutex_destroy(&(l)->lock)
+#else
+static inline void mutex_destroy(struct mutex *lock) {}
+#endif
+
+#ifdef CONFIG_DEBUG_LOCK_ALLOC
+# define mutex_lock_nested(l, s)	_mutex_lock_nested(l, s)
+# define mutex_lock_interruptible_nested(l, s) \
+					_mutex_lock_interruptible_nested(l, s)
+# define mutex_lock_killable_nested(l, s) \
+					_mutex_lock_killable_nested(l, s)
+# define mutex_lock_io_nested(l, s)	_mutex_lock_io_nested(l, s)
+
+# define mutex_lock_nest_lock(lock, nest_lock)				\
+do {									\
+	typecheck(struct lockdep_map *, &(nest_lock)->dep_map);		\
+	_mutex_lock_nest_lock(lock, &(nest_lock)->dep_map);		\
+} while (0)
+
+#else
+# define mutex_lock_nested(l, s)	_mutex_lock(l)
+# define mutex_lock_interruptible_nested(l, s) \
+					_mutex_lock_interruptible(l)
+# define mutex_lock_killable_nested(l, s) \
+					_mutex_lock_killable(l)
+# define mutex_lock_nest_lock(lock, nest_lock) mutex_lock(lock)
+# define mutex_lock_io_nested(l, s)	_mutex_lock_io_nested(l, s)
+#endif
+
+# define mutex_init(mutex)				\
+do {							\
+	static struct lock_class_key __key;		\
+							\
+	rt_mutex_init(&(mutex)->lock);			\
+	__mutex_do_init((mutex), #mutex, &__key);	\
+} while (0)
+
+# define __mutex_init(mutex, name, key)			\
+do {							\
+	rt_mutex_init(&(mutex)->lock);			\
+	__mutex_do_init((mutex), name, key);		\
+} while (0)
+
+/**
+ * These values are chosen such that FAIL and SUCCESS match the
+ * values of the regular mutex_trylock().
+ */
+enum mutex_trylock_recursive_enum {
+	MUTEX_TRYLOCK_FAILED    = 0,
+	MUTEX_TRYLOCK_SUCCESS   = 1,
+	MUTEX_TRYLOCK_RECURSIVE,
+};
+/**
+ * mutex_trylock_recursive - trylock variant that allows recursive locking
+ * @lock: mutex to be locked
+ *
+ * This function should not be used, _ever_. It is purely for hysterical GEM
+ * raisins, and once those are gone this will be removed.
+ *
+ * Returns:
+ *  MUTEX_TRYLOCK_FAILED    - trylock failed,
+ *  MUTEX_TRYLOCK_SUCCESS   - lock acquired,
+ *  MUTEX_TRYLOCK_RECURSIVE - we already owned the lock.
+ */
+int __rt_mutex_owner_current(struct rt_mutex *lock);
+
+static inline /* __deprecated */ __must_check enum mutex_trylock_recursive_enum
+mutex_trylock_recursive(struct mutex *lock)
+{
+	if (unlikely(__rt_mutex_owner_current(&lock->lock)))
+		return MUTEX_TRYLOCK_RECURSIVE;
+
+	return mutex_trylock(lock);
+}
+
+extern int atomic_dec_and_mutex_lock(atomic_t *cnt, struct mutex *lock);
+
+#endif
diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index 5491ad5f48a9..cd9e5b3f1831 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -1675,7 +1675,7 @@ struct nfs_unlinkdata {
 	struct nfs_removeargs args;
 	struct nfs_removeres res;
 	struct dentry *dentry;
-	wait_queue_head_t wq;
+	struct swait_queue_head wq;
 	const struct cred *cred;
 	struct nfs_fattr dir_attr;
 	long timeout;
diff --git a/include/linux/notifier.h b/include/linux/notifier.h
index 2fb373a5c1ed..723bc2df6388 100644
--- a/include/linux/notifier.h
+++ b/include/linux/notifier.h
@@ -58,7 +58,7 @@ struct notifier_block {
 };
 
 struct atomic_notifier_head {
-	spinlock_t lock;
+	raw_spinlock_t lock;
 	struct notifier_block __rcu *head;
 };
 
@@ -78,7 +78,7 @@ struct srcu_notifier_head {
 };
 
 #define ATOMIC_INIT_NOTIFIER_HEAD(name) do {	\
-		spin_lock_init(&(name)->lock);	\
+		raw_spin_lock_init(&(name)->lock);	\
 		(name)->head = NULL;		\
 	} while (0)
 #define BLOCKING_INIT_NOTIFIER_HEAD(name) do {	\
@@ -95,7 +95,7 @@ extern void srcu_init_notifier_head(struct srcu_notifier_head *nh);
 		cleanup_srcu_struct(&(name)->srcu);
 
 #define ATOMIC_NOTIFIER_INIT(name) {				\
-		.lock = __SPIN_LOCK_UNLOCKED(name.lock),	\
+		.lock = __RAW_SPIN_LOCK_UNLOCKED(name.lock),	\
 		.head = NULL }
 #define BLOCKING_NOTIFIER_INIT(name) {				\
 		.rwsem = __RWSEM_INITIALIZER((name).rwsem),	\
diff --git a/include/linux/pid.h b/include/linux/pid.h
index 34afff2dc888..514dd026c6b8 100644
--- a/include/linux/pid.h
+++ b/include/linux/pid.h
@@ -3,6 +3,7 @@
 #define _LINUX_PID_H
 
 #include <linux/rculist.h>
+#include <linux/atomic.h>
 #include <linux/wait.h>
 #include <linux/refcount.h>
 
diff --git a/include/linux/preempt.h b/include/linux/preempt.h
index 7d9c1c0e149c..7b5b2ed55531 100644
--- a/include/linux/preempt.h
+++ b/include/linux/preempt.h
@@ -77,31 +77,37 @@
 /* preempt_count() and related functions, depends on PREEMPT_NEED_RESCHED */
 #include <asm/preempt.h>
 
+#define nmi_count()	(preempt_count() & NMI_MASK)
 #define hardirq_count()	(preempt_count() & HARDIRQ_MASK)
-#define softirq_count()	(preempt_count() & SOFTIRQ_MASK)
-#define irq_count()	(preempt_count() & (HARDIRQ_MASK | SOFTIRQ_MASK \
-				 | NMI_MASK))
+#ifdef CONFIG_PREEMPT_RT
+# define softirq_count()	(current->softirq_disable_cnt & SOFTIRQ_MASK)
+#else
+# define softirq_count()	(preempt_count() & SOFTIRQ_MASK)
+#endif
+#define irq_count()	(nmi_count() | hardirq_count() | softirq_count())
 
 /*
- * Are we doing bottom half or hardware interrupt processing?
+ * Macros to retrieve the current execution context:
  *
- * in_irq()       - We're in (hard) IRQ context
+ * in_nmi()		- We're in NMI context
+ * in_hardirq()		- We're in hard IRQ context
+ * in_serving_softirq()	- We're in softirq context
+ * in_task()		- We're in task context
+ */
+#define in_nmi()		(nmi_count())
+#define in_hardirq()		(hardirq_count())
+#define in_serving_softirq()	(softirq_count() & SOFTIRQ_OFFSET)
+#define in_task()		(!(in_nmi() | in_hardirq() | in_serving_softirq()))
+
+/*
+ * The following macros are deprecated and should not be used in new code:
+ * in_irq()       - Obsolete version of in_hardirq()
  * in_softirq()   - We have BH disabled, or are processing softirqs
  * in_interrupt() - We're in NMI,IRQ,SoftIRQ context or have BH disabled
- * in_serving_softirq() - We're in softirq context
- * in_nmi()       - We're in NMI context
- * in_task()	  - We're in task context
- *
- * Note: due to the BH disabled confusion: in_softirq(),in_interrupt() really
- *       should not be used in new code.
  */
 #define in_irq()		(hardirq_count())
 #define in_softirq()		(softirq_count())
 #define in_interrupt()		(irq_count())
-#define in_serving_softirq()	(softirq_count() & SOFTIRQ_OFFSET)
-#define in_nmi()		(preempt_count() & NMI_MASK)
-#define in_task()		(!(preempt_count() & \
-				   (NMI_MASK | HARDIRQ_MASK | SOFTIRQ_OFFSET)))
 
 /*
  * The preempt_count offset after preempt_disable();
@@ -115,7 +121,11 @@
 /*
  * The preempt_count offset after spin_lock()
  */
+#if !defined(CONFIG_PREEMPT_RT)
 #define PREEMPT_LOCK_OFFSET	PREEMPT_DISABLE_OFFSET
+#else
+#define PREEMPT_LOCK_OFFSET	0
+#endif
 
 /*
  * The preempt_count offset needed for things like:
@@ -164,6 +174,20 @@ extern void preempt_count_sub(int val);
 #define preempt_count_inc() preempt_count_add(1)
 #define preempt_count_dec() preempt_count_sub(1)
 
+#ifdef CONFIG_PREEMPT_LAZY
+#define add_preempt_lazy_count(val)	do { preempt_lazy_count() += (val); } while (0)
+#define sub_preempt_lazy_count(val)	do { preempt_lazy_count() -= (val); } while (0)
+#define inc_preempt_lazy_count()	add_preempt_lazy_count(1)
+#define dec_preempt_lazy_count()	sub_preempt_lazy_count(1)
+#define preempt_lazy_count()		(current_thread_info()->preempt_lazy_count)
+#else
+#define add_preempt_lazy_count(val)	do { } while (0)
+#define sub_preempt_lazy_count(val)	do { } while (0)
+#define inc_preempt_lazy_count()	do { } while (0)
+#define dec_preempt_lazy_count()	do { } while (0)
+#define preempt_lazy_count()		(0)
+#endif
+
 #ifdef CONFIG_PREEMPT_COUNT
 
 #define preempt_disable() \
@@ -172,13 +196,25 @@ do { \
 	barrier(); \
 } while (0)
 
+#define preempt_lazy_disable() \
+do { \
+	inc_preempt_lazy_count(); \
+	barrier(); \
+} while (0)
+
 #define sched_preempt_enable_no_resched() \
 do { \
 	barrier(); \
 	preempt_count_dec(); \
 } while (0)
 
-#define preempt_enable_no_resched() sched_preempt_enable_no_resched()
+#ifndef CONFIG_PREEMPT_RT
+# define preempt_enable_no_resched() sched_preempt_enable_no_resched()
+# define preempt_check_resched_rt() barrier();
+#else
+# define preempt_enable_no_resched() preempt_enable()
+# define preempt_check_resched_rt() preempt_check_resched()
+#endif
 
 #define preemptible()	(preempt_count() == 0 && !irqs_disabled())
 
@@ -203,6 +239,18 @@ do { \
 		__preempt_schedule(); \
 } while (0)
 
+/*
+ * open code preempt_check_resched() because it is not exported to modules and
+ * used by local_unlock() or bpf_enable_instrumentation().
+ */
+#define preempt_lazy_enable() \
+do { \
+	dec_preempt_lazy_count(); \
+	barrier(); \
+	if (should_resched(0)) \
+		__preempt_schedule(); \
+} while (0)
+
 #else /* !CONFIG_PREEMPTION */
 #define preempt_enable() \
 do { \
@@ -210,6 +258,12 @@ do { \
 	preempt_count_dec(); \
 } while (0)
 
+#define preempt_lazy_enable() \
+do { \
+	dec_preempt_lazy_count(); \
+	barrier(); \
+} while (0)
+
 #define preempt_enable_notrace() \
 do { \
 	barrier(); \
@@ -248,8 +302,12 @@ do { \
 #define preempt_disable_notrace()		barrier()
 #define preempt_enable_no_resched_notrace()	barrier()
 #define preempt_enable_notrace()		barrier()
+#define preempt_check_resched_rt()		barrier()
 #define preemptible()				0
 
+#define preempt_lazy_disable()			barrier()
+#define preempt_lazy_enable()			barrier()
+
 #endif /* CONFIG_PREEMPT_COUNT */
 
 #ifdef MODULE
@@ -268,10 +326,22 @@ do { \
 } while (0)
 #define preempt_fold_need_resched() \
 do { \
-	if (tif_need_resched()) \
+	if (tif_need_resched_now()) \
 		set_preempt_need_resched(); \
 } while (0)
 
+#ifdef CONFIG_PREEMPT_RT
+# define preempt_disable_rt()		preempt_disable()
+# define preempt_enable_rt()		preempt_enable()
+# define preempt_disable_nort()		barrier()
+# define preempt_enable_nort()		barrier()
+#else
+# define preempt_disable_rt()		barrier()
+# define preempt_enable_rt()		barrier()
+# define preempt_disable_nort()		preempt_disable()
+# define preempt_enable_nort()		preempt_enable()
+#endif
+
 #ifdef CONFIG_PREEMPT_NOTIFIERS
 
 struct preempt_notifier;
@@ -322,34 +392,78 @@ static inline void preempt_notifier_init(struct preempt_notifier *notifier,
 
 #endif
 
-/**
- * migrate_disable - Prevent migration of the current task
+#ifdef CONFIG_SMP
+
+/*
+ * Migrate-Disable and why it is undesired.
  *
- * Maps to preempt_disable() which also disables preemption. Use
- * migrate_disable() to annotate that the intent is to prevent migration,
- * but not necessarily preemption.
+ * When a preempted task becomes elegible to run under the ideal model (IOW it
+ * becomes one of the M highest priority tasks), it might still have to wait
+ * for the preemptee's migrate_disable() section to complete. Thereby suffering
+ * a reduction in bandwidth in the exact duration of the migrate_disable()
+ * section.
  *
- * Can be invoked nested like preempt_disable() and needs the corresponding
- * number of migrate_enable() invocations.
- */
-static __always_inline void migrate_disable(void)
-{
-	preempt_disable();
-}
-
-/**
- * migrate_enable - Allow migration of the current task
+ * Per this argument, the change from preempt_disable() to migrate_disable()
+ * gets us:
+ *
+ * - a higher priority tasks gains reduced wake-up latency; with preempt_disable()
+ *   it would have had to wait for the lower priority task.
+ *
+ * - a lower priority tasks; which under preempt_disable() could've instantly
+ *   migrated away when another CPU becomes available, is now constrained
+ *   by the ability to push the higher priority task away, which might itself be
+ *   in a migrate_disable() section, reducing it's available bandwidth.
+ *
+ * IOW it trades latency / moves the interference term, but it stays in the
+ * system, and as long as it remains unbounded, the system is not fully
+ * deterministic.
  *
- * Counterpart to migrate_disable().
  *
- * As migrate_disable() can be invoked nested, only the outermost invocation
- * reenables migration.
+ * The reason we have it anyway.
+ *
+ * PREEMPT_RT breaks a number of assumptions traditionally held. By forcing a
+ * number of primitives into becoming preemptible, they would also allow
+ * migration. This turns out to break a bunch of per-cpu usage. To this end,
+ * all these primitives employ migirate_disable() to restore this implicit
+ * assumption.
+ *
+ * This is a 'temporary' work-around at best. The correct solution is getting
+ * rid of the above assumptions and reworking the code to employ explicit
+ * per-cpu locking or short preempt-disable regions.
+ *
+ * The end goal must be to get rid of migrate_disable(), alternatively we need
+ * a schedulability theory that does not depend on abritrary migration.
+ *
+ *
+ * Notes on the implementation.
+ *
+ * The implementation is particularly tricky since existing code patterns
+ * dictate neither migrate_disable() nor migrate_enable() is allowed to block.
+ * This means that it cannot use cpus_read_lock() to serialize against hotplug,
+ * nor can it easily migrate itself into a pending affinity mask change on
+ * migrate_enable().
+ *
+ *
+ * Note: even non-work-conserving schedulers like semi-partitioned depends on
+ *       migration, so migrate_disable() is not only a problem for
+ *       work-conserving schedulers.
  *
- * Currently mapped to preempt_enable().
  */
-static __always_inline void migrate_enable(void)
+extern void migrate_disable(void);
+extern void migrate_enable(void);
+
+#else
+
+static inline void migrate_disable(void)
 {
-	preempt_enable();
+	preempt_lazy_disable();
 }
 
+static inline void migrate_enable(void)
+{
+	preempt_lazy_enable();
+}
+
+#endif /* CONFIG_SMP */
+
 #endif /* __LINUX_PREEMPT_H */
diff --git a/include/linux/printk.h b/include/linux/printk.h
index 7d787f91db92..9331b131ba25 100644
--- a/include/linux/printk.h
+++ b/include/linux/printk.h
@@ -46,6 +46,12 @@ static inline const char *printk_skip_headers(const char *buffer)
 
 #define CONSOLE_EXT_LOG_MAX	8192
 
+/*
+ * The maximum size of a record formatted for console printing
+ * (i.e. with the prefix prepended to every line).
+ */
+#define CONSOLE_LOG_MAX		4096
+
 /* printk's without a loglevel use this.. */
 #define MESSAGE_LOGLEVEL_DEFAULT CONFIG_MESSAGE_LOGLEVEL_DEFAULT
 
@@ -149,18 +155,6 @@ static inline __printf(1, 2) __cold
 void early_printk(const char *s, ...) { }
 #endif
 
-#ifdef CONFIG_PRINTK_NMI
-extern void printk_nmi_enter(void);
-extern void printk_nmi_exit(void);
-extern void printk_nmi_direct_enter(void);
-extern void printk_nmi_direct_exit(void);
-#else
-static inline void printk_nmi_enter(void) { }
-static inline void printk_nmi_exit(void) { }
-static inline void printk_nmi_direct_enter(void) { }
-static inline void printk_nmi_direct_exit(void) { }
-#endif /* PRINTK_NMI */
-
 #ifdef CONFIG_PRINTK
 extern void printk_safe_enter(void);
 extern void printk_safe_exit(void);
@@ -247,8 +241,6 @@ __printf(1, 2) void dump_stack_set_arch_desc(const char *fmt, ...);
 void dump_stack_print_info(const char *log_lvl);
 void show_regs_print_info(const char *log_lvl);
 extern asmlinkage void dump_stack(void) __cold;
-extern void printk_safe_flush(void);
-extern void printk_safe_flush_on_panic(void);
 #if defined(CONFIG_X86) || defined(CONFIG_ARM64_PSEUDO_NMI)
 extern void zap_locks(void);
 #else
@@ -318,14 +310,6 @@ static inline void dump_stack(void)
 {
 }
 
-static inline void printk_safe_flush(void)
-{
-}
-
-static inline void printk_safe_flush_on_panic(void)
-{
-}
-
 static inline void zap_locks(void)
 {
 }
@@ -546,6 +530,8 @@ extern int kptr_restrict;
 	no_printk(KERN_DEBUG pr_fmt(fmt), ##__VA_ARGS__)
 #endif
 
+bool pr_flush(int timeout_ms, bool reset_on_progress);
+
 /*
  * ratelimited messages with local ratelimit_state,
  * no local ratelimit_state used in the !PRINTK case
diff --git a/include/linux/rbtree.h b/include/linux/rbtree.h
index d31ecaf4fdd3..e711efc2e009 100644
--- a/include/linux/rbtree.h
+++ b/include/linux/rbtree.h
@@ -19,19 +19,9 @@
 
 #include <linux/kernel.h>
 #include <linux/stddef.h>
+#include <linux/rbtree_type.h>
 #include <linux/rcupdate.h>
 
-struct rb_node {
-	unsigned long  __rb_parent_color;
-	struct rb_node *rb_right;
-	struct rb_node *rb_left;
-} __attribute__((aligned(sizeof(long))));
-    /* The alignment might seem pointless, but allegedly CRIS needs it */
-
-struct rb_root {
-	struct rb_node *rb_node;
-};
-
 #define rb_parent(r)   ((struct rb_node *)((r)->__rb_parent_color & ~3))
 
 #define RB_ROOT	(struct rb_root) { NULL, }
@@ -112,21 +102,6 @@ static inline void rb_link_node_rcu(struct rb_node *node, struct rb_node *parent
 			typeof(*pos), field); 1; }); \
 	     pos = n)
 
-/*
- * Leftmost-cached rbtrees.
- *
- * We do not cache the rightmost node based on footprint
- * size vs number of potential users that could benefit
- * from O(1) rb_last(). Just not worth it, users that want
- * this feature can always implement the logic explicitly.
- * Furthermore, users that want to cache both pointers may
- * find it a bit asymmetric, but that's ok.
- */
-struct rb_root_cached {
-	struct rb_root rb_root;
-	struct rb_node *rb_leftmost;
-};
-
 #define RB_ROOT_CACHED (struct rb_root_cached) { {NULL, }, NULL }
 
 /* Same as rb_first(), but O(1) */
diff --git a/include/linux/rbtree_type.h b/include/linux/rbtree_type.h
new file mode 100644
index 000000000000..77a89dd2c7c6
--- /dev/null
+++ b/include/linux/rbtree_type.h
@@ -0,0 +1,31 @@
+/* SPDX-License-Identifier: GPL-2.0-or-later */
+#ifndef _LINUX_RBTREE_TYPE_H
+#define _LINUX_RBTREE_TYPE_H
+
+struct rb_node {
+	unsigned long  __rb_parent_color;
+	struct rb_node *rb_right;
+	struct rb_node *rb_left;
+} __attribute__((aligned(sizeof(long))));
+/* The alignment might seem pointless, but allegedly CRIS needs it */
+
+struct rb_root {
+	struct rb_node *rb_node;
+};
+
+/*
+ * Leftmost-cached rbtrees.
+ *
+ * We do not cache the rightmost node based on footprint
+ * size vs number of potential users that could benefit
+ * from O(1) rb_last(). Just not worth it, users that want
+ * this feature can always implement the logic explicitly.
+ * Furthermore, users that want to cache both pointers may
+ * find it a bit asymmetric, but that's ok.
+ */
+struct rb_root_cached {
+	struct rb_root rb_root;
+	struct rb_node *rb_leftmost;
+};
+
+#endif
diff --git a/include/linux/rcupdate.h b/include/linux/rcupdate.h
index 095b3b39bd03..1effcae06ea1 100644
--- a/include/linux/rcupdate.h
+++ b/include/linux/rcupdate.h
@@ -54,6 +54,11 @@ void __rcu_read_unlock(void);
  * types of kernel builds, the rcu_read_lock() nesting depth is unknowable.
  */
 #define rcu_preempt_depth() (current->rcu_read_lock_nesting)
+#ifndef CONFIG_PREEMPT_RT
+#define sched_rcu_preempt_depth()	rcu_preempt_depth()
+#else
+static inline int sched_rcu_preempt_depth(void) { return 0; }
+#endif
 
 #else /* #ifdef CONFIG_PREEMPT_RCU */
 
@@ -79,6 +84,8 @@ static inline int rcu_preempt_depth(void)
 	return 0;
 }
 
+#define sched_rcu_preempt_depth()	rcu_preempt_depth()
+
 #endif /* #else #ifdef CONFIG_PREEMPT_RCU */
 
 /* Internal to kernel */
@@ -329,7 +336,8 @@ static inline void rcu_preempt_sleep_check(void) { }
 #define rcu_sleep_check()						\
 	do {								\
 		rcu_preempt_sleep_check();				\
-		RCU_LOCKDEP_WARN(lock_is_held(&rcu_bh_lock_map),	\
+		if (!IS_ENABLED(CONFIG_PREEMPT_RT))			\
+		    RCU_LOCKDEP_WARN(lock_is_held(&rcu_bh_lock_map),	\
 				 "Illegal context switch in RCU-bh read-side critical section"); \
 		RCU_LOCKDEP_WARN(lock_is_held(&rcu_sched_lock_map),	\
 				 "Illegal context switch in RCU-sched read-side critical section"); \
diff --git a/include/linux/rtmutex.h b/include/linux/rtmutex.h
index 6fd615a0eea9..b02009f53026 100644
--- a/include/linux/rtmutex.h
+++ b/include/linux/rtmutex.h
@@ -14,11 +14,15 @@
 #define __LINUX_RT_MUTEX_H
 
 #include <linux/linkage.h>
-#include <linux/rbtree.h>
-#include <linux/spinlock_types.h>
+#include <linux/rbtree_type.h>
+#include <linux/spinlock_types_raw.h>
 
 extern int max_lock_depth; /* for sysctl */
 
+#ifdef CONFIG_DEBUG_MUTEXES
+#include <linux/debug_locks.h>
+#endif
+
 /**
  * The rt_mutex structure
  *
@@ -31,12 +35,7 @@ struct rt_mutex {
 	raw_spinlock_t		wait_lock;
 	struct rb_root_cached   waiters;
 	struct task_struct	*owner;
-#ifdef CONFIG_DEBUG_RT_MUTEXES
 	int			save_state;
-	const char		*name, *file;
-	int			line;
-	void			*magic;
-#endif
 #ifdef CONFIG_DEBUG_LOCK_ALLOC
 	struct lockdep_map	dep_map;
 #endif
@@ -49,6 +48,7 @@ struct hrtimer_sleeper;
  extern int rt_mutex_debug_check_no_locks_freed(const void *from,
 						unsigned long len);
  extern void rt_mutex_debug_check_no_locks_held(struct task_struct *task);
+ extern void rt_mutex_debug_task_free(struct task_struct *tsk);
 #else
  static inline int rt_mutex_debug_check_no_locks_freed(const void *from,
 						       unsigned long len)
@@ -56,25 +56,15 @@ struct hrtimer_sleeper;
 	return 0;
  }
 # define rt_mutex_debug_check_no_locks_held(task)	do { } while (0)
+# define rt_mutex_debug_task_free(t)			do { } while (0)
 #endif
 
-#ifdef CONFIG_DEBUG_RT_MUTEXES
-# define __DEBUG_RT_MUTEX_INITIALIZER(mutexname) \
-	, .name = #mutexname, .file = __FILE__, .line = __LINE__
-
-# define rt_mutex_init(mutex) \
+#define rt_mutex_init(mutex) \
 do { \
 	static struct lock_class_key __key; \
 	__rt_mutex_init(mutex, __func__, &__key); \
 } while (0)
 
- extern void rt_mutex_debug_task_free(struct task_struct *tsk);
-#else
-# define __DEBUG_RT_MUTEX_INITIALIZER(mutexname)
-# define rt_mutex_init(mutex)			__rt_mutex_init(mutex, NULL, NULL)
-# define rt_mutex_debug_task_free(t)			do { } while (0)
-#endif
-
 #ifdef CONFIG_DEBUG_LOCK_ALLOC
 #define __DEP_MAP_RT_MUTEX_INITIALIZER(mutexname) \
 	, .dep_map = { .name = #mutexname }
@@ -82,12 +72,19 @@ do { \
 #define __DEP_MAP_RT_MUTEX_INITIALIZER(mutexname)
 #endif
 
-#define __RT_MUTEX_INITIALIZER(mutexname) \
-	{ .wait_lock = __RAW_SPIN_LOCK_UNLOCKED(mutexname.wait_lock) \
+#define __RT_MUTEX_INITIALIZER_PLAIN(mutexname) \
+	  .wait_lock = __RAW_SPIN_LOCK_UNLOCKED(mutexname.wait_lock) \
 	, .waiters = RB_ROOT_CACHED \
 	, .owner = NULL \
-	__DEBUG_RT_MUTEX_INITIALIZER(mutexname) \
-	__DEP_MAP_RT_MUTEX_INITIALIZER(mutexname)}
+	__DEP_MAP_RT_MUTEX_INITIALIZER(mutexname)
+
+#define __RT_MUTEX_INITIALIZER(mutexname) \
+	{ __RT_MUTEX_INITIALIZER_PLAIN(mutexname) \
+	, .save_state = 0 }
+
+#define __RT_MUTEX_INITIALIZER_SAVE_STATE(mutexname) \
+	{ __RT_MUTEX_INITIALIZER_PLAIN(mutexname)    \
+	, .save_state = 1 }
 
 #define DEFINE_RT_MUTEX(mutexname) \
 	struct rt_mutex mutexname = __RT_MUTEX_INITIALIZER(mutexname)
@@ -115,9 +112,6 @@ extern void rt_mutex_lock(struct rt_mutex *lock);
 #endif
 
 extern int rt_mutex_lock_interruptible(struct rt_mutex *lock);
-extern int rt_mutex_timed_lock(struct rt_mutex *lock,
-			       struct hrtimer_sleeper *timeout);
-
 extern int rt_mutex_trylock(struct rt_mutex *lock);
 
 extern void rt_mutex_unlock(struct rt_mutex *lock);
diff --git a/include/linux/rwlock_rt.h b/include/linux/rwlock_rt.h
new file mode 100644
index 000000000000..aafdb0a685d5
--- /dev/null
+++ b/include/linux/rwlock_rt.h
@@ -0,0 +1,109 @@
+// SPDX-License-Identifier: GPL-2.0-only
+#ifndef __LINUX_RWLOCK_RT_H
+#define __LINUX_RWLOCK_RT_H
+
+#ifndef __LINUX_SPINLOCK_H
+#error Do not include directly. Use spinlock.h
+#endif
+
+extern void __lockfunc rt_write_lock(rwlock_t *rwlock);
+extern void __lockfunc rt_read_lock(rwlock_t *rwlock);
+extern int __lockfunc rt_write_trylock(rwlock_t *rwlock);
+extern int __lockfunc rt_read_trylock(rwlock_t *rwlock);
+extern void __lockfunc rt_write_unlock(rwlock_t *rwlock);
+extern void __lockfunc rt_read_unlock(rwlock_t *rwlock);
+extern int __lockfunc rt_read_can_lock(rwlock_t *rwlock);
+extern int __lockfunc rt_write_can_lock(rwlock_t *rwlock);
+extern void __rt_rwlock_init(rwlock_t *rwlock, char *name, struct lock_class_key *key);
+
+#define read_can_lock(rwlock)		rt_read_can_lock(rwlock)
+#define write_can_lock(rwlock)		rt_write_can_lock(rwlock)
+
+#define read_trylock(lock)	__cond_lock(lock, rt_read_trylock(lock))
+#define write_trylock(lock)	__cond_lock(lock, rt_write_trylock(lock))
+
+static inline int __write_trylock_rt_irqsave(rwlock_t *lock, unsigned long *flags)
+{
+	*flags = 0;
+	return rt_write_trylock(lock);
+}
+
+#define write_trylock_irqsave(lock, flags)		\
+	__cond_lock(lock, __write_trylock_rt_irqsave(lock, &(flags)))
+
+#define read_lock_irqsave(lock, flags)			\
+	do {						\
+		typecheck(unsigned long, flags);	\
+		rt_read_lock(lock);			\
+		flags = 0;				\
+	} while (0)
+
+#define write_lock_irqsave(lock, flags)			\
+	do {						\
+		typecheck(unsigned long, flags);	\
+		rt_write_lock(lock);			\
+		flags = 0;				\
+	} while (0)
+
+#define read_lock(lock)		rt_read_lock(lock)
+
+#define read_lock_bh(lock)				\
+	do {						\
+		local_bh_disable();			\
+		rt_read_lock(lock);			\
+	} while (0)
+
+#define read_lock_irq(lock)	read_lock(lock)
+
+#define write_lock(lock)	rt_write_lock(lock)
+
+#define write_lock_bh(lock)				\
+	do {						\
+		local_bh_disable();			\
+		rt_write_lock(lock);			\
+	} while (0)
+
+#define write_lock_irq(lock)	write_lock(lock)
+
+#define read_unlock(lock)	rt_read_unlock(lock)
+
+#define read_unlock_bh(lock)				\
+	do {						\
+		rt_read_unlock(lock);			\
+		local_bh_enable();			\
+	} while (0)
+
+#define read_unlock_irq(lock)	read_unlock(lock)
+
+#define write_unlock(lock)	rt_write_unlock(lock)
+
+#define write_unlock_bh(lock)				\
+	do {						\
+		rt_write_unlock(lock);			\
+		local_bh_enable();			\
+	} while (0)
+
+#define write_unlock_irq(lock)	write_unlock(lock)
+
+#define read_unlock_irqrestore(lock, flags)		\
+	do {						\
+		typecheck(unsigned long, flags);	\
+		(void) flags;				\
+		rt_read_unlock(lock);			\
+	} while (0)
+
+#define write_unlock_irqrestore(lock, flags) \
+	do {						\
+		typecheck(unsigned long, flags);	\
+		(void) flags;				\
+		rt_write_unlock(lock);			\
+	} while (0)
+
+#define rwlock_init(rwl)				\
+do {							\
+	static struct lock_class_key __key;		\
+							\
+	__rt_rwlock_init(rwl, #rwl, &__key);		\
+} while (0)
+
+#endif
diff --git a/include/linux/rwlock_types.h b/include/linux/rwlock_types.h
index 3bd03e18061c..0ad226b5d8fd 100644
--- a/include/linux/rwlock_types.h
+++ b/include/linux/rwlock_types.h
@@ -1,6 +1,10 @@
 #ifndef __LINUX_RWLOCK_TYPES_H
 #define __LINUX_RWLOCK_TYPES_H
 
+#if !defined(__LINUX_SPINLOCK_TYPES_H)
+# error "Do not include directly, include spinlock_types.h"
+#endif
+
 /*
  * include/linux/rwlock_types.h - generic rwlock type definitions
  *				  and initializers
diff --git a/include/linux/rwlock_types_rt.h b/include/linux/rwlock_types_rt.h
new file mode 100644
index 000000000000..4762391d659b
--- /dev/null
+++ b/include/linux/rwlock_types_rt.h
@@ -0,0 +1,56 @@
+// SPDX-License-Identifier: GPL-2.0-only
+#ifndef __LINUX_RWLOCK_TYPES_RT_H
+#define __LINUX_RWLOCK_TYPES_RT_H
+
+#ifndef __LINUX_SPINLOCK_TYPES_H
+#error "Do not include directly. Include spinlock_types.h instead"
+#endif
+
+#ifdef CONFIG_DEBUG_LOCK_ALLOC
+# define RW_DEP_MAP_INIT(lockname)	.dep_map = { .name = #lockname }
+#else
+# define RW_DEP_MAP_INIT(lockname)
+#endif
+
+typedef struct rt_rw_lock rwlock_t;
+
+#define __RW_LOCK_UNLOCKED(name) __RWLOCK_RT_INITIALIZER(name)
+
+#define DEFINE_RWLOCK(name) \
+	rwlock_t name = __RW_LOCK_UNLOCKED(name)
+
+/*
+ * A reader biased implementation primarily for CPU pinning.
+ *
+ * Can be selected as general replacement for the single reader RT rwlock
+ * variant
+ */
+struct rt_rw_lock {
+	struct rt_mutex		rtmutex;
+	atomic_t		readers;
+#ifdef CONFIG_DEBUG_LOCK_ALLOC
+	struct lockdep_map	dep_map;
+#endif
+};
+
+#define READER_BIAS	(1U << 31)
+#define WRITER_BIAS	(1U << 30)
+
+#define __RWLOCK_RT_INITIALIZER(name)					\
+{									\
+	.readers = ATOMIC_INIT(READER_BIAS),				\
+	.rtmutex = __RT_MUTEX_INITIALIZER_SAVE_STATE(name.rtmutex),	\
+	RW_DEP_MAP_INIT(name)						\
+}
+
+void __rwlock_biased_rt_init(struct rt_rw_lock *lock, const char *name,
+			     struct lock_class_key *key);
+
+#define rwlock_biased_rt_init(rwlock)					\
+	do {								\
+		static struct lock_class_key __key;			\
+									\
+		__rwlock_biased_rt_init((rwlock), #rwlock, &__key);	\
+	} while (0)
+
+#endif
diff --git a/include/linux/rwsem-rt.h b/include/linux/rwsem-rt.h
new file mode 100644
index 000000000000..0ba8aae9a198
--- /dev/null
+++ b/include/linux/rwsem-rt.h
@@ -0,0 +1,70 @@
+// SPDX-License-Identifier: GPL-2.0-only
+#ifndef _LINUX_RWSEM_RT_H
+#define _LINUX_RWSEM_RT_H
+
+#ifndef _LINUX_RWSEM_H
+#error "Include rwsem.h"
+#endif
+
+#include <linux/rtmutex.h>
+#include <linux/swait.h>
+
+#define READER_BIAS		(1U << 31)
+#define WRITER_BIAS		(1U << 30)
+
+struct rw_semaphore {
+	atomic_t		readers;
+	struct rt_mutex		rtmutex;
+#ifdef CONFIG_DEBUG_LOCK_ALLOC
+	struct lockdep_map	dep_map;
+#endif
+};
+
+#define __RWSEM_INITIALIZER(name)				\
+{								\
+	.readers = ATOMIC_INIT(READER_BIAS),			\
+	.rtmutex = __RT_MUTEX_INITIALIZER(name.rtmutex),	\
+	RW_DEP_MAP_INIT(name)					\
+}
+
+#define DECLARE_RWSEM(lockname) \
+	struct rw_semaphore lockname = __RWSEM_INITIALIZER(lockname)
+
+extern void  __rwsem_init(struct rw_semaphore *rwsem, const char *name,
+			  struct lock_class_key *key);
+
+#define __init_rwsem(sem, name, key)			\
+do {							\
+		rt_mutex_init(&(sem)->rtmutex);		\
+		__rwsem_init((sem), (name), (key));	\
+} while (0)
+
+#define init_rwsem(sem)					\
+do {							\
+	static struct lock_class_key __key;		\
+							\
+	__init_rwsem((sem), #sem, &__key);		\
+} while (0)
+
+static inline int rwsem_is_locked(struct rw_semaphore *sem)
+{
+	return atomic_read(&sem->readers) != READER_BIAS;
+}
+
+static inline int rwsem_is_contended(struct rw_semaphore *sem)
+{
+	return atomic_read(&sem->readers) > 0;
+}
+
+extern void __down_read(struct rw_semaphore *sem);
+extern int __down_read_interruptible(struct rw_semaphore *sem);
+extern int __down_read_killable(struct rw_semaphore *sem);
+extern int __down_read_trylock(struct rw_semaphore *sem);
+extern void __down_write(struct rw_semaphore *sem);
+extern int __must_check __down_write_killable(struct rw_semaphore *sem);
+extern int __down_write_trylock(struct rw_semaphore *sem);
+extern void __up_read(struct rw_semaphore *sem);
+extern void __up_write(struct rw_semaphore *sem);
+extern void __downgrade_write(struct rw_semaphore *sem);
+
+#endif
diff --git a/include/linux/rwsem.h b/include/linux/rwsem.h
index 4c715be48717..9323af8a9244 100644
--- a/include/linux/rwsem.h
+++ b/include/linux/rwsem.h
@@ -16,6 +16,11 @@
 #include <linux/spinlock.h>
 #include <linux/atomic.h>
 #include <linux/err.h>
+
+#ifdef CONFIG_PREEMPT_RT
+#include <linux/rwsem-rt.h>
+#else /* PREEMPT_RT */
+
 #ifdef CONFIG_RWSEM_SPIN_ON_OWNER
 #include <linux/osq_lock.h>
 #endif
@@ -119,6 +124,13 @@ static inline int rwsem_is_contended(struct rw_semaphore *sem)
 	return !list_empty(&sem->wait_list);
 }
 
+#endif /* !PREEMPT_RT */
+
+/*
+ * The functions below are the same for all rwsem implementations including
+ * the RT specific variant.
+ */
+
 /*
  * lock for reading
  */
diff --git a/include/linux/sched.h b/include/linux/sched.h
index a84372945f9e..ee643c051373 100644
--- a/include/linux/sched.h
+++ b/include/linux/sched.h
@@ -36,6 +36,7 @@
 #include <linux/kcsan.h>
 #include <linux/thread_bits.h>
 #include <linux/kabi.h>
+#include <asm/kmap_size.h>
 
 /* task_struct member predeclarations (sorted alphabetically): */
 struct audit_context;
@@ -114,12 +115,8 @@ struct io_uring_task;
 					 __TASK_TRACED | EXIT_DEAD | EXIT_ZOMBIE | \
 					 TASK_PARKED)
 
-#define task_is_traced(task)		((task->state & __TASK_TRACED) != 0)
-
 #define task_is_stopped(task)		((task->state & __TASK_STOPPED) != 0)
 
-#define task_is_stopped_or_traced(task)	((task->state & (__TASK_STOPPED | __TASK_TRACED)) != 0)
-
 #ifdef CONFIG_DEBUG_ATOMIC_SLEEP
 
 /*
@@ -143,6 +140,9 @@ struct io_uring_task;
 		smp_store_mb(current->state, (state_value));	\
 	} while (0)
 
+#define __set_current_state_no_track(state_value)		\
+	current->state = (state_value);
+
 #define set_special_state(state_value)					\
 	do {								\
 		unsigned long flags; /* may shadow */			\
@@ -196,6 +196,9 @@ struct io_uring_task;
 #define set_current_state(state_value)					\
 	smp_store_mb(current->state, (state_value))
 
+#define __set_current_state_no_track(state_value)	\
+	__set_current_state(state_value)
+
 /*
  * set_special_state() should be used for those states when the blocking task
  * can not use the regular condition based wait-loop. In that case we must
@@ -669,6 +672,13 @@ struct wake_q_node {
 	struct wake_q_node *next;
 };
 
+struct kmap_ctrl {
+#ifdef CONFIG_KMAP_LOCAL
+	int				idx;
+	pte_t				pteval[KM_MAX_IDX];
+#endif
+};
+
 /**
 * struct task_struct_resvd - KABI extension struct
 */
@@ -691,6 +701,8 @@ struct task_struct {
 #endif
 	/* -1 unrunnable, 0 runnable, >0 stopped: */
 	volatile long			state;
+	/* saved state for "spinlock sleepers" */
+	volatile long			saved_state;
 
 	/*
 	 * This begins the randomizable portion of task_struct. Only
@@ -763,6 +775,11 @@ struct task_struct {
 	int				nr_cpus_allowed;
 	const cpumask_t			*cpus_ptr;
 	cpumask_t			cpus_mask;
+	void				*migration_pending;
+#ifdef CONFIG_SMP
+	unsigned short			migration_disabled;
+#endif
+	unsigned short			migration_flags;
 
 #ifdef CONFIG_PREEMPT_RCU
 	int				rcu_read_lock_nesting;
@@ -872,6 +889,11 @@ struct task_struct {
 	KABI_FILL_HOLE(unsigned		pasid_activated:1)
 #endif
 
+#ifdef CONFIG_EVENTFD
+	/* Recursion prevention for eventfd_signal() */
+	unsigned			in_eventfd_signal:1;
+#endif
+
 	unsigned long			atomic_flags; /* Flags requiring atomic access. */
 
 	struct restart_block		restart_block;
@@ -1012,11 +1034,16 @@ struct task_struct {
 	/* Signal handlers: */
 	struct signal_struct		*signal;
 	struct sighand_struct __rcu		*sighand;
+	struct sigqueue			*sigqueue_cache;
 	sigset_t			blocked;
 	sigset_t			real_blocked;
 	/* Restored if set_restore_sigmask() was used: */
 	sigset_t			saved_sigmask;
 	struct sigpending		pending;
+#ifdef CONFIG_PREEMPT_RT
+	/* TODO: move me into ->restart_block ? */
+	struct				kernel_siginfo forced_info;
+#endif
 	unsigned long			sas_ss_sp;
 	size_t				sas_ss_size;
 	unsigned int			sas_ss_flags;
@@ -1043,6 +1070,7 @@ struct task_struct {
 	raw_spinlock_t			pi_lock;
 
 	struct wake_q_node		wake_q;
+	struct wake_q_node		wake_q_sleeper;
 
 #ifdef CONFIG_RT_MUTEXES
 	/* PI waiters blocked on a rt_mutex held by this task: */
@@ -1070,6 +1098,9 @@ struct task_struct {
 	int				softirq_context;
 	int				irq_config;
 #endif
+#ifdef CONFIG_PREEMPT_RT
+	int				softirq_disable_cnt;
+#endif
 
 #ifdef CONFIG_LOCKDEP
 # define MAX_LOCK_DEPTH			48UL
@@ -1355,6 +1386,7 @@ struct task_struct {
 	unsigned int			sequential_io;
 	unsigned int			sequential_io_avg;
 #endif
+	struct kmap_ctrl		kmap_ctrl;
 #ifdef CONFIG_DEBUG_ATOMIC_SLEEP
 	unsigned long			task_state_change;
 #endif
@@ -1832,6 +1864,7 @@ extern struct task_struct *find_get_task_by_vpid(pid_t nr);
 
 extern int wake_up_state(struct task_struct *tsk, unsigned int state);
 extern int wake_up_process(struct task_struct *tsk);
+extern int wake_up_lock_sleeper(struct task_struct *tsk);
 extern void wake_up_new_task(struct task_struct *tsk);
 
 #ifdef CONFIG_SMP
@@ -1929,6 +1962,89 @@ static inline int test_tsk_need_resched(struct task_struct *tsk)
 	return unlikely(test_tsk_thread_flag(tsk,TIF_NEED_RESCHED));
 }
 
+#ifdef CONFIG_PREEMPT_LAZY
+static inline void set_tsk_need_resched_lazy(struct task_struct *tsk)
+{
+	set_tsk_thread_flag(tsk,TIF_NEED_RESCHED_LAZY);
+}
+
+static inline void clear_tsk_need_resched_lazy(struct task_struct *tsk)
+{
+	clear_tsk_thread_flag(tsk,TIF_NEED_RESCHED_LAZY);
+}
+
+static inline int test_tsk_need_resched_lazy(struct task_struct *tsk)
+{
+	return unlikely(test_tsk_thread_flag(tsk,TIF_NEED_RESCHED_LAZY));
+}
+
+static inline int need_resched_lazy(void)
+{
+	return test_thread_flag(TIF_NEED_RESCHED_LAZY);
+}
+
+static inline int need_resched_now(void)
+{
+	return test_thread_flag(TIF_NEED_RESCHED);
+}
+
+#else
+static inline void clear_tsk_need_resched_lazy(struct task_struct *tsk) { }
+static inline int need_resched_lazy(void) { return 0; }
+
+static inline int need_resched_now(void)
+{
+	return test_thread_flag(TIF_NEED_RESCHED);
+}
+
+#endif
+
+
+static inline bool __task_is_stopped_or_traced(struct task_struct *task)
+{
+	if (task->state & (__TASK_STOPPED | __TASK_TRACED))
+		return true;
+#ifdef CONFIG_PREEMPT_RT
+	if (task->saved_state & (__TASK_STOPPED | __TASK_TRACED))
+		return true;
+#endif
+	return false;
+}
+
+static inline bool task_is_stopped_or_traced(struct task_struct *task)
+{
+	bool traced_stopped;
+
+#ifdef CONFIG_PREEMPT_RT
+	unsigned long flags;
+
+	raw_spin_lock_irqsave(&task->pi_lock, flags);
+	traced_stopped = __task_is_stopped_or_traced(task);
+	raw_spin_unlock_irqrestore(&task->pi_lock, flags);
+#else
+	traced_stopped = __task_is_stopped_or_traced(task);
+#endif
+	return traced_stopped;
+}
+
+static inline bool task_is_traced(struct task_struct *task)
+{
+	bool traced = false;
+
+	if (task->state & __TASK_TRACED)
+		return true;
+#ifdef CONFIG_PREEMPT_RT
+	/* in case the task is sleeping on tasklist_lock */
+	raw_spin_lock_irq(&task->pi_lock);
+	if (task->state & __TASK_TRACED)
+		traced = true;
+	else if (task->saved_state & __TASK_TRACED)
+		traced = true;
+	raw_spin_unlock_irq(&task->pi_lock);
+#endif
+	return traced;
+}
+
 /*
  * cond_resched() and cond_resched_lock(): latency reduction via
  * explicit rescheduling in places that are safe. The return
diff --git a/include/linux/sched/hotplug.h b/include/linux/sched/hotplug.h
index 9a62ffdd296f..412cdaba33eb 100644
--- a/include/linux/sched/hotplug.h
+++ b/include/linux/sched/hotplug.h
@@ -11,8 +11,10 @@ extern int sched_cpu_activate(unsigned int cpu);
 extern int sched_cpu_deactivate(unsigned int cpu);
 
 #ifdef CONFIG_HOTPLUG_CPU
+extern int sched_cpu_wait_empty(unsigned int cpu);
 extern int sched_cpu_dying(unsigned int cpu);
 #else
+# define sched_cpu_wait_empty	NULL
 # define sched_cpu_dying	NULL
 #endif
 
diff --git a/include/linux/sched/mm.h b/include/linux/sched/mm.h
index f58a2730a130..5f4aa984245e 100644
--- a/include/linux/sched/mm.h
+++ b/include/linux/sched/mm.h
@@ -50,6 +50,17 @@ static inline void mmdrop(struct mm_struct *mm)
 		__mmdrop(mm);
 }
 
+#ifdef CONFIG_PREEMPT_RT
+extern void __mmdrop_delayed(struct rcu_head *rhp);
+static inline void mmdrop_delayed(struct mm_struct *mm)
+{
+	if (atomic_dec_and_test(&mm->mm_count))
+		call_rcu(&mm->delayed_drop, __mmdrop_delayed);
+}
+#else
+# define mmdrop_delayed(mm)    mmdrop(mm)
+#endif
+
 /**
  * mmget() - Pin the address space associated with a &struct mm_struct.
  * @mm: The address space to pin.
diff --git a/include/linux/sched/rt.h b/include/linux/sched/rt.h
index e5af028c08b4..994c25640e15 100644
--- a/include/linux/sched/rt.h
+++ b/include/linux/sched/rt.h
@@ -39,20 +39,12 @@ static inline struct task_struct *rt_mutex_get_top_task(struct task_struct *p)
 }
 extern void rt_mutex_setprio(struct task_struct *p, struct task_struct *pi_task);
 extern void rt_mutex_adjust_pi(struct task_struct *p);
-static inline bool tsk_is_pi_blocked(struct task_struct *tsk)
-{
-	return tsk->pi_blocked_on != NULL;
-}
 #else
 static inline struct task_struct *rt_mutex_get_top_task(struct task_struct *task)
 {
 	return NULL;
 }
 # define rt_mutex_adjust_pi(p)		do { } while (0)
-static inline bool tsk_is_pi_blocked(struct task_struct *tsk)
-{
-	return false;
-}
 #endif
 
 extern void normalize_rt_tasks(void);
diff --git a/include/linux/sched/wake_q.h b/include/linux/sched/wake_q.h
index 26a2013ac39c..6e2dff721547 100644
--- a/include/linux/sched/wake_q.h
+++ b/include/linux/sched/wake_q.h
@@ -58,6 +58,17 @@ static inline bool wake_q_empty(struct wake_q_head *head)
 
 extern void wake_q_add(struct wake_q_head *head, struct task_struct *task);
 extern void wake_q_add_safe(struct wake_q_head *head, struct task_struct *task);
-extern void wake_up_q(struct wake_q_head *head);
+extern void wake_q_add_sleeper(struct wake_q_head *head, struct task_struct *task);
+extern void __wake_up_q(struct wake_q_head *head, bool sleeper);
+
+static inline void wake_up_q(struct wake_q_head *head)
+{
+	__wake_up_q(head, false);
+}
+
+static inline void wake_up_q_sleeper(struct wake_q_head *head)
+{
+	__wake_up_q(head, true);
+}
 
 #endif /* _LINUX_SCHED_WAKE_Q_H */
diff --git a/include/linux/serial_8250.h b/include/linux/serial_8250.h
index 9e655055112d..ffef674deda7 100644
--- a/include/linux/serial_8250.h
+++ b/include/linux/serial_8250.h
@@ -7,6 +7,7 @@
 #ifndef _LINUX_SERIAL_8250_H
 #define _LINUX_SERIAL_8250_H
 
+#include <linux/atomic.h>
 #include <linux/serial_core.h>
 #include <linux/serial_reg.h>
 #include <linux/platform_device.h>
@@ -125,6 +126,8 @@ struct uart_8250_port {
 #define MSR_SAVE_FLAGS UART_MSR_ANY_DELTA
 	unsigned char		msr_saved_flags;
 
+	atomic_t		console_printing;
+
 	struct uart_8250_dma	*dma;
 	const struct uart_8250_ops *ops;
 
@@ -180,6 +183,8 @@ void serial8250_init_port(struct uart_8250_port *up);
 void serial8250_set_defaults(struct uart_8250_port *up);
 void serial8250_console_write(struct uart_8250_port *up, const char *s,
 			      unsigned int count);
+void serial8250_console_write_atomic(struct uart_8250_port *up, const char *s,
+				     unsigned int count);
 int serial8250_console_setup(struct uart_port *port, char *options, bool probe);
 int serial8250_console_exit(struct uart_port *port);
 
diff --git a/include/linux/shmem_fs.h b/include/linux/shmem_fs.h
index 93240799a404..df2871ed82dc 100644
--- a/include/linux/shmem_fs.h
+++ b/include/linux/shmem_fs.h
@@ -32,7 +32,7 @@ struct shmem_sb_info {
 	struct percpu_counter used_blocks;  /* How many are allocated */
 	unsigned long max_inodes;   /* How many inodes are allowed */
 	unsigned long free_inodes;  /* How many are left for allocation */
-	spinlock_t stat_lock;	    /* Serialize shmem_sb_info changes */
+	raw_spinlock_t stat_lock;   /* Serialize shmem_sb_info changes */
 	umode_t mode;		    /* Mount mode for root directory */
 	unsigned char huge;	    /* Whether to try for hugepages */
 	kuid_t uid;		    /* Mount uid for root directory */
diff --git a/include/linux/signal.h b/include/linux/signal.h
index 3038a0610407..fff1656c6b6f 100644
--- a/include/linux/signal.h
+++ b/include/linux/signal.h
@@ -265,6 +265,7 @@ static inline void init_sigpending(struct sigpending *sig)
 }
 
 extern void flush_sigqueue(struct sigpending *queue);
+extern void flush_task_sigqueue(struct task_struct *tsk);
 
 /* Test if 'sig' is valid signal. Use this instead of testing _NSIG directly */
 static inline int valid_signal(unsigned long sig)
diff --git a/include/linux/skbuff.h b/include/linux/skbuff.h
index 26c431883c69..c91fa019e28d 100644
--- a/include/linux/skbuff.h
+++ b/include/linux/skbuff.h
@@ -298,6 +298,7 @@ struct sk_buff_head {
 
 	__u32		qlen;
 	spinlock_t	lock;
+	raw_spinlock_t	raw_lock;
 };
 
 struct sk_buff;
@@ -1924,6 +1925,12 @@ static inline void skb_queue_head_init(struct sk_buff_head *list)
 	__skb_queue_head_init(list);
 }
 
+static inline void skb_queue_head_init_raw(struct sk_buff_head *list)
+{
+	raw_spin_lock_init(&list->raw_lock);
+	__skb_queue_head_init(list);
+}
+
 static inline void skb_queue_head_init_class(struct sk_buff_head *list,
 		struct lock_class_key *class)
 {
diff --git a/include/linux/smp.h b/include/linux/smp.h
index 84a0b4828f66..8348fa4127a0 100644
--- a/include/linux/smp.h
+++ b/include/linux/smp.h
@@ -260,6 +260,9 @@ static inline int get_boot_cpu_id(void)
 #define get_cpu()		({ preempt_disable(); __smp_processor_id(); })
 #define put_cpu()		preempt_enable()
 
+#define get_cpu_light()		({ migrate_disable(); __smp_processor_id(); })
+#define put_cpu_light()		migrate_enable()
+
 /*
  * Callback to arch code if there's nosmp or maxcpus=0 on the
  * boot command line:
diff --git a/include/linux/spinlock.h b/include/linux/spinlock.h
index 79897841a2cc..c3c70291b46c 100644
--- a/include/linux/spinlock.h
+++ b/include/linux/spinlock.h
@@ -309,7 +309,11 @@ static inline void do_raw_spin_unlock(raw_spinlock_t *lock) __releases(lock)
 })
 
 /* Include rwlock functions */
-#include <linux/rwlock.h>
+#ifdef CONFIG_PREEMPT_RT
+# include <linux/rwlock_rt.h>
+#else
+# include <linux/rwlock.h>
+#endif
 
 /*
  * Pull the _spin_*()/_read_*()/_write_*() functions/declarations:
@@ -320,6 +324,10 @@ static inline void do_raw_spin_unlock(raw_spinlock_t *lock) __releases(lock)
 # include <linux/spinlock_api_up.h>
 #endif
 
+#ifdef CONFIG_PREEMPT_RT
+# include <linux/spinlock_rt.h>
+#else /* PREEMPT_RT */
+
 /*
  * Map the spin_lock functions to the raw variants for PREEMPT_RT=n
  */
@@ -454,6 +462,8 @@ static __always_inline int spin_is_contended(spinlock_t *lock)
 
 #define assert_spin_locked(lock)	assert_raw_spin_locked(&(lock)->rlock)
 
+#endif /* !PREEMPT_RT */
+
 /*
  * Pull the atomic_t declaration:
  * (asm-mips/atomic.h needs above definitions)
diff --git a/include/linux/spinlock_api_smp.h b/include/linux/spinlock_api_smp.h
index 19a9be9d97ee..da38149f2843 100644
--- a/include/linux/spinlock_api_smp.h
+++ b/include/linux/spinlock_api_smp.h
@@ -187,6 +187,8 @@ static inline int __raw_spin_trylock_bh(raw_spinlock_t *lock)
 	return 0;
 }
 
-#include <linux/rwlock_api_smp.h>
+#ifndef CONFIG_PREEMPT_RT
+# include <linux/rwlock_api_smp.h>
+#endif
 
 #endif /* __LINUX_SPINLOCK_API_SMP_H */
diff --git a/include/linux/spinlock_rt.h b/include/linux/spinlock_rt.h
new file mode 100644
index 000000000000..3085132eae38
--- /dev/null
+++ b/include/linux/spinlock_rt.h
@@ -0,0 +1,155 @@
+// SPDX-License-Identifier: GPL-2.0-only
+#ifndef __LINUX_SPINLOCK_RT_H
+#define __LINUX_SPINLOCK_RT_H
+
+#ifndef __LINUX_SPINLOCK_H
+#error Do not include directly. Use spinlock.h
+#endif
+
+#include <linux/bug.h>
+
+extern void
+__rt_spin_lock_init(spinlock_t *lock, const char *name, struct lock_class_key *key);
+
+#define spin_lock_init(slock)				\
+do {							\
+	static struct lock_class_key __key;		\
+							\
+	rt_mutex_init(&(slock)->lock);			\
+	__rt_spin_lock_init(slock, #slock, &__key);	\
+} while (0)
+
+extern void __lockfunc rt_spin_lock(spinlock_t *lock);
+extern void __lockfunc rt_spin_lock_nested(spinlock_t *lock, int subclass);
+extern void __lockfunc rt_spin_lock_nest_lock(spinlock_t *lock, struct lockdep_map *nest_lock);
+extern void __lockfunc rt_spin_unlock(spinlock_t *lock);
+extern void __lockfunc rt_spin_lock_unlock(spinlock_t *lock);
+extern int __lockfunc rt_spin_trylock_irqsave(spinlock_t *lock, unsigned long *flags);
+extern int __lockfunc rt_spin_trylock_bh(spinlock_t *lock);
+extern int __lockfunc rt_spin_trylock(spinlock_t *lock);
+extern int atomic_dec_and_spin_lock(atomic_t *atomic, spinlock_t *lock);
+
+/*
+ * lockdep-less calls, for derived types like rwlock:
+ * (for trylock they can use rt_mutex_trylock() directly.
+ * Migrate disable handling must be done at the call site.
+ */
+extern void __lockfunc __rt_spin_lock(struct rt_mutex *lock);
+extern void __lockfunc __rt_spin_trylock(struct rt_mutex *lock);
+extern void __lockfunc __rt_spin_unlock(struct rt_mutex *lock);
+
+#define spin_lock(lock)			rt_spin_lock(lock)
+
+#define spin_lock_bh(lock)			\
+	do {					\
+		local_bh_disable();		\
+		rt_spin_lock(lock);		\
+	} while (0)
+
+#define spin_lock_irq(lock)		spin_lock(lock)
+
+#define spin_do_trylock(lock)		__cond_lock(lock, rt_spin_trylock(lock))
+
+#define spin_trylock(lock)			\
+({						\
+	int __locked;				\
+	__locked = spin_do_trylock(lock);	\
+	__locked;				\
+})
+
+#ifdef CONFIG_LOCKDEP
+# define spin_lock_nested(lock, subclass)		\
+	do {						\
+		rt_spin_lock_nested(lock, subclass);	\
+	} while (0)
+
+#define spin_lock_bh_nested(lock, subclass)		\
+	do {						\
+		local_bh_disable();			\
+		rt_spin_lock_nested(lock, subclass);	\
+	} while (0)
+
+# define spin_lock_nest_lock(lock, subclass)		\
+	do {                                                           \
+		typecheck(struct lockdep_map *, &(subclass)->dep_map);	\
+		rt_spin_lock_nest_lock(lock, &(subclass)->dep_map);	\
+	} while (0)
+
+# define spin_lock_irqsave_nested(lock, flags, subclass) \
+	do {						 \
+		typecheck(unsigned long, flags);	 \
+		flags = 0;				 \
+		rt_spin_lock_nested(lock, subclass);	 \
+	} while (0)
+#else
+# define spin_lock_nested(lock, subclass)	spin_lock(((void)(subclass), (lock)))
+# define spin_lock_nest_lock(lock, subclass)	spin_lock(((void)(subclass), (lock)))
+# define spin_lock_bh_nested(lock, subclass)	spin_lock_bh(((void)(subclass), (lock)))
+
+# define spin_lock_irqsave_nested(lock, flags, subclass) \
+	do {						 \
+		typecheck(unsigned long, flags);	 \
+		flags = 0;				 \
+		spin_lock(((void)(subclass), (lock)));	 \
+	} while (0)
+#endif
+
+#define spin_lock_irqsave(lock, flags)			 \
+	do {						 \
+		typecheck(unsigned long, flags);	 \
+		flags = 0;				 \
+		spin_lock(lock);			 \
+	} while (0)
+
+#define spin_unlock(lock)			rt_spin_unlock(lock)
+
+#define spin_unlock_bh(lock)				\
+	do {						\
+		rt_spin_unlock(lock);			\
+		local_bh_enable();			\
+	} while (0)
+
+#define spin_unlock_irq(lock)		spin_unlock(lock)
+
+#define spin_unlock_irqrestore(lock, flags)		\
+	do {						\
+		typecheck(unsigned long, flags);	\
+		(void) flags;				\
+		spin_unlock(lock);			\
+	} while (0)
+
+#define spin_trylock_bh(lock)	__cond_lock(lock, rt_spin_trylock_bh(lock))
+#define spin_trylock_irq(lock)	spin_trylock(lock)
+
+#define spin_trylock_irqsave(lock, flags)		\
+({							\
+	int __locked;					\
+							\
+	typecheck(unsigned long, flags);		\
+	flags = 0;					\
+	__locked = spin_trylock(lock);			\
+	__locked;					\
+})
+
+#ifdef CONFIG_GENERIC_LOCKBREAK
+# define spin_is_contended(lock)	((lock)->break_lock)
+#else
+# define spin_is_contended(lock)	(((void)(lock), 0))
+#endif
+
+static inline int spin_can_lock(spinlock_t *lock)
+{
+	return !rt_mutex_is_locked(&lock->lock);
+}
+
+static inline int spin_is_locked(spinlock_t *lock)
+{
+	return rt_mutex_is_locked(&lock->lock);
+}
+
+static inline void assert_spin_locked(spinlock_t *lock)
+{
+	BUG_ON(!spin_is_locked(lock));
+}
+
+#endif
diff --git a/include/linux/spinlock_types.h b/include/linux/spinlock_types.h
index b981caafe8bf..8d896d3e1a01 100644
--- a/include/linux/spinlock_types.h
+++ b/include/linux/spinlock_types.h
@@ -9,93 +9,15 @@
  * Released under the General Public License (GPL).
  */
 
-#if defined(CONFIG_SMP)
-# include <asm/spinlock_types.h>
-#else
-# include <linux/spinlock_types_up.h>
-#endif
-
-#include <linux/lockdep_types.h>
-
-typedef struct raw_spinlock {
-	arch_spinlock_t raw_lock;
-#ifdef CONFIG_DEBUG_SPINLOCK
-	unsigned int magic, owner_cpu;
-	void *owner;
-#endif
-#ifdef CONFIG_DEBUG_LOCK_ALLOC
-	struct lockdep_map dep_map;
-#endif
-} raw_spinlock_t;
-
-#define SPINLOCK_MAGIC		0xdead4ead
-
-#define SPINLOCK_OWNER_INIT	((void *)-1L)
-
-#ifdef CONFIG_DEBUG_LOCK_ALLOC
-# define RAW_SPIN_DEP_MAP_INIT(lockname)		\
-	.dep_map = {					\
-		.name = #lockname,			\
-		.wait_type_inner = LD_WAIT_SPIN,	\
-	}
-# define SPIN_DEP_MAP_INIT(lockname)			\
-	.dep_map = {					\
-		.name = #lockname,			\
-		.wait_type_inner = LD_WAIT_CONFIG,	\
-	}
-#else
-# define RAW_SPIN_DEP_MAP_INIT(lockname)
-# define SPIN_DEP_MAP_INIT(lockname)
-#endif
+#include <linux/spinlock_types_raw.h>
 
-#ifdef CONFIG_DEBUG_SPINLOCK
-# define SPIN_DEBUG_INIT(lockname)		\
-	.magic = SPINLOCK_MAGIC,		\
-	.owner_cpu = -1,			\
-	.owner = SPINLOCK_OWNER_INIT,
+#ifndef CONFIG_PREEMPT_RT
+# include <linux/spinlock_types_nort.h>
+# include <linux/rwlock_types.h>
 #else
-# define SPIN_DEBUG_INIT(lockname)
+# include <linux/rtmutex.h>
+# include <linux/spinlock_types_rt.h>
+# include <linux/rwlock_types_rt.h>
 #endif
 
-#define __RAW_SPIN_LOCK_INITIALIZER(lockname)	\
-	{					\
-	.raw_lock = __ARCH_SPIN_LOCK_UNLOCKED,	\
-	SPIN_DEBUG_INIT(lockname)		\
-	RAW_SPIN_DEP_MAP_INIT(lockname) }
-
-#define __RAW_SPIN_LOCK_UNLOCKED(lockname)	\
-	(raw_spinlock_t) __RAW_SPIN_LOCK_INITIALIZER(lockname)
-
-#define DEFINE_RAW_SPINLOCK(x)	raw_spinlock_t x = __RAW_SPIN_LOCK_UNLOCKED(x)
-
-typedef struct spinlock {
-	union {
-		struct raw_spinlock rlock;
-
-#ifdef CONFIG_DEBUG_LOCK_ALLOC
-# define LOCK_PADSIZE (offsetof(struct raw_spinlock, dep_map))
-		struct {
-			u8 __padding[LOCK_PADSIZE];
-			struct lockdep_map dep_map;
-		};
-#endif
-	};
-} spinlock_t;
-
-#define ___SPIN_LOCK_INITIALIZER(lockname)	\
-	{					\
-	.raw_lock = __ARCH_SPIN_LOCK_UNLOCKED,	\
-	SPIN_DEBUG_INIT(lockname)		\
-	SPIN_DEP_MAP_INIT(lockname) }
-
-#define __SPIN_LOCK_INITIALIZER(lockname) \
-	{ { .rlock = ___SPIN_LOCK_INITIALIZER(lockname) } }
-
-#define __SPIN_LOCK_UNLOCKED(lockname) \
-	(spinlock_t) __SPIN_LOCK_INITIALIZER(lockname)
-
-#define DEFINE_SPINLOCK(x)	spinlock_t x = __SPIN_LOCK_UNLOCKED(x)
-
-#include <linux/rwlock_types.h>
-
 #endif /* __LINUX_SPINLOCK_TYPES_H */
diff --git a/include/linux/spinlock_types_nort.h b/include/linux/spinlock_types_nort.h
new file mode 100644
index 000000000000..e4549f0dd197
--- /dev/null
+++ b/include/linux/spinlock_types_nort.h
@@ -0,0 +1,39 @@
+#ifndef __LINUX_SPINLOCK_TYPES_NORT_H
+#define __LINUX_SPINLOCK_TYPES_NORT_H
+
+#ifndef __LINUX_SPINLOCK_TYPES_H
+#error "Do not include directly. Include spinlock_types.h instead"
+#endif
+
+/*
+ * The non RT version maps spinlocks to raw_spinlocks
+ */
+typedef struct spinlock {
+	union {
+		struct raw_spinlock rlock;
+
+#ifdef CONFIG_DEBUG_LOCK_ALLOC
+# define LOCK_PADSIZE (offsetof(struct raw_spinlock, dep_map))
+		struct {
+			u8 __padding[LOCK_PADSIZE];
+			struct lockdep_map dep_map;
+		};
+#endif
+	};
+} spinlock_t;
+
+#define ___SPIN_LOCK_INITIALIZER(lockname)	\
+{						\
+	.raw_lock = __ARCH_SPIN_LOCK_UNLOCKED,	\
+	SPIN_DEBUG_INIT(lockname)		\
+	SPIN_DEP_MAP_INIT(lockname) }
+
+#define __SPIN_LOCK_INITIALIZER(lockname) \
+	{ { .rlock = ___SPIN_LOCK_INITIALIZER(lockname) } }
+
+#define __SPIN_LOCK_UNLOCKED(lockname) \
+	(spinlock_t) __SPIN_LOCK_INITIALIZER(lockname)
+
+#define DEFINE_SPINLOCK(x)	spinlock_t x = __SPIN_LOCK_UNLOCKED(x)
+
+#endif
diff --git a/include/linux/spinlock_types_raw.h b/include/linux/spinlock_types_raw.h
new file mode 100644
index 000000000000..1d4a180e983d
--- /dev/null
+++ b/include/linux/spinlock_types_raw.h
@@ -0,0 +1,65 @@
+#ifndef __LINUX_SPINLOCK_TYPES_RAW_H
+#define __LINUX_SPINLOCK_TYPES_RAW_H
+
+#include <linux/types.h>
+
+#if defined(CONFIG_SMP)
+# include <asm/spinlock_types.h>
+#else
+# include <linux/spinlock_types_up.h>
+#endif
+
+#include <linux/lockdep_types.h>
+
+typedef struct raw_spinlock {
+	arch_spinlock_t raw_lock;
+#ifdef CONFIG_DEBUG_SPINLOCK
+	unsigned int magic, owner_cpu;
+	void *owner;
+#endif
+#ifdef CONFIG_DEBUG_LOCK_ALLOC
+	struct lockdep_map dep_map;
+#endif
+} raw_spinlock_t;
+
+#define SPINLOCK_MAGIC		0xdead4ead
+
+#define SPINLOCK_OWNER_INIT	((void *)-1L)
+
+#ifdef CONFIG_DEBUG_LOCK_ALLOC
+# define RAW_SPIN_DEP_MAP_INIT(lockname)		\
+	.dep_map = {					\
+		.name = #lockname,			\
+		.wait_type_inner = LD_WAIT_SPIN,	\
+	}
+# define SPIN_DEP_MAP_INIT(lockname)			\
+	.dep_map = {					\
+		.name = #lockname,			\
+		.wait_type_inner = LD_WAIT_CONFIG,	\
+	}
+#else
+# define RAW_SPIN_DEP_MAP_INIT(lockname)
+# define SPIN_DEP_MAP_INIT(lockname)
+#endif
+
+#ifdef CONFIG_DEBUG_SPINLOCK
+# define SPIN_DEBUG_INIT(lockname)		\
+	.magic = SPINLOCK_MAGIC,		\
+	.owner_cpu = -1,			\
+	.owner = SPINLOCK_OWNER_INIT,
+#else
+# define SPIN_DEBUG_INIT(lockname)
+#endif
+
+#define __RAW_SPIN_LOCK_INITIALIZER(lockname)	\
+{						\
+	.raw_lock = __ARCH_SPIN_LOCK_UNLOCKED,	\
+	SPIN_DEBUG_INIT(lockname)		\
+	RAW_SPIN_DEP_MAP_INIT(lockname) }
+
+#define __RAW_SPIN_LOCK_UNLOCKED(lockname)	\
+	(raw_spinlock_t) __RAW_SPIN_LOCK_INITIALIZER(lockname)
+
+#define DEFINE_RAW_SPINLOCK(x)  raw_spinlock_t x = __RAW_SPIN_LOCK_UNLOCKED(x)
+
+#endif
diff --git a/include/linux/spinlock_types_rt.h b/include/linux/spinlock_types_rt.h
new file mode 100644
index 000000000000..446da786e5d5
--- /dev/null
+++ b/include/linux/spinlock_types_rt.h
@@ -0,0 +1,38 @@
+// SPDX-License-Identifier: GPL-2.0-only
+#ifndef __LINUX_SPINLOCK_TYPES_RT_H
+#define __LINUX_SPINLOCK_TYPES_RT_H
+
+#ifndef __LINUX_SPINLOCK_TYPES_H
+#error "Do not include directly. Include spinlock_types.h instead"
+#endif
+
+#include <linux/cache.h>
+
+/*
+ * PREEMPT_RT: spinlocks - an RT mutex plus lock-break field:
+ */
+typedef struct spinlock {
+	struct rt_mutex		lock;
+	unsigned int		break_lock;
+#ifdef CONFIG_DEBUG_LOCK_ALLOC
+	struct lockdep_map	dep_map;
+#endif
+} spinlock_t;
+
+#define __RT_SPIN_INITIALIZER(name) \
+	{ \
+	.wait_lock = __RAW_SPIN_LOCK_UNLOCKED(name.wait_lock), \
+	.save_state = 1, \
+	}
+/*
+.wait_list = PLIST_HEAD_INIT_RAW((name).lock.wait_list, (name).lock.wait_lock)
+*/
+
+#define __SPIN_LOCK_UNLOCKED(name)			\
+	{ .lock = __RT_SPIN_INITIALIZER(name.lock),		\
+	  SPIN_DEP_MAP_INIT(name) }
+
+#define DEFINE_SPINLOCK(name) \
+	spinlock_t name = __SPIN_LOCK_UNLOCKED(name)
+
+#endif
diff --git a/include/linux/spinlock_types_up.h b/include/linux/spinlock_types_up.h
index c09b6407ae1b..d9b371fa13e0 100644
--- a/include/linux/spinlock_types_up.h
+++ b/include/linux/spinlock_types_up.h
@@ -1,7 +1,7 @@
 #ifndef __LINUX_SPINLOCK_TYPES_UP_H
 #define __LINUX_SPINLOCK_TYPES_UP_H
 
-#ifndef __LINUX_SPINLOCK_TYPES_H
+#if !defined(__LINUX_SPINLOCK_TYPES_H) && !defined(__LINUX_RT_MUTEX_H)
 # error "please don't include this file directly"
 #endif
 
diff --git a/include/linux/stop_machine.h b/include/linux/stop_machine.h
index 2959b9e52af4..13be92a607a8 100644
--- a/include/linux/stop_machine.h
+++ b/include/linux/stop_machine.h
@@ -25,6 +25,7 @@ typedef int (*cpu_stop_fn_t)(void *arg);
 struct cpu_stop_work {
 	struct list_head	list;		/* cpu_stopper->works */
 	cpu_stop_fn_t		fn;
+	unsigned long		caller;
 	void			*arg;
 	struct cpu_stop_done	*done;
 	KABI_RESERVE(1)
@@ -38,6 +39,8 @@ void stop_machine_park(int cpu);
 void stop_machine_unpark(int cpu);
 void stop_machine_yield(const struct cpumask *cpumask);
 
+extern void print_stop_info(const char *log_lvl, struct task_struct *task);
+
 #else	/* CONFIG_SMP */
 
 #include <linux/workqueue.h>
@@ -82,6 +85,8 @@ static inline bool stop_one_cpu_nowait(unsigned int cpu,
 	return false;
 }
 
+static inline void print_stop_info(const char *log_lvl, struct task_struct *task) { }
+
 #endif	/* CONFIG_SMP */
 
 /*
diff --git a/include/linux/thread_info.h b/include/linux/thread_info.h
index 19f76d87f20f..1c89c7d9f7cd 100644
--- a/include/linux/thread_info.h
+++ b/include/linux/thread_info.h
@@ -36,7 +36,17 @@ static inline long set_restart_fn(struct restart_block *restart,
 
 #define THREADINFO_GFP		(GFP_KERNEL_ACCOUNT | __GFP_ZERO)
 
-#define tif_need_resched() test_thread_flag(TIF_NEED_RESCHED)
+#ifdef CONFIG_PREEMPT_LAZY
+#define tif_need_resched()	(test_thread_flag(TIF_NEED_RESCHED) || \
+				 test_thread_flag(TIF_NEED_RESCHED_LAZY))
+#define tif_need_resched_now()	(test_thread_flag(TIF_NEED_RESCHED))
+#define tif_need_resched_lazy()	test_thread_flag(TIF_NEED_RESCHED_LAZY))
+
+#else
+#define tif_need_resched()	test_thread_flag(TIF_NEED_RESCHED)
+#define tif_need_resched_now()	test_thread_flag(TIF_NEED_RESCHED)
+#define tif_need_resched_lazy()	0
+#endif
 
 #ifndef CONFIG_HAVE_ARCH_WITHIN_STACK_FRAMES
 static inline int arch_within_stack_frames(const void * const stack,
diff --git a/include/linux/trace_events.h b/include/linux/trace_events.h
index 409385b25ecb..4a0f567d69ce 100644
--- a/include/linux/trace_events.h
+++ b/include/linux/trace_events.h
@@ -67,6 +67,8 @@ struct trace_entry {
 	unsigned char		flags;
 	unsigned char		preempt_count;
 	int			pid;
+	unsigned char		migrate_disable;
+	unsigned char		preempt_lazy_count;
 };
 
 #define TRACE_EVENT_TYPE_MAX						\
@@ -152,17 +154,66 @@ static inline void tracing_generic_entry_update(struct trace_entry *entry,
 						unsigned short type,
 						unsigned int trace_ctx)
 {
-	struct task_struct *tsk = current;
-
 	entry->preempt_count		= trace_ctx & 0xff;
-	entry->pid			= (tsk) ? tsk->pid : 0;
+	entry->migrate_disable		= (trace_ctx >> 8) & 0xff;
+	entry->preempt_lazy_count	= (trace_ctx >> 16) & 0xff;
+	entry->pid			= current->pid;
 	entry->type			= type;
-	entry->flags =			trace_ctx >> 16;
+	entry->flags =			trace_ctx >> 24;
 }
 
-unsigned int tracing_gen_ctx_flags(unsigned long irqflags);
-unsigned int tracing_gen_ctx(void);
-unsigned int tracing_gen_ctx_dec(void);
+unsigned int tracing_gen_ctx_irq_test(unsigned int irqs_status);
+
+enum trace_flag_type {
+	TRACE_FLAG_IRQS_OFF		= 0x01,
+	TRACE_FLAG_IRQS_NOSUPPORT	= 0x02,
+	TRACE_FLAG_NEED_RESCHED		= 0x04,
+	TRACE_FLAG_HARDIRQ		= 0x08,
+	TRACE_FLAG_SOFTIRQ		= 0x10,
+	TRACE_FLAG_PREEMPT_RESCHED	= 0x20,
+	TRACE_FLAG_NMI			= 0x40,
+	TRACE_FLAG_NEED_RESCHED_LAZY	= 0x80,
+};
+
+#ifdef CONFIG_TRACE_IRQFLAGS_SUPPORT
+static inline unsigned int tracing_gen_ctx_flags(unsigned long irqflags)
+{
+	unsigned int irq_status = irqs_disabled_flags(irqflags) ?
+		TRACE_FLAG_IRQS_OFF : 0;
+	return tracing_gen_ctx_irq_test(irq_status);
+}
+static inline unsigned int tracing_gen_ctx(void)
+{
+	unsigned long irqflags;
+
+	local_save_flags(irqflags);
+	return tracing_gen_ctx_flags(irqflags);
+}
+#else
+
+static inline unsigned int tracing_gen_ctx_flags(unsigned long irqflags)
+{
+	return tracing_gen_ctx_irq_test(TRACE_FLAG_IRQS_NOSUPPORT);
+}
+static inline unsigned int tracing_gen_ctx(void)
+{
+	return tracing_gen_ctx_irq_test(TRACE_FLAG_IRQS_NOSUPPORT);
+}
+#endif
+
+static inline unsigned int tracing_gen_ctx_dec(void)
+{
+	unsigned int trace_ctx;
+
+	trace_ctx = tracing_gen_ctx();
+	/*
+	 * Subtract one from the preeption counter if preemption is enabled,
+	 * see trace_event_buffer_reserve()for details.
+	 */
+	if (IS_ENABLED(CONFIG_PREEMPTION))
+		trace_ctx--;
+	return trace_ctx;
+}
 
 struct trace_event_file;
 
diff --git a/include/linux/u64_stats_sync.h b/include/linux/u64_stats_sync.h
index e81856c0ba13..66eb968a09d4 100644
--- a/include/linux/u64_stats_sync.h
+++ b/include/linux/u64_stats_sync.h
@@ -66,7 +66,7 @@
 #include <linux/seqlock.h>
 
 struct u64_stats_sync {
-#if BITS_PER_LONG==32 && defined(CONFIG_SMP)
+#if BITS_PER_LONG==32 && (defined(CONFIG_SMP) || defined(CONFIG_PREEMPT_RT))
 	seqcount_t	seq;
 #endif
 };
@@ -115,7 +115,7 @@ static inline void u64_stats_inc(u64_stats_t *p)
 }
 #endif
 
-#if BITS_PER_LONG == 32 && defined(CONFIG_SMP)
+#if BITS_PER_LONG == 32 && (defined(CONFIG_SMP) || defined(CONFIG_PREEMPT_RT))
 #define u64_stats_init(syncp)	seqcount_init(&(syncp)->seq)
 #else
 static inline void u64_stats_init(struct u64_stats_sync *syncp)
@@ -125,15 +125,19 @@ static inline void u64_stats_init(struct u64_stats_sync *syncp)
 
 static inline void u64_stats_update_begin(struct u64_stats_sync *syncp)
 {
-#if BITS_PER_LONG==32 && defined(CONFIG_SMP)
+#if BITS_PER_LONG == 32 && (defined(CONFIG_SMP) || defined(CONFIG_PREEMPT_RT))
+	if (IS_ENABLED(CONFIG_PREEMPT_RT))
+		preempt_disable();
 	write_seqcount_begin(&syncp->seq);
 #endif
 }
 
 static inline void u64_stats_update_end(struct u64_stats_sync *syncp)
 {
-#if BITS_PER_LONG==32 && defined(CONFIG_SMP)
+#if BITS_PER_LONG == 32 && (defined(CONFIG_SMP) || defined(CONFIG_PREEMPT_RT))
 	write_seqcount_end(&syncp->seq);
+	if (IS_ENABLED(CONFIG_PREEMPT_RT))
+		preempt_enable();
 #endif
 }
 
@@ -142,8 +146,11 @@ u64_stats_update_begin_irqsave(struct u64_stats_sync *syncp)
 {
 	unsigned long flags = 0;
 
-#if BITS_PER_LONG==32 && defined(CONFIG_SMP)
-	local_irq_save(flags);
+#if BITS_PER_LONG == 32 && (defined(CONFIG_SMP) || defined(CONFIG_PREEMPT_RT))
+	if (IS_ENABLED(CONFIG_PREEMPT_RT))
+		preempt_disable();
+	else
+		local_irq_save(flags);
 	write_seqcount_begin(&syncp->seq);
 #endif
 	return flags;
@@ -153,15 +160,18 @@ static inline void
 u64_stats_update_end_irqrestore(struct u64_stats_sync *syncp,
 				unsigned long flags)
 {
-#if BITS_PER_LONG==32 && defined(CONFIG_SMP)
+#if BITS_PER_LONG == 32 && (defined(CONFIG_SMP) || defined(CONFIG_PREEMPT_RT))
 	write_seqcount_end(&syncp->seq);
-	local_irq_restore(flags);
+	if (IS_ENABLED(CONFIG_PREEMPT_RT))
+		preempt_enable();
+	else
+		local_irq_restore(flags);
 #endif
 }
 
 static inline unsigned int __u64_stats_fetch_begin(const struct u64_stats_sync *syncp)
 {
-#if BITS_PER_LONG==32 && defined(CONFIG_SMP)
+#if BITS_PER_LONG == 32 && (defined(CONFIG_SMP) || defined(CONFIG_PREEMPT_RT))
 	return read_seqcount_begin(&syncp->seq);
 #else
 	return 0;
@@ -170,7 +180,7 @@ static inline unsigned int __u64_stats_fetch_begin(const struct u64_stats_sync *
 
 static inline unsigned int u64_stats_fetch_begin(const struct u64_stats_sync *syncp)
 {
-#if BITS_PER_LONG==32 && !defined(CONFIG_SMP)
+#if BITS_PER_LONG == 32 && (!defined(CONFIG_SMP) && !defined(CONFIG_PREEMPT_RT))
 	preempt_disable();
 #endif
 	return __u64_stats_fetch_begin(syncp);
@@ -179,7 +189,7 @@ static inline unsigned int u64_stats_fetch_begin(const struct u64_stats_sync *sy
 static inline bool __u64_stats_fetch_retry(const struct u64_stats_sync *syncp,
 					 unsigned int start)
 {
-#if BITS_PER_LONG==32 && defined(CONFIG_SMP)
+#if BITS_PER_LONG == 32 && (defined(CONFIG_SMP) || defined(CONFIG_PREEMPT_RT))
 	return read_seqcount_retry(&syncp->seq, start);
 #else
 	return false;
@@ -189,7 +199,7 @@ static inline bool __u64_stats_fetch_retry(const struct u64_stats_sync *syncp,
 static inline bool u64_stats_fetch_retry(const struct u64_stats_sync *syncp,
 					 unsigned int start)
 {
-#if BITS_PER_LONG==32 && !defined(CONFIG_SMP)
+#if BITS_PER_LONG == 32 && (!defined(CONFIG_SMP) && !defined(CONFIG_PREEMPT_RT))
 	preempt_enable();
 #endif
 	return __u64_stats_fetch_retry(syncp, start);
@@ -203,7 +213,9 @@ static inline bool u64_stats_fetch_retry(const struct u64_stats_sync *syncp,
  */
 static inline unsigned int u64_stats_fetch_begin_irq(const struct u64_stats_sync *syncp)
 {
-#if BITS_PER_LONG==32 && !defined(CONFIG_SMP)
+#if BITS_PER_LONG == 32 && defined(CONFIG_PREEMPT_RT)
+	preempt_disable();
+#elif BITS_PER_LONG == 32 && !defined(CONFIG_SMP)
 	local_irq_disable();
 #endif
 	return __u64_stats_fetch_begin(syncp);
@@ -212,7 +224,9 @@ static inline unsigned int u64_stats_fetch_begin_irq(const struct u64_stats_sync
 static inline bool u64_stats_fetch_retry_irq(const struct u64_stats_sync *syncp,
 					     unsigned int start)
 {
-#if BITS_PER_LONG==32 && !defined(CONFIG_SMP)
+#if BITS_PER_LONG == 32 && defined(CONFIG_PREEMPT_RT)
+	preempt_enable();
+#elif BITS_PER_LONG == 32 && !defined(CONFIG_SMP)
 	local_irq_enable();
 #endif
 	return __u64_stats_fetch_retry(syncp, start);
diff --git a/include/linux/vmstat.h b/include/linux/vmstat.h
index 322dcbfcc933..9a3a10ea3e3c 100644
--- a/include/linux/vmstat.h
+++ b/include/linux/vmstat.h
@@ -63,7 +63,9 @@ DECLARE_PER_CPU(struct vm_event_state, vm_event_states);
  */
 static inline void __count_vm_event(enum vm_event_item item)
 {
+	preempt_disable_rt();
 	raw_cpu_inc(vm_event_states.event[item]);
+	preempt_enable_rt();
 }
 
 static inline void count_vm_event(enum vm_event_item item)
@@ -73,7 +75,9 @@ static inline void count_vm_event(enum vm_event_item item)
 
 static inline void __count_vm_events(enum vm_event_item item, long delta)
 {
+	preempt_disable_rt();
 	raw_cpu_add(vm_event_states.event[item], delta);
+	preempt_enable_rt();
 }
 
 static inline void count_vm_events(enum vm_event_item item, long delta)
diff --git a/include/linux/vtime.h b/include/linux/vtime.h
index 2cdeca062db3..041d6524d144 100644
--- a/include/linux/vtime.h
+++ b/include/linux/vtime.h
@@ -83,36 +83,46 @@ static inline void vtime_init_idle(struct task_struct *tsk, int cpu) { }
 #endif
 
 #ifdef CONFIG_VIRT_CPU_ACCOUNTING_NATIVE
-extern void vtime_account_irq_enter(struct task_struct *tsk);
-static inline void vtime_account_irq_exit(struct task_struct *tsk)
-{
-	/* On hard|softirq exit we always account to hard|softirq cputime */
-	vtime_account_kernel(tsk);
-}
+extern void vtime_account_irq(struct task_struct *tsk, unsigned int offset);
+extern void vtime_account_softirq(struct task_struct *tsk);
+extern void vtime_account_hardirq(struct task_struct *tsk);
 extern void vtime_flush(struct task_struct *tsk);
 #else /* !CONFIG_VIRT_CPU_ACCOUNTING_NATIVE */
-static inline void vtime_account_irq_enter(struct task_struct *tsk) { }
-static inline void vtime_account_irq_exit(struct task_struct *tsk) { }
+static inline void vtime_account_irq(struct task_struct *tsk, unsigned int offset) { }
+static inline void vtime_account_softirq(struct task_struct *tsk) { }
+static inline void vtime_account_hardirq(struct task_struct *tsk) { }
 static inline void vtime_flush(struct task_struct *tsk) { }
 #endif
 
 
 #ifdef CONFIG_IRQ_TIME_ACCOUNTING
-extern void irqtime_account_irq(struct task_struct *tsk);
+extern void irqtime_account_irq(struct task_struct *tsk, unsigned int offset);
 #else
-static inline void irqtime_account_irq(struct task_struct *tsk) { }
+static inline void irqtime_account_irq(struct task_struct *tsk, unsigned int offset) { }
 #endif
 
-static inline void account_irq_enter_time(struct task_struct *tsk)
+static inline void account_softirq_enter(struct task_struct *tsk)
+{
+	vtime_account_irq(tsk, SOFTIRQ_OFFSET);
+	irqtime_account_irq(tsk, SOFTIRQ_OFFSET);
+}
+
+static inline void account_softirq_exit(struct task_struct *tsk)
+{
+	vtime_account_softirq(tsk);
+	irqtime_account_irq(tsk, 0);
+}
+
+static inline void account_hardirq_enter(struct task_struct *tsk)
 {
-	vtime_account_irq_enter(tsk);
-	irqtime_account_irq(tsk);
+	vtime_account_irq(tsk, HARDIRQ_OFFSET);
+	irqtime_account_irq(tsk, HARDIRQ_OFFSET);
 }
 
-static inline void account_irq_exit_time(struct task_struct *tsk)
+static inline void account_hardirq_exit(struct task_struct *tsk)
 {
-	vtime_account_irq_exit(tsk);
-	irqtime_account_irq(tsk);
+	vtime_account_hardirq(tsk);
+	irqtime_account_irq(tsk, 0);
 }
 
 #endif /* _LINUX_KERNEL_VTIME_H */
diff --git a/include/linux/wait.h b/include/linux/wait.h
index 1663e47681a3..20aae69387aa 100644
--- a/include/linux/wait.h
+++ b/include/linux/wait.h
@@ -10,6 +10,7 @@
 
 #include <asm/current.h>
 #include <uapi/linux/wait.h>
+#include <linux/atomic.h>
 
 typedef struct wait_queue_entry wait_queue_entry_t;
 
diff --git a/include/linux/ww_mutex.h b/include/linux/ww_mutex.h
index 6ecf2a0220db..3145de598645 100644
--- a/include/linux/ww_mutex.h
+++ b/include/linux/ww_mutex.h
@@ -28,6 +28,14 @@ struct ww_class {
 	unsigned int is_wait_die;
 };
 
+struct ww_mutex {
+	struct mutex base;
+	struct ww_acquire_ctx *ctx;
+#ifdef CONFIG_DEBUG_MUTEXES
+	struct ww_class *ww_class;
+#endif
+};
+
 struct ww_acquire_ctx {
 	struct task_struct *task;
 	unsigned long stamp;
diff --git a/include/net/gen_stats.h b/include/net/gen_stats.h
index 1424e02cef90..163f8415e5db 100644
--- a/include/net/gen_stats.h
+++ b/include/net/gen_stats.h
@@ -6,6 +6,7 @@
 #include <linux/socket.h>
 #include <linux/rtnetlink.h>
 #include <linux/pkt_sched.h>
+#include <net/net_seq_lock.h>
 
 /* Note: this used to be in include/uapi/linux/gen_stats.h */
 struct gnet_stats_basic_packed {
@@ -42,15 +43,15 @@ int gnet_stats_start_copy_compat(struct sk_buff *skb, int type,
 				 spinlock_t *lock, struct gnet_dump *d,
 				 int padattr);
 
-int gnet_stats_copy_basic(const seqcount_t *running,
+int gnet_stats_copy_basic(net_seqlock_t *running,
 			  struct gnet_dump *d,
 			  struct gnet_stats_basic_cpu __percpu *cpu,
 			  struct gnet_stats_basic_packed *b);
-void __gnet_stats_copy_basic(const seqcount_t *running,
+void __gnet_stats_copy_basic(net_seqlock_t *running,
 			     struct gnet_stats_basic_packed *bstats,
 			     struct gnet_stats_basic_cpu __percpu *cpu,
 			     struct gnet_stats_basic_packed *b);
-int gnet_stats_copy_basic_hw(const seqcount_t *running,
+int gnet_stats_copy_basic_hw(net_seqlock_t *running,
 			     struct gnet_dump *d,
 			     struct gnet_stats_basic_cpu __percpu *cpu,
 			     struct gnet_stats_basic_packed *b);
@@ -70,13 +71,13 @@ int gen_new_estimator(struct gnet_stats_basic_packed *bstats,
 		      struct gnet_stats_basic_cpu __percpu *cpu_bstats,
 		      struct net_rate_estimator __rcu **rate_est,
 		      spinlock_t *lock,
-		      seqcount_t *running, struct nlattr *opt);
+		      net_seqlock_t *running, struct nlattr *opt);
 void gen_kill_estimator(struct net_rate_estimator __rcu **ptr);
 int gen_replace_estimator(struct gnet_stats_basic_packed *bstats,
 			  struct gnet_stats_basic_cpu __percpu *cpu_bstats,
 			  struct net_rate_estimator __rcu **ptr,
 			  spinlock_t *lock,
-			  seqcount_t *running, struct nlattr *opt);
+			  net_seqlock_t *running, struct nlattr *opt);
 bool gen_estimator_active(struct net_rate_estimator __rcu **ptr);
 bool gen_estimator_read(struct net_rate_estimator __rcu **ptr,
 			struct gnet_stats_rate_est64 *sample);
diff --git a/include/net/net_seq_lock.h b/include/net/net_seq_lock.h
new file mode 100644
index 000000000000..67710bace741
--- /dev/null
+++ b/include/net/net_seq_lock.h
@@ -0,0 +1,15 @@
+#ifndef __NET_NET_SEQ_LOCK_H__
+#define __NET_NET_SEQ_LOCK_H__
+
+#ifdef CONFIG_PREEMPT_RT
+# define net_seqlock_t			seqlock_t
+# define net_seq_begin(__r)		read_seqbegin(__r)
+# define net_seq_retry(__r, __s)	read_seqretry(__r, __s)
+
+#else
+# define net_seqlock_t			seqcount_t
+# define net_seq_begin(__r)		read_seqcount_begin(__r)
+# define net_seq_retry(__r, __s)	read_seqcount_retry(__r, __s)
+#endif
+
+#endif
diff --git a/include/net/netns/xfrm.h b/include/net/netns/xfrm.h
index 9144e0f09a30..464d14b2aca3 100644
--- a/include/net/netns/xfrm.h
+++ b/include/net/netns/xfrm.h
@@ -74,7 +74,7 @@ struct netns_xfrm {
 	struct dst_ops		xfrm6_dst_ops;
 #endif
 	spinlock_t		xfrm_state_lock;
-	seqcount_t		xfrm_state_hash_generation;
+	seqcount_spinlock_t	xfrm_state_hash_generation;
 	seqcount_spinlock_t	xfrm_policy_hash_generation;
 
 	spinlock_t xfrm_policy_lock;
diff --git a/include/net/sch_generic.h b/include/net/sch_generic.h
index 250569d8df65..c8b8dba10d9a 100644
--- a/include/net/sch_generic.h
+++ b/include/net/sch_generic.h
@@ -10,6 +10,7 @@
 #include <linux/percpu.h>
 #include <linux/dynamic_queue_limits.h>
 #include <linux/list.h>
+#include <net/net_seq_lock.h>
 #include <linux/refcount.h>
 #include <linux/workqueue.h>
 #include <linux/mutex.h>
@@ -102,7 +103,7 @@ struct Qdisc {
 	struct sk_buff_head	gso_skb ____cacheline_aligned_in_smp;
 	struct qdisc_skb_head	q;
 	struct gnet_stats_basic_packed bstats;
-	seqcount_t		running;
+	net_seqlock_t		running;
 	struct gnet_stats_queue	qstats;
 	unsigned long		state;
 	struct Qdisc            *next_sched;
@@ -146,7 +147,11 @@ static inline bool qdisc_is_running(struct Qdisc *qdisc)
 {
 	if (qdisc->flags & TCQ_F_NOLOCK)
 		return spin_is_locked(&qdisc->seqlock);
+#ifdef CONFIG_PREEMPT_RT
+	return spin_is_locked(&qdisc->running.lock) ? true : false;
+#else
 	return (raw_read_seqcount(&qdisc->running) & 1) ? true : false;
+#endif
 }
 
 static inline bool qdisc_is_percpu_stats(const struct Qdisc *q)
@@ -187,17 +192,35 @@ static inline bool qdisc_run_begin(struct Qdisc *qdisc)
 	} else if (qdisc_is_running(qdisc)) {
 		return false;
 	}
+#ifdef CONFIG_PREEMPT_RT
+	if (spin_trylock(&qdisc->running.lock)) {
+		seqcount_t *s = &qdisc->running.seqcount.seqcount;
+		/*
+		 * Variant of write_seqcount_t_begin() telling lockdep that a
+		 * trylock was attempted.
+		 */
+		raw_write_seqcount_t_begin(s);
+		seqcount_acquire(&s->dep_map, 0, 1, _RET_IP_);
+		return true;
+	}
+	return false;
+#else
 	/* Variant of write_seqcount_begin() telling lockdep a trylock
 	 * was attempted.
 	 */
 	raw_write_seqcount_begin(&qdisc->running);
 	seqcount_acquire(&qdisc->running.dep_map, 0, 1, _RET_IP_);
 	return true;
+#endif
 }
 
 static inline void qdisc_run_end(struct Qdisc *qdisc)
 {
+#ifdef CONFIG_PREEMPT_RT
+	write_sequnlock(&qdisc->running);
+#else
 	write_seqcount_end(&qdisc->running);
+#endif
 	if (qdisc->flags & TCQ_F_NOLOCK) {
 		spin_unlock(&qdisc->seqlock);
 
@@ -591,7 +614,7 @@ static inline spinlock_t *qdisc_root_sleeping_lock(const struct Qdisc *qdisc)
 	return qdisc_lock(root);
 }
 
-static inline seqcount_t *qdisc_root_sleeping_running(const struct Qdisc *qdisc)
+static inline net_seqlock_t *qdisc_root_sleeping_running(const struct Qdisc *qdisc)
 {
 	struct Qdisc *root = qdisc_root_sleeping(qdisc);
 
diff --git a/include/trace/events/sched.h b/include/trace/events/sched.h
index eb5ec1fb66b4..0e5ff10e57b2 100644
--- a/include/trace/events/sched.h
+++ b/include/trace/events/sched.h
@@ -705,6 +705,18 @@ DECLARE_TRACE(sched_update_nr_running_tp,
 	TP_PROTO(struct rq *rq, int change),
 	TP_ARGS(rq, change));
 
+DECLARE_TRACE(sched_migrate_disable_tp,
+	      TP_PROTO(struct task_struct *p),
+	      TP_ARGS(p));
+
+DECLARE_TRACE(sched_migrate_enable_tp,
+	      TP_PROTO(struct task_struct *p),
+	      TP_ARGS(p));
+
+DECLARE_TRACE(sched_migrate_pull_tp,
+	      TP_PROTO(struct task_struct *p),
+	      TP_ARGS(p));
+
 DECLARE_EVENT_CLASS(psi_memstall_template,
 
 	TP_PROTO(unsigned long function),
diff --git a/init/Kconfig b/init/Kconfig
index b137a6c043ac..ea2b1b7043a4 100644
--- a/init/Kconfig
+++ b/init/Kconfig
@@ -866,7 +866,7 @@ config NUMA_BALANCING
 	bool "Memory placement aware NUMA scheduler"
 	depends on ARCH_SUPPORTS_NUMA_BALANCING
 	depends on !ARCH_WANT_NUMA_VARIABLE_LOCALITY
-	depends on SMP && NUMA && MIGRATION
+	depends on SMP && NUMA && MIGRATION && !PREEMPT_RT
 	help
 	  This option adds support for automatic NUMA aware memory/task placement.
 	  The mechanism is quite primitive and is based on migrating memory when
@@ -1005,6 +1005,7 @@ config CFS_BANDWIDTH
 config RT_GROUP_SCHED
 	bool "Group scheduling for SCHED_RR/FIFO"
 	depends on CGROUP_SCHED
+	depends on !PREEMPT_RT
 	default n
 	help
 	  This feature lets you explicitly allocate real CPU bandwidth
@@ -1977,6 +1978,7 @@ choice
 
 config SLAB
 	bool "SLAB"
+	depends on !PREEMPT_RT
 	select HAVE_HARDENED_USERCOPY_ALLOCATOR
 	help
 	  The regular slab allocator that is established and known to work
@@ -1997,6 +1999,7 @@ config SLUB
 config SLOB
 	depends on EXPERT
 	bool "SLOB (Simple Allocator)"
+	depends on !PREEMPT_RT
 	help
 	   SLOB replaces the stock allocator with a drastically simpler
 	   allocator. SLOB is generally more space efficient but
@@ -2063,7 +2066,7 @@ config SHUFFLE_PAGE_ALLOCATOR
 
 config SLUB_CPU_PARTIAL
 	default y
-	depends on SLUB && SMP
+	depends on SLUB && SMP && !PREEMPT_RT
 	bool "SLUB per cpu partial cache"
 	help
 	  Per cpu partial caches accelerate objects allocation and freeing
diff --git a/kernel/Kconfig.locks b/kernel/Kconfig.locks
index 3de8fd11873b..4198f0273ecd 100644
--- a/kernel/Kconfig.locks
+++ b/kernel/Kconfig.locks
@@ -251,7 +251,7 @@ config ARCH_USE_QUEUED_RWLOCKS
 
 config QUEUED_RWLOCKS
 	def_bool y if ARCH_USE_QUEUED_RWLOCKS
-	depends on SMP
+	depends on SMP && !PREEMPT_RT
 
 config ARCH_HAS_MMIOWB
 	bool
diff --git a/kernel/Kconfig.preempt b/kernel/Kconfig.preempt
index e62a623031ea..b95f8784c4e4 100644
--- a/kernel/Kconfig.preempt
+++ b/kernel/Kconfig.preempt
@@ -1,5 +1,11 @@
 # SPDX-License-Identifier: GPL-2.0-only
 
+config HAVE_PREEMPT_LAZY
+	bool
+
+config PREEMPT_LAZY
+	def_bool y if HAVE_PREEMPT_LAZY && PREEMPT_RT
+
 choice
 	prompt "Preemption Model"
 	default PREEMPT_NONE
@@ -60,6 +66,7 @@ config PREEMPT_RT
 	bool "Fully Preemptible Kernel (Real-Time)"
 	depends on EXPERT && ARCH_SUPPORTS_RT
 	select PREEMPTION
+	select RT_MUTEXES
 	help
 	  This option turns the kernel into a real-time kernel by replacing
 	  various locking primitives (spinlocks, rwlocks, etc.) with
diff --git a/kernel/cgroup/cpuset.c b/kernel/cgroup/cpuset.c
index dc1f782f8e0a..879204826e1b 100644
--- a/kernel/cgroup/cpuset.c
+++ b/kernel/cgroup/cpuset.c
@@ -351,7 +351,7 @@ void cpuset_read_unlock(void)
 	percpu_up_read(&cpuset_rwsem);
 }
 
-static DEFINE_SPINLOCK(callback_lock);
+static DEFINE_RAW_SPINLOCK(callback_lock);
 
 static struct workqueue_struct *cpuset_migrate_mm_wq;
 
@@ -1290,7 +1290,7 @@ static int update_parent_subparts_cpumask(struct cpuset *cpuset, int cmd,
 	 * Newly added CPUs will be removed from effective_cpus and
 	 * newly deleted ones will be added back to effective_cpus.
 	 */
-	spin_lock_irq(&callback_lock);
+	raw_spin_lock_irq(&callback_lock);
 	if (adding) {
 		cpumask_or(parent->subparts_cpus,
 			   parent->subparts_cpus, tmp->addmask);
@@ -1312,7 +1312,7 @@ static int update_parent_subparts_cpumask(struct cpuset *cpuset, int cmd,
 
 	if (cpuset->partition_root_state != new_prs)
 		cpuset->partition_root_state = new_prs;
-	spin_unlock_irq(&callback_lock);
+	raw_spin_unlock_irq(&callback_lock);
 
 	return cmd == partcmd_update;
 }
@@ -1415,7 +1415,7 @@ static void update_cpumasks_hier(struct cpuset *cs, struct tmpmasks *tmp)
 			continue;
 		rcu_read_unlock();
 
-		spin_lock_irq(&callback_lock);
+		raw_spin_lock_irq(&callback_lock);
 
 		cpumask_copy(cp->effective_cpus, tmp->new_cpus);
 		if (cp->nr_subparts_cpus && (new_prs != PRS_ENABLED)) {
@@ -1449,7 +1449,7 @@ static void update_cpumasks_hier(struct cpuset *cs, struct tmpmasks *tmp)
 		if (new_prs != cp->partition_root_state)
 			cp->partition_root_state = new_prs;
 
-		spin_unlock_irq(&callback_lock);
+		raw_spin_unlock_irq(&callback_lock);
 
 		WARN_ON(!is_in_v2_mode() &&
 			!cpumask_equal(cp->cpus_allowed, cp->effective_cpus));
@@ -1577,7 +1577,7 @@ static int update_cpumask(struct cpuset *cs, struct cpuset *trialcs,
 			return -EINVAL;
 	}
 
-	spin_lock_irq(&callback_lock);
+	raw_spin_lock_irq(&callback_lock);
 	cpumask_copy(cs->cpus_allowed, trialcs->cpus_allowed);
 
 	/*
@@ -1587,7 +1587,7 @@ static int update_cpumask(struct cpuset *cs, struct cpuset *trialcs,
 		cpumask_and(cs->subparts_cpus, cs->subparts_cpus, cs->cpus_allowed);
 		cs->nr_subparts_cpus = cpumask_weight(cs->subparts_cpus);
 	}
-	spin_unlock_irq(&callback_lock);
+	raw_spin_unlock_irq(&callback_lock);
 
 	update_cpumasks_hier(cs, &tmp);
 
@@ -1781,9 +1781,9 @@ static void update_nodemasks_hier(struct cpuset *cs, nodemask_t *new_mems)
 			continue;
 		rcu_read_unlock();
 
-		spin_lock_irq(&callback_lock);
+		raw_spin_lock_irq(&callback_lock);
 		cp->effective_mems = *new_mems;
-		spin_unlock_irq(&callback_lock);
+		raw_spin_unlock_irq(&callback_lock);
 
 		WARN_ON(!is_in_v2_mode() &&
 			!nodes_equal(cp->mems_allowed, cp->effective_mems));
@@ -1851,9 +1851,9 @@ static int update_nodemask(struct cpuset *cs, struct cpuset *trialcs,
 	if (retval < 0)
 		goto done;
 
-	spin_lock_irq(&callback_lock);
+	raw_spin_lock_irq(&callback_lock);
 	cs->mems_allowed = trialcs->mems_allowed;
-	spin_unlock_irq(&callback_lock);
+	raw_spin_unlock_irq(&callback_lock);
 
 	/* use trialcs->mems_allowed as a temp variable */
 	update_nodemasks_hier(cs, &trialcs->mems_allowed);
@@ -1944,9 +1944,9 @@ static int update_flag(cpuset_flagbits_t bit, struct cpuset *cs,
 	spread_flag_changed = ((is_spread_slab(cs) != is_spread_slab(trialcs))
 			|| (is_spread_page(cs) != is_spread_page(trialcs)));
 
-	spin_lock_irq(&callback_lock);
+	raw_spin_lock_irq(&callback_lock);
 	cs->flags = trialcs->flags;
-	spin_unlock_irq(&callback_lock);
+	raw_spin_unlock_irq(&callback_lock);
 
 	if (!cpumask_empty(trialcs->cpus_allowed) && balance_flag_changed)
 		rebuild_sched_domains_locked();
@@ -2037,9 +2037,9 @@ static int update_prstate(struct cpuset *cs, int new_prs)
 	rebuild_sched_domains_locked();
 out:
 	if (!err) {
-		spin_lock_irq(&callback_lock);
+		raw_spin_lock_irq(&callback_lock);
 		cs->partition_root_state = new_prs;
-		spin_unlock_irq(&callback_lock);
+		raw_spin_unlock_irq(&callback_lock);
 	}
 
 	free_cpumasks(NULL, &tmpmask);
@@ -2457,7 +2457,7 @@ static int cpuset_common_seq_show(struct seq_file *sf, void *v)
 	cpuset_filetype_t type = seq_cft(sf)->private;
 	int ret = 0;
 
-	spin_lock_irq(&callback_lock);
+	raw_spin_lock_irq(&callback_lock);
 
 	switch (type) {
 	case FILE_CPULIST:
@@ -2479,7 +2479,7 @@ static int cpuset_common_seq_show(struct seq_file *sf, void *v)
 		ret = -EINVAL;
 	}
 
-	spin_unlock_irq(&callback_lock);
+	raw_spin_unlock_irq(&callback_lock);
 	return ret;
 }
 
@@ -2792,14 +2792,14 @@ static int cpuset_css_online(struct cgroup_subsys_state *css)
 
 	cpuset_inc();
 
-	spin_lock_irq(&callback_lock);
+	raw_spin_lock_irq(&callback_lock);
 	if (is_in_v2_mode()) {
 		cpumask_copy(cs->effective_cpus, parent->effective_cpus);
 		cs->effective_mems = parent->effective_mems;
 		cs->use_parent_ecpus = true;
 		parent->child_ecpus_count++;
 	}
-	spin_unlock_irq(&callback_lock);
+	raw_spin_unlock_irq(&callback_lock);
 
 	if (!test_bit(CGRP_CPUSET_CLONE_CHILDREN, &css->cgroup->flags))
 		goto out_unlock;
@@ -2826,12 +2826,12 @@ static int cpuset_css_online(struct cgroup_subsys_state *css)
 	}
 	rcu_read_unlock();
 
-	spin_lock_irq(&callback_lock);
+	raw_spin_lock_irq(&callback_lock);
 	cs->mems_allowed = parent->mems_allowed;
 	cs->effective_mems = parent->mems_allowed;
 	cpumask_copy(cs->cpus_allowed, parent->cpus_allowed);
 	cpumask_copy(cs->effective_cpus, parent->cpus_allowed);
-	spin_unlock_irq(&callback_lock);
+	raw_spin_unlock_irq(&callback_lock);
 out_unlock:
 	percpu_up_write(&cpuset_rwsem);
 	put_online_cpus();
@@ -2887,7 +2887,7 @@ static void cpuset_css_free(struct cgroup_subsys_state *css)
 static void cpuset_bind(struct cgroup_subsys_state *root_css)
 {
 	percpu_down_write(&cpuset_rwsem);
-	spin_lock_irq(&callback_lock);
+	raw_spin_lock_irq(&callback_lock);
 
 	if (is_in_v2_mode()) {
 		cpumask_copy(top_cpuset.cpus_allowed, cpu_possible_mask);
@@ -2898,7 +2898,7 @@ static void cpuset_bind(struct cgroup_subsys_state *root_css)
 		top_cpuset.mems_allowed = top_cpuset.effective_mems;
 	}
 
-	spin_unlock_irq(&callback_lock);
+	raw_spin_unlock_irq(&callback_lock);
 	percpu_up_write(&cpuset_rwsem);
 }
 
@@ -2995,12 +2995,12 @@ hotplug_update_tasks_legacy(struct cpuset *cs,
 {
 	bool is_empty;
 
-	spin_lock_irq(&callback_lock);
+	raw_spin_lock_irq(&callback_lock);
 	cpumask_copy(cs->cpus_allowed, new_cpus);
 	cpumask_copy(cs->effective_cpus, new_cpus);
 	cs->mems_allowed = *new_mems;
 	cs->effective_mems = *new_mems;
-	spin_unlock_irq(&callback_lock);
+	raw_spin_unlock_irq(&callback_lock);
 
 	/*
 	 * Don't call update_tasks_cpumask() if the cpuset becomes empty,
@@ -3037,10 +3037,10 @@ hotplug_update_tasks(struct cpuset *cs,
 	if (nodes_empty(*new_mems))
 		*new_mems = parent_cs(cs)->effective_mems;
 
-	spin_lock_irq(&callback_lock);
+	raw_spin_lock_irq(&callback_lock);
 	cpumask_copy(cs->effective_cpus, new_cpus);
 	cs->effective_mems = *new_mems;
-	spin_unlock_irq(&callback_lock);
+	raw_spin_unlock_irq(&callback_lock);
 
 	if (cpus_updated)
 		update_tasks_cpumask(cs);
@@ -3107,10 +3107,10 @@ static void cpuset_hotplug_update_tasks(struct cpuset *cs, struct tmpmasks *tmp)
 	if (is_partition_root(cs) && (cpumask_empty(&new_cpus) ||
 	   (parent->partition_root_state == PRS_ERROR))) {
 		if (cs->nr_subparts_cpus) {
-			spin_lock_irq(&callback_lock);
+			raw_spin_lock_irq(&callback_lock);
 			cs->nr_subparts_cpus = 0;
 			cpumask_clear(cs->subparts_cpus);
-			spin_unlock_irq(&callback_lock);
+			raw_spin_unlock_irq(&callback_lock);
 			compute_effective_cpumask(&new_cpus, cs, parent);
 		}
 
@@ -3124,9 +3124,9 @@ static void cpuset_hotplug_update_tasks(struct cpuset *cs, struct tmpmasks *tmp)
 		     cpumask_empty(&new_cpus)) {
 			update_parent_subparts_cpumask(cs, partcmd_disable,
 						       NULL, tmp);
-			spin_lock_irq(&callback_lock);
+			raw_spin_lock_irq(&callback_lock);
 			cs->partition_root_state = PRS_ERROR;
-			spin_unlock_irq(&callback_lock);
+			raw_spin_unlock_irq(&callback_lock);
 		}
 		cpuset_force_rebuild();
 	}
@@ -3206,7 +3206,7 @@ static void cpuset_hotplug_workfn(struct work_struct *work)
 
 	/* synchronize cpus_allowed to cpu_active_mask */
 	if (cpus_updated) {
-		spin_lock_irq(&callback_lock);
+		raw_spin_lock_irq(&callback_lock);
 		if (!on_dfl)
 			cpumask_copy(top_cpuset.cpus_allowed, &new_cpus);
 		/*
@@ -3226,17 +3226,17 @@ static void cpuset_hotplug_workfn(struct work_struct *work)
 			}
 		}
 		cpumask_copy(top_cpuset.effective_cpus, &new_cpus);
-		spin_unlock_irq(&callback_lock);
+		raw_spin_unlock_irq(&callback_lock);
 		/* we don't mess with cpumasks of tasks in top_cpuset */
 	}
 
 	/* synchronize mems_allowed to N_MEMORY */
 	if (mems_updated) {
-		spin_lock_irq(&callback_lock);
+		raw_spin_lock_irq(&callback_lock);
 		if (!on_dfl)
 			top_cpuset.mems_allowed = new_mems;
 		top_cpuset.effective_mems = new_mems;
-		spin_unlock_irq(&callback_lock);
+		raw_spin_unlock_irq(&callback_lock);
 		update_tasks_nodemask(&top_cpuset);
 	}
 
@@ -3340,11 +3340,11 @@ void cpuset_cpus_allowed(struct task_struct *tsk, struct cpumask *pmask)
 {
 	unsigned long flags;
 
-	spin_lock_irqsave(&callback_lock, flags);
+	raw_spin_lock_irqsave(&callback_lock, flags);
 	rcu_read_lock();
 	guarantee_online_cpus(task_cs(tsk), pmask);
 	rcu_read_unlock();
-	spin_unlock_irqrestore(&callback_lock, flags);
+	raw_spin_unlock_irqrestore(&callback_lock, flags);
 }
 
 /**
@@ -3405,11 +3405,11 @@ nodemask_t cpuset_mems_allowed(struct task_struct *tsk)
 	nodemask_t mask;
 	unsigned long flags;
 
-	spin_lock_irqsave(&callback_lock, flags);
+	raw_spin_lock_irqsave(&callback_lock, flags);
 	rcu_read_lock();
 	guarantee_online_mems(task_cs(tsk), &mask);
 	rcu_read_unlock();
-	spin_unlock_irqrestore(&callback_lock, flags);
+	raw_spin_unlock_irqrestore(&callback_lock, flags);
 
 	return mask;
 }
@@ -3501,14 +3501,14 @@ bool __cpuset_node_allowed(int node, gfp_t gfp_mask)
 		return true;
 
 	/* Not hardwall and node outside mems_allowed: scan up cpusets */
-	spin_lock_irqsave(&callback_lock, flags);
+	raw_spin_lock_irqsave(&callback_lock, flags);
 
 	rcu_read_lock();
 	cs = nearest_hardwall_ancestor(task_cs(current));
 	allowed = node_isset(node, cs->mems_allowed);
 	rcu_read_unlock();
 
-	spin_unlock_irqrestore(&callback_lock, flags);
+	raw_spin_unlock_irqrestore(&callback_lock, flags);
 	return allowed;
 }
 
diff --git a/kernel/cgroup/rstat.c b/kernel/cgroup/rstat.c
index d2ae14d0b9e5..7b3bea56d593 100644
--- a/kernel/cgroup/rstat.c
+++ b/kernel/cgroup/rstat.c
@@ -156,8 +156,9 @@ static void cgroup_rstat_flush_locked(struct cgroup *cgrp, bool may_sleep)
 		raw_spinlock_t *cpu_lock = per_cpu_ptr(&cgroup_rstat_cpu_lock,
 						       cpu);
 		struct cgroup *pos = NULL;
+		unsigned long flags;
 
-		raw_spin_lock(cpu_lock);
+		raw_spin_lock_irqsave(cpu_lock, flags);
 		while ((pos = cgroup_rstat_cpu_pop_updated(pos, cgrp, cpu))) {
 			struct cgroup_subsys_state *css;
 
@@ -169,7 +170,7 @@ static void cgroup_rstat_flush_locked(struct cgroup *cgrp, bool may_sleep)
 				css->ss->css_rstat_flush(css, cpu);
 			rcu_read_unlock();
 		}
-		raw_spin_unlock(cpu_lock);
+		raw_spin_unlock_irqrestore(cpu_lock, flags);
 
 		/* if @may_sleep, play nice and yield if necessary */
 		if (may_sleep && (need_resched() ||
diff --git a/kernel/cpu.c b/kernel/cpu.c
index c06ced18f78a..10b6287afe97 100644
--- a/kernel/cpu.c
+++ b/kernel/cpu.c
@@ -1662,7 +1662,7 @@ static struct cpuhp_step cpuhp_hp_states[] = {
 		.name			= "ap:online",
 	},
 	/*
-	 * Handled on controll processor until the plugged processor manages
+	 * Handled on control processor until the plugged processor manages
 	 * this itself.
 	 */
 	[CPUHP_TEARDOWN_CPU] = {
@@ -1671,6 +1671,13 @@ static struct cpuhp_step cpuhp_hp_states[] = {
 		.teardown.single	= takedown_cpu,
 		.cant_stop		= true,
 	},
+
+	[CPUHP_AP_SCHED_WAIT_EMPTY] = {
+		.name			= "sched:waitempty",
+		.startup.single		= NULL,
+		.teardown.single	= sched_cpu_wait_empty,
+	},
+
 	/* Handle smpboot threads park/unpark */
 	[CPUHP_AP_SMPBOOT_THREADS] = {
 		.name			= "smpboot/threads:online",
diff --git a/kernel/debug/kdb/kdb_main.c b/kernel/debug/kdb/kdb_main.c
index 4e09fab52faf..1f5c577b926e 100644
--- a/kernel/debug/kdb/kdb_main.c
+++ b/kernel/debug/kdb/kdb_main.c
@@ -2157,7 +2157,7 @@ static int kdb_dmesg(int argc, const char **argv)
 	int adjust = 0;
 	int n = 0;
 	int skip = 0;
-	struct kmsg_dumper dumper = { .active = 1 };
+	struct kmsg_dumper_iter iter = { .active = 1 };
 	size_t len;
 	char buf[201];
 
@@ -2182,8 +2182,8 @@ static int kdb_dmesg(int argc, const char **argv)
 		kdb_set(2, setargs);
 	}
 
-	kmsg_dump_rewind_nolock(&dumper);
-	while (kmsg_dump_get_line_nolock(&dumper, 1, NULL, 0, NULL))
+	kmsg_dump_rewind(&iter);
+	while (kmsg_dump_get_line(&iter, 1, NULL, 0, NULL))
 		n++;
 
 	if (lines < 0) {
@@ -2215,8 +2215,8 @@ static int kdb_dmesg(int argc, const char **argv)
 	if (skip >= n || skip < 0)
 		return 0;
 
-	kmsg_dump_rewind_nolock(&dumper);
-	while (kmsg_dump_get_line_nolock(&dumper, 1, buf, sizeof(buf), &len)) {
+	kmsg_dump_rewind(&iter);
+	while (kmsg_dump_get_line(&iter, 1, buf, sizeof(buf), &len)) {
 		if (skip) {
 			skip--;
 			continue;
diff --git a/kernel/entry/common.c b/kernel/entry/common.c
index 2228de39bb4f..4d29b123f0d5 100644
--- a/kernel/entry/common.c
+++ b/kernel/entry/common.c
@@ -2,6 +2,7 @@
 
 #include <linux/context_tracking.h>
 #include <linux/entry-common.h>
+#include <linux/highmem.h>
 #include <linux/livepatch.h>
 #include <linux/audit.h>
 
@@ -148,9 +149,17 @@ static unsigned long exit_to_user_mode_loop(struct pt_regs *regs,
 
 		local_irq_enable_exit_to_user(ti_work);
 
-		if (ti_work & _TIF_NEED_RESCHED)
+		if (ti_work & _TIF_NEED_RESCHED_MASK)
 			schedule();
 
+#ifdef ARCH_RT_DELAYS_SIGNAL_SEND
+		if (unlikely(current->forced_info.si_signo)) {
+			struct task_struct *t = current;
+			force_sig_info(&t->forced_info);
+			t->forced_info.si_signo = 0;
+		}
+#endif
+
 		if (ti_work & _TIF_UPROBE)
 			uprobe_notify_resume(regs);
 
@@ -201,6 +210,7 @@ static void exit_to_user_mode_prepare(struct pt_regs *regs)
 
 	/* Ensure that the address limit is intact and no locks are held */
 	addr_limit_user_check();
+	kmap_assert_nomap();
 	lockdep_assert_irqs_disabled();
 	lockdep_sys_exit();
 }
@@ -360,7 +370,7 @@ void irqentry_exit_cond_resched(void)
 		rcu_irq_exit_check_preempt();
 		if (IS_ENABLED(CONFIG_DEBUG_ENTRY))
 			WARN_ON_ONCE(!on_thread_stack());
-		if (need_resched())
+		if (should_resched(0))
 			preempt_schedule_irq();
 	}
 }
diff --git a/kernel/exit.c b/kernel/exit.c
index d612cb5b5943..f1c818aa5eed 100644
--- a/kernel/exit.c
+++ b/kernel/exit.c
@@ -153,7 +153,7 @@ static void __exit_signal(struct task_struct *tsk)
 	 * Do this under ->siglock, we can race with another thread
 	 * doing sigqueue_free() if we have SIGQUEUE_PREALLOC signals.
 	 */
-	flush_sigqueue(&tsk->pending);
+	flush_task_sigqueue(tsk);
 	tsk->sighand = NULL;
 	spin_unlock(&sighand->siglock);
 
diff --git a/kernel/fork.c b/kernel/fork.c
index 0ac2ae1e8f85..9d563ce0aae5 100644
--- a/kernel/fork.c
+++ b/kernel/fork.c
@@ -42,6 +42,7 @@
 #include <linux/mmu_notifier.h>
 #include <linux/fs.h>
 #include <linux/mm.h>
+#include <linux/kprobes.h>
 #include <linux/vmacache.h>
 #include <linux/nsproxy.h>
 #include <linux/capability.h>
@@ -291,7 +292,7 @@ static inline void free_thread_stack(struct task_struct *tsk)
 			return;
 		}
 
-		vfree_atomic(tsk->stack);
+		vfree(tsk->stack);
 		return;
 	}
 #endif
@@ -692,6 +693,19 @@ void __mmdrop(struct mm_struct *mm)
 }
 EXPORT_SYMBOL_GPL(__mmdrop);
 
+#ifdef CONFIG_PREEMPT_RT
+/*
+ * RCU callback for delayed mm drop. Not strictly rcu, but we don't
+ * want another facility to make this work.
+ */
+void __mmdrop_delayed(struct rcu_head *rhp)
+{
+	struct mm_struct *mm = container_of(rhp, struct mm_struct, delayed_drop);
+
+	__mmdrop(mm);
+}
+#endif
+
 static void mmdrop_async_fn(struct work_struct *work)
 {
 	struct mm_struct *mm;
@@ -733,6 +747,15 @@ void __put_task_struct(struct task_struct *tsk)
 	WARN_ON(refcount_read(&tsk->usage));
 	WARN_ON(tsk == current);
 
+	/*
+	 * Remove function-return probe instances associated with this
+	 * task and put them back on the free list.
+	 */
+	kprobe_flush_task(tsk);
+
+	/* Task is done with its stack. */
+	put_task_stack(tsk);
+
 	io_uring_free(tsk);
 	cgroup_free(tsk);
 	task_numa_free(tsk, true);
@@ -949,10 +972,12 @@ static struct task_struct *dup_task_struct(struct task_struct *orig, int node)
 	tsk->splice_pipe = NULL;
 	tsk->task_frag.page = NULL;
 	tsk->wake_q.next = NULL;
+	tsk->wake_q_sleeper.next = NULL;
 
 	account_kernel_stack(tsk, 1);
 
 	kcov_task_init(tsk);
+	kmap_local_fork(tsk);
 
 #ifdef CONFIG_FAULT_INJECTION
 	tsk->fail_nth = 0;
@@ -2076,6 +2101,7 @@ static __latent_entropy struct task_struct *copy_process(
 	spin_lock_init(&p->alloc_lock);
 
 	init_sigpending(&p->pending);
+	p->sigqueue_cache = NULL;
 
 	p->utime = p->stime = p->gtime = 0;
 #ifdef CONFIG_ARCH_HAS_SCALED_CPUTIME
diff --git a/kernel/futex.c b/kernel/futex.c
index 98a6e1b80bfe..b2b275bc1958 100644
--- a/kernel/futex.c
+++ b/kernel/futex.c
@@ -1498,6 +1498,7 @@ static int wake_futex_pi(u32 __user *uaddr, u32 uval, struct futex_pi_state *pi_
 	struct task_struct *new_owner;
 	bool postunlock = false;
 	DEFINE_WAKE_Q(wake_q);
+	DEFINE_WAKE_Q(wake_sleeper_q);
 	int ret = 0;
 
 	new_owner = rt_mutex_next_owner(&pi_state->pi_mutex);
@@ -1547,14 +1548,15 @@ static int wake_futex_pi(u32 __user *uaddr, u32 uval, struct futex_pi_state *pi_
 		 * not fail.
 		 */
 		pi_state_update_owner(pi_state, new_owner);
-		postunlock = __rt_mutex_futex_unlock(&pi_state->pi_mutex, &wake_q);
+		postunlock = __rt_mutex_futex_unlock(&pi_state->pi_mutex, &wake_q,
+						     &wake_sleeper_q);
 	}
 
 out_unlock:
 	raw_spin_unlock_irq(&pi_state->pi_mutex.wait_lock);
 
 	if (postunlock)
-		rt_mutex_postunlock(&wake_q);
+		rt_mutex_postunlock(&wake_q, &wake_sleeper_q);
 
 	return ret;
 }
@@ -2155,6 +2157,16 @@ static int futex_requeue(u32 __user *uaddr1, unsigned int flags,
 				 */
 				requeue_pi_wake_futex(this, &key2, hb2);
 				continue;
+			} else if (ret == -EAGAIN) {
+				/*
+				 * Waiter was woken by timeout or
+				 * signal and has set pi_blocked_on to
+				 * PI_WAKEUP_INPROGRESS before we
+				 * tried to enqueue it on the rtmutex.
+				 */
+				this->pi_state = NULL;
+				put_pi_state(pi_state);
+				continue;
 			} else if (ret) {
 				/*
 				 * rt_mutex_start_proxy_lock() detected a
@@ -2847,7 +2859,7 @@ static int futex_lock_pi(u32 __user *uaddr, unsigned int flags,
 		goto no_block;
 	}
 
-	rt_mutex_init_waiter(&rt_waiter);
+	rt_mutex_init_waiter(&rt_waiter, false);
 
 	/*
 	 * On PREEMPT_RT_FULL, when hb->lock becomes an rt_mutex, we must not
@@ -3172,7 +3184,7 @@ static int futex_wait_requeue_pi(u32 __user *uaddr, unsigned int flags,
 {
 	struct hrtimer_sleeper timeout, *to;
 	struct rt_mutex_waiter rt_waiter;
-	struct futex_hash_bucket *hb;
+	struct futex_hash_bucket *hb, *hb2;
 	union futex_key key2 = FUTEX_KEY_INIT;
 	struct futex_q q = futex_q_init;
 	int res, ret;
@@ -3193,7 +3205,7 @@ static int futex_wait_requeue_pi(u32 __user *uaddr, unsigned int flags,
 	 * The waiter is allocated on our stack, manipulated by the requeue
 	 * code while we sleep on uaddr.
 	 */
-	rt_mutex_init_waiter(&rt_waiter);
+	rt_mutex_init_waiter(&rt_waiter, false);
 
 	ret = get_futex_key(uaddr2, flags & FLAGS_SHARED, &key2, FUTEX_WRITE);
 	if (unlikely(ret != 0))
@@ -3224,20 +3236,55 @@ static int futex_wait_requeue_pi(u32 __user *uaddr, unsigned int flags,
 	/* Queue the futex_q, drop the hb lock, wait for wakeup. */
 	futex_wait_queue_me(hb, &q, to);
 
-	spin_lock(&hb->lock);
-	ret = handle_early_requeue_pi_wakeup(hb, &q, &key2, to);
-	spin_unlock(&hb->lock);
-	if (ret)
-		goto out;
+	/*
+	 * On RT we must avoid races with requeue and trying to block
+	 * on two mutexes (hb->lock and uaddr2's rtmutex) by
+	 * serializing access to pi_blocked_on with pi_lock.
+	 */
+	raw_spin_lock_irq(&current->pi_lock);
+	if (current->pi_blocked_on) {
+		/*
+		 * We have been requeued or are in the process of
+		 * being requeued.
+		 */
+		raw_spin_unlock_irq(&current->pi_lock);
+	} else {
+		/*
+		 * Setting pi_blocked_on to PI_WAKEUP_INPROGRESS
+		 * prevents a concurrent requeue from moving us to the
+		 * uaddr2 rtmutex. After that we can safely acquire
+		 * (and possibly block on) hb->lock.
+		 */
+		current->pi_blocked_on = PI_WAKEUP_INPROGRESS;
+		raw_spin_unlock_irq(&current->pi_lock);
+
+		spin_lock(&hb->lock);
+
+		/*
+		 * Clean up pi_blocked_on. We might leak it otherwise
+		 * when we succeeded with the hb->lock in the fast
+		 * path.
+		 */
+		raw_spin_lock_irq(&current->pi_lock);
+		current->pi_blocked_on = NULL;
+		raw_spin_unlock_irq(&current->pi_lock);
+
+		ret = handle_early_requeue_pi_wakeup(hb, &q, &key2, to);
+		spin_unlock(&hb->lock);
+		if (ret)
+			goto out;
+	}
 
 	/*
-	 * In order for us to be here, we know our q.key == key2, and since
-	 * we took the hb->lock above, we also know that futex_requeue() has
-	 * completed and we no longer have to concern ourselves with a wakeup
-	 * race with the atomic proxy lock acquisition by the requeue code. The
-	 * futex_requeue dropped our key1 reference and incremented our key2
-	 * reference count.
+	 * In order to be here, we have either been requeued, are in
+	 * the process of being requeued, or requeue successfully
+	 * acquired uaddr2 on our behalf.  If pi_blocked_on was
+	 * non-null above, we may be racing with a requeue.  Do not
+	 * rely on q->lock_ptr to be hb2->lock until after blocking on
+	 * hb->lock or hb2->lock. The futex_requeue dropped our key1
+	 * reference and incremented our key2 reference count.
 	 */
+	hb2 = hash_futex(&key2);
 
 	/* Check if the requeue code acquired the second futex for us. */
 	if (!q.rt_waiter) {
@@ -3246,14 +3293,15 @@ static int futex_wait_requeue_pi(u32 __user *uaddr, unsigned int flags,
 		 * did a lock-steal - fix up the PI-state in that case.
 		 */
 		if (q.pi_state && (q.pi_state->owner != current)) {
-			spin_lock(q.lock_ptr);
+			spin_lock(&hb2->lock);
+			BUG_ON(&hb2->lock != q.lock_ptr);
 			ret = fixup_pi_state_owner(uaddr2, &q, current);
 			/*
 			 * Drop the reference to the pi state which
 			 * the requeue_pi() code acquired for us.
 			 */
 			put_pi_state(q.pi_state);
-			spin_unlock(q.lock_ptr);
+			spin_unlock(&hb2->lock);
 			/*
 			 * Adjust the return value. It's either -EFAULT or
 			 * success (1) but the caller expects 0 for success.
@@ -3272,7 +3320,8 @@ static int futex_wait_requeue_pi(u32 __user *uaddr, unsigned int flags,
 		pi_mutex = &q.pi_state->pi_mutex;
 		ret = rt_mutex_wait_proxy_lock(pi_mutex, to, &rt_waiter);
 
-		spin_lock(q.lock_ptr);
+		spin_lock(&hb2->lock);
+		BUG_ON(&hb2->lock != q.lock_ptr);
 		if (ret && !rt_mutex_cleanup_proxy_lock(pi_mutex, &rt_waiter))
 			ret = 0;
 
diff --git a/kernel/irq/manage.c b/kernel/irq/manage.c
index 239f5084bfb2..56aff6396080 100644
--- a/kernel/irq/manage.c
+++ b/kernel/irq/manage.c
@@ -1301,7 +1301,7 @@ static int irq_thread(void *data)
 			struct irqaction *action);
 
 	irq_thread_set_ready(desc, action);
-
+  sched_set_fifo(current);
 	if (force_irqthreads && test_bit(IRQTF_FORCED_THREAD,
 					&action->thread_flags))
 		handler_fn = irq_forced_thread_fn;
@@ -1322,6 +1322,11 @@ static int irq_thread(void *data)
 		if (action_ret == IRQ_WAKE_THREAD)
 			irq_wake_secondary(desc, action);
 
+		if (IS_ENABLED(CONFIG_PREEMPT_RT)) {
+			migrate_disable();
+			add_interrupt_randomness(action->irq);
+			migrate_enable();
+		}
 		wake_threads_waitq(desc);
 	}
 
@@ -1467,8 +1472,6 @@ setup_irq_thread(struct irqaction *new, unsigned int irq, bool secondary)
 	if (IS_ERR(t))
 		return PTR_ERR(t);
 
-	sched_set_fifo(t);
-
 	/*
 	 * We keep the reference to the task struct even if
 	 * the thread dies to avoid that the interrupt code
@@ -2857,7 +2860,7 @@ EXPORT_SYMBOL_GPL(irq_get_irqchip_state);
  *	This call sets the internal irqchip state of an interrupt,
  *	depending on the value of @which.
  *
- *	This function should be called with preemption disabled if the
+ *	This function should be called with migration disabled if the
  *	interrupt controller has per-cpu registers.
  */
 int irq_set_irqchip_state(unsigned int irq, enum irqchip_irq_state which,
diff --git a/kernel/irq/spurious.c b/kernel/irq/spurious.c
index f865e5f4d382..dc7311dd74b1 100644
--- a/kernel/irq/spurious.c
+++ b/kernel/irq/spurious.c
@@ -443,6 +443,10 @@ MODULE_PARM_DESC(noirqdebug, "Disable irq lockup detection when true");
 
 static int __init irqfixup_setup(char *str)
 {
+#ifdef CONFIG_PREEMPT_RT
+	pr_warn("irqfixup boot option not supported w/ CONFIG_PREEMPT_RT\n");
+	return 1;
+#endif
 	irqfixup = 1;
 	printk(KERN_WARNING "Misrouted IRQ fixup support enabled.\n");
 	printk(KERN_WARNING "This may impact system performance.\n");
@@ -455,6 +459,10 @@ module_param(irqfixup, int, 0644);
 
 static int __init irqpoll_setup(char *str)
 {
+#ifdef CONFIG_PREEMPT_RT
+	pr_warn("irqpoll boot option not supported w/ CONFIG_PREEMPT_RT\n");
+	return 1;
+#endif
 	irqfixup = 2;
 	printk(KERN_WARNING "Misrouted IRQ fixup and polling support "
 				"enabled\n");
diff --git a/kernel/irq_work.c b/kernel/irq_work.c
index fbff25adb574..711bd5e87201 100644
--- a/kernel/irq_work.c
+++ b/kernel/irq_work.c
@@ -18,11 +18,37 @@
 #include <linux/cpu.h>
 #include <linux/notifier.h>
 #include <linux/smp.h>
+#include <linux/smpboot.h>
+#include <linux/interrupt.h>
 #include <asm/processor.h>
 
 
 static DEFINE_PER_CPU(struct llist_head, raised_list);
 static DEFINE_PER_CPU(struct llist_head, lazy_list);
+static DEFINE_PER_CPU(struct task_struct *, irq_workd);
+
+static void wake_irq_workd(void)
+{
+	struct task_struct *tsk = __this_cpu_read(irq_workd);
+
+	if (!llist_empty(this_cpu_ptr(&lazy_list)) && tsk)
+		wake_up_process(tsk);
+}
+
+#ifdef CONFIG_SMP
+static void irq_work_wake(struct irq_work *entry)
+{
+	wake_irq_workd();
+}
+
+static DEFINE_PER_CPU(struct irq_work, irq_work_wakeup) =
+	IRQ_WORK_INIT_HARD(irq_work_wake);
+#endif
+
+static int irq_workd_should_run(unsigned int cpu)
+{
+	return !llist_empty(this_cpu_ptr(&lazy_list));
+}
 
 /*
  * Claim the entry so that no one else will poke at it.
@@ -52,15 +78,30 @@ void __weak arch_irq_work_raise(void)
 /* Enqueue on current CPU, work must already be claimed and preempt disabled */
 static void __irq_work_queue_local(struct irq_work *work)
 {
+	struct llist_head *list;
+	bool rt_lazy_work = false;
+	bool lazy_work = false;
+	int work_flags;
+
+	work_flags = atomic_read(&work->node.a_flags);
+	if (work_flags & IRQ_WORK_LAZY)
+		lazy_work = true;
+	else if (IS_ENABLED(CONFIG_PREEMPT_RT) &&
+		 !(work_flags & IRQ_WORK_HARD_IRQ))
+		rt_lazy_work = true;
+
+	if (lazy_work || rt_lazy_work)
+		list = this_cpu_ptr(&lazy_list);
+	else
+		list = this_cpu_ptr(&raised_list);
+
+	if (!llist_add(&work->node.llist, list))
+		return;
+
+
 	/* If the work is "lazy", handle it from next tick if any */
-	if (atomic_read(&work->node.a_flags) & IRQ_WORK_LAZY) {
-		if (llist_add(&work->node.llist, this_cpu_ptr(&lazy_list)) &&
-		    tick_nohz_tick_stopped())
-			arch_irq_work_raise();
-	} else {
-		if (llist_add(&work->node.llist, this_cpu_ptr(&raised_list)))
-			arch_irq_work_raise();
-	}
+	if (!lazy_work || tick_nohz_tick_stopped())
+		arch_irq_work_raise();
 }
 
 /* Enqueue the irq work @work on the current CPU */
@@ -102,10 +143,28 @@ bool irq_work_queue_on(struct irq_work *work, int cpu)
 	if (cpu != smp_processor_id()) {
 		/* Arch remote IPI send/receive backend aren't NMI safe */
 		WARN_ON_ONCE(in_nmi());
+
+		/*
+		 * On PREEMPT_RT the items which are not marked as
+		 * IRQ_WORK_HARD_IRQ are added to the lazy list and a HARD work
+		 * item is used on the remote CPU to wake the thread.
+		 */
+		if (IS_ENABLED(CONFIG_PREEMPT_RT) &&
+		    !(atomic_read(&work->node.a_flags) & IRQ_WORK_HARD_IRQ)) {
+
+			if (!llist_add(&work->node.llist, &per_cpu(lazy_list, cpu)))
+				goto out;
+
+			work = &per_cpu(irq_work_wakeup, cpu);
+			if (!irq_work_claim(work))
+				goto out;
+		}
+
 		__smp_call_single_queue(cpu, &work->node.llist);
 	} else {
 		__irq_work_queue_local(work);
 	}
+out:	
 	preempt_enable();
 
 	return true;
@@ -120,9 +179,8 @@ bool irq_work_needs_cpu(void)
 	raised = this_cpu_ptr(&raised_list);
 	lazy = this_cpu_ptr(&lazy_list);
 
-	if (llist_empty(raised) || arch_irq_work_has_interrupt())
-		if (llist_empty(lazy))
-			return false;
+	if (llist_empty(raised) && llist_empty(lazy))
+		return false;
 
 	/* All work should have been flushed before going offline */
 	WARN_ON_ONCE(cpu_is_offline(smp_processor_id()));
@@ -153,6 +211,10 @@ void irq_work_single(void *arg)
 	 */
 	flags &= ~IRQ_WORK_PENDING;
 	(void)atomic_cmpxchg(&work->node.a_flags, flags, flags & ~IRQ_WORK_BUSY);
+
+	if ((IS_ENABLED(CONFIG_PREEMPT_RT) && !irq_work_is_hard(work)) ||
+	    !arch_irq_work_has_interrupt())
+		rcuwait_wake_up(&work->irqwait);
 }
 
 static void irq_work_run_list(struct llist_head *list)
@@ -160,7 +222,12 @@ static void irq_work_run_list(struct llist_head *list)
 	struct irq_work *work, *tmp;
 	struct llist_node *llnode;
 
-	BUG_ON(!irqs_disabled());
+	/*
+	 * On PREEMPT_RT IRQ-work which is not marked as HARD will be processed
+	 * in a per-CPU thread in preemptible context. Only the items which are
+	 * marked as IRQ_WORK_HARD_IRQ will be processed in hardirq context.
+	 */
+	BUG_ON(!irqs_disabled() && !IS_ENABLED(CONFIG_PREEMPT_RT));
 
 	if (llist_empty(list))
 		return;
@@ -177,7 +244,10 @@ static void irq_work_run_list(struct llist_head *list)
 void irq_work_run(void)
 {
 	irq_work_run_list(this_cpu_ptr(&raised_list));
-	irq_work_run_list(this_cpu_ptr(&lazy_list));
+	if (!IS_ENABLED(CONFIG_PREEMPT_RT))
+		irq_work_run_list(this_cpu_ptr(&lazy_list));
+	else
+		wake_irq_workd();
 }
 EXPORT_SYMBOL_GPL(irq_work_run);
 
@@ -187,7 +257,11 @@ void irq_work_tick(void)
 
 	if (!llist_empty(raised) && !arch_irq_work_has_interrupt())
 		irq_work_run_list(raised);
-	irq_work_run_list(this_cpu_ptr(&lazy_list));
+
+	if (!IS_ENABLED(CONFIG_PREEMPT_RT))
+		irq_work_run_list(this_cpu_ptr(&lazy_list));
+	else
+		wake_irq_workd();
 }
 
 /*
@@ -197,8 +271,42 @@ void irq_work_tick(void)
 void irq_work_sync(struct irq_work *work)
 {
 	lockdep_assert_irqs_enabled();
+	might_sleep();
+
+	if ((IS_ENABLED(CONFIG_PREEMPT_RT) && !irq_work_is_hard(work)) ||
+	    !arch_irq_work_has_interrupt()) {
+		rcuwait_wait_event(&work->irqwait, !irq_work_is_busy(work),
+				   TASK_UNINTERRUPTIBLE);
+		return;
+	}
 
 	while (irq_work_is_busy(work))
 		cpu_relax();
 }
 EXPORT_SYMBOL_GPL(irq_work_sync);
+
+static void run_irq_workd(unsigned int cpu)
+{
+	irq_work_run_list(this_cpu_ptr(&lazy_list));
+}
+
+static void irq_workd_setup(unsigned int cpu)
+{
+	sched_set_fifo_low(current);
+}
+
+static struct smp_hotplug_thread irqwork_threads = {
+	.store                  = &irq_workd,
+	.setup			= irq_workd_setup,
+	.thread_should_run      = irq_workd_should_run,
+	.thread_fn              = run_irq_workd,
+	.thread_comm            = "irq_work/%u",
+};
+
+static __init int irq_work_init_threads(void)
+{
+	if (IS_ENABLED(CONFIG_PREEMPT_RT))
+		BUG_ON(smpboot_register_percpu_thread(&irqwork_threads));
+	return 0;
+}
+early_initcall(irq_work_init_threads);
\ No newline at end of file
diff --git a/kernel/kexec_core.c b/kernel/kexec_core.c
index b9a6f4658f89..c26219f34445 100644
--- a/kernel/kexec_core.c
+++ b/kernel/kexec_core.c
@@ -984,7 +984,6 @@ void crash_kexec(struct pt_regs *regs)
 	old_cpu = atomic_cmpxchg(&panic_cpu, PANIC_CPU_INVALID, this_cpu);
 	if (old_cpu == PANIC_CPU_INVALID) {
 		/* This is the 1st CPU which comes here, so go ahead. */
-		printk_safe_flush_on_panic();
 		__crash_kexec(regs);
 
 		/*
diff --git a/kernel/ksysfs.c b/kernel/ksysfs.c
index 35859da8bd4f..dfff31ed644a 100644
--- a/kernel/ksysfs.c
+++ b/kernel/ksysfs.c
@@ -138,6 +138,15 @@ KERNEL_ATTR_RO(vmcoreinfo);
 
 #endif /* CONFIG_CRASH_CORE */
 
+#if defined(CONFIG_PREEMPT_RT)
+static ssize_t realtime_show(struct kobject *kobj,
+			     struct kobj_attribute *attr, char *buf)
+{
+	return sprintf(buf, "%d\n", 1);
+}
+KERNEL_ATTR_RO(realtime);
+#endif
+
 /* whether file capabilities are enabled */
 static ssize_t fscaps_show(struct kobject *kobj,
 				  struct kobj_attribute *attr, char *buf)
@@ -228,6 +237,9 @@ static struct attribute * kernel_attrs[] = {
 #ifndef CONFIG_TINY_RCU
 	&rcu_expedited_attr.attr,
 	&rcu_normal_attr.attr,
+#endif
+#ifdef CONFIG_PREEMPT_RT
+	&realtime_attr.attr,
 #endif
 	NULL
 };
diff --git a/kernel/kthread.c b/kernel/kthread.c
index 508fe5278285..3ce6a31db7b4 100644
--- a/kernel/kthread.c
+++ b/kernel/kthread.c
@@ -264,6 +264,7 @@ EXPORT_SYMBOL_GPL(kthread_parkme);
 
 static int kthread(void *_create)
 {
+	static const struct sched_param param = { .sched_priority = 0 };
 	/* Copy data: it's on kthread's stack */
 	struct kthread_create_info *create = _create;
 	int (*threadfn)(void *data) = create->threadfn;
@@ -294,6 +295,13 @@ static int kthread(void *_create)
 	init_completion(&self->parked);
 	current->vfork_done = &self->exited;
 
+	/*
+	 * The new thread inherited kthreadd's priority and CPU mask. Reset
+	 * back to default in case they have been changed.
+	 */
+	sched_setscheduler_nocheck(current, SCHED_NORMAL, &param);
+	set_cpus_allowed_ptr(current, housekeeping_cpumask(HK_FLAG_KTHREAD));
+
 	/* OK, tell user we're spawned, wait for stop or wakeup */
 	__set_current_state(TASK_UNINTERRUPTIBLE);
 	create->result = current;
@@ -391,7 +399,6 @@ struct task_struct *__kthread_create_on_node(int (*threadfn)(void *data),
 	}
 	task = create->result;
 	if (!IS_ERR(task)) {
-		static const struct sched_param param = { .sched_priority = 0 };
 		char name[TASK_COMM_LEN];
 
 		/*
@@ -400,13 +407,6 @@ struct task_struct *__kthread_create_on_node(int (*threadfn)(void *data),
 		 */
 		vsnprintf(name, sizeof(name), namefmt, args);
 		set_task_comm(task, name);
-		/*
-		 * root may have changed our (kthreadd's) priority or CPU mask.
-		 * The kernel thread should not inherit these properties.
-		 */
-		sched_setscheduler_nocheck(task, SCHED_NORMAL, &param);
-		set_cpus_allowed_ptr(task,
-				     housekeeping_cpumask(HK_FLAG_KTHREAD));
 	}
 	kfree(create);
 	return task;
diff --git a/kernel/locking/Makefile b/kernel/locking/Makefile
index 6d11cfb9b41f..c7fbf737e16e 100644
--- a/kernel/locking/Makefile
+++ b/kernel/locking/Makefile
@@ -3,7 +3,7 @@
 # and is generally not a function of system call inputs.
 KCOV_INSTRUMENT		:= n
 
-obj-y += mutex.o semaphore.o rwsem.o percpu-rwsem.o
+obj-y += semaphore.o rwsem.o percpu-rwsem.o
 
 # Avoid recursion lockdep -> KCSAN -> ... -> lockdep.
 KCSAN_SANITIZE_lockdep.o := n
@@ -15,19 +15,23 @@ CFLAGS_REMOVE_mutex-debug.o = $(CC_FLAGS_FTRACE)
 CFLAGS_REMOVE_rtmutex-debug.o = $(CC_FLAGS_FTRACE)
 endif
 
-obj-$(CONFIG_DEBUG_MUTEXES) += mutex-debug.o
 obj-$(CONFIG_LOCKDEP) += lockdep.o
 ifeq ($(CONFIG_PROC_FS),y)
 obj-$(CONFIG_LOCKDEP) += lockdep_proc.o
 endif
 obj-$(CONFIG_SMP) += spinlock.o
-obj-$(CONFIG_LOCK_SPIN_ON_OWNER) += osq_lock.o
 obj-$(CONFIG_PROVE_LOCKING) += spinlock.o
 obj-$(CONFIG_QUEUED_SPINLOCKS) += qspinlock.o
 obj-$(CONFIG_RT_MUTEXES) += rtmutex.o
 obj-$(CONFIG_DEBUG_RT_MUTEXES) += rtmutex-debug.o
 obj-$(CONFIG_DEBUG_SPINLOCK) += spinlock.o
 obj-$(CONFIG_DEBUG_SPINLOCK) += spinlock_debug.o
+ifneq ($(CONFIG_PREEMPT_RT),y)
+obj-y += mutex.o
+obj-$(CONFIG_LOCK_SPIN_ON_OWNER) += osq_lock.o
+obj-$(CONFIG_DEBUG_MUTEXES) += mutex-debug.o
+endif
+obj-$(CONFIG_PREEMPT_RT) += mutex-rt.o rwsem-rt.o rwlock-rt.o
 obj-$(CONFIG_QUEUED_RWLOCKS) += qrwlock.o
 obj-$(CONFIG_LOCK_TORTURE_TEST) += locktorture.o
 obj-$(CONFIG_WW_MUTEX_SELFTEST) += test-ww_mutex.o
diff --git a/kernel/locking/lockdep.c b/kernel/locking/lockdep.c
index 6cbd2b444476..f2f5defaf4e7 100644
--- a/kernel/locking/lockdep.c
+++ b/kernel/locking/lockdep.c
@@ -5413,6 +5413,7 @@ static noinstr void check_flags(unsigned long flags)
 		}
 	}
 
+#ifndef CONFIG_PREEMPT_RT
 	/*
 	 * We dont accurately track softirq state in e.g.
 	 * hardirq contexts (such as on 4KSTACKS), so only
@@ -5427,6 +5428,7 @@ static noinstr void check_flags(unsigned long flags)
 			DEBUG_LOCKS_WARN_ON(!current->softirqs_enabled);
 		}
 	}
+#endif
 
 	if (!debug_locks)
 		print_irqtrace_events(current);
diff --git a/kernel/locking/mutex-rt.c b/kernel/locking/mutex-rt.c
new file mode 100644
index 000000000000..2b849e6b9b4a
--- /dev/null
+++ b/kernel/locking/mutex-rt.c
@@ -0,0 +1,224 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+ * Real-Time Preemption Support
+ *
+ * started by Ingo Molnar:
+ *
+ *  Copyright (C) 2004-2006 Red Hat, Inc., Ingo Molnar <mingo@redhat.com>
+ *  Copyright (C) 2006, Timesys Corp., Thomas Gleixner <tglx@timesys.com>
+ *
+ * historic credit for proving that Linux spinlocks can be implemented via
+ * RT-aware mutexes goes to many people: The Pmutex project (Dirk Grambow
+ * and others) who prototyped it on 2.4 and did lots of comparative
+ * research and analysis; TimeSys, for proving that you can implement a
+ * fully preemptible kernel via the use of IRQ threading and mutexes;
+ * Bill Huey for persuasively arguing on lkml that the mutex model is the
+ * right one; and to MontaVista, who ported pmutexes to 2.6.
+ *
+ * This code is a from-scratch implementation and is not based on pmutexes,
+ * but the idea of converting spinlocks to mutexes is used here too.
+ *
+ * lock debugging, locking tree, deadlock detection:
+ *
+ *  Copyright (C) 2004, LynuxWorks, Inc., Igor Manyilov, Bill Huey
+ *  Released under the General Public License (GPL).
+ *
+ * Includes portions of the generic R/W semaphore implementation from:
+ *
+ *  Copyright (c) 2001   David Howells (dhowells@redhat.com).
+ *  - Derived partially from idea by Andrea Arcangeli <andrea@suse.de>
+ *  - Derived also from comments by Linus
+ *
+ * Pending ownership of locks and ownership stealing:
+ *
+ *  Copyright (C) 2005, Kihon Technologies Inc., Steven Rostedt
+ *
+ *   (also by Steven Rostedt)
+ *    - Converted single pi_lock to individual task locks.
+ *
+ * By Esben Nielsen:
+ *    Doing priority inheritance with help of the scheduler.
+ *
+ *  Copyright (C) 2006, Timesys Corp., Thomas Gleixner <tglx@timesys.com>
+ *  - major rework based on Esben Nielsens initial patch
+ *  - replaced thread_info references by task_struct refs
+ *  - removed task->pending_owner dependency
+ *  - BKL drop/reacquire for semaphore style locks to avoid deadlocks
+ *    in the scheduler return path as discussed with Steven Rostedt
+ *
+ *  Copyright (C) 2006, Kihon Technologies Inc.
+ *    Steven Rostedt <rostedt@goodmis.org>
+ *  - debugged and patched Thomas Gleixner's rework.
+ *  - added back the cmpxchg to the rework.
+ *  - turned atomic require back on for SMP.
+ */
+
+#include <linux/spinlock.h>
+#include <linux/rtmutex.h>
+#include <linux/sched.h>
+#include <linux/delay.h>
+#include <linux/module.h>
+#include <linux/kallsyms.h>
+#include <linux/syscalls.h>
+#include <linux/interrupt.h>
+#include <linux/plist.h>
+#include <linux/fs.h>
+#include <linux/futex.h>
+#include <linux/hrtimer.h>
+#include <linux/blkdev.h>
+
+#include "rtmutex_common.h"
+
+/*
+ * struct mutex functions
+ */
+void __mutex_do_init(struct mutex *mutex, const char *name,
+		     struct lock_class_key *key)
+{
+#ifdef CONFIG_DEBUG_LOCK_ALLOC
+	/*
+	 * Make sure we are not reinitializing a held lock:
+	 */
+	debug_check_no_locks_freed((void *)mutex, sizeof(*mutex));
+	lockdep_init_map(&mutex->dep_map, name, key, 0);
+#endif
+	mutex->lock.save_state = 0;
+}
+EXPORT_SYMBOL(__mutex_do_init);
+
+static int _mutex_lock_blk_flush(struct mutex *lock, int state)
+{
+	/*
+	 * Flush blk before ->pi_blocked_on is set. At schedule() time it is too
+	 * late if one of the callbacks needs to acquire a sleeping lock.
+	 */
+	if (blk_needs_flush_plug(current))
+		blk_schedule_flush_plug(current);
+	return __rt_mutex_lock_state(&lock->lock, state);
+}
+
+void __lockfunc _mutex_lock(struct mutex *lock)
+{
+	mutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);
+	_mutex_lock_blk_flush(lock, TASK_UNINTERRUPTIBLE);
+}
+EXPORT_SYMBOL(_mutex_lock);
+
+void __lockfunc _mutex_lock_io_nested(struct mutex *lock, int subclass)
+{
+	int token;
+
+	token = io_schedule_prepare();
+
+	mutex_acquire_nest(&lock->dep_map, subclass, 0, NULL, _RET_IP_);
+	__rt_mutex_lock_state(&lock->lock, TASK_UNINTERRUPTIBLE);
+
+	io_schedule_finish(token);
+}
+EXPORT_SYMBOL_GPL(_mutex_lock_io_nested);
+
+int __lockfunc _mutex_lock_interruptible(struct mutex *lock)
+{
+	int ret;
+
+	mutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);
+	ret = _mutex_lock_blk_flush(lock, TASK_INTERRUPTIBLE);
+	if (ret)
+		mutex_release(&lock->dep_map, _RET_IP_);
+	return ret;
+}
+EXPORT_SYMBOL(_mutex_lock_interruptible);
+
+int __lockfunc _mutex_lock_killable(struct mutex *lock)
+{
+	int ret;
+
+	mutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);
+	ret = _mutex_lock_blk_flush(lock, TASK_KILLABLE);
+	if (ret)
+		mutex_release(&lock->dep_map, _RET_IP_);
+	return ret;
+}
+EXPORT_SYMBOL(_mutex_lock_killable);
+
+#ifdef CONFIG_DEBUG_LOCK_ALLOC
+void __lockfunc _mutex_lock_nested(struct mutex *lock, int subclass)
+{
+	mutex_acquire_nest(&lock->dep_map, subclass, 0, NULL, _RET_IP_);
+	_mutex_lock_blk_flush(lock, TASK_UNINTERRUPTIBLE);
+}
+EXPORT_SYMBOL(_mutex_lock_nested);
+
+void __lockfunc _mutex_lock_nest_lock(struct mutex *lock, struct lockdep_map *nest)
+{
+	mutex_acquire_nest(&lock->dep_map, 0, 0, nest, _RET_IP_);
+	_mutex_lock_blk_flush(lock, TASK_UNINTERRUPTIBLE);
+}
+EXPORT_SYMBOL(_mutex_lock_nest_lock);
+
+int __lockfunc _mutex_lock_interruptible_nested(struct mutex *lock, int subclass)
+{
+	int ret;
+
+	mutex_acquire_nest(&lock->dep_map, subclass, 0, NULL, _RET_IP_);
+	ret = _mutex_lock_blk_flush(lock, TASK_INTERRUPTIBLE);
+	if (ret)
+		mutex_release(&lock->dep_map, _RET_IP_);
+	return ret;
+}
+EXPORT_SYMBOL(_mutex_lock_interruptible_nested);
+
+int __lockfunc _mutex_lock_killable_nested(struct mutex *lock, int subclass)
+{
+	int ret;
+
+	mutex_acquire(&lock->dep_map, subclass, 0, _RET_IP_);
+	ret = _mutex_lock_blk_flush(lock, TASK_KILLABLE);
+	if (ret)
+		mutex_release(&lock->dep_map, _RET_IP_);
+	return ret;
+}
+EXPORT_SYMBOL(_mutex_lock_killable_nested);
+#endif
+
+int __lockfunc _mutex_trylock(struct mutex *lock)
+{
+	int ret = __rt_mutex_trylock(&lock->lock);
+
+	if (ret)
+		mutex_acquire(&lock->dep_map, 0, 1, _RET_IP_);
+
+	return ret;
+}
+EXPORT_SYMBOL(_mutex_trylock);
+
+void __lockfunc _mutex_unlock(struct mutex *lock)
+{
+	mutex_release(&lock->dep_map, _RET_IP_);
+	__rt_mutex_unlock(&lock->lock);
+}
+EXPORT_SYMBOL(_mutex_unlock);
+
+/**
+ * atomic_dec_and_mutex_lock - return holding mutex if we dec to 0
+ * @cnt: the atomic which we are to dec
+ * @lock: the mutex to return holding if we dec to 0
+ *
+ * return true and hold lock if we dec to 0, return false otherwise
+ */
+int atomic_dec_and_mutex_lock(atomic_t *cnt, struct mutex *lock)
+{
+	/* dec if we can't possibly hit 0 */
+	if (atomic_add_unless(cnt, -1, 1))
+		return 0;
+	/* we might hit 0, so take the lock */
+	mutex_lock(lock);
+	if (!atomic_dec_and_test(cnt)) {
+		/* when we actually did the dec, we didn't hit 0 */
+		mutex_unlock(lock);
+		return 0;
+	}
+	/* we hit 0, and we hold the lock */
+	return 1;
+}
+EXPORT_SYMBOL(atomic_dec_and_mutex_lock);
diff --git a/kernel/locking/rtmutex-debug.c b/kernel/locking/rtmutex-debug.c
index 36e69100e8e0..fb150100335f 100644
--- a/kernel/locking/rtmutex-debug.c
+++ b/kernel/locking/rtmutex-debug.c
@@ -32,110 +32,12 @@
 
 #include "rtmutex_common.h"
 
-static void printk_task(struct task_struct *p)
-{
-	if (p)
-		printk("%16s:%5d [%p, %3d]", p->comm, task_pid_nr(p), p, p->prio);
-	else
-		printk("<none>");
-}
-
-static void printk_lock(struct rt_mutex *lock, int print_owner)
-{
-	if (lock->name)
-		printk(" [%p] {%s}\n",
-			lock, lock->name);
-	else
-		printk(" [%p] {%s:%d}\n",
-			lock, lock->file, lock->line);
-
-	if (print_owner && rt_mutex_owner(lock)) {
-		printk(".. ->owner: %p\n", lock->owner);
-		printk(".. held by:  ");
-		printk_task(rt_mutex_owner(lock));
-		printk("\n");
-	}
-}
-
 void rt_mutex_debug_task_free(struct task_struct *task)
 {
 	DEBUG_LOCKS_WARN_ON(!RB_EMPTY_ROOT(&task->pi_waiters.rb_root));
 	DEBUG_LOCKS_WARN_ON(task->pi_blocked_on);
 }
 
-/*
- * We fill out the fields in the waiter to store the information about
- * the deadlock. We print when we return. act_waiter can be NULL in
- * case of a remove waiter operation.
- */
-void debug_rt_mutex_deadlock(enum rtmutex_chainwalk chwalk,
-			     struct rt_mutex_waiter *act_waiter,
-			     struct rt_mutex *lock)
-{
-	struct task_struct *task;
-
-	if (!debug_locks || chwalk == RT_MUTEX_FULL_CHAINWALK || !act_waiter)
-		return;
-
-	task = rt_mutex_owner(act_waiter->lock);
-	if (task && task != current) {
-		act_waiter->deadlock_task_pid = get_pid(task_pid(task));
-		act_waiter->deadlock_lock = lock;
-	}
-}
-
-void debug_rt_mutex_print_deadlock(struct rt_mutex_waiter *waiter)
-{
-	struct task_struct *task;
-
-	if (!waiter->deadlock_lock || !debug_locks)
-		return;
-
-	rcu_read_lock();
-	task = pid_task(waiter->deadlock_task_pid, PIDTYPE_PID);
-	if (!task) {
-		rcu_read_unlock();
-		return;
-	}
-
-	if (!debug_locks_off()) {
-		rcu_read_unlock();
-		return;
-	}
-
-	pr_warn("\n");
-	pr_warn("============================================\n");
-	pr_warn("WARNING: circular locking deadlock detected!\n");
-	pr_warn("%s\n", print_tainted());
-	pr_warn("--------------------------------------------\n");
-	printk("%s/%d is deadlocking current task %s/%d\n\n",
-	       task->comm, task_pid_nr(task),
-	       current->comm, task_pid_nr(current));
-
-	printk("\n1) %s/%d is trying to acquire this lock:\n",
-	       current->comm, task_pid_nr(current));
-	printk_lock(waiter->lock, 1);
-
-	printk("\n2) %s/%d is blocked on this lock:\n",
-		task->comm, task_pid_nr(task));
-	printk_lock(waiter->deadlock_lock, 1);
-
-	debug_show_held_locks(current);
-	debug_show_held_locks(task);
-
-	printk("\n%s/%d's [blocked] stackdump:\n\n",
-		task->comm, task_pid_nr(task));
-	show_stack(task, NULL, KERN_DEFAULT);
-	printk("\n%s/%d's [current] stackdump:\n\n",
-		current->comm, task_pid_nr(current));
-	dump_stack();
-	debug_show_all_locks();
-	rcu_read_unlock();
-
-	printk("[ turning off deadlock detection."
-	       "Please report this trace. ]\n\n");
-}
-
 void debug_rt_mutex_lock(struct rt_mutex *lock)
 {
 }
@@ -158,12 +60,10 @@ void debug_rt_mutex_proxy_unlock(struct rt_mutex *lock)
 void debug_rt_mutex_init_waiter(struct rt_mutex_waiter *waiter)
 {
 	memset(waiter, 0x11, sizeof(*waiter));
-	waiter->deadlock_task_pid = NULL;
 }
 
 void debug_rt_mutex_free_waiter(struct rt_mutex_waiter *waiter)
 {
-	put_pid(waiter->deadlock_task_pid);
 	memset(waiter, 0x22, sizeof(*waiter));
 }
 
@@ -173,10 +73,8 @@ void debug_rt_mutex_init(struct rt_mutex *lock, const char *name, struct lock_cl
 	 * Make sure we are not reinitializing a held lock:
 	 */
 	debug_check_no_locks_freed((void *)lock, sizeof(*lock));
-	lock->name = name;
 
 #ifdef CONFIG_DEBUG_LOCK_ALLOC
 	lockdep_init_map(&lock->dep_map, name, key, 0);
 #endif
 }
-
diff --git a/kernel/locking/rtmutex-debug.h b/kernel/locking/rtmutex-debug.h
index fc549713bba3..659e93e256c6 100644
--- a/kernel/locking/rtmutex-debug.h
+++ b/kernel/locking/rtmutex-debug.h
@@ -18,20 +18,9 @@ extern void debug_rt_mutex_unlock(struct rt_mutex *lock);
 extern void debug_rt_mutex_proxy_lock(struct rt_mutex *lock,
 				      struct task_struct *powner);
 extern void debug_rt_mutex_proxy_unlock(struct rt_mutex *lock);
-extern void debug_rt_mutex_deadlock(enum rtmutex_chainwalk chwalk,
-				    struct rt_mutex_waiter *waiter,
-				    struct rt_mutex *lock);
-extern void debug_rt_mutex_print_deadlock(struct rt_mutex_waiter *waiter);
-# define debug_rt_mutex_reset_waiter(w)			\
-	do { (w)->deadlock_lock = NULL; } while (0)
 
 static inline bool debug_rt_mutex_detect_deadlock(struct rt_mutex_waiter *waiter,
 						  enum rtmutex_chainwalk walk)
 {
 	return (waiter != NULL);
 }
-
-static inline void rt_mutex_print_deadlock(struct rt_mutex_waiter *w)
-{
-	debug_rt_mutex_print_deadlock(w);
-}
diff --git a/kernel/locking/rtmutex.c b/kernel/locking/rtmutex.c
index a82d1176e7c6..d224c0229bc0 100644
--- a/kernel/locking/rtmutex.c
+++ b/kernel/locking/rtmutex.c
@@ -8,6 +8,11 @@
  *  Copyright (C) 2005-2006 Timesys Corp., Thomas Gleixner <tglx@timesys.com>
  *  Copyright (C) 2005 Kihon Technologies Inc., Steven Rostedt
  *  Copyright (C) 2006 Esben Nielsen
+ * Adaptive Spinlocks:
+ *  Copyright (C) 2008 Novell, Inc., Gregory Haskins, Sven Dietrich,
+ *				     and Peter Morreale,
+ * Adaptive Spinlocks simplification:
+ *  Copyright (C) 2008 Red Hat, Inc., Steven Rostedt <srostedt@redhat.com>
  *
  *  See Documentation/locking/rt-mutex-design.rst for details.
  */
@@ -19,6 +24,7 @@
 #include <linux/sched/wake_q.h>
 #include <linux/sched/debug.h>
 #include <linux/timer.h>
+#include <linux/ww_mutex.h>
 
 #include "rtmutex_common.h"
 
@@ -136,6 +142,12 @@ static void fixup_rt_mutex_waiters(struct rt_mutex *lock)
 		WRITE_ONCE(*p, owner & ~RT_MUTEX_HAS_WAITERS);
 }
 
+static int rt_mutex_real_waiter(struct rt_mutex_waiter *waiter)
+{
+	return waiter && waiter != PI_WAKEUP_INPROGRESS &&
+		waiter != PI_REQUEUE_INPROGRESS;
+}
+
 /*
  * We can speed up the acquire/release, if there's no debugging state to be
  * set up.
@@ -227,7 +239,7 @@ static inline bool unlock_rt_mutex_safe(struct rt_mutex *lock,
  * Only use with rt_mutex_waiter_{less,equal}()
  */
 #define task_to_waiter(p)	\
-	&(struct rt_mutex_waiter){ .prio = (p)->prio, .deadline = (p)->dl.deadline }
+	&(struct rt_mutex_waiter){ .prio = (p)->prio, .deadline = (p)->dl.deadline, .task = (p) }
 
 static inline int
 rt_mutex_waiter_less(struct rt_mutex_waiter *left,
@@ -267,6 +279,28 @@ rt_mutex_waiter_equal(struct rt_mutex_waiter *left,
 	return 1;
 }
 
+#define STEAL_NORMAL  0
+#define STEAL_LATERAL 1
+
+static inline int
+rt_mutex_steal(struct rt_mutex *lock, struct rt_mutex_waiter *waiter, int mode)
+{
+	struct rt_mutex_waiter *top_waiter = rt_mutex_top_waiter(lock);
+
+	if (waiter == top_waiter || rt_mutex_waiter_less(waiter, top_waiter))
+		return 1;
+
+	/*
+	 * Note that RT tasks are excluded from lateral-steals
+	 * to prevent the introduction of an unbounded latency.
+	 */
+	if (mode == STEAL_NORMAL || rt_task(waiter->task))
+		return 0;
+
+	return rt_mutex_waiter_equal(waiter, top_waiter);
+}
+
+
 #define __node_2_waiter(node) \
 	rb_entry((node), struct rt_mutex_waiter, tree_entry)
 
@@ -353,6 +387,14 @@ static bool rt_mutex_cond_detect_deadlock(struct rt_mutex_waiter *waiter,
 	return debug_rt_mutex_detect_deadlock(waiter, chwalk);
 }
 
+static void rt_mutex_wake_waiter(struct rt_mutex_waiter *waiter)
+{
+	if (waiter->savestate)
+		wake_up_lock_sleeper(waiter->task);
+	else
+		wake_up_process(waiter->task);
+}
+
 /*
  * Max number of times we'll walk the boosting chain:
  */
@@ -360,7 +402,8 @@ int max_lock_depth = 1024;
 
 static inline struct rt_mutex *task_blocked_on_lock(struct task_struct *p)
 {
-	return p->pi_blocked_on ? p->pi_blocked_on->lock : NULL;
+	return rt_mutex_real_waiter(p->pi_blocked_on) ?
+		p->pi_blocked_on->lock : NULL;
 }
 
 /*
@@ -496,7 +539,7 @@ static int rt_mutex_adjust_prio_chain(struct task_struct *task,
 	 * reached or the state of the chain has changed while we
 	 * dropped the locks.
 	 */
-	if (!waiter)
+	if (!rt_mutex_real_waiter(waiter))
 		goto out_unlock_pi;
 
 	/*
@@ -579,7 +622,6 @@ static int rt_mutex_adjust_prio_chain(struct task_struct *task,
 	 * walk, we detected a deadlock.
 	 */
 	if (lock == orig_lock || rt_mutex_owner(lock) == top_task) {
-		debug_rt_mutex_deadlock(chwalk, orig_waiter, lock);
 		raw_spin_unlock(&lock->wait_lock);
 		ret = -EDEADLK;
 		goto out_unlock_pi;
@@ -676,13 +718,16 @@ static int rt_mutex_adjust_prio_chain(struct task_struct *task,
 	 * follow here. This is the end of the chain we are walking.
 	 */
 	if (!rt_mutex_owner(lock)) {
+		struct rt_mutex_waiter *lock_top_waiter;
+
 		/*
 		 * If the requeue [7] above changed the top waiter,
 		 * then we need to wake the new top waiter up to try
 		 * to get the lock.
 		 */
-		if (prerequeue_top_waiter != rt_mutex_top_waiter(lock))
-			wake_up_process(rt_mutex_top_waiter(lock)->task);
+		lock_top_waiter = rt_mutex_top_waiter(lock);
+		if (prerequeue_top_waiter != lock_top_waiter)
+			rt_mutex_wake_waiter(lock_top_waiter);
 		raw_spin_unlock_irq(&lock->wait_lock);
 		return 0;
 	}
@@ -783,9 +828,11 @@ static int rt_mutex_adjust_prio_chain(struct task_struct *task,
  * @task:   The task which wants to acquire the lock
  * @waiter: The waiter that is queued to the lock's wait tree if the
  *	    callsite called task_blocked_on_lock(), otherwise NULL
+ * @mode:   Lock steal mode (STEAL_NORMAL, STEAL_LATERAL)
  */
-static int try_to_take_rt_mutex(struct rt_mutex *lock, struct task_struct *task,
-				struct rt_mutex_waiter *waiter)
+static int __try_to_take_rt_mutex(struct rt_mutex *lock,
+				  struct task_struct *task,
+				  struct rt_mutex_waiter *waiter, int mode)
 {
 	lockdep_assert_held(&lock->wait_lock);
 
@@ -821,12 +868,11 @@ static int try_to_take_rt_mutex(struct rt_mutex *lock, struct task_struct *task,
 	 */
 	if (waiter) {
 		/*
-		 * If waiter is not the highest priority waiter of
-		 * @lock, give up.
+		 * If waiter is not the highest priority waiter of @lock,
+		 * or its peer when lateral steal is allowed, give up.
 		 */
-		if (waiter != rt_mutex_top_waiter(lock))
+		if (!rt_mutex_steal(lock, waiter, mode))
 			return 0;
-
 		/*
 		 * We can acquire the lock. Remove the waiter from the
 		 * lock waiters tree.
@@ -844,14 +890,12 @@ static int try_to_take_rt_mutex(struct rt_mutex *lock, struct task_struct *task,
 		 */
 		if (rt_mutex_has_waiters(lock)) {
 			/*
-			 * If @task->prio is greater than or equal to
-			 * the top waiter priority (kernel view),
-			 * @task lost.
+			 * If @task->prio is greater than the top waiter
+			 * priority (kernel view), or equal to it when a
+			 * lateral steal is forbidden, @task lost.
 			 */
-			if (!rt_mutex_waiter_less(task_to_waiter(task),
-						  rt_mutex_top_waiter(lock)))
+			if (!rt_mutex_steal(lock, task_to_waiter(task), mode))
 				return 0;
-
 			/*
 			 * The current top waiter stays enqueued. We
 			 * don't have to change anything in the lock
@@ -898,6 +942,329 @@ static int try_to_take_rt_mutex(struct rt_mutex *lock, struct task_struct *task,
 	return 1;
 }
 
+#ifdef CONFIG_PREEMPT_RT
+/*
+ * preemptible spin_lock functions:
+ */
+static inline void rt_spin_lock_fastlock(struct rt_mutex *lock,
+					 void  (*slowfn)(struct rt_mutex *lock))
+{
+	might_sleep_no_state_check();
+
+	if (likely(rt_mutex_cmpxchg_acquire(lock, NULL, current)))
+		return;
+	else
+		slowfn(lock);
+}
+
+static inline void rt_spin_lock_fastunlock(struct rt_mutex *lock,
+					   void  (*slowfn)(struct rt_mutex *lock))
+{
+	if (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))
+		return;
+	else
+		slowfn(lock);
+}
+#ifdef CONFIG_SMP
+/*
+ * Note that owner is a speculative pointer and dereferencing relies
+ * on rcu_read_lock() and the check against the lock owner.
+ */
+static int adaptive_wait(struct rt_mutex *lock,
+			 struct task_struct *owner)
+{
+	int res = 0;
+
+	rcu_read_lock();
+	for (;;) {
+		if (owner != rt_mutex_owner(lock))
+			break;
+		/*
+		 * Ensure that owner->on_cpu is dereferenced _after_
+		 * checking the above to be valid.
+		 */
+		barrier();
+		if (!owner->on_cpu) {
+			res = 1;
+			break;
+		}
+		cpu_relax();
+	}
+	rcu_read_unlock();
+	return res;
+}
+#else
+static int adaptive_wait(struct rt_mutex *lock,
+			 struct task_struct *orig_owner)
+{
+	return 1;
+}
+#endif
+
+static int task_blocks_on_rt_mutex(struct rt_mutex *lock,
+				   struct rt_mutex_waiter *waiter,
+				   struct task_struct *task,
+				   enum rtmutex_chainwalk chwalk);
+/*
+ * Slow path lock function spin_lock style: this variant is very
+ * careful not to miss any non-lock wakeups.
+ *
+ * We store the current state under p->pi_lock in p->saved_state and
+ * the try_to_wake_up() code handles this accordingly.
+ */
+void __sched rt_spin_lock_slowlock_locked(struct rt_mutex *lock,
+					  struct rt_mutex_waiter *waiter,
+					  unsigned long flags)
+{
+	struct task_struct *lock_owner, *self = current;
+	struct rt_mutex_waiter *top_waiter;
+	int ret;
+
+	if (__try_to_take_rt_mutex(lock, self, NULL, STEAL_LATERAL))
+		return;
+
+	BUG_ON(rt_mutex_owner(lock) == self);
+
+	/*
+	 * We save whatever state the task is in and we'll restore it
+	 * after acquiring the lock taking real wakeups into account
+	 * as well. We are serialized via pi_lock against wakeups. See
+	 * try_to_wake_up().
+	 */
+	raw_spin_lock(&self->pi_lock);
+	self->saved_state = self->state;
+	__set_current_state_no_track(TASK_UNINTERRUPTIBLE);
+	raw_spin_unlock(&self->pi_lock);
+
+	ret = task_blocks_on_rt_mutex(lock, waiter, self, RT_MUTEX_MIN_CHAINWALK);
+	BUG_ON(ret);
+
+	for (;;) {
+		/* Try to acquire the lock again. */
+		if (__try_to_take_rt_mutex(lock, self, waiter, STEAL_LATERAL))
+			break;
+
+		top_waiter = rt_mutex_top_waiter(lock);
+		lock_owner = rt_mutex_owner(lock);
+
+		raw_spin_unlock_irqrestore(&lock->wait_lock, flags);
+
+		if (top_waiter != waiter || adaptive_wait(lock, lock_owner))
+			preempt_schedule_lock();
+
+		raw_spin_lock_irqsave(&lock->wait_lock, flags);
+
+		raw_spin_lock(&self->pi_lock);
+		__set_current_state_no_track(TASK_UNINTERRUPTIBLE);
+		raw_spin_unlock(&self->pi_lock);
+	}
+
+	/*
+	 * Restore the task state to current->saved_state. We set it
+	 * to the original state above and the try_to_wake_up() code
+	 * has possibly updated it when a real (non-rtmutex) wakeup
+	 * happened while we were blocked. Clear saved_state so
+	 * try_to_wakeup() does not get confused.
+	 */
+	raw_spin_lock(&self->pi_lock);
+	__set_current_state_no_track(self->saved_state);
+	self->saved_state = TASK_RUNNING;
+	raw_spin_unlock(&self->pi_lock);
+
+	/*
+	 * try_to_take_rt_mutex() sets the waiter bit
+	 * unconditionally. We might have to fix that up:
+	 */
+	fixup_rt_mutex_waiters(lock);
+
+	BUG_ON(rt_mutex_has_waiters(lock) && waiter == rt_mutex_top_waiter(lock));
+	BUG_ON(!RB_EMPTY_NODE(&waiter->tree_entry));
+}
+
+static void noinline __sched rt_spin_lock_slowlock(struct rt_mutex *lock)
+{
+	struct rt_mutex_waiter waiter;
+	unsigned long flags;
+
+	rt_mutex_init_waiter(&waiter, true);
+
+	raw_spin_lock_irqsave(&lock->wait_lock, flags);
+	rt_spin_lock_slowlock_locked(lock, &waiter, flags);
+	raw_spin_unlock_irqrestore(&lock->wait_lock, flags);
+	debug_rt_mutex_free_waiter(&waiter);
+}
+
+static bool __sched __rt_mutex_unlock_common(struct rt_mutex *lock,
+					     struct wake_q_head *wake_q,
+					     struct wake_q_head *wq_sleeper);
+/*
+ * Slow path to release a rt_mutex spin_lock style
+ */
+void __sched rt_spin_lock_slowunlock(struct rt_mutex *lock)
+{
+	unsigned long flags;
+	DEFINE_WAKE_Q(wake_q);
+	DEFINE_WAKE_Q(wake_sleeper_q);
+	bool postunlock;
+
+	raw_spin_lock_irqsave(&lock->wait_lock, flags);
+	postunlock = __rt_mutex_unlock_common(lock, &wake_q, &wake_sleeper_q);
+	raw_spin_unlock_irqrestore(&lock->wait_lock, flags);
+
+	if (postunlock)
+		rt_mutex_postunlock(&wake_q, &wake_sleeper_q);
+}
+
+void __lockfunc rt_spin_lock(spinlock_t *lock)
+{
+	spin_acquire(&lock->dep_map, 0, 0, _RET_IP_);
+	rt_spin_lock_fastlock(&lock->lock, rt_spin_lock_slowlock);
+	rcu_read_lock();
+	migrate_disable();
+}
+EXPORT_SYMBOL(rt_spin_lock);
+
+void __lockfunc __rt_spin_lock(struct rt_mutex *lock)
+{
+	rt_spin_lock_fastlock(lock, rt_spin_lock_slowlock);
+}
+
+#ifdef CONFIG_DEBUG_LOCK_ALLOC
+void __lockfunc rt_spin_lock_nested(spinlock_t *lock, int subclass)
+{
+	spin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);
+	rt_spin_lock_fastlock(&lock->lock, rt_spin_lock_slowlock);
+	rcu_read_lock();
+	migrate_disable();
+}
+EXPORT_SYMBOL(rt_spin_lock_nested);
+
+void __lockfunc rt_spin_lock_nest_lock(spinlock_t *lock,
+				       struct lockdep_map *nest_lock)
+{
+	spin_acquire_nest(&lock->dep_map, 0, 0, nest_lock, _RET_IP_);
+	rt_spin_lock_fastlock(&lock->lock, rt_spin_lock_slowlock);
+	rcu_read_lock();
+	migrate_disable();
+}
+EXPORT_SYMBOL(rt_spin_lock_nest_lock);
+#endif
+
+void __lockfunc rt_spin_unlock(spinlock_t *lock)
+{
+	/* NOTE: we always pass in '1' for nested, for simplicity */
+	spin_release(&lock->dep_map, _RET_IP_);
+	migrate_enable();
+	rcu_read_unlock();
+	rt_spin_lock_fastunlock(&lock->lock, rt_spin_lock_slowunlock);
+}
+EXPORT_SYMBOL(rt_spin_unlock);
+
+void __lockfunc __rt_spin_unlock(struct rt_mutex *lock)
+{
+	rt_spin_lock_fastunlock(lock, rt_spin_lock_slowunlock);
+}
+EXPORT_SYMBOL(__rt_spin_unlock);
+
+/*
+ * Wait for the lock to get unlocked: instead of polling for an unlock
+ * (like raw spinlocks do), we lock and unlock, to force the kernel to
+ * schedule if there's contention:
+ */
+void __lockfunc rt_spin_lock_unlock(spinlock_t *lock)
+{
+	spin_lock(lock);
+	spin_unlock(lock);
+}
+EXPORT_SYMBOL(rt_spin_lock_unlock);
+
+int __lockfunc rt_spin_trylock(spinlock_t *lock)
+{
+	int ret;
+
+	ret = __rt_mutex_trylock(&lock->lock);
+	if (ret) {
+		spin_acquire(&lock->dep_map, 0, 1, _RET_IP_);
+		rcu_read_lock();
+		migrate_disable();
+	}
+	return ret;
+}
+EXPORT_SYMBOL(rt_spin_trylock);
+
+int __lockfunc rt_spin_trylock_bh(spinlock_t *lock)
+{
+	int ret;
+
+	local_bh_disable();
+	ret = __rt_mutex_trylock(&lock->lock);
+	if (ret) {
+		spin_acquire(&lock->dep_map, 0, 1, _RET_IP_);
+		rcu_read_lock();
+		migrate_disable();
+	} else {
+		local_bh_enable();
+	}
+	return ret;
+}
+EXPORT_SYMBOL(rt_spin_trylock_bh);
+
+void
+__rt_spin_lock_init(spinlock_t *lock, const char *name, struct lock_class_key *key)
+{
+#ifdef CONFIG_DEBUG_LOCK_ALLOC
+	/*
+	 * Make sure we are not reinitializing a held lock:
+	 */
+	debug_check_no_locks_freed((void *)lock, sizeof(*lock));
+	lockdep_init_map(&lock->dep_map, name, key, 0);
+#endif
+}
+EXPORT_SYMBOL(__rt_spin_lock_init);
+
+#endif /* PREEMPT_RT */
+
+#ifdef CONFIG_PREEMPT_RT
+	static inline int __sched
+__mutex_lock_check_stamp(struct rt_mutex *lock, struct ww_acquire_ctx *ctx)
+{
+	struct ww_mutex *ww = container_of(lock, struct ww_mutex, base.lock);
+	struct ww_acquire_ctx *hold_ctx = READ_ONCE(ww->ctx);
+
+	if (!hold_ctx)
+		return 0;
+
+	if (unlikely(ctx == hold_ctx))
+		return -EALREADY;
+
+	if (ctx->stamp - hold_ctx->stamp <= LONG_MAX &&
+	    (ctx->stamp != hold_ctx->stamp || ctx > hold_ctx)) {
+#ifdef CONFIG_DEBUG_MUTEXES
+		DEBUG_LOCKS_WARN_ON(ctx->contending_lock);
+		ctx->contending_lock = ww;
+#endif
+		return -EDEADLK;
+	}
+
+	return 0;
+}
+#else
+	static inline int __sched
+__mutex_lock_check_stamp(struct rt_mutex *lock, struct ww_acquire_ctx *ctx)
+{
+	BUG();
+	return 0;
+}
+
+#endif
+
+static inline int
+try_to_take_rt_mutex(struct rt_mutex *lock, struct task_struct *task,
+		     struct rt_mutex_waiter *waiter)
+{
+	return __try_to_take_rt_mutex(lock, task, waiter, STEAL_NORMAL);
+}
+
 /*
  * Task blocks on lock.
  *
@@ -930,6 +1297,22 @@ static int task_blocks_on_rt_mutex(struct rt_mutex *lock,
 		return -EDEADLK;
 
 	raw_spin_lock(&task->pi_lock);
+	/*
+	 * In the case of futex requeue PI, this will be a proxy
+	 * lock. The task will wake unaware that it is enqueueed on
+	 * this lock. Avoid blocking on two locks and corrupting
+	 * pi_blocked_on via the PI_WAKEUP_INPROGRESS
+	 * flag. futex_wait_requeue_pi() sets this when it wakes up
+	 * before requeue (due to a signal or timeout). Do not enqueue
+	 * the task if PI_WAKEUP_INPROGRESS is set.
+	 */
+	if (task != current && task->pi_blocked_on == PI_WAKEUP_INPROGRESS) {
+		raw_spin_unlock(&task->pi_lock);
+		return -EAGAIN;
+	}
+
+       BUG_ON(rt_mutex_real_waiter(task->pi_blocked_on));
+
 	waiter->task = task;
 	waiter->lock = lock;
 	waiter->prio = task->prio;
@@ -953,7 +1336,7 @@ static int task_blocks_on_rt_mutex(struct rt_mutex *lock,
 		rt_mutex_enqueue_pi(owner, waiter);
 
 		rt_mutex_adjust_prio(owner);
-		if (owner->pi_blocked_on)
+		if (rt_mutex_real_waiter(owner->pi_blocked_on))
 			chain_walk = 1;
 	} else if (rt_mutex_cond_detect_deadlock(waiter, chwalk)) {
 		chain_walk = 1;
@@ -995,6 +1378,7 @@ static int task_blocks_on_rt_mutex(struct rt_mutex *lock,
  * Called with lock->wait_lock held and interrupts disabled.
  */
 static void mark_wakeup_next_waiter(struct wake_q_head *wake_q,
+				    struct wake_q_head *wake_sleeper_q,
 				    struct rt_mutex *lock)
 {
 	struct rt_mutex_waiter *waiter;
@@ -1034,7 +1418,10 @@ static void mark_wakeup_next_waiter(struct wake_q_head *wake_q,
 	 * Pairs with preempt_enable() in rt_mutex_postunlock();
 	 */
 	preempt_disable();
-	wake_q_add(wake_q, waiter->task);
+	if (waiter->savestate)
+		wake_q_add_sleeper(wake_sleeper_q, waiter->task);
+	else
+		wake_q_add(wake_q, waiter->task);
 	raw_spin_unlock(&current->pi_lock);
 }
 
@@ -1049,7 +1436,7 @@ static void remove_waiter(struct rt_mutex *lock,
 {
 	bool is_top_waiter = (waiter == rt_mutex_top_waiter(lock));
 	struct task_struct *owner = rt_mutex_owner(lock);
-	struct rt_mutex *next_lock;
+	struct rt_mutex *next_lock = NULL;
 
 	lockdep_assert_held(&lock->wait_lock);
 
@@ -1075,7 +1462,8 @@ static void remove_waiter(struct rt_mutex *lock,
 	rt_mutex_adjust_prio(owner);
 
 	/* Store the lock on which owner is blocked or NULL */
-	next_lock = task_blocked_on_lock(owner);
+	if (rt_mutex_real_waiter(owner->pi_blocked_on))
+		next_lock = task_blocked_on_lock(owner);
 
 	raw_spin_unlock(&owner->pi_lock);
 
@@ -1111,26 +1499,28 @@ void rt_mutex_adjust_pi(struct task_struct *task)
 	raw_spin_lock_irqsave(&task->pi_lock, flags);
 
 	waiter = task->pi_blocked_on;
-	if (!waiter || rt_mutex_waiter_equal(waiter, task_to_waiter(task))) {
+	if (!rt_mutex_real_waiter(waiter) ||
+	    rt_mutex_waiter_equal(waiter, task_to_waiter(task))) {
 		raw_spin_unlock_irqrestore(&task->pi_lock, flags);
 		return;
 	}
 	next_lock = waiter->lock;
-	raw_spin_unlock_irqrestore(&task->pi_lock, flags);
 
 	/* gets dropped in rt_mutex_adjust_prio_chain()! */
 	get_task_struct(task);
 
+	raw_spin_unlock_irqrestore(&task->pi_lock, flags);
 	rt_mutex_adjust_prio_chain(task, RT_MUTEX_MIN_CHAINWALK, NULL,
 				   next_lock, NULL, task);
 }
 
-void rt_mutex_init_waiter(struct rt_mutex_waiter *waiter)
+void rt_mutex_init_waiter(struct rt_mutex_waiter *waiter, bool savestate)
 {
 	debug_rt_mutex_init_waiter(waiter);
 	RB_CLEAR_NODE(&waiter->pi_tree_entry);
 	RB_CLEAR_NODE(&waiter->tree_entry);
 	waiter->task = NULL;
+	waiter->savestate = savestate;
 }
 
 /**
@@ -1146,7 +1536,8 @@ void rt_mutex_init_waiter(struct rt_mutex_waiter *waiter)
 static int __sched
 __rt_mutex_slowlock(struct rt_mutex *lock, int state,
 		    struct hrtimer_sleeper *timeout,
-		    struct rt_mutex_waiter *waiter)
+		    struct rt_mutex_waiter *waiter,
+		    struct ww_acquire_ctx *ww_ctx)
 {
 	int ret = 0;
 
@@ -1155,24 +1546,23 @@ __rt_mutex_slowlock(struct rt_mutex *lock, int state,
 		if (try_to_take_rt_mutex(lock, current, waiter))
 			break;
 
-		/*
-		 * TASK_INTERRUPTIBLE checks for signals and
-		 * timeout. Ignored otherwise.
-		 */
-		if (likely(state == TASK_INTERRUPTIBLE)) {
-			/* Signal pending? */
-			if (signal_pending(current))
-				ret = -EINTR;
-			if (timeout && !timeout->task)
-				ret = -ETIMEDOUT;
+		if (timeout && !timeout->task) {
+			ret = -ETIMEDOUT;
+			break;
+		}
+		if (signal_pending_state(state, current)) {
+			ret = -EINTR;
+			break;
+		}
+
+		if (ww_ctx && ww_ctx->acquired > 0) {
+			ret = __mutex_lock_check_stamp(lock, ww_ctx);
 			if (ret)
 				break;
 		}
 
 		raw_spin_unlock_irq(&lock->wait_lock);
 
-		debug_rt_mutex_print_deadlock(waiter);
-
 		schedule();
 
 		raw_spin_lock_irq(&lock->wait_lock);
@@ -1193,43 +1583,110 @@ static void rt_mutex_handle_deadlock(int res, int detect_deadlock,
 	if (res != -EDEADLOCK || detect_deadlock)
 		return;
 
-	/*
-	 * Yell lowdly and stop the task right here.
-	 */
-	rt_mutex_print_deadlock(w);
 	while (1) {
 		set_current_state(TASK_INTERRUPTIBLE);
 		schedule();
 	}
 }
 
-/*
- * Slow path lock function:
- */
-static int __sched
-rt_mutex_slowlock(struct rt_mutex *lock, int state,
-		  struct hrtimer_sleeper *timeout,
-		  enum rtmutex_chainwalk chwalk)
+static __always_inline void ww_mutex_lock_acquired(struct ww_mutex *ww,
+						   struct ww_acquire_ctx *ww_ctx)
 {
-	struct rt_mutex_waiter waiter;
-	unsigned long flags;
-	int ret = 0;
+#ifdef CONFIG_DEBUG_MUTEXES
+	/*
+	 * If this WARN_ON triggers, you used ww_mutex_lock to acquire,
+	 * but released with a normal mutex_unlock in this call.
+	 *
+	 * This should never happen, always use ww_mutex_unlock.
+	 */
+	DEBUG_LOCKS_WARN_ON(ww->ctx);
+
+	/*
+	 * Not quite done after calling ww_acquire_done() ?
+	 */
+	DEBUG_LOCKS_WARN_ON(ww_ctx->done_acquire);
 
-	rt_mutex_init_waiter(&waiter);
+	if (ww_ctx->contending_lock) {
+		/*
+		 * After -EDEADLK you tried to
+		 * acquire a different ww_mutex? Bad!
+		 */
+		DEBUG_LOCKS_WARN_ON(ww_ctx->contending_lock != ww);
+
+		/*
+		 * You called ww_mutex_lock after receiving -EDEADLK,
+		 * but 'forgot' to unlock everything else first?
+		 */
+		DEBUG_LOCKS_WARN_ON(ww_ctx->acquired > 0);
+		ww_ctx->contending_lock = NULL;
+	}
 
 	/*
-	 * Technically we could use raw_spin_[un]lock_irq() here, but this can
-	 * be called in early boot if the cmpxchg() fast path is disabled
-	 * (debug, no architecture support). In this case we will acquire the
-	 * rtmutex with lock->wait_lock held. But we cannot unconditionally
-	 * enable interrupts in that early boot case. So we need to use the
-	 * irqsave/restore variants.
+	 * Naughty, using a different class will lead to undefined behavior!
 	 */
-	raw_spin_lock_irqsave(&lock->wait_lock, flags);
+	DEBUG_LOCKS_WARN_ON(ww_ctx->ww_class != ww->ww_class);
+#endif
+	ww_ctx->acquired++;
+}
+
+#ifdef CONFIG_PREEMPT_RT
+static void ww_mutex_account_lock(struct rt_mutex *lock,
+				  struct ww_acquire_ctx *ww_ctx)
+{
+	struct ww_mutex *ww = container_of(lock, struct ww_mutex, base.lock);
+	struct rt_mutex_waiter *waiter, *n;
+
+	/*
+	 * This branch gets optimized out for the common case,
+	 * and is only important for ww_mutex_lock.
+	 */
+	ww_mutex_lock_acquired(ww, ww_ctx);
+	ww->ctx = ww_ctx;
+
+	/*
+	 * Give any possible sleeping processes the chance to wake up,
+	 * so they can recheck if they have to back off.
+	 */
+	rbtree_postorder_for_each_entry_safe(waiter, n, &lock->waiters.rb_root,
+					     tree_entry) {
+		/* XXX debug rt mutex waiter wakeup */
+
+		BUG_ON(waiter->lock != lock);
+		rt_mutex_wake_waiter(waiter);
+	}
+}
+
+#else
+
+static void ww_mutex_account_lock(struct rt_mutex *lock,
+				  struct ww_acquire_ctx *ww_ctx)
+{
+	BUG();
+}
+#endif
+
+int __sched rt_mutex_slowlock_locked(struct rt_mutex *lock, int state,
+				     struct hrtimer_sleeper *timeout,
+				     enum rtmutex_chainwalk chwalk,
+				     struct ww_acquire_ctx *ww_ctx,
+				     struct rt_mutex_waiter *waiter)
+{
+	int ret;
+
+#ifdef CONFIG_PREEMPT_RT
+	if (ww_ctx) {
+		struct ww_mutex *ww;
+
+		ww = container_of(lock, struct ww_mutex, base.lock);
+		if (unlikely(ww_ctx == READ_ONCE(ww->ctx)))
+			return -EALREADY;
+	}
+#endif
 
 	/* Try to acquire the lock again: */
 	if (try_to_take_rt_mutex(lock, current, NULL)) {
-		raw_spin_unlock_irqrestore(&lock->wait_lock, flags);
+		if (ww_ctx)
+			ww_mutex_account_lock(lock, ww_ctx);
 		return 0;
 	}
 
@@ -1239,16 +1696,26 @@ rt_mutex_slowlock(struct rt_mutex *lock, int state,
 	if (unlikely(timeout))
 		hrtimer_start_expires(&timeout->timer, HRTIMER_MODE_ABS);
 
-	ret = task_blocks_on_rt_mutex(lock, &waiter, current, chwalk);
+	ret = task_blocks_on_rt_mutex(lock, waiter, current, chwalk);
 
-	if (likely(!ret))
+	if (likely(!ret)) {
 		/* sleep on the mutex */
-		ret = __rt_mutex_slowlock(lock, state, timeout, &waiter);
+		ret = __rt_mutex_slowlock(lock, state, timeout, waiter,
+					  ww_ctx);
+	} else if (ww_ctx) {
+		/* ww_mutex received EDEADLK, let it become EALREADY */
+		ret = __mutex_lock_check_stamp(lock, ww_ctx);
+		BUG_ON(!ret);
+	}
 
 	if (unlikely(ret)) {
 		__set_current_state(TASK_RUNNING);
-		remove_waiter(lock, &waiter);
-		rt_mutex_handle_deadlock(ret, chwalk, &waiter);
+		remove_waiter(lock, waiter);
+		/* ww_mutex wants to report EDEADLK/EALREADY, let it */
+		if (!ww_ctx)
+			rt_mutex_handle_deadlock(ret, chwalk, waiter);
+	} else if (ww_ctx) {
+		ww_mutex_account_lock(lock, ww_ctx);
 	}
 
 	/*
@@ -1256,6 +1723,36 @@ rt_mutex_slowlock(struct rt_mutex *lock, int state,
 	 * unconditionally. We might have to fix that up.
 	 */
 	fixup_rt_mutex_waiters(lock);
+	return ret;
+}
+
+/*
+ * Slow path lock function:
+ */
+static int __sched
+rt_mutex_slowlock(struct rt_mutex *lock, int state,
+		  struct hrtimer_sleeper *timeout,
+		  enum rtmutex_chainwalk chwalk,
+		  struct ww_acquire_ctx *ww_ctx)
+{
+	struct rt_mutex_waiter waiter;
+	unsigned long flags;
+	int ret = 0;
+
+	rt_mutex_init_waiter(&waiter, false);
+
+	/*
+	 * Technically we could use raw_spin_[un]lock_irq() here, but this can
+	 * be called in early boot if the cmpxchg() fast path is disabled
+	 * (debug, no architecture support). In this case we will acquire the
+	 * rtmutex with lock->wait_lock held. But we cannot unconditionally
+	 * enable interrupts in that early boot case. So we need to use the
+	 * irqsave/restore variants.
+	 */
+	raw_spin_lock_irqsave(&lock->wait_lock, flags);
+
+	ret = rt_mutex_slowlock_locked(lock, state, timeout, chwalk, ww_ctx,
+				       &waiter);
 
 	raw_spin_unlock_irqrestore(&lock->wait_lock, flags);
 
@@ -1316,7 +1813,8 @@ static inline int rt_mutex_slowtrylock(struct rt_mutex *lock)
  * Return whether the current task needs to call rt_mutex_postunlock().
  */
 static bool __sched rt_mutex_slowunlock(struct rt_mutex *lock,
-					struct wake_q_head *wake_q)
+					struct wake_q_head *wake_q,
+					struct wake_q_head *wake_sleeper_q)
 {
 	unsigned long flags;
 
@@ -1370,7 +1868,7 @@ static bool __sched rt_mutex_slowunlock(struct rt_mutex *lock,
 	 *
 	 * Queue the next waiter for wakeup once we release the wait_lock.
 	 */
-	mark_wakeup_next_waiter(wake_q, lock);
+	mark_wakeup_next_waiter(wake_q, wake_sleeper_q, lock);
 	raw_spin_unlock_irqrestore(&lock->wait_lock, flags);
 
 	return true; /* call rt_mutex_postunlock() */
@@ -1384,29 +1882,16 @@ static bool __sched rt_mutex_slowunlock(struct rt_mutex *lock,
  */
 static inline int
 rt_mutex_fastlock(struct rt_mutex *lock, int state,
+		  struct ww_acquire_ctx *ww_ctx,
 		  int (*slowfn)(struct rt_mutex *lock, int state,
 				struct hrtimer_sleeper *timeout,
-				enum rtmutex_chainwalk chwalk))
+				enum rtmutex_chainwalk chwalk,
+				struct ww_acquire_ctx *ww_ctx))
 {
 	if (likely(rt_mutex_cmpxchg_acquire(lock, NULL, current)))
 		return 0;
 
-	return slowfn(lock, state, NULL, RT_MUTEX_MIN_CHAINWALK);
-}
-
-static inline int
-rt_mutex_timed_fastlock(struct rt_mutex *lock, int state,
-			struct hrtimer_sleeper *timeout,
-			enum rtmutex_chainwalk chwalk,
-			int (*slowfn)(struct rt_mutex *lock, int state,
-				      struct hrtimer_sleeper *timeout,
-				      enum rtmutex_chainwalk chwalk))
-{
-	if (chwalk == RT_MUTEX_MIN_CHAINWALK &&
-	    likely(rt_mutex_cmpxchg_acquire(lock, NULL, current)))
-		return 0;
-
-	return slowfn(lock, state, timeout, chwalk);
+	return slowfn(lock, state, NULL, RT_MUTEX_MIN_CHAINWALK, ww_ctx);
 }
 
 static inline int
@@ -1422,10 +1907,12 @@ rt_mutex_fasttrylock(struct rt_mutex *lock,
 /*
  * Performs the wakeup of the top-waiter and re-enables preemption.
  */
-void rt_mutex_postunlock(struct wake_q_head *wake_q)
+void rt_mutex_postunlock(struct wake_q_head *wake_q,
+                        struct wake_q_head *wake_sleeper_q)
 {
 	wake_up_q(wake_q);
-
+    wake_up_q_sleeper(wake_sleeper_q);
+      
 	/* Pairs with preempt_disable() in rt_mutex_slowunlock() */
 	preempt_enable();
 }
@@ -1433,23 +1920,46 @@ void rt_mutex_postunlock(struct wake_q_head *wake_q)
 static inline void
 rt_mutex_fastunlock(struct rt_mutex *lock,
 		    bool (*slowfn)(struct rt_mutex *lock,
-				   struct wake_q_head *wqh))
+				   struct wake_q_head *wqh,
+				   struct wake_q_head *wq_sleeper))
 {
 	DEFINE_WAKE_Q(wake_q);
+	DEFINE_WAKE_Q(wake_sleeper_q);
 
 	if (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))
 		return;
 
-	if (slowfn(lock, &wake_q))
-		rt_mutex_postunlock(&wake_q);
+	if (slowfn(lock, &wake_q, &wake_sleeper_q))
+		rt_mutex_postunlock(&wake_q, &wake_sleeper_q);
 }
 
-static inline void __rt_mutex_lock(struct rt_mutex *lock, unsigned int subclass)
+int __sched __rt_mutex_lock_state(struct rt_mutex *lock, int state)
 {
 	might_sleep();
+	return rt_mutex_fastlock(lock, state, NULL, rt_mutex_slowlock);
+}
+
+/**
+ * rt_mutex_lock_state - lock a rt_mutex with a given state
+ *
+ * @lock:      The rt_mutex to be locked
+ * @state:     The state to set when blocking on the rt_mutex
+ */
+static inline int __sched rt_mutex_lock_state(struct rt_mutex *lock,
+					      unsigned int subclass, int state)
+{
+	int ret;
 
 	mutex_acquire(&lock->dep_map, subclass, 0, _RET_IP_);
-	rt_mutex_fastlock(lock, TASK_UNINTERRUPTIBLE, rt_mutex_slowlock);
+	ret = __rt_mutex_lock_state(lock, state);
+	if (ret)
+		mutex_release(&lock->dep_map, _RET_IP_);
+	return ret;
+}
+
+static inline void __rt_mutex_lock(struct rt_mutex *lock, unsigned int subclass)
+{
+	rt_mutex_lock_state(lock, subclass, TASK_UNINTERRUPTIBLE);
 }
 
 #ifdef CONFIG_DEBUG_LOCK_ALLOC
@@ -1490,16 +2000,7 @@ EXPORT_SYMBOL_GPL(rt_mutex_lock);
  */
 int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)
 {
-	int ret;
-
-	might_sleep();
-
-	mutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);
-	ret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);
-	if (ret)
-		mutex_release(&lock->dep_map, _RET_IP_);
-
-	return ret;
+	return rt_mutex_lock_state(lock, 0, TASK_INTERRUPTIBLE);
 }
 EXPORT_SYMBOL_GPL(rt_mutex_lock_interruptible);
 
@@ -1516,36 +2017,17 @@ int __sched __rt_mutex_futex_trylock(struct rt_mutex *lock)
 	return __rt_mutex_slowtrylock(lock);
 }
 
-/**
- * rt_mutex_timed_lock - lock a rt_mutex interruptible
- *			the timeout structure is provided
- *			by the caller
- *
- * @lock:		the rt_mutex to be locked
- * @timeout:		timeout structure or NULL (no timeout)
- *
- * Returns:
- *  0		on success
- * -EINTR	when interrupted by a signal
- * -ETIMEDOUT	when the timeout expired
- */
-int
-rt_mutex_timed_lock(struct rt_mutex *lock, struct hrtimer_sleeper *timeout)
+int __sched __rt_mutex_trylock(struct rt_mutex *lock)
 {
-	int ret;
-
-	might_sleep();
-
-	mutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);
-	ret = rt_mutex_timed_fastlock(lock, TASK_INTERRUPTIBLE, timeout,
-				       RT_MUTEX_MIN_CHAINWALK,
-				       rt_mutex_slowlock);
-	if (ret)
-		mutex_release(&lock->dep_map, _RET_IP_);
+#ifdef CONFIG_PREEMPT_RT
+	if (WARN_ON_ONCE(in_irq() || in_nmi()))
+#else
+	if (WARN_ON_ONCE(in_irq() || in_nmi() || in_serving_softirq()))
+#endif
+		return 0;
 
-	return ret;
+	return rt_mutex_fasttrylock(lock, rt_mutex_slowtrylock);
 }
-EXPORT_SYMBOL_GPL(rt_mutex_timed_lock);
 
 /**
  * rt_mutex_trylock - try to lock a rt_mutex
@@ -1562,10 +2044,7 @@ int __sched rt_mutex_trylock(struct rt_mutex *lock)
 {
 	int ret;
 
-	if (WARN_ON_ONCE(in_irq() || in_nmi() || in_serving_softirq()))
-		return 0;
-
-	ret = rt_mutex_fasttrylock(lock, rt_mutex_slowtrylock);
+	ret = __rt_mutex_trylock(lock);
 	if (ret)
 		mutex_acquire(&lock->dep_map, 0, 1, _RET_IP_);
 
@@ -1573,6 +2052,11 @@ int __sched rt_mutex_trylock(struct rt_mutex *lock)
 }
 EXPORT_SYMBOL_GPL(rt_mutex_trylock);
 
+void __sched __rt_mutex_unlock(struct rt_mutex *lock)
+{
+	rt_mutex_fastunlock(lock, rt_mutex_slowunlock);
+}
+
 /**
  * rt_mutex_unlock - unlock a rt_mutex
  *
@@ -1581,16 +2065,13 @@ EXPORT_SYMBOL_GPL(rt_mutex_trylock);
 void __sched rt_mutex_unlock(struct rt_mutex *lock)
 {
 	mutex_release(&lock->dep_map, _RET_IP_);
-	rt_mutex_fastunlock(lock, rt_mutex_slowunlock);
+	__rt_mutex_unlock(lock);
 }
 EXPORT_SYMBOL_GPL(rt_mutex_unlock);
 
-/**
- * Futex variant, that since futex variants do not use the fast-path, can be
- * simple and will not need to retry.
- */
-bool __sched __rt_mutex_futex_unlock(struct rt_mutex *lock,
-				    struct wake_q_head *wake_q)
+static bool __sched __rt_mutex_unlock_common(struct rt_mutex *lock,
+					     struct wake_q_head *wake_q,
+					     struct wake_q_head *wq_sleeper)
 {
 	lockdep_assert_held(&lock->wait_lock);
 
@@ -1607,23 +2088,35 @@ bool __sched __rt_mutex_futex_unlock(struct rt_mutex *lock,
 	 * avoid inversion prior to the wakeup.  preempt_disable()
 	 * therein pairs with rt_mutex_postunlock().
 	 */
-	mark_wakeup_next_waiter(wake_q, lock);
+	mark_wakeup_next_waiter(wake_q, wq_sleeper, lock);
 
 	return true; /* call postunlock() */
 }
 
+/**
+ * Futex variant, that since futex variants do not use the fast-path, can be
+ * simple and will not need to retry.
+ */
+bool __sched __rt_mutex_futex_unlock(struct rt_mutex *lock,
+				     struct wake_q_head *wake_q,
+				     struct wake_q_head *wq_sleeper)
+{
+	return __rt_mutex_unlock_common(lock, wake_q, wq_sleeper);
+}
+
 void __sched rt_mutex_futex_unlock(struct rt_mutex *lock)
 {
 	DEFINE_WAKE_Q(wake_q);
+	DEFINE_WAKE_Q(wake_sleeper_q);
 	unsigned long flags;
 	bool postunlock;
 
 	raw_spin_lock_irqsave(&lock->wait_lock, flags);
-	postunlock = __rt_mutex_futex_unlock(lock, &wake_q);
+	postunlock = __rt_mutex_futex_unlock(lock, &wake_q, &wake_sleeper_q);
 	raw_spin_unlock_irqrestore(&lock->wait_lock, flags);
 
 	if (postunlock)
-		rt_mutex_postunlock(&wake_q);
+		rt_mutex_postunlock(&wake_q, &wake_sleeper_q);
 }
 
 /**
@@ -1637,9 +2130,6 @@ void __sched rt_mutex_futex_unlock(struct rt_mutex *lock)
 void rt_mutex_destroy(struct rt_mutex *lock)
 {
 	WARN_ON(rt_mutex_is_locked(lock));
-#ifdef CONFIG_DEBUG_RT_MUTEXES
-	lock->magic = NULL;
-#endif
 }
 EXPORT_SYMBOL_GPL(rt_mutex_destroy);
 
@@ -1662,7 +2152,7 @@ void __rt_mutex_init(struct rt_mutex *lock, const char *name,
 	if (name && key)
 		debug_rt_mutex_init(lock, name, key);
 }
-EXPORT_SYMBOL_GPL(__rt_mutex_init);
+EXPORT_SYMBOL(__rt_mutex_init);
 
 /**
  * rt_mutex_init_proxy_locked - initialize and lock a rt_mutex on behalf of a
@@ -1682,6 +2172,14 @@ void rt_mutex_init_proxy_locked(struct rt_mutex *lock,
 				struct task_struct *proxy_owner)
 {
 	__rt_mutex_init(lock, NULL, NULL);
+#ifdef CONFIG_DEBUG_SPINLOCK
+	/*
+	 * get another key class for the wait_lock. LOCK_PI and UNLOCK_PI is
+	 * holding the ->wait_lock of the proxy_lock while unlocking a sleeping
+	 * lock.
+	 */
+	raw_spin_lock_init(&lock->wait_lock);
+#endif
 	debug_rt_mutex_proxy_lock(lock, proxy_owner);
 	rt_mutex_set_owner(lock, proxy_owner);
 }
@@ -1704,6 +2202,26 @@ void rt_mutex_proxy_unlock(struct rt_mutex *lock)
 	rt_mutex_set_owner(lock, NULL);
 }
 
+static void fixup_rt_mutex_blocked(struct rt_mutex *lock)
+{
+	struct task_struct *tsk = current;
+	/*
+	 * RT has a problem here when the wait got interrupted by a timeout
+	 * or a signal. task->pi_blocked_on is still set. The task must
+	 * acquire the hash bucket lock when returning from this function.
+	 *
+	 * If the hash bucket lock is contended then the
+	 * BUG_ON(rt_mutex_real_waiter(task->pi_blocked_on)) in
+	 * task_blocks_on_rt_mutex() will trigger. This can be avoided by
+	 * clearing task->pi_blocked_on which removes the task from the
+	 * boosting chain of the rtmutex. That's correct because the task
+	 * is not longer blocked on it.
+	 */
+	raw_spin_lock(&tsk->pi_lock);
+	tsk->pi_blocked_on = NULL;
+	raw_spin_unlock(&tsk->pi_lock);
+}
+
 /**
  * __rt_mutex_start_proxy_lock() - Start lock acquisition for another task
  * @lock:		the rt_mutex to take
@@ -1734,6 +2252,34 @@ int __rt_mutex_start_proxy_lock(struct rt_mutex *lock,
 	if (try_to_take_rt_mutex(lock, task, NULL))
 		return 1;
 
+#ifdef CONFIG_PREEMPT_RT
+	/*
+	 * In PREEMPT_RT there's an added race.
+	 * If the task, that we are about to requeue, times out,
+	 * it can set the PI_WAKEUP_INPROGRESS. This tells the requeue
+	 * to skip this task. But right after the task sets
+	 * its pi_blocked_on to PI_WAKEUP_INPROGRESS it can then
+	 * block on the spin_lock(&hb->lock), which in RT is an rtmutex.
+	 * This will replace the PI_WAKEUP_INPROGRESS with the actual
+	 * lock that it blocks on. We *must not* place this task
+	 * on this proxy lock in that case.
+	 *
+	 * To prevent this race, we first take the task's pi_lock
+	 * and check if it has updated its pi_blocked_on. If it has,
+	 * we assume that it woke up and we return -EAGAIN.
+	 * Otherwise, we set the task's pi_blocked_on to
+	 * PI_REQUEUE_INPROGRESS, so that if the task is waking up
+	 * it will know that we are in the process of requeuing it.
+	 */
+	raw_spin_lock(&task->pi_lock);
+	if (task->pi_blocked_on) {
+		raw_spin_unlock(&task->pi_lock);
+		return -EAGAIN;
+	}
+	task->pi_blocked_on = PI_REQUEUE_INPROGRESS;
+	raw_spin_unlock(&task->pi_lock);
+#endif
+
 	/* We enforce deadlock detection for futexes */
 	ret = task_blocks_on_rt_mutex(lock, waiter, task,
 				      RT_MUTEX_FULL_CHAINWALK);
@@ -1748,7 +2294,8 @@ int __rt_mutex_start_proxy_lock(struct rt_mutex *lock,
 		ret = 0;
 	}
 
-	debug_rt_mutex_print_deadlock(waiter);
+	if (ret)
+		fixup_rt_mutex_blocked(lock);
 
 	return ret;
 }
@@ -1833,12 +2380,15 @@ int rt_mutex_wait_proxy_lock(struct rt_mutex *lock,
 	raw_spin_lock_irq(&lock->wait_lock);
 	/* sleep on the mutex */
 	set_current_state(TASK_INTERRUPTIBLE);
-	ret = __rt_mutex_slowlock(lock, TASK_INTERRUPTIBLE, to, waiter);
+	ret = __rt_mutex_slowlock(lock, TASK_INTERRUPTIBLE, to, waiter, NULL);
 	/*
 	 * try_to_take_rt_mutex() sets the waiter bit unconditionally. We might
 	 * have to fix that up.
 	 */
 	fixup_rt_mutex_waiters(lock);
+	if (ret)
+		fixup_rt_mutex_blocked(lock);
+
 	raw_spin_unlock_irq(&lock->wait_lock);
 
 	return ret;
@@ -1900,3 +2450,97 @@ bool rt_mutex_cleanup_proxy_lock(struct rt_mutex *lock,
 
 	return cleanup;
 }
+
+static inline int
+ww_mutex_deadlock_injection(struct ww_mutex *lock, struct ww_acquire_ctx *ctx)
+{
+#ifdef CONFIG_DEBUG_WW_MUTEX_SLOWPATH
+	unsigned int tmp;
+
+	if (ctx->deadlock_inject_countdown-- == 0) {
+		tmp = ctx->deadlock_inject_interval;
+		if (tmp > UINT_MAX/4)
+			tmp = UINT_MAX;
+		else
+			tmp = tmp*2 + tmp + tmp/2;
+
+		ctx->deadlock_inject_interval = tmp;
+		ctx->deadlock_inject_countdown = tmp;
+		ctx->contending_lock = lock;
+
+		ww_mutex_unlock(lock);
+
+		return -EDEADLK;
+	}
+#endif
+
+	return 0;
+}
+
+#ifdef CONFIG_PREEMPT_RT
+int __sched
+ww_mutex_lock_interruptible(struct ww_mutex *lock, struct ww_acquire_ctx *ctx)
+{
+	int ret;
+
+	might_sleep();
+
+	mutex_acquire_nest(&lock->base.dep_map, 0, 0,
+			   ctx ? &ctx->dep_map : NULL, _RET_IP_);
+	ret = rt_mutex_slowlock(&lock->base.lock, TASK_INTERRUPTIBLE, NULL, 0,
+				ctx);
+	if (ret)
+		mutex_release(&lock->base.dep_map, _RET_IP_);
+	else if (!ret && ctx && ctx->acquired > 1)
+		return ww_mutex_deadlock_injection(lock, ctx);
+
+	return ret;
+}
+EXPORT_SYMBOL_GPL(ww_mutex_lock_interruptible);
+
+int __sched
+ww_mutex_lock(struct ww_mutex *lock, struct ww_acquire_ctx *ctx)
+{
+	int ret;
+
+	might_sleep();
+
+	mutex_acquire_nest(&lock->base.dep_map, 0, 0,
+			   ctx ? &ctx->dep_map : NULL, _RET_IP_);
+	ret = rt_mutex_slowlock(&lock->base.lock, TASK_UNINTERRUPTIBLE, NULL, 0,
+				ctx);
+	if (ret)
+		mutex_release(&lock->base.dep_map, _RET_IP_);
+	else if (!ret && ctx && ctx->acquired > 1)
+		return ww_mutex_deadlock_injection(lock, ctx);
+
+	return ret;
+}
+EXPORT_SYMBOL_GPL(ww_mutex_lock);
+
+void __sched ww_mutex_unlock(struct ww_mutex *lock)
+{
+	/*
+	 * The unlocking fastpath is the 0->1 transition from 'locked'
+	 * into 'unlocked' state:
+	 */
+	if (lock->ctx) {
+#ifdef CONFIG_DEBUG_MUTEXES
+		DEBUG_LOCKS_WARN_ON(!lock->ctx->acquired);
+#endif
+		if (lock->ctx->acquired > 0)
+			lock->ctx->acquired--;
+		lock->ctx = NULL;
+	}
+
+	mutex_release(&lock->base.dep_map, _RET_IP_);
+	__rt_mutex_unlock(&lock->base.lock);
+}
+EXPORT_SYMBOL(ww_mutex_unlock);
+
+int __rt_mutex_owner_current(struct rt_mutex *lock)
+{
+	return rt_mutex_owner(lock) == current;
+}
+EXPORT_SYMBOL(__rt_mutex_owner_current);
+#endif
diff --git a/kernel/locking/rtmutex.h b/kernel/locking/rtmutex.h
index 732f96abf462..338ccd29119a 100644
--- a/kernel/locking/rtmutex.h
+++ b/kernel/locking/rtmutex.h
@@ -19,15 +19,8 @@
 #define debug_rt_mutex_proxy_unlock(l)			do { } while (0)
 #define debug_rt_mutex_unlock(l)			do { } while (0)
 #define debug_rt_mutex_init(m, n, k)			do { } while (0)
-#define debug_rt_mutex_deadlock(d, a ,l)		do { } while (0)
-#define debug_rt_mutex_print_deadlock(w)		do { } while (0)
 #define debug_rt_mutex_reset_waiter(w)			do { } while (0)
 
-static inline void rt_mutex_print_deadlock(struct rt_mutex_waiter *w)
-{
-	WARN(1, "rtmutex deadlock detected\n");
-}
-
 static inline bool debug_rt_mutex_detect_deadlock(struct rt_mutex_waiter *w,
 						  enum rtmutex_chainwalk walk)
 {
diff --git a/kernel/locking/rtmutex_common.h b/kernel/locking/rtmutex_common.h
index ca6fb489007b..248a7d91583b 100644
--- a/kernel/locking/rtmutex_common.h
+++ b/kernel/locking/rtmutex_common.h
@@ -15,6 +15,7 @@
 
 #include <linux/rtmutex.h>
 #include <linux/sched/wake_q.h>
+#include <linux/sched/debug.h>
 
 /*
  * This is the control structure for tasks blocked on a rt_mutex,
@@ -29,12 +30,8 @@ struct rt_mutex_waiter {
 	struct rb_node          pi_tree_entry;
 	struct task_struct	*task;
 	struct rt_mutex		*lock;
-#ifdef CONFIG_DEBUG_RT_MUTEXES
-	unsigned long		ip;
-	struct pid		*deadlock_task_pid;
-	struct rt_mutex		*deadlock_lock;
-#endif
 	int prio;
+	bool			savestate;
 	u64 deadline;
 };
 
@@ -130,11 +127,14 @@ enum rtmutex_chainwalk {
 /*
  * PI-futex support (proxy locking functions, etc.):
  */
+#define PI_WAKEUP_INPROGRESS	((struct rt_mutex_waiter *) 1)
+#define PI_REQUEUE_INPROGRESS	((struct rt_mutex_waiter *) 2)
+
 extern struct task_struct *rt_mutex_next_owner(struct rt_mutex *lock);
 extern void rt_mutex_init_proxy_locked(struct rt_mutex *lock,
 				       struct task_struct *proxy_owner);
 extern void rt_mutex_proxy_unlock(struct rt_mutex *lock);
-extern void rt_mutex_init_waiter(struct rt_mutex_waiter *waiter);
+extern void rt_mutex_init_waiter(struct rt_mutex_waiter *waiter, bool savetate);
 extern int __rt_mutex_start_proxy_lock(struct rt_mutex *lock,
 				     struct rt_mutex_waiter *waiter,
 				     struct task_struct *task);
@@ -152,9 +152,27 @@ extern int __rt_mutex_futex_trylock(struct rt_mutex *l);
 
 extern void rt_mutex_futex_unlock(struct rt_mutex *lock);
 extern bool __rt_mutex_futex_unlock(struct rt_mutex *lock,
-				 struct wake_q_head *wqh);
-
-extern void rt_mutex_postunlock(struct wake_q_head *wake_q);
+				 struct wake_q_head *wqh,
+				 struct wake_q_head *wq_sleeper);
+
+extern void rt_mutex_postunlock(struct wake_q_head *wake_q,
+				struct wake_q_head *wake_sleeper_q);
+
+/* RW semaphore special interface */
+struct ww_acquire_ctx;
+
+extern int __rt_mutex_lock_state(struct rt_mutex *lock, int state);
+extern int __rt_mutex_trylock(struct rt_mutex *lock);
+extern void __rt_mutex_unlock(struct rt_mutex *lock);
+int __sched rt_mutex_slowlock_locked(struct rt_mutex *lock, int state,
+				     struct hrtimer_sleeper *timeout,
+				     enum rtmutex_chainwalk chwalk,
+				     struct ww_acquire_ctx *ww_ctx,
+				     struct rt_mutex_waiter *waiter);
+void __sched rt_spin_lock_slowlock_locked(struct rt_mutex *lock,
+					  struct rt_mutex_waiter *waiter,
+					  unsigned long flags);
+void __sched rt_spin_lock_slowunlock(struct rt_mutex *lock);
 
 #ifdef CONFIG_DEBUG_RT_MUTEXES
 # include "rtmutex-debug.h"
diff --git a/kernel/locking/rwlock-rt.c b/kernel/locking/rwlock-rt.c
new file mode 100644
index 000000000000..3d2d1f14b513
--- /dev/null
+++ b/kernel/locking/rwlock-rt.c
@@ -0,0 +1,334 @@
+// SPDX-License-Identifier: GPL-2.0-only
+#include <linux/sched/debug.h>
+#include <linux/export.h>
+
+#include "rtmutex_common.h"
+#include <linux/rwlock_types_rt.h>
+
+/*
+ * RT-specific reader/writer locks
+ *
+ * write_lock()
+ *  1) Lock lock->rtmutex
+ *  2) Remove the reader BIAS to force readers into the slow path
+ *  3) Wait until all readers have left the critical region
+ *  4) Mark it write locked
+ *
+ * write_unlock()
+ *  1) Remove the write locked marker
+ *  2) Set the reader BIAS so readers can use the fast path again
+ *  3) Unlock lock->rtmutex to release blocked readers
+ *
+ * read_lock()
+ *  1) Try fast path acquisition (reader BIAS is set)
+ *  2) Take lock->rtmutex.wait_lock which protects the writelocked flag
+ *  3) If !writelocked, acquire it for read
+ *  4) If writelocked, block on lock->rtmutex
+ *  5) unlock lock->rtmutex, goto 1)
+ *
+ * read_unlock()
+ *  1) Try fast path release (reader count != 1)
+ *  2) Wake the writer waiting in write_lock()#3
+ *
+ * read_lock()#3 has the consequence, that rw locks on RT are not writer
+ * fair, but writers, which should be avoided in RT tasks (think tasklist
+ * lock), are subject to the rtmutex priority/DL inheritance mechanism.
+ *
+ * It's possible to make the rw locks writer fair by keeping a list of
+ * active readers. A blocked writer would force all newly incoming readers
+ * to block on the rtmutex, but the rtmutex would have to be proxy locked
+ * for one reader after the other. We can't use multi-reader inheritance
+ * because there is no way to support that with
+ * SCHED_DEADLINE. Implementing the one by one reader boosting/handover
+ * mechanism is a major surgery for a very dubious value.
+ *
+ * The risk of writer starvation is there, but the pathological use cases
+ * which trigger it are not necessarily the typical RT workloads.
+ */
+
+void __rwlock_biased_rt_init(struct rt_rw_lock *lock, const char *name,
+			     struct lock_class_key *key)
+{
+#ifdef CONFIG_DEBUG_LOCK_ALLOC
+	/*
+	 * Make sure we are not reinitializing a held semaphore:
+	 */
+	debug_check_no_locks_freed((void *)lock, sizeof(*lock));
+	lockdep_init_map(&lock->dep_map, name, key, 0);
+#endif
+	atomic_set(&lock->readers, READER_BIAS);
+	rt_mutex_init(&lock->rtmutex);
+	lock->rtmutex.save_state = 1;
+}
+
+static int __read_rt_trylock(struct rt_rw_lock *lock)
+{
+	int r, old;
+
+	/*
+	 * Increment reader count, if lock->readers < 0, i.e. READER_BIAS is
+	 * set.
+	 */
+	for (r = atomic_read(&lock->readers); r < 0;) {
+		old = atomic_cmpxchg(&lock->readers, r, r + 1);
+		if (likely(old == r))
+			return 1;
+		r = old;
+	}
+	return 0;
+}
+
+static void __read_rt_lock(struct rt_rw_lock *lock)
+{
+	struct rt_mutex *m = &lock->rtmutex;
+	struct rt_mutex_waiter waiter;
+	unsigned long flags;
+
+	if (__read_rt_trylock(lock))
+		return;
+
+	raw_spin_lock_irqsave(&m->wait_lock, flags);
+	/*
+	 * Allow readers as long as the writer has not completely
+	 * acquired the semaphore for write.
+	 */
+	if (atomic_read(&lock->readers) != WRITER_BIAS) {
+		atomic_inc(&lock->readers);
+		raw_spin_unlock_irqrestore(&m->wait_lock, flags);
+		return;
+	}
+
+	/*
+	 * Call into the slow lock path with the rtmutex->wait_lock
+	 * held, so this can't result in the following race:
+	 *
+	 * Reader1		Reader2		Writer
+	 *			read_lock()
+	 *					write_lock()
+	 *					rtmutex_lock(m)
+	 *					swait()
+	 * read_lock()
+	 * unlock(m->wait_lock)
+	 *			read_unlock()
+	 *			swake()
+	 *					lock(m->wait_lock)
+	 *					lock->writelocked=true
+	 *					unlock(m->wait_lock)
+	 *
+	 *					write_unlock()
+	 *					lock->writelocked=false
+	 *					rtmutex_unlock(m)
+	 *			read_lock()
+	 *					write_lock()
+	 *					rtmutex_lock(m)
+	 *					swait()
+	 * rtmutex_lock(m)
+	 *
+	 * That would put Reader1 behind the writer waiting on
+	 * Reader2 to call read_unlock() which might be unbound.
+	 */
+	rt_mutex_init_waiter(&waiter, true);
+	rt_spin_lock_slowlock_locked(m, &waiter, flags);
+	/*
+	 * The slowlock() above is guaranteed to return with the rtmutex is
+	 * now held, so there can't be a writer active. Increment the reader
+	 * count and immediately drop the rtmutex again.
+	 */
+	atomic_inc(&lock->readers);
+	raw_spin_unlock_irqrestore(&m->wait_lock, flags);
+	rt_spin_lock_slowunlock(m);
+
+	debug_rt_mutex_free_waiter(&waiter);
+}
+
+static void __read_rt_unlock(struct rt_rw_lock *lock)
+{
+	struct rt_mutex *m = &lock->rtmutex;
+	struct task_struct *tsk;
+
+	/*
+	 * sem->readers can only hit 0 when a writer is waiting for the
+	 * active readers to leave the critical region.
+	 */
+	if (!atomic_dec_and_test(&lock->readers))
+		return;
+
+	raw_spin_lock_irq(&m->wait_lock);
+	/*
+	 * Wake the writer, i.e. the rtmutex owner. It might release the
+	 * rtmutex concurrently in the fast path, but to clean up the rw
+	 * lock it needs to acquire m->wait_lock. The worst case which can
+	 * happen is a spurious wakeup.
+	 */
+	tsk = rt_mutex_owner(m);
+	if (tsk)
+		wake_up_process(tsk);
+
+	raw_spin_unlock_irq(&m->wait_lock);
+}
+
+static void __write_unlock_common(struct rt_rw_lock *lock, int bias,
+				  unsigned long flags)
+{
+	struct rt_mutex *m = &lock->rtmutex;
+
+	atomic_add(READER_BIAS - bias, &lock->readers);
+	raw_spin_unlock_irqrestore(&m->wait_lock, flags);
+	rt_spin_lock_slowunlock(m);
+}
+
+static void __write_rt_lock(struct rt_rw_lock *lock)
+{
+	struct rt_mutex *m = &lock->rtmutex;
+	struct task_struct *self = current;
+	unsigned long flags;
+
+	/* Take the rtmutex as a first step */
+	__rt_spin_lock(m);
+
+	/* Force readers into slow path */
+	atomic_sub(READER_BIAS, &lock->readers);
+
+	raw_spin_lock_irqsave(&m->wait_lock, flags);
+
+	raw_spin_lock(&self->pi_lock);
+	self->saved_state = self->state;
+	__set_current_state_no_track(TASK_UNINTERRUPTIBLE);
+	raw_spin_unlock(&self->pi_lock);
+
+	for (;;) {
+		/* Have all readers left the critical region? */
+		if (!atomic_read(&lock->readers)) {
+			atomic_set(&lock->readers, WRITER_BIAS);
+			raw_spin_lock(&self->pi_lock);
+			__set_current_state_no_track(self->saved_state);
+			self->saved_state = TASK_RUNNING;
+			raw_spin_unlock(&self->pi_lock);
+			raw_spin_unlock_irqrestore(&m->wait_lock, flags);
+			return;
+		}
+
+		raw_spin_unlock_irqrestore(&m->wait_lock, flags);
+
+		if (atomic_read(&lock->readers) != 0)
+			preempt_schedule_lock();
+
+		raw_spin_lock_irqsave(&m->wait_lock, flags);
+
+		raw_spin_lock(&self->pi_lock);
+		__set_current_state_no_track(TASK_UNINTERRUPTIBLE);
+		raw_spin_unlock(&self->pi_lock);
+	}
+}
+
+static int __write_rt_trylock(struct rt_rw_lock *lock)
+{
+	struct rt_mutex *m = &lock->rtmutex;
+	unsigned long flags;
+
+	if (!__rt_mutex_trylock(m))
+		return 0;
+
+	atomic_sub(READER_BIAS, &lock->readers);
+
+	raw_spin_lock_irqsave(&m->wait_lock, flags);
+	if (!atomic_read(&lock->readers)) {
+		atomic_set(&lock->readers, WRITER_BIAS);
+		raw_spin_unlock_irqrestore(&m->wait_lock, flags);
+		return 1;
+	}
+	__write_unlock_common(lock, 0, flags);
+	return 0;
+}
+
+static void __write_rt_unlock(struct rt_rw_lock *lock)
+{
+	struct rt_mutex *m = &lock->rtmutex;
+	unsigned long flags;
+
+	raw_spin_lock_irqsave(&m->wait_lock, flags);
+	__write_unlock_common(lock, WRITER_BIAS, flags);
+}
+
+int __lockfunc rt_read_can_lock(rwlock_t *rwlock)
+{
+	return  atomic_read(&rwlock->readers) < 0;
+}
+
+int __lockfunc rt_write_can_lock(rwlock_t *rwlock)
+{
+	return atomic_read(&rwlock->readers) == READER_BIAS;
+}
+
+/*
+ * The common functions which get wrapped into the rwlock API.
+ */
+int __lockfunc rt_read_trylock(rwlock_t *rwlock)
+{
+	int ret;
+
+	ret = __read_rt_trylock(rwlock);
+	if (ret) {
+		rwlock_acquire_read(&rwlock->dep_map, 0, 1, _RET_IP_);
+		rcu_read_lock();
+		migrate_disable();
+	}
+	return ret;
+}
+EXPORT_SYMBOL(rt_read_trylock);
+
+int __lockfunc rt_write_trylock(rwlock_t *rwlock)
+{
+	int ret;
+
+	ret = __write_rt_trylock(rwlock);
+	if (ret) {
+		rwlock_acquire(&rwlock->dep_map, 0, 1, _RET_IP_);
+		rcu_read_lock();
+		migrate_disable();
+	}
+	return ret;
+}
+EXPORT_SYMBOL(rt_write_trylock);
+
+void __lockfunc rt_read_lock(rwlock_t *rwlock)
+{
+	rwlock_acquire_read(&rwlock->dep_map, 0, 0, _RET_IP_);
+	__read_rt_lock(rwlock);
+	rcu_read_lock();
+	migrate_disable();
+}
+EXPORT_SYMBOL(rt_read_lock);
+
+void __lockfunc rt_write_lock(rwlock_t *rwlock)
+{
+	rwlock_acquire(&rwlock->dep_map, 0, 0, _RET_IP_);
+	__write_rt_lock(rwlock);
+	rcu_read_lock();
+	migrate_disable();
+}
+EXPORT_SYMBOL(rt_write_lock);
+
+void __lockfunc rt_read_unlock(rwlock_t *rwlock)
+{
+	rwlock_release(&rwlock->dep_map, _RET_IP_);
+	migrate_enable();
+	rcu_read_unlock();
+	__read_rt_unlock(rwlock);
+}
+EXPORT_SYMBOL(rt_read_unlock);
+
+void __lockfunc rt_write_unlock(rwlock_t *rwlock)
+{
+	rwlock_release(&rwlock->dep_map, _RET_IP_);
+	migrate_enable();
+	rcu_read_unlock();
+	__write_rt_unlock(rwlock);
+}
+EXPORT_SYMBOL(rt_write_unlock);
+
+void __rt_rwlock_init(rwlock_t *rwlock, char *name, struct lock_class_key *key)
+{
+	__rwlock_biased_rt_init(rwlock, name, key);
+}
+EXPORT_SYMBOL(__rt_rwlock_init);
diff --git a/kernel/locking/rwsem-rt.c b/kernel/locking/rwsem-rt.c
new file mode 100644
index 000000000000..b61edc4dcb73
--- /dev/null
+++ b/kernel/locking/rwsem-rt.c
@@ -0,0 +1,317 @@
+// SPDX-License-Identifier: GPL-2.0-only
+#include <linux/rwsem.h>
+#include <linux/sched/debug.h>
+#include <linux/sched/signal.h>
+#include <linux/export.h>
+#include <linux/blkdev.h>
+
+#include "rtmutex_common.h"
+
+/*
+ * RT-specific reader/writer semaphores
+ *
+ * down_write()
+ *  1) Lock sem->rtmutex
+ *  2) Remove the reader BIAS to force readers into the slow path
+ *  3) Wait until all readers have left the critical region
+ *  4) Mark it write locked
+ *
+ * up_write()
+ *  1) Remove the write locked marker
+ *  2) Set the reader BIAS so readers can use the fast path again
+ *  3) Unlock sem->rtmutex to release blocked readers
+ *
+ * down_read()
+ *  1) Try fast path acquisition (reader BIAS is set)
+ *  2) Take sem->rtmutex.wait_lock which protects the writelocked flag
+ *  3) If !writelocked, acquire it for read
+ *  4) If writelocked, block on sem->rtmutex
+ *  5) unlock sem->rtmutex, goto 1)
+ *
+ * up_read()
+ *  1) Try fast path release (reader count != 1)
+ *  2) Wake the writer waiting in down_write()#3
+ *
+ * down_read()#3 has the consequence, that rw semaphores on RT are not writer
+ * fair, but writers, which should be avoided in RT tasks (think mmap_sem),
+ * are subject to the rtmutex priority/DL inheritance mechanism.
+ *
+ * It's possible to make the rw semaphores writer fair by keeping a list of
+ * active readers. A blocked writer would force all newly incoming readers to
+ * block on the rtmutex, but the rtmutex would have to be proxy locked for one
+ * reader after the other. We can't use multi-reader inheritance because there
+ * is no way to support that with SCHED_DEADLINE. Implementing the one by one
+ * reader boosting/handover mechanism is a major surgery for a very dubious
+ * value.
+ *
+ * The risk of writer starvation is there, but the pathological use cases
+ * which trigger it are not necessarily the typical RT workloads.
+ */
+
+void __rwsem_init(struct rw_semaphore *sem, const char *name,
+		  struct lock_class_key *key)
+{
+#ifdef CONFIG_DEBUG_LOCK_ALLOC
+	/*
+	 * Make sure we are not reinitializing a held semaphore:
+	 */
+	debug_check_no_locks_freed((void *)sem, sizeof(*sem));
+	lockdep_init_map(&sem->dep_map, name, key, 0);
+#endif
+	atomic_set(&sem->readers, READER_BIAS);
+}
+EXPORT_SYMBOL(__rwsem_init);
+
+int __down_read_trylock(struct rw_semaphore *sem)
+{
+	int r, old;
+
+	/*
+	 * Increment reader count, if sem->readers < 0, i.e. READER_BIAS is
+	 * set.
+	 */
+	for (r = atomic_read(&sem->readers); r < 0;) {
+		old = atomic_cmpxchg(&sem->readers, r, r + 1);
+		if (likely(old == r))
+			return 1;
+		r = old;
+	}
+	return 0;
+}
+
+static int __sched __down_read_common(struct rw_semaphore *sem, int state)
+{
+	struct rt_mutex *m = &sem->rtmutex;
+	struct rt_mutex_waiter waiter;
+	int ret;
+
+	if (__down_read_trylock(sem))
+		return 0;
+
+	/*
+	 * Flush blk before ->pi_blocked_on is set. At schedule() time it is too
+	 * late if one of the callbacks needs to acquire a sleeping lock.
+	 */
+	if (blk_needs_flush_plug(current))
+		blk_schedule_flush_plug(current);
+
+	might_sleep();
+	raw_spin_lock_irq(&m->wait_lock);
+	/*
+	 * Allow readers as long as the writer has not completely
+	 * acquired the semaphore for write.
+	 */
+	if (atomic_read(&sem->readers) != WRITER_BIAS) {
+		atomic_inc(&sem->readers);
+		raw_spin_unlock_irq(&m->wait_lock);
+		return 0;
+	}
+
+	/*
+	 * Call into the slow lock path with the rtmutex->wait_lock
+	 * held, so this can't result in the following race:
+	 *
+	 * Reader1		Reader2		Writer
+	 *			down_read()
+	 *					down_write()
+	 *					rtmutex_lock(m)
+	 *					swait()
+	 * down_read()
+	 * unlock(m->wait_lock)
+	 *			up_read()
+	 *			swake()
+	 *					lock(m->wait_lock)
+	 *					sem->writelocked=true
+	 *					unlock(m->wait_lock)
+	 *
+	 *					up_write()
+	 *					sem->writelocked=false
+	 *					rtmutex_unlock(m)
+	 *			down_read()
+	 *					down_write()
+	 *					rtmutex_lock(m)
+	 *					swait()
+	 * rtmutex_lock(m)
+	 *
+	 * That would put Reader1 behind the writer waiting on
+	 * Reader2 to call up_read() which might be unbound.
+	 */
+	rt_mutex_init_waiter(&waiter, false);
+	ret = rt_mutex_slowlock_locked(m, state, NULL, RT_MUTEX_MIN_CHAINWALK,
+				       NULL, &waiter);
+	/*
+	 * The slowlock() above is guaranteed to return with the rtmutex (for
+	 * ret = 0) is now held, so there can't be a writer active. Increment
+	 * the reader count and immediately drop the rtmutex again.
+	 * For ret != 0 we don't hold the rtmutex and need unlock the wait_lock.
+	 * We don't own the lock then.
+	 */
+	if (!ret)
+		atomic_inc(&sem->readers);
+	raw_spin_unlock_irq(&m->wait_lock);
+	if (!ret)
+		__rt_mutex_unlock(m);
+
+	debug_rt_mutex_free_waiter(&waiter);
+	return ret;
+}
+
+void __down_read(struct rw_semaphore *sem)
+{
+	int ret;
+
+	ret = __down_read_common(sem, TASK_UNINTERRUPTIBLE);
+	WARN_ON_ONCE(ret);
+}
+
+int __down_read_interruptible(struct rw_semaphore *sem)
+{
+	int ret;
+
+	ret = __down_read_common(sem, TASK_INTERRUPTIBLE);
+	if (likely(!ret))
+		return ret;
+	WARN_ONCE(ret != -EINTR, "Unexpected state: %d\n", ret);
+	return -EINTR;
+}
+
+int __down_read_killable(struct rw_semaphore *sem)
+{
+	int ret;
+
+	ret = __down_read_common(sem, TASK_KILLABLE);
+	if (likely(!ret))
+		return ret;
+	WARN_ONCE(ret != -EINTR, "Unexpected state: %d\n", ret);
+	return -EINTR;
+}
+
+void __up_read(struct rw_semaphore *sem)
+{
+	struct rt_mutex *m = &sem->rtmutex;
+	struct task_struct *tsk;
+
+	/*
+	 * sem->readers can only hit 0 when a writer is waiting for the
+	 * active readers to leave the critical region.
+	 */
+	if (!atomic_dec_and_test(&sem->readers))
+		return;
+
+	raw_spin_lock_irq(&m->wait_lock);
+	/*
+	 * Wake the writer, i.e. the rtmutex owner. It might release the
+	 * rtmutex concurrently in the fast path (due to a signal), but to
+	 * clean up the rwsem it needs to acquire m->wait_lock. The worst
+	 * case which can happen is a spurious wakeup.
+	 */
+	tsk = rt_mutex_owner(m);
+	if (tsk)
+		wake_up_process(tsk);
+
+	raw_spin_unlock_irq(&m->wait_lock);
+}
+
+static void __up_write_unlock(struct rw_semaphore *sem, int bias,
+			      unsigned long flags)
+{
+	struct rt_mutex *m = &sem->rtmutex;
+
+	atomic_add(READER_BIAS - bias, &sem->readers);
+	raw_spin_unlock_irqrestore(&m->wait_lock, flags);
+	__rt_mutex_unlock(m);
+}
+
+static int __sched __down_write_common(struct rw_semaphore *sem, int state)
+{
+	struct rt_mutex *m = &sem->rtmutex;
+	unsigned long flags;
+
+	/*
+	 * Flush blk before ->pi_blocked_on is set. At schedule() time it is too
+	 * late if one of the callbacks needs to acquire a sleeping lock.
+	 */
+	if (blk_needs_flush_plug(current))
+		blk_schedule_flush_plug(current);
+
+	/* Take the rtmutex as a first step */
+	if (__rt_mutex_lock_state(m, state))
+		return -EINTR;
+
+	/* Force readers into slow path */
+	atomic_sub(READER_BIAS, &sem->readers);
+	might_sleep();
+
+	set_current_state(state);
+	for (;;) {
+		raw_spin_lock_irqsave(&m->wait_lock, flags);
+		/* Have all readers left the critical region? */
+		if (!atomic_read(&sem->readers)) {
+			atomic_set(&sem->readers, WRITER_BIAS);
+			__set_current_state(TASK_RUNNING);
+			raw_spin_unlock_irqrestore(&m->wait_lock, flags);
+			return 0;
+		}
+
+		if (signal_pending_state(state, current)) {
+			__set_current_state(TASK_RUNNING);
+			__up_write_unlock(sem, 0, flags);
+			return -EINTR;
+		}
+		raw_spin_unlock_irqrestore(&m->wait_lock, flags);
+
+		if (atomic_read(&sem->readers) != 0) {
+			schedule();
+			set_current_state(state);
+		}
+	}
+}
+
+void __sched __down_write(struct rw_semaphore *sem)
+{
+	__down_write_common(sem, TASK_UNINTERRUPTIBLE);
+}
+
+int __sched __down_write_killable(struct rw_semaphore *sem)
+{
+	return __down_write_common(sem, TASK_KILLABLE);
+}
+
+int __down_write_trylock(struct rw_semaphore *sem)
+{
+	struct rt_mutex *m = &sem->rtmutex;
+	unsigned long flags;
+
+	if (!__rt_mutex_trylock(m))
+		return 0;
+
+	atomic_sub(READER_BIAS, &sem->readers);
+
+	raw_spin_lock_irqsave(&m->wait_lock, flags);
+	if (!atomic_read(&sem->readers)) {
+		atomic_set(&sem->readers, WRITER_BIAS);
+		raw_spin_unlock_irqrestore(&m->wait_lock, flags);
+		return 1;
+	}
+	__up_write_unlock(sem, 0, flags);
+	return 0;
+}
+
+void __up_write(struct rw_semaphore *sem)
+{
+	struct rt_mutex *m = &sem->rtmutex;
+	unsigned long flags;
+
+	raw_spin_lock_irqsave(&m->wait_lock, flags);
+	__up_write_unlock(sem, WRITER_BIAS, flags);
+}
+
+void __downgrade_write(struct rw_semaphore *sem)
+{
+	struct rt_mutex *m = &sem->rtmutex;
+	unsigned long flags;
+
+	raw_spin_lock_irqsave(&m->wait_lock, flags);
+	/* Release it and account current as reader */
+	__up_write_unlock(sem, WRITER_BIAS - 1, flags);
+}
diff --git a/kernel/locking/rwsem.c b/kernel/locking/rwsem.c
index cc5cc889b5b7..f7c909ef1261 100644
--- a/kernel/locking/rwsem.c
+++ b/kernel/locking/rwsem.c
@@ -28,6 +28,7 @@
 #include <linux/rwsem.h>
 #include <linux/atomic.h>
 
+#ifndef CONFIG_PREEMPT_RT
 #include "lock_events.h"
 
 /*
@@ -1494,6 +1495,7 @@ static inline void __downgrade_write(struct rw_semaphore *sem)
 	if (tmp & RWSEM_FLAG_WAITERS)
 		rwsem_downgrade_wake(sem);
 }
+#endif
 
 /*
  * lock for reading
@@ -1657,7 +1659,9 @@ void down_read_non_owner(struct rw_semaphore *sem)
 {
 	might_sleep();
 	__down_read(sem);
+#ifndef CONFIG_PREEMPT_RT
 	__rwsem_set_reader_owned(sem, NULL);
+#endif
 }
 EXPORT_SYMBOL(down_read_non_owner);
 
@@ -1686,7 +1690,9 @@ EXPORT_SYMBOL(down_write_killable_nested);
 
 void up_read_non_owner(struct rw_semaphore *sem)
 {
+#ifndef CONFIG_PREEMPT_RT
 	DEBUG_RWSEMS_WARN_ON(!is_rwsem_reader_owned(sem), sem);
+#endif
 	__up_read(sem);
 }
 EXPORT_SYMBOL(up_read_non_owner);
diff --git a/kernel/locking/spinlock.c b/kernel/locking/spinlock.c
index 0ff08380f531..45445a2f1799 100644
--- a/kernel/locking/spinlock.c
+++ b/kernel/locking/spinlock.c
@@ -124,8 +124,11 @@ void __lockfunc __raw_##op##_lock_bh(locktype##_t *lock)		\
  *         __[spin|read|write]_lock_bh()
  */
 BUILD_LOCK_OPS(spin, raw_spinlock);
+
+#ifndef CONFIG_PREEMPT_RT
 BUILD_LOCK_OPS(read, rwlock);
 BUILD_LOCK_OPS(write, rwlock);
+#endif
 
 #endif
 
@@ -209,6 +212,8 @@ void __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)
 EXPORT_SYMBOL(_raw_spin_unlock_bh);
 #endif
 
+#ifndef CONFIG_PREEMPT_RT
+
 #ifndef CONFIG_INLINE_READ_TRYLOCK
 int __lockfunc _raw_read_trylock(rwlock_t *lock)
 {
@@ -353,6 +358,8 @@ void __lockfunc _raw_write_unlock_bh(rwlock_t *lock)
 EXPORT_SYMBOL(_raw_write_unlock_bh);
 #endif
 
+#endif /* !PREEMPT_RT */
+
 #ifdef CONFIG_DEBUG_LOCK_ALLOC
 
 void __lockfunc _raw_spin_lock_nested(raw_spinlock_t *lock, int subclass)
diff --git a/kernel/locking/spinlock_debug.c b/kernel/locking/spinlock_debug.c
index b9d93087ee66..72e306e0e8a3 100644
--- a/kernel/locking/spinlock_debug.c
+++ b/kernel/locking/spinlock_debug.c
@@ -31,6 +31,7 @@ void __raw_spin_lock_init(raw_spinlock_t *lock, const char *name,
 
 EXPORT_SYMBOL(__raw_spin_lock_init);
 
+#ifndef CONFIG_PREEMPT_RT
 void __rwlock_init(rwlock_t *lock, const char *name,
 		   struct lock_class_key *key)
 {
@@ -48,6 +49,7 @@ void __rwlock_init(rwlock_t *lock, const char *name,
 }
 
 EXPORT_SYMBOL(__rwlock_init);
+#endif
 
 static void spin_dump(raw_spinlock_t *lock, const char *msg)
 {
@@ -139,6 +141,7 @@ void do_raw_spin_unlock(raw_spinlock_t *lock)
 	arch_spin_unlock(&lock->raw_lock);
 }
 
+#ifndef CONFIG_PREEMPT_RT
 static void rwlock_bug(rwlock_t *lock, const char *msg)
 {
 	if (!debug_locks_off())
@@ -228,3 +231,5 @@ void do_raw_write_unlock(rwlock_t *lock)
 	debug_write_unlock(lock);
 	arch_write_unlock(&lock->raw_lock);
 }
+
+#endif
diff --git a/kernel/notifier.c b/kernel/notifier.c
index 1b019cbca594..c20782f07643 100644
--- a/kernel/notifier.c
+++ b/kernel/notifier.c
@@ -142,9 +142,9 @@ int atomic_notifier_chain_register(struct atomic_notifier_head *nh,
 	unsigned long flags;
 	int ret;
 
-	spin_lock_irqsave(&nh->lock, flags);
+	raw_spin_lock_irqsave(&nh->lock, flags);
 	ret = notifier_chain_register(&nh->head, n);
-	spin_unlock_irqrestore(&nh->lock, flags);
+	raw_spin_unlock_irqrestore(&nh->lock, flags);
 	return ret;
 }
 EXPORT_SYMBOL_GPL(atomic_notifier_chain_register);
@@ -164,9 +164,9 @@ int atomic_notifier_chain_unregister(struct atomic_notifier_head *nh,
 	unsigned long flags;
 	int ret;
 
-	spin_lock_irqsave(&nh->lock, flags);
+	raw_spin_lock_irqsave(&nh->lock, flags);
 	ret = notifier_chain_unregister(&nh->head, n);
-	spin_unlock_irqrestore(&nh->lock, flags);
+	raw_spin_unlock_irqrestore(&nh->lock, flags);
 	synchronize_rcu();
 	return ret;
 }
@@ -182,9 +182,9 @@ int atomic_notifier_call_chain_robust(struct atomic_notifier_head *nh,
 	 * Musn't use RCU; because then the notifier list can
 	 * change between the up and down traversal.
 	 */
-	spin_lock_irqsave(&nh->lock, flags);
+	raw_spin_lock_irqsave(&nh->lock, flags);
 	ret = notifier_call_chain_robust(&nh->head, val_up, val_down, v);
-	spin_unlock_irqrestore(&nh->lock, flags);
+	raw_spin_unlock_irqrestore(&nh->lock, flags);
 
 	return ret;
 }
diff --git a/kernel/panic.c b/kernel/panic.c
index d991c3b1b559..fa3025e0c601 100644
--- a/kernel/panic.c
+++ b/kernel/panic.c
@@ -177,12 +177,28 @@ static void panic_print_sys_info(void)
 void panic(const char *fmt, ...)
 {
 	static char buf[1024];
+	va_list args2;
 	va_list args;
 	long i, i_next = 0, len;
 	int state = 0;
 	int old_cpu, this_cpu;
 	bool _crash_kexec_post_notifiers = crash_kexec_post_notifiers;
 
+	console_verbose();
+	pr_emerg("Kernel panic - not syncing:\n");
+	va_start(args2, fmt);
+	va_copy(args, args2);
+	vprintk(fmt, args2);
+	va_end(args2);
+#ifdef CONFIG_DEBUG_BUGVERBOSE
+	/*
+	 * Avoid nested stack-dumping if a panic occurs during oops processing
+	 */
+	if (!test_taint(TAINT_DIE) && oops_in_progress <= 1)
+		dump_stack();
+#endif
+	pr_flush(1000, true);
+
 	/*
 	 * Disable local interrupts. This will prevent panic_smp_self_stop
 	 * from deadlocking the first cpu that invokes the panic, since
@@ -213,24 +229,13 @@ void panic(const char *fmt, ...)
 	if (old_cpu != PANIC_CPU_INVALID && old_cpu != this_cpu)
 		panic_smp_self_stop();
 
-	console_verbose();
 	bust_spinlocks(1);
-	va_start(args, fmt);
 	len = vscnprintf(buf, sizeof(buf), fmt, args);
 	va_end(args);
 
 	if (len && buf[len - 1] == '\n')
 		buf[len - 1] = '\0';
 
-	pr_emerg("Kernel panic - not syncing: %s\n", buf);
-#ifdef CONFIG_DEBUG_BUGVERBOSE
-	/*
-	 * Avoid nested stack-dumping if a panic occurs during oops processing
-	 */
-	if (!test_taint(TAINT_DIE) && oops_in_progress <= 1)
-		dump_stack();
-#endif
-
 	/*
 	 * If kgdb is enabled, give it a chance to run before we stop all
 	 * the other CPUs or else we won't be able to debug processes left
@@ -247,7 +252,6 @@ void panic(const char *fmt, ...)
 	 * Bypass the panic_cpu check and call __crash_kexec directly.
 	 */
 	if (!_crash_kexec_post_notifiers) {
-		printk_safe_flush_on_panic();
 		__crash_kexec(NULL);
 
 		/*
@@ -298,8 +302,6 @@ void panic(const char *fmt, ...)
 	 */
 	atomic_notifier_call_chain(&panic_notifier_list, 0, buf);
 
-	/* Call flush even twice. It tries harder with a single online CPU */
-	printk_safe_flush_on_panic();
 	kmsg_dump(KMSG_DUMP_PANIC);
 
 	/*
@@ -569,9 +571,11 @@ static u64 oops_id;
 
 static int init_oops_id(void)
 {
+#ifndef CONFIG_PREEMPT_RT
 	if (!oops_id)
 		get_random_bytes(&oops_id, sizeof(oops_id));
 	else
+#endif
 		oops_id++;
 
 	return 0;
@@ -582,6 +586,7 @@ static void print_oops_end_marker(void)
 {
 	init_oops_id();
 	pr_warn("---[ end trace %016llx ]---\n", (unsigned long long)oops_id);
+	pr_flush(1000, true);
 }
 
 /*
diff --git a/kernel/printk/Makefile b/kernel/printk/Makefile
index eee3dc9b60a9..59cb24e25f00 100644
--- a/kernel/printk/Makefile
+++ b/kernel/printk/Makefile
@@ -1,5 +1,4 @@
 # SPDX-License-Identifier: GPL-2.0-only
 obj-y	= printk.o
-obj-$(CONFIG_PRINTK)	+= printk_safe.o
 obj-$(CONFIG_A11Y_BRAILLE_CONSOLE)	+= braille.o
 obj-$(CONFIG_PRINTK)	+= printk_ringbuffer.o
diff --git a/kernel/printk/internal.h b/kernel/printk/internal.h
index b1c155328b04..e69de29bb2d1 100644
--- a/kernel/printk/internal.h
+++ b/kernel/printk/internal.h
@@ -1,37 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0-or-later */
-/*
- * internal.h - printk internal definitions
- */
-#include <linux/percpu.h>
-
-#ifdef CONFIG_PRINTK
-
-#define PRINTK_SAFE_CONTEXT_MASK	0x007ffffff
-#define PRINTK_NMI_DIRECT_CONTEXT_MASK	0x008000000
-#define PRINTK_NMI_CONTEXT_MASK		0xff0000000
-
-#define PRINTK_NMI_CONTEXT_OFFSET	0x010000000
-
-extern raw_spinlock_t logbuf_lock;
-
-__printf(4, 0)
-int vprintk_store(int facility, int level,
-		  const struct dev_printk_info *dev_info,
-		  const char *fmt, va_list args);
-
-__printf(1, 0) int vprintk_default(const char *fmt, va_list args);
-__printf(1, 0) int vprintk_deferred(const char *fmt, va_list args);
-__printf(1, 0) int vprintk_func(const char *fmt, va_list args);
-
-void printk_safe_init(void);
-bool printk_percpu_data_ready(void);
-
-void defer_console_output(void);
-
-#else
-
-__printf(1, 0) int vprintk_func(const char *fmt, va_list args) { return 0; }
-
-static inline void printk_safe_init(void) { }
-static inline bool printk_percpu_data_ready(void) { return false; }
-#endif /* CONFIG_PRINTK */
diff --git a/kernel/printk/printk.c b/kernel/printk/printk.c
index ecd28d4fa20e..5d44477e4c1d 100644
--- a/kernel/printk/printk.c
+++ b/kernel/printk/printk.c
@@ -44,6 +44,9 @@
 #include <linux/irq_work.h>
 #include <linux/ctype.h>
 #include <linux/uio.h>
+#include <linux/kthread.h>
+#include <linux/kdb.h>
+#include <linux/clocksource.h>
 #include <linux/sched/clock.h>
 #include <linux/sched/debug.h>
 #include <linux/sched/task_stack.h>
@@ -58,7 +61,6 @@
 #include "printk_ringbuffer.h"
 #include "console_cmdline.h"
 #include "braille.h"
-#include "internal.h"
 
 int console_printk[4] = {
 	CONSOLE_LOGLEVEL_DEFAULT,	/* console_loglevel */
@@ -93,12 +95,6 @@ EXPORT_SYMBOL_GPL(console_drivers);
  */
 int __read_mostly suppress_printk;
 
-#ifdef CONFIG_LOCKDEP
-static struct lockdep_map console_lock_dep_map = {
-	.name = "console_lock"
-};
-#endif
-
 enum devkmsg_log_bits {
 	__DEVKMSG_LOG_BIT_ON = 0,
 	__DEVKMSG_LOG_BIT_OFF,
@@ -227,19 +223,7 @@ static int nr_ext_console_drivers;
 
 static int __down_trylock_console_sem(unsigned long ip)
 {
-	int lock_failed;
-	unsigned long flags;
-
-	/*
-	 * Here and in __up_console_sem() we need to be in safe mode,
-	 * because spindump/WARN/etc from under console ->lock will
-	 * deadlock in printk()->down_trylock_console_sem() otherwise.
-	 */
-	printk_safe_enter_irqsave(flags);
-	lock_failed = down_trylock(&console_sem);
-	printk_safe_exit_irqrestore(flags);
-
-	if (lock_failed)
+	if (down_trylock(&console_sem))
 		return 1;
 	mutex_acquire(&console_lock_dep_map, 0, 1, ip);
 	return 0;
@@ -248,13 +232,9 @@ static int __down_trylock_console_sem(unsigned long ip)
 
 static void __up_console_sem(unsigned long ip)
 {
-	unsigned long flags;
-
 	mutex_release(&console_lock_dep_map, ip);
 
-	printk_safe_enter_irqsave(flags);
 	up(&console_sem);
-	printk_safe_exit_irqrestore(flags);
 }
 #define up_console_sem() __up_console_sem(_RET_IP_)
 
@@ -268,11 +248,6 @@ static void __up_console_sem(unsigned long ip)
  */
 static int console_locked, console_suspended;
 
-/*
- * If exclusive_console is non-NULL then only this console is to be printed to.
- */
-static struct console *exclusive_console;
-
 /*
  *	Array of consoles built from command line options (console=)
  */
@@ -357,61 +332,43 @@ enum log_flags {
 	LOG_CONT	= 8,	/* text is a fragment of a continuation line */
 };
 
-/*
- * The logbuf_lock protects kmsg buffer, indices, counters.  This can be taken
- * within the scheduler's rq lock. It must be released before calling
- * console_unlock() or anything else that might wake up a process.
- */
-DEFINE_RAW_SPINLOCK(logbuf_lock);
+#ifdef CONFIG_PRINTK
+/* syslog_lock protects syslog_* variables and write access to clear_seq. */
+static DEFINE_SPINLOCK(syslog_lock);
 
-/*
- * Helper macros to lock/unlock logbuf_lock and switch between
- * printk-safe/unsafe modes.
- */
-#define logbuf_lock_irq()				\
-	do {						\
-		printk_safe_enter_irq();		\
-		raw_spin_lock(&logbuf_lock);		\
-	} while (0)
-
-#define logbuf_unlock_irq()				\
-	do {						\
-		raw_spin_unlock(&logbuf_lock);		\
-		printk_safe_exit_irq();			\
-	} while (0)
-
-#define logbuf_lock_irqsave(flags)			\
-	do {						\
-		printk_safe_enter_irqsave(flags);	\
-		raw_spin_lock(&logbuf_lock);		\
-	} while (0)
-
-#define logbuf_unlock_irqrestore(flags)		\
-	do {						\
-		raw_spin_unlock(&logbuf_lock);		\
-		printk_safe_exit_irqrestore(flags);	\
-	} while (0)
+/* Set to enable sync mode. Once set, it is never cleared. */
+static bool sync_mode;
 
-#ifdef CONFIG_PRINTK
 DECLARE_WAIT_QUEUE_HEAD(log_wait);
+/* All 3 protected by @syslog_lock. */
 /* the next printk record to read by syslog(READ) or /proc/kmsg */
 static u64 syslog_seq;
 static size_t syslog_partial;
 static bool syslog_time;
 
-/* the next printk record to write to the console */
-static u64 console_seq;
-static u64 exclusive_console_stop_seq;
-static unsigned long console_dropped;
+struct latched_seq {
+	seqcount_latch_t	latch;
+	u64			val[2];
+};
 
-/* the next printk record to read after the last 'clear' command */
-static u64 clear_seq;
+/*
+ * The next printk record to read after the last 'clear' command. There are
+ * two copies (updated with seqcount_latch) so that reads can locklessly
+ * access a valid value. Writers are synchronized by @syslog_lock.
+ */
+static struct latched_seq clear_seq = {
+	.latch		= SEQCNT_LATCH_ZERO(clear_seq.latch),
+	.val[0]		= 0,
+	.val[1]		= 0,
+};
 
 #ifdef CONFIG_PRINTK_CALLER
 #define PREFIX_MAX		48
 #else
 #define PREFIX_MAX		32
 #endif
+
+/* the maximum size allowed to be reserved for a record */
 #define LOG_LINE_MAX		(1024 - PREFIX_MAX)
 
 #define LOG_LEVEL(v)		((v) & 0x07)
@@ -449,11 +406,36 @@ static struct printk_ringbuffer *prb = &printk_rb_static;
  */
 static bool __printk_percpu_data_ready __read_mostly;
 
-bool printk_percpu_data_ready(void)
+static bool printk_percpu_data_ready(void)
 {
 	return __printk_percpu_data_ready;
 }
 
+/* Must be called under syslog_lock. */
+static void latched_seq_write(struct latched_seq *ls, u64 val)
+{
+	raw_write_seqcount_latch(&ls->latch);
+	ls->val[0] = val;
+	raw_write_seqcount_latch(&ls->latch);
+	ls->val[1] = val;
+}
+
+/* Can be called from any context. */
+static u64 latched_seq_read_nolock(struct latched_seq *ls)
+{
+	unsigned int seq;
+	unsigned int idx;
+	u64 val;
+
+	do {
+		seq = raw_read_seqcount_latch(&ls->latch);
+		idx = seq & 0x1;
+		val = ls->val[idx];
+	} while (read_seqcount_latch_retry(&ls->latch, seq));
+
+	return val;
+}
+
 /* Return log buffer address */
 char *log_buf_addr_get(void)
 {
@@ -495,52 +477,6 @@ static void truncate_msg(u16 *text_len, u16 *trunc_msg_len)
 		*trunc_msg_len = 0;
 }
 
-/* insert record into the buffer, discard old ones, update heads */
-static int log_store(u32 caller_id, int facility, int level,
-		     enum log_flags flags, u64 ts_nsec,
-		     const struct dev_printk_info *dev_info,
-		     const char *text, u16 text_len)
-{
-	struct prb_reserved_entry e;
-	struct printk_record r;
-	u16 trunc_msg_len = 0;
-
-	prb_rec_init_wr(&r, text_len);
-
-	if (!prb_reserve(&e, prb, &r)) {
-		/* truncate the message if it is too long for empty buffer */
-		truncate_msg(&text_len, &trunc_msg_len);
-		prb_rec_init_wr(&r, text_len + trunc_msg_len);
-		/* survive when the log buffer is too small for trunc_msg */
-		if (!prb_reserve(&e, prb, &r))
-			return 0;
-	}
-
-	/* fill message */
-	memcpy(&r.text_buf[0], text, text_len);
-	if (trunc_msg_len)
-		memcpy(&r.text_buf[text_len], trunc_msg, trunc_msg_len);
-	r.info->text_len = text_len + trunc_msg_len;
-	r.info->facility = facility;
-	r.info->level = level & 7;
-	r.info->flags = flags & 0x1f;
-	if (ts_nsec > 0)
-		r.info->ts_nsec = ts_nsec;
-	else
-		r.info->ts_nsec = local_clock();
-	r.info->caller_id = caller_id;
-	if (dev_info)
-		memcpy(&r.info->dev_info, dev_info, sizeof(r.info->dev_info));
-
-	/* A message without a trailing newline can be continued. */
-	if (!(flags & LOG_NEWLINE))
-		prb_commit(&e);
-	else
-		prb_final_commit(&e);
-
-	return (text_len + trunc_msg_len);
-}
-
 int dmesg_restrict = IS_ENABLED(CONFIG_SECURITY_DMESG_RESTRICT);
 
 static int syslog_action_restricted(int type)
@@ -669,7 +605,7 @@ static ssize_t msg_print_ext_body(char *buf, size_t size,
 
 /* /dev/kmsg - userspace message inject/listen interface */
 struct devkmsg_user {
-	u64 seq;
+	atomic64_t seq;
 	struct ratelimit_state rs;
 	struct mutex lock;
 	char buf[CONSOLE_EXT_LOG_MAX];
@@ -770,27 +706,22 @@ static ssize_t devkmsg_read(struct file *file, char __user *buf,
 	if (ret)
 		return ret;
 
-	logbuf_lock_irq();
-	if (!prb_read_valid(prb, user->seq, r)) {
+	if (!prb_read_valid(prb, atomic64_read(&user->seq), r)) {
 		if (file->f_flags & O_NONBLOCK) {
 			ret = -EAGAIN;
-			logbuf_unlock_irq();
 			goto out;
 		}
 
-		logbuf_unlock_irq();
 		ret = wait_event_interruptible(log_wait,
-					prb_read_valid(prb, user->seq, r));
+				prb_read_valid(prb, atomic64_read(&user->seq), r));
 		if (ret)
 			goto out;
-		logbuf_lock_irq();
 	}
 
-	if (r->info->seq != user->seq) {
+	if (r->info->seq != atomic64_read(&user->seq)) {
 		/* our last seen message is gone, return error and reset */
-		user->seq = r->info->seq;
+		atomic64_set(&user->seq, r->info->seq);
 		ret = -EPIPE;
-		logbuf_unlock_irq();
 		goto out;
 	}
 
@@ -799,8 +730,7 @@ static ssize_t devkmsg_read(struct file *file, char __user *buf,
 				  &r->text_buf[0], r->info->text_len,
 				  &r->info->dev_info);
 
-	user->seq = r->info->seq + 1;
-	logbuf_unlock_irq();
+	atomic64_set(&user->seq, r->info->seq + 1);
 
 	if (len > count) {
 		ret = -EINVAL;
@@ -835,11 +765,10 @@ static loff_t devkmsg_llseek(struct file *file, loff_t offset, int whence)
 	if (offset)
 		return -ESPIPE;
 
-	logbuf_lock_irq();
 	switch (whence) {
 	case SEEK_SET:
 		/* the first record */
-		user->seq = prb_first_valid_seq(prb);
+		atomic64_set(&user->seq, prb_first_valid_seq(prb));
 		break;
 	case SEEK_DATA:
 		/*
@@ -847,16 +776,15 @@ static loff_t devkmsg_llseek(struct file *file, loff_t offset, int whence)
 		 * like issued by 'dmesg -c'. Reading /dev/kmsg itself
 		 * changes no global state, and does not clear anything.
 		 */
-		user->seq = clear_seq;
+		atomic64_set(&user->seq, latched_seq_read_nolock(&clear_seq));
 		break;
 	case SEEK_END:
 		/* after the last record */
-		user->seq = prb_next_seq(prb);
+		atomic64_set(&user->seq, prb_next_seq(prb));
 		break;
 	default:
 		ret = -EINVAL;
 	}
-	logbuf_unlock_irq();
 	return ret;
 }
 
@@ -871,15 +799,13 @@ static __poll_t devkmsg_poll(struct file *file, poll_table *wait)
 
 	poll_wait(file, &log_wait, wait);
 
-	logbuf_lock_irq();
-	if (prb_read_valid_info(prb, user->seq, &info, NULL)) {
+	if (prb_read_valid_info(prb, atomic64_read(&user->seq), &info, NULL)) {
 		/* return error when data has vanished underneath us */
-		if (info.seq != user->seq)
+		if (info.seq != atomic64_read(&user->seq))
 			ret = EPOLLIN|EPOLLRDNORM|EPOLLERR|EPOLLPRI;
 		else
 			ret = EPOLLIN|EPOLLRDNORM;
 	}
-	logbuf_unlock_irq();
 
 	return ret;
 }
@@ -912,9 +838,7 @@ static int devkmsg_open(struct inode *inode, struct file *file)
 	prb_rec_init_rd(&user->record, &user->info,
 			&user->text_buf[0], sizeof(user->text_buf));
 
-	logbuf_lock_irq();
-	user->seq = prb_first_valid_seq(prb);
-	logbuf_unlock_irq();
+	atomic64_set(&user->seq, prb_first_valid_seq(prb));
 
 	file->private_data = user;
 	return 0;
@@ -1006,6 +930,9 @@ void log_buf_vmcoreinfo_setup(void)
 
 	VMCOREINFO_SIZE(atomic_long_t);
 	VMCOREINFO_TYPE_OFFSET(atomic_long_t, counter);
+
+	VMCOREINFO_STRUCT_SIZE(latched_seq);
+	VMCOREINFO_OFFSET(latched_seq, val);
 }
 #endif
 
@@ -1077,9 +1004,6 @@ static inline void log_buf_add_cpu(void) {}
 
 static void __init set_percpu_data_ready(void)
 {
-	printk_safe_init();
-	/* Make sure we set this flag only after printk_safe() init is done */
-	barrier();
 	__printk_percpu_data_ready = true;
 }
 
@@ -1119,7 +1043,6 @@ void __init setup_log_buf(int early)
 	struct printk_record r;
 	size_t new_descs_size;
 	size_t new_infos_size;
-	unsigned long flags;
 	char *new_log_buf;
 	unsigned int free;
 	u64 seq;
@@ -1177,8 +1100,6 @@ void __init setup_log_buf(int early)
 		 new_descs, ilog2(new_descs_count),
 		 new_infos);
 
-	logbuf_lock_irqsave(flags);
-
 	log_buf_len = new_log_buf_len;
 	log_buf = new_log_buf;
 	new_log_buf_len = 0;
@@ -1194,8 +1115,6 @@ void __init setup_log_buf(int early)
 	 */
 	prb = &printk_rb_dynamic;
 
-	logbuf_unlock_irqrestore(flags);
-
 	if (seq != prb_next_seq(&printk_rb_static)) {
 		pr_err("dropped %llu messages\n",
 		       prb_next_seq(&printk_rb_static) - seq);
@@ -1472,6 +1391,50 @@ static size_t get_record_print_text_size(struct printk_info *info,
 	return ((prefix_len * line_count) + info->text_len + 1);
 }
 
+/*
+ * Beginning with @start_seq, find the first record where it and all following
+ * records up to (but not including) @max_seq fit into @size.
+ *
+ * @max_seq is simply an upper bound and does not need to exist. If the caller
+ * does not require an upper bound, -1 can be used for @max_seq.
+ */
+static u64 find_first_fitting_seq(u64 start_seq, u64 max_seq, size_t size,
+				  bool syslog, bool time)
+{
+	struct printk_info info;
+	unsigned int line_count;
+	size_t len = 0;
+	u64 seq;
+
+	/* Determine the size of the records up to @max_seq. */
+	prb_for_each_info(start_seq, prb, seq, &info, &line_count) {
+		if (info.seq >= max_seq)
+			break;
+		len += get_record_print_text_size(&info, line_count, syslog, time);
+	}
+
+	/*
+	 * Adjust the upper bound for the next loop to avoid subtracting
+	 * lengths that were never added.
+	 */
+	if (seq < max_seq)
+		max_seq = seq;
+
+	/*
+	 * Move first record forward until length fits into the buffer. Ignore
+	 * newest messages that were not counted in the above cycle. Messages
+	 * might appear and get lost in the meantime. This is a best effort
+	 * that prevents an infinite loop that could occur with a retry.
+	 */
+	prb_for_each_info(start_seq, prb, seq, &info, &line_count) {
+		if (len <= size || info.seq >= max_seq)
+			break;
+		len -= get_record_print_text_size(&info, line_count, syslog, time);
+	}
+
+	return seq;
+}
+
 static int syslog_print(char __user *buf, int size)
 {
 	struct printk_info info;
@@ -1479,19 +1442,19 @@ static int syslog_print(char __user *buf, int size)
 	char *text;
 	int len = 0;
 
-	text = kmalloc(LOG_LINE_MAX + PREFIX_MAX, GFP_KERNEL);
+	text = kmalloc(CONSOLE_LOG_MAX, GFP_KERNEL);
 	if (!text)
 		return -ENOMEM;
 
-	prb_rec_init_rd(&r, &info, text, LOG_LINE_MAX + PREFIX_MAX);
+	prb_rec_init_rd(&r, &info, text, CONSOLE_LOG_MAX);
 
 	while (size > 0) {
 		size_t n;
 		size_t skip;
 
-		logbuf_lock_irq();
+		spin_lock_irq(&syslog_lock);
 		if (!prb_read_valid(prb, syslog_seq, &r)) {
-			logbuf_unlock_irq();
+			spin_unlock_irq(&syslog_lock);
 			break;
 		}
 		if (r.info->seq != syslog_seq) {
@@ -1520,7 +1483,7 @@ static int syslog_print(char __user *buf, int size)
 			syslog_partial += n;
 		} else
 			n = 0;
-		logbuf_unlock_irq();
+		spin_unlock_irq(&syslog_lock);
 
 		if (!n)
 			break;
@@ -1543,34 +1506,25 @@ static int syslog_print(char __user *buf, int size)
 static int syslog_print_all(char __user *buf, int size, bool clear)
 {
 	struct printk_info info;
-	unsigned int line_count;
 	struct printk_record r;
 	char *text;
 	int len = 0;
 	u64 seq;
 	bool time;
 
-	text = kmalloc(LOG_LINE_MAX + PREFIX_MAX, GFP_KERNEL);
+	text = kmalloc(CONSOLE_LOG_MAX, GFP_KERNEL);
 	if (!text)
 		return -ENOMEM;
 
 	time = printk_time;
-	logbuf_lock_irq();
 	/*
 	 * Find first record that fits, including all following records,
 	 * into the user-provided buffer for this dump.
 	 */
-	prb_for_each_info(clear_seq, prb, seq, &info, &line_count)
-		len += get_record_print_text_size(&info, line_count, true, time);
-
-	/* move first record forward until length fits into the buffer */
-	prb_for_each_info(clear_seq, prb, seq, &info, &line_count) {
-		if (len <= size)
-			break;
-		len -= get_record_print_text_size(&info, line_count, true, time);
-	}
+	seq = find_first_fitting_seq(latched_seq_read_nolock(&clear_seq), -1,
+				     size, true, time);
 
-	prb_rec_init_rd(&r, &info, text, LOG_LINE_MAX + PREFIX_MAX);
+	prb_rec_init_rd(&r, &info, text, CONSOLE_LOG_MAX);
 
 	len = 0;
 	prb_for_each_record(seq, prb, seq, &r) {
@@ -1583,20 +1537,20 @@ static int syslog_print_all(char __user *buf, int size, bool clear)
 			break;
 		}
 
-		logbuf_unlock_irq();
 		if (copy_to_user(buf + len, text, textlen))
 			len = -EFAULT;
 		else
 			len += textlen;
-		logbuf_lock_irq();
 
 		if (len < 0)
 			break;
 	}
 
-	if (clear)
-		clear_seq = seq;
-	logbuf_unlock_irq();
+	if (clear) {
+		spin_lock_irq(&syslog_lock);
+		latched_seq_write(&clear_seq, seq);
+		spin_unlock_irq(&syslog_lock);
+	}
 
 	kfree(text);
 	return len;
@@ -1604,9 +1558,21 @@ static int syslog_print_all(char __user *buf, int size, bool clear)
 
 static void syslog_clear(void)
 {
-	logbuf_lock_irq();
-	clear_seq = prb_next_seq(prb);
-	logbuf_unlock_irq();
+	spin_lock_irq(&syslog_lock);
+	latched_seq_write(&clear_seq, prb_next_seq(prb));
+	spin_unlock_irq(&syslog_lock);
+}
+
+/* Return a consistent copy of @syslog_seq. */
+static u64 read_syslog_seq_irq(void)
+{
+	u64 seq;
+
+	spin_lock_irq(&syslog_lock);
+	seq = syslog_seq;
+	spin_unlock_irq(&syslog_lock);
+
+	return seq;
 }
 
 int do_syslog(int type, char __user *buf, int len, int source)
@@ -1632,8 +1598,9 @@ int do_syslog(int type, char __user *buf, int len, int source)
 			return 0;
 		if (!access_ok(buf, len))
 			return -EFAULT;
+
 		error = wait_event_interruptible(log_wait,
-				prb_read_valid(prb, syslog_seq, NULL));
+				prb_read_valid(prb, read_syslog_seq_irq(), NULL));
 		if (error)
 			return error;
 		error = syslog_print(buf, len);
@@ -1681,10 +1648,10 @@ int do_syslog(int type, char __user *buf, int len, int source)
 		break;
 	/* Number of chars in the log buffer */
 	case SYSLOG_ACTION_SIZE_UNREAD:
-		logbuf_lock_irq();
+		spin_lock_irq(&syslog_lock);
 		if (!prb_read_valid_info(prb, syslog_seq, &info, NULL)) {
 			/* No unread messages. */
-			logbuf_unlock_irq();
+			spin_unlock_irq(&syslog_lock);
 			return 0;
 		}
 		if (info.seq != syslog_seq) {
@@ -1712,7 +1679,7 @@ int do_syslog(int type, char __user *buf, int len, int source)
 			}
 			error -= syslog_partial;
 		}
-		logbuf_unlock_irq();
+		spin_unlock_irq(&syslog_lock);
 		break;
 	/* Size of the log buffer */
 	case SYSLOG_ACTION_SIZE_BUFFER:
@@ -1742,9 +1709,7 @@ static struct lockdep_map console_owner_dep_map = {
 };
 #endif
 
-static DEFINE_RAW_SPINLOCK(console_owner_lock);
-static struct task_struct *console_owner;
-static bool console_waiter;
+int printk_delay_msec __read_mostly;
 
 #if defined(CONFIG_X86) || defined(CONFIG_ARM64_PSEUDO_NMI)
 void zap_locks(void)
@@ -1765,187 +1730,171 @@ void zap_locks(void)
 }
 #endif
 
-/**
- * console_lock_spinning_enable - mark beginning of code where another
- *	thread might safely busy wait
- *
- * This basically converts console_lock into a spinlock. This marks
- * the section where the console_lock owner can not sleep, because
- * there may be a waiter spinning (like a spinlock). Also it must be
- * ready to hand over the lock at the end of the section.
- */
-static void console_lock_spinning_enable(void)
+static inline void printk_delay(int level)
 {
-	raw_spin_lock(&console_owner_lock);
-	console_owner = current;
-	raw_spin_unlock(&console_owner_lock);
+	boot_delay_msec(level);
+
+	if (unlikely(printk_delay_msec)) {
+		int m = printk_delay_msec;
 
-	/* The waiter may spin on us after setting console_owner */
-	spin_acquire(&console_owner_dep_map, 0, 0, _THIS_IP_);
+		while (m--) {
+			mdelay(1);
+			touch_nmi_watchdog();
+		}
+	}
 }
 
-/**
- * console_lock_spinning_disable_and_check - mark end of code where another
- *	thread was able to busy wait and check if there is a waiter
- *
- * This is called at the end of the section where spinning is allowed.
- * It has two functions. First, it is a signal that it is no longer
- * safe to start busy waiting for the lock. Second, it checks if
- * there is a busy waiter and passes the lock rights to her.
- *
- * Important: Callers lose the lock if there was a busy waiter.
- *	They must not touch items synchronized by console_lock
- *	in this case.
- *
- * Return: 1 if the lock rights were passed, 0 otherwise.
- */
-static int console_lock_spinning_disable_and_check(void)
+static bool kernel_sync_mode(void)
 {
-	int waiter;
+	return (oops_in_progress || sync_mode);
+}
 
-	raw_spin_lock(&console_owner_lock);
-	waiter = READ_ONCE(console_waiter);
-	console_owner = NULL;
-	raw_spin_unlock(&console_owner_lock);
+static bool console_can_sync(struct console *con)
+{
+	if (!(con->flags & CON_ENABLED))
+		return false;
+	if (con->write_atomic && kernel_sync_mode())
+		return true;
+	if (con->write_atomic && (con->flags & CON_HANDOVER) && !con->thread)
+		return true;
+	if (con->write && (con->flags & CON_BOOT) && !con->thread)
+		return true;
+	return false;
+}
 
-	if (!waiter) {
-		spin_release(&console_owner_dep_map, _THIS_IP_);
-		return 0;
-	}
+static bool call_sync_console_driver(struct console *con, const char *text, size_t text_len)
+{
+	if (!(con->flags & CON_ENABLED))
+		return false;
+	if (con->write_atomic && kernel_sync_mode())
+		con->write_atomic(con, text, text_len);
+	else if (con->write_atomic && (con->flags & CON_HANDOVER) && !con->thread)
+		con->write_atomic(con, text, text_len);
+	else if (con->write && (con->flags & CON_BOOT) && !con->thread)
+		con->write(con, text, text_len);
+	else
+		return false;
 
-	/* The waiter is now free to continue */
-	WRITE_ONCE(console_waiter, false);
+	return true;
+}
 
-	spin_release(&console_owner_dep_map, _THIS_IP_);
+static bool have_atomic_console(void)
+{
+	struct console *con;
 
-	/*
-	 * Hand off console_lock to waiter. The waiter will perform
-	 * the up(). After this, the waiter is the console_lock owner.
-	 */
-	mutex_release(&console_lock_dep_map, _THIS_IP_);
-	return 1;
+	for_each_console(con) {
+		if (!(con->flags & CON_ENABLED))
+			continue;
+		if (con->write_atomic)
+			return true;
+	}
+	return false;
 }
 
-/**
- * console_trylock_spinning - try to get console_lock by busy waiting
- *
- * This allows to busy wait for the console_lock when the current
- * owner is running in specially marked sections. It means that
- * the current owner is running and cannot reschedule until it
- * is ready to lose the lock.
- *
- * Return: 1 if we got the lock, 0 othrewise
- */
-static int console_trylock_spinning(void)
+static bool print_sync(struct console *con, u64 *seq)
 {
-	struct task_struct *owner = NULL;
-	bool waiter;
-	bool spin = false;
-	unsigned long flags;
+	struct printk_info info;
+	struct printk_record r;
+	size_t text_len;
 
-	if (console_trylock())
-		return 1;
+	prb_rec_init_rd(&r, &info, &con->sync_buf[0], sizeof(con->sync_buf));
 
-	printk_safe_enter_irqsave(flags);
+	if (!prb_read_valid(prb, *seq, &r))
+		return false;
 
-	raw_spin_lock(&console_owner_lock);
-	owner = READ_ONCE(console_owner);
-	waiter = READ_ONCE(console_waiter);
-	if (!waiter && owner && owner != current) {
-		WRITE_ONCE(console_waiter, true);
-		spin = true;
-	}
-	raw_spin_unlock(&console_owner_lock);
+	text_len = record_print_text(&r, console_msg_format & MSG_FORMAT_SYSLOG, printk_time);
 
-	/*
-	 * If there is an active printk() writing to the
-	 * consoles, instead of having it write our data too,
-	 * see if we can offload that load from the active
-	 * printer, and do some printing ourselves.
-	 * Go into a spin only if there isn't already a waiter
-	 * spinning, and there is an active printer, and
-	 * that active printer isn't us (recursive printk?).
-	 */
-	if (!spin) {
-		printk_safe_exit_irqrestore(flags);
-		return 0;
-	}
+	if (!call_sync_console_driver(con, &con->sync_buf[0], text_len))
+		return false;
 
-	/* We spin waiting for the owner to release us */
-	spin_acquire(&console_owner_dep_map, 0, 0, _THIS_IP_);
-	/* Owner will clear console_waiter on hand off */
-	while (READ_ONCE(console_waiter))
-		cpu_relax();
-	spin_release(&console_owner_dep_map, _THIS_IP_);
+	*seq = r.info->seq;
 
-	printk_safe_exit_irqrestore(flags);
-	/*
-	 * The owner passed the console lock to us.
-	 * Since we did not spin on console lock, annotate
-	 * this as a trylock. Otherwise lockdep will
-	 * complain.
-	 */
-	mutex_acquire(&console_lock_dep_map, 0, 1, _THIS_IP_);
+	touch_softlockup_watchdog_sync();
+	clocksource_touch_watchdog();
+	rcu_cpu_stall_reset();
+	touch_nmi_watchdog();
 
-	return 1;
+	if (text_len)
+		printk_delay(r.info->level);
+
+	return true;
 }
 
-/*
- * Call the console drivers, asking them to write out
- * log_buf[start] to log_buf[end - 1].
- * The console_lock must be held.
- */
-static void call_console_drivers(const char *ext_text, size_t ext_len,
-				 const char *text, size_t len)
+static void print_sync_until(struct console *con, u64 seq)
 {
-	static char dropped_text[64];
-	size_t dropped_len = 0;
-	struct console *con;
+	unsigned int flags;
+	u64 printk_seq;
+
+	console_atomic_lock(&flags);
+	for (;;) {
+		printk_seq = atomic64_read(&con->printk_seq);
+		if (printk_seq >= seq)
+			break;
+		if (!print_sync(con, &printk_seq))
+			break;
+		atomic64_set(&con->printk_seq, printk_seq + 1);
+	}
+	console_atomic_unlock(flags);
+}
 
-	trace_console_rcuidle(text, len);
+#ifdef CONFIG_PRINTK_NMI
+#define NUM_RECURSION_CTX 2
+#else
+#define NUM_RECURSION_CTX 1
+#endif
 
-	if (!console_drivers)
-		return;
+struct printk_recursion {
+	char	count[NUM_RECURSION_CTX];
+};
 
-	if (console_dropped) {
-		dropped_len = snprintf(dropped_text, sizeof(dropped_text),
-				       "** %lu printk messages dropped **\n",
-				       console_dropped);
-		console_dropped = 0;
-	}
+static DEFINE_PER_CPU(struct printk_recursion, percpu_printk_recursion);
+static char printk_recursion_count[NUM_RECURSION_CTX];
 
-	for_each_console(con) {
-		if (exclusive_console && con != exclusive_console)
-			continue;
-		if (!(con->flags & CON_ENABLED))
-			continue;
-		if (!con->write)
-			continue;
-		if (!cpu_online(smp_processor_id()) &&
-		    !(con->flags & CON_ANYTIME))
-			continue;
-		if (con->flags & CON_EXTENDED)
-			con->write(con, ext_text, ext_len);
-		else {
-			if (dropped_len)
-				con->write(con, dropped_text, dropped_len);
-			con->write(con, text, len);
-		}
+static char *printk_recursion_counter(void)
+{
+	struct printk_recursion *rec;
+	char *count;
+
+	if (!printk_percpu_data_ready()) {
+		count = &printk_recursion_count[0];
+	} else {
+		rec = this_cpu_ptr(&percpu_printk_recursion);
+
+		count = &rec->count[0];
 	}
+
+#ifdef CONFIG_PRINTK_NMI
+	if (in_nmi())
+		count++;
+#endif
+
+	return count;
 }
 
-int printk_delay_msec __read_mostly;
 
-static inline void printk_delay(void)
+static bool printk_enter_irqsave(unsigned long *flags)
 {
-	if (unlikely(printk_delay_msec)) {
-		int m = printk_delay_msec;
+	char *count;
 
-		while (m--) {
-			mdelay(1);
-			touch_nmi_watchdog();
-		}
+	local_irq_save(*flags);
+	count = printk_recursion_counter();
+	/* Only 1 level of recursion allowed. */
+	if (*count > 1) {
+		local_irq_restore(*flags);
+		return false;
 	}
+	(*count)++;
+
+	return true;
+}
+
+static void printk_exit_irqrestore(unsigned long flags)
+{
+	char *count;
+
+	count = printk_recursion_counter();
+	(*count)--;
+	local_irq_restore(flags);
 }
 
 static inline u32 printk_caller_id(void)
@@ -1954,144 +1903,248 @@ static inline u32 printk_caller_id(void)
 		0x80000000 + raw_smp_processor_id();
 }
 
-static size_t log_output(int facility, int level, enum log_flags lflags,
-			 const struct dev_printk_info *dev_info,
-			 char *text, size_t text_len)
+/**
+ * parse_prefix - Parse level and control flags.
+ *
+ * @text:     The terminated text message.
+ * @level:    A pointer to the current level value, will be updated.
+ * @lflags:   A pointer to the current log flags, will be updated.
+ *
+ * @level may be NULL if the caller is not interested in the parsed value.
+ * Otherwise the variable pointed to by @level must be set to
+ * LOGLEVEL_DEFAULT in order to be updated with the parsed value.
+ *
+ * @lflags may be NULL if the caller is not interested in the parsed value.
+ * Otherwise the variable pointed to by @lflags will be OR'd with the parsed
+ * value.
+ *
+ * Return: The length of the parsed level and control flags.
+ */
+static u16 parse_prefix(char *text, int *level, enum log_flags *lflags)
 {
-	const u32 caller_id = printk_caller_id();
+	u16 prefix_len = 0;
+	int kern_level;
 
-	if (lflags & LOG_CONT) {
-		struct prb_reserved_entry e;
-		struct printk_record r;
+	while (*text) {
+		kern_level = printk_get_level(text);
+		if (!kern_level)
+			break;
 
-		prb_rec_init_wr(&r, text_len);
-		if (prb_reserve_in_last(&e, prb, &r, caller_id, LOG_LINE_MAX)) {
-			memcpy(&r.text_buf[r.info->text_len], text, text_len);
-			r.info->text_len += text_len;
-			if (lflags & LOG_NEWLINE) {
-				r.info->flags |= LOG_NEWLINE;
-				prb_final_commit(&e);
-			} else {
-				prb_commit(&e);
-			}
-			return text_len;
+		switch (kern_level) {
+		case '0' ... '7':
+			if (level && *level == LOGLEVEL_DEFAULT)
+				*level = kern_level - '0';
+			break;
+		case 'c':	/* KERN_CONT */
+			if (lflags)
+				*lflags |= LOG_CONT;
 		}
+
+		prefix_len += 2;
+		text += 2;
 	}
 
-	/* Store it in the record log */
-	return log_store(caller_id, facility, level, lflags, 0,
-			 dev_info, text, text_len);
+	return prefix_len;
 }
 
-/* Must be called under logbuf_lock. */
-int vprintk_store(int facility, int level,
-		  const struct dev_printk_info *dev_info,
-		  const char *fmt, va_list args)
+static u16 printk_sprint(char *text, u16 size, int facility, enum log_flags *lflags,
+			 const char *fmt, va_list args)
 {
-	static char textbuf[LOG_LINE_MAX];
-	char *text = textbuf;
-	size_t text_len;
-	enum log_flags lflags = 0;
+	u16 text_len;
 
-	/*
-	 * The printf needs to come first; we need the syslog
-	 * prefix which might be passed-in as a parameter.
-	 */
-	text_len = vscnprintf(text, sizeof(textbuf), fmt, args);
+	text_len = vscnprintf(text, size, fmt, args);
 
-	/* mark and strip a trailing newline */
-	if (text_len && text[text_len-1] == '\n') {
+	/* Mark and strip a trailing newline. */
+	if (text_len && text[text_len - 1] == '\n') {
 		text_len--;
-		lflags |= LOG_NEWLINE;
+		*lflags |= LOG_NEWLINE;
 	}
 
-	/* strip kernel syslog prefix and extract log level or control flags */
+	/* Strip log level and control flags. */
 	if (facility == 0) {
-		int kern_level;
-
-		while ((kern_level = printk_get_level(text)) != 0) {
-			switch (kern_level) {
-			case '0' ... '7':
-				if (level == LOGLEVEL_DEFAULT)
-					level = kern_level - '0';
-				break;
-			case 'c':	/* KERN_CONT */
-				lflags |= LOG_CONT;
-			}
+		u16 prefix_len;
 
-			text_len -= 2;
-			text += 2;
+		prefix_len = parse_prefix(text, NULL, NULL);
+		if (prefix_len) {
+			text_len -= prefix_len;
+			memmove(text, text + prefix_len, text_len);
 		}
 	}
 
-	if (level == LOGLEVEL_DEFAULT)
-		level = default_message_loglevel;
-
-	if (dev_info)
-		lflags |= LOG_NEWLINE;
-
-	return log_output(facility, level, lflags, dev_info, text, text_len);
+	return text_len;
 }
 
-asmlinkage int vprintk_emit(int facility, int level,
-			    const struct dev_printk_info *dev_info,
-			    const char *fmt, va_list args)
+__printf(4, 0)
+static int vprintk_store(int facility, int level,
+			 const struct dev_printk_info *dev_info,
+			 const char *fmt, va_list args)
 {
-	int printed_len;
-	bool in_sched = false;
-	unsigned long flags;
+	const u32 caller_id = printk_caller_id();
+	struct prb_reserved_entry e;
+	enum log_flags lflags = 0;
+	bool final_commit = false;
+	struct printk_record r;
+	unsigned long irqflags;
+	u16 trunc_msg_len = 0;
+	char prefix_buf[8];
+	u16 reserve_size;
+	va_list args2;
+	u16 text_len;
+	int ret = 0;
+	u64 ts_nsec;
+	u64 seq;
 
-	/* Suppress unimportant messages after panic happens */
-	if (unlikely(suppress_printk))
+	/*
+	 * Since the duration of printk() can vary depending on the message
+	 * and state of the ringbuffer, grab the timestamp now so that it is
+	 * close to the call of printk(). This provides a more deterministic
+	 * timestamp with respect to the caller.
+	 */
+	ts_nsec = local_clock();
+
+	if (!printk_enter_irqsave(&irqflags))
 		return 0;
 
-	if (level == LOGLEVEL_SCHED) {
-		level = LOGLEVEL_DEFAULT;
-		in_sched = true;
+	/*
+	 * The sprintf needs to come first since the syslog prefix might be
+	 * passed in as a parameter. An extra byte must be reserved so that
+	 * later the vscnprintf() into the reserved buffer has room for the
+	 * terminating '\0', which is not counted by vsnprintf().
+	 */
+	va_copy(args2, args);
+	reserve_size = vsnprintf(&prefix_buf[0], sizeof(prefix_buf), fmt, args2) + 1;
+	va_end(args2);
+
+	if (reserve_size > LOG_LINE_MAX)
+		reserve_size = LOG_LINE_MAX;
+
+	/* Extract log level or control flags. */
+	if (facility == 0)
+		parse_prefix(&prefix_buf[0], &level, &lflags);
+
+	if (level == LOGLEVEL_DEFAULT)
+		level = default_message_loglevel;
+
+	if (dev_info)
+		lflags |= LOG_NEWLINE;
+
+	if (lflags & LOG_CONT) {
+		prb_rec_init_wr(&r, reserve_size);
+		if (prb_reserve_in_last(&e, prb, &r, caller_id, LOG_LINE_MAX)) {
+			seq = r.info->seq;
+			text_len = printk_sprint(&r.text_buf[r.info->text_len], reserve_size,
+						 facility, &lflags, fmt, args);
+			r.info->text_len += text_len;
+
+			if (lflags & LOG_NEWLINE) {
+				r.info->flags |= LOG_NEWLINE;
+				prb_final_commit(&e);
+				final_commit = true;
+			} else {
+				prb_commit(&e);
+			}
+
+			ret = text_len;
+			goto out;
+		}
 	}
 
-	boot_delay_msec(level);
-	printk_delay();
+	/*
+	 * Explicitly initialize the record before every prb_reserve() call.
+	 * prb_reserve_in_last() and prb_reserve() purposely invalidate the
+	 * structure when they fail.
+	 */
+	prb_rec_init_wr(&r, reserve_size);
+	if (!prb_reserve(&e, prb, &r)) {
+		/* truncate the message if it is too long for empty buffer */
+		truncate_msg(&reserve_size, &trunc_msg_len);
 
-	/* This stops the holder of console_sem just where we want him */
-	logbuf_lock_irqsave(flags);
-	printed_len = vprintk_store(facility, level, dev_info, fmt, args);
-	logbuf_unlock_irqrestore(flags);
+		prb_rec_init_wr(&r, reserve_size + trunc_msg_len);
+		if (!prb_reserve(&e, prb, &r))
+			goto out;
+	}
 
-	/* If called from the scheduler, we can not call up(). */
-	if (!in_sched) {
-		/*
-		 * Disable preemption to avoid being preempted while holding
-		 * console_sem which would prevent anyone from printing to
-		 * console
-		 */
-		preempt_disable();
-		/*
-		 * Try to acquire and then immediately release the console
-		 * semaphore.  The release will print out buffers and wake up
-		 * /dev/kmsg and syslog() users.
-		 */
-		if (console_trylock_spinning())
-			console_unlock();
-		preempt_enable();
+	seq = r.info->seq;
+
+	/* fill message */
+	text_len = printk_sprint(&r.text_buf[0], reserve_size, facility, &lflags, fmt, args);
+	if (trunc_msg_len)
+		memcpy(&r.text_buf[text_len], trunc_msg, trunc_msg_len);
+	r.info->text_len = text_len + trunc_msg_len;
+	r.info->facility = facility;
+	r.info->level = level & 7;
+	r.info->flags = lflags & 0x1f;
+	r.info->ts_nsec = ts_nsec;
+	r.info->caller_id = caller_id;
+	if (dev_info)
+		memcpy(&r.info->dev_info, dev_info, sizeof(r.info->dev_info));
+
+	/* A message without a trailing newline can be continued. */
+	if (!(lflags & LOG_NEWLINE)) {
+		prb_commit(&e);
+	} else {
+		prb_final_commit(&e);
+		final_commit = true;
 	}
 
+	ret = text_len + trunc_msg_len;
+out:
+	/* only the kernel may perform synchronous printing */
+	if (facility == 0 && final_commit) {
+		struct console *con;
+
+		for_each_console(con) {
+			if (console_can_sync(con))
+				print_sync_until(con, seq + 1);
+		}
+	}
+
+	printk_exit_irqrestore(irqflags);
+	return ret;
+}
+
+asmlinkage int vprintk_emit(int facility, int level,
+			    const struct dev_printk_info *dev_info,
+			    const char *fmt, va_list args)
+{
+	int printed_len;
+
+	/* Suppress unimportant messages after panic happens */
+	if (unlikely(suppress_printk))
+		return 0;
+
+	if (level == LOGLEVEL_SCHED)
+		level = LOGLEVEL_DEFAULT;
+
+	printed_len = vprintk_store(facility, level, dev_info, fmt, args);
+
 	wake_up_klogd();
 	return printed_len;
 }
 EXPORT_SYMBOL(vprintk_emit);
 
-asmlinkage int vprintk(const char *fmt, va_list args)
+__printf(1, 0)
+static int vprintk_default(const char *fmt, va_list args)
 {
-	return vprintk_func(fmt, args);
+	return vprintk_emit(0, LOGLEVEL_DEFAULT, NULL, fmt, args);
 }
-EXPORT_SYMBOL(vprintk);
 
-int vprintk_default(const char *fmt, va_list args)
+__printf(1, 0)
+static int vprintk_func(const char *fmt, va_list args)
 {
-	return vprintk_emit(0, LOGLEVEL_DEFAULT, NULL, fmt, args);
+#ifdef CONFIG_KGDB_KDB
+	/* Allow to pass printk() to kdb but avoid a recursion. */
+	if (unlikely(kdb_trap_printk && kdb_printf_cpu < 0))
+		return vkdb_printf(KDB_MSGSRC_PRINTK, fmt, args);
+#endif
+	return vprintk_default(fmt, args);
+}
+
+asmlinkage int vprintk(const char *fmt, va_list args)
+{
+	return vprintk_func(fmt, args);
 }
-EXPORT_SYMBOL_GPL(vprintk_default);
+EXPORT_SYMBOL(vprintk);
 
 /**
  * printk - print a kernel message
@@ -2127,38 +2180,158 @@ asmlinkage __visible int printk(const char *fmt, ...)
 }
 EXPORT_SYMBOL(printk);
 
-#else /* CONFIG_PRINTK */
+static int printk_kthread_func(void *data)
+{
+	struct console *con = data;
+	unsigned long dropped = 0;
+	char *dropped_text = NULL;
+	struct printk_info info;
+	struct printk_record r;
+	char *ext_text = NULL;
+	size_t dropped_len;
+	int ret = -ENOMEM;
+	char *text = NULL;
+	char *write_text;
+	u64 printk_seq;
+	size_t len;
+	int error;
+	u64 seq;
+
+	if (con->flags & CON_EXTENDED) {
+		ext_text = kmalloc(CONSOLE_EXT_LOG_MAX, GFP_KERNEL);
+		if (!ext_text)
+			goto out;
+	}
+	text = kmalloc(LOG_LINE_MAX + PREFIX_MAX, GFP_KERNEL);
+	dropped_text = kmalloc(64, GFP_KERNEL);
+	if (!text || !dropped_text)
+		goto out;
 
-#define LOG_LINE_MAX		0
-#define PREFIX_MAX		0
-#define printk_time		false
+	if (con->flags & CON_EXTENDED)
+		write_text = ext_text;
+	else
+		write_text = text;
 
-#define prb_read_valid(rb, seq, r)	false
-#define prb_first_valid_seq(rb)		0
+	seq = atomic64_read(&con->printk_seq);
 
-static u64 syslog_seq;
-static u64 console_seq;
-static u64 exclusive_console_stop_seq;
-static unsigned long console_dropped;
+	prb_rec_init_rd(&r, &info, text, LOG_LINE_MAX + PREFIX_MAX);
+
+	for (;;) {
+		error = wait_event_interruptible(log_wait,
+				prb_read_valid(prb, seq, &r) || kthread_should_stop());
+
+		if (kthread_should_stop())
+			break;
+
+		if (error)
+			continue;
+
+		if (seq != r.info->seq) {
+			dropped += r.info->seq - seq;
+			seq = r.info->seq;
+		}
+
+		seq++;
+
+		if (!(con->flags & CON_ENABLED))
+			continue;
+
+		if (suppress_message_printing(r.info->level))
+			continue;
+
+		if (con->flags & CON_EXTENDED) {
+			len = info_print_ext_header(ext_text,
+				CONSOLE_EXT_LOG_MAX,
+				r.info);
+			len += msg_print_ext_body(ext_text + len,
+				CONSOLE_EXT_LOG_MAX - len,
+				&r.text_buf[0], r.info->text_len,
+				&r.info->dev_info);
+		} else {
+			len = record_print_text(&r,
+				console_msg_format & MSG_FORMAT_SYSLOG,
+				printk_time);
+		}
+
+		printk_seq = atomic64_read(&con->printk_seq);
 
-static size_t record_print_text(const struct printk_record *r,
-				bool syslog, bool time)
+		console_lock();
+		console_may_schedule = 0;
+
+		if (kernel_sync_mode() && con->write_atomic) {
+			console_unlock();
+			break;
+		}
+
+		if (!(con->flags & CON_EXTENDED) && dropped) {
+			dropped_len = snprintf(dropped_text, 64,
+					       "** %lu printk messages dropped **\n",
+					       dropped);
+			dropped = 0;
+
+			con->write(con, dropped_text, dropped_len);
+			printk_delay(r.info->level);
+		}
+
+		con->write(con, write_text, len);
+		if (len)
+			printk_delay(r.info->level);
+
+		atomic64_cmpxchg_relaxed(&con->printk_seq, printk_seq, seq);
+
+		console_unlock();
+	}
+out:
+	kfree(dropped_text);
+	kfree(text);
+	kfree(ext_text);
+	pr_info("%sconsole [%s%d]: printing thread stopped\n",
+		(con->flags & CON_BOOT) ? "boot" : "",
+		con->name, con->index);
+	return ret;
+}
+
+/* Must be called within console_lock(). */
+static void start_printk_kthread(struct console *con)
 {
-	return 0;
+	con->thread = kthread_run(printk_kthread_func, con,
+				  "pr/%s%d", con->name, con->index);
+	if (IS_ERR(con->thread)) {
+		pr_err("%sconsole [%s%d]: unable to start printing thread\n",
+			(con->flags & CON_BOOT) ? "boot" : "",
+			con->name, con->index);
+		return;
+	}
+	pr_info("%sconsole [%s%d]: printing thread started\n",
+		(con->flags & CON_BOOT) ? "boot" : "",
+		con->name, con->index);
 }
-static ssize_t info_print_ext_header(char *buf, size_t size,
-				     struct printk_info *info)
+
+/* protected by console_lock */
+static bool kthreads_started;
+
+/* Must be called within console_lock(). */
+static void console_try_thread(struct console *con)
 {
-	return 0;
+	if (kthreads_started) {
+		start_printk_kthread(con);
+		return;
+	}
+
+	/*
+	 * The printing threads have not been started yet. If this console
+	 * can print synchronously, print all unprinted messages.
+	 */
+	if (console_can_sync(con))
+		print_sync_until(con, prb_next_seq(prb));
 }
-static ssize_t msg_print_ext_body(char *buf, size_t size,
-				  char *text, size_t text_len,
-				  struct dev_printk_info *dev_info) { return 0; }
-static void console_lock_spinning_enable(void) { }
-static int console_lock_spinning_disable_and_check(void) { return 0; }
-static void call_console_drivers(const char *ext_text, size_t ext_len,
-				 const char *text, size_t len) {}
-static bool suppress_message_printing(int level) { return false; }
+
+#else /* CONFIG_PRINTK */
+
+#define prb_first_valid_seq(rb)		0
+#define prb_next_seq(rb)		0
+
+#define console_try_thread(con)
 
 #endif /* CONFIG_PRINTK */
 
@@ -2403,34 +2576,6 @@ int is_console_locked(void)
 }
 EXPORT_SYMBOL(is_console_locked);
 
-/*
- * Check if we have any console that is capable of printing while cpu is
- * booting or shutting down. Requires console_sem.
- */
-static int have_callable_console(void)
-{
-	struct console *con;
-
-	for_each_console(con)
-		if ((con->flags & CON_ENABLED) &&
-				(con->flags & CON_ANYTIME))
-			return 1;
-
-	return 0;
-}
-
-/*
- * Can we actually use the console at this time on this cpu?
- *
- * Console drivers may assume that per-cpu resources have been allocated. So
- * unless they're explicitly marked as being able to cope (CON_ANYTIME) don't
- * call them until this CPU is officially up.
- */
-static inline int can_use_console(void)
-{
-	return cpu_online(raw_smp_processor_id()) || have_callable_console();
-}
-
 /**
  * console_unlock - unlock the console system
  *
@@ -2447,142 +2592,14 @@ static inline int can_use_console(void)
  */
 void console_unlock(void)
 {
-	static char ext_text[CONSOLE_EXT_LOG_MAX];
-	static char text[LOG_LINE_MAX + PREFIX_MAX];
-	unsigned long flags;
-	bool do_cond_resched, retry;
-	struct printk_info info;
-	struct printk_record r;
-
 	if (console_suspended) {
 		up_console_sem();
 		return;
 	}
 
-	prb_rec_init_rd(&r, &info, text, sizeof(text));
-
-	/*
-	 * Console drivers are called with interrupts disabled, so
-	 * @console_may_schedule should be cleared before; however, we may
-	 * end up dumping a lot of lines, for example, if called from
-	 * console registration path, and should invoke cond_resched()
-	 * between lines if allowable.  Not doing so can cause a very long
-	 * scheduling stall on a slow console leading to RCU stall and
-	 * softlockup warnings which exacerbate the issue with more
-	 * messages practically incapacitating the system.
-	 *
-	 * console_trylock() is not able to detect the preemptive
-	 * context reliably. Therefore the value must be stored before
-	 * and cleared after the "again" goto label.
-	 */
-	do_cond_resched = console_may_schedule;
-again:
-	console_may_schedule = 0;
-
-	/*
-	 * We released the console_sem lock, so we need to recheck if
-	 * cpu is online and (if not) is there at least one CON_ANYTIME
-	 * console.
-	 */
-	if (!can_use_console()) {
-		console_locked = 0;
-		up_console_sem();
-		return;
-	}
-
-	for (;;) {
-		size_t ext_len = 0;
-		size_t len;
-
-		printk_safe_enter_irqsave(flags);
-		raw_spin_lock(&logbuf_lock);
-skip:
-		if (!prb_read_valid(prb, console_seq, &r))
-			break;
-
-		if (console_seq != r.info->seq) {
-			console_dropped += r.info->seq - console_seq;
-			console_seq = r.info->seq;
-		}
-
-		if (suppress_message_printing(r.info->level)) {
-			/*
-			 * Skip record we have buffered and already printed
-			 * directly to the console when we received it, and
-			 * record that has level above the console loglevel.
-			 */
-			console_seq++;
-			goto skip;
-		}
-
-		/* Output to all consoles once old messages replayed. */
-		if (unlikely(exclusive_console &&
-			     console_seq >= exclusive_console_stop_seq)) {
-			exclusive_console = NULL;
-		}
-
-		/*
-		 * Handle extended console text first because later
-		 * record_print_text() will modify the record buffer in-place.
-		 */
-		if (nr_ext_console_drivers) {
-			ext_len = info_print_ext_header(ext_text,
-						sizeof(ext_text),
-						r.info);
-			ext_len += msg_print_ext_body(ext_text + ext_len,
-						sizeof(ext_text) - ext_len,
-						&r.text_buf[0],
-						r.info->text_len,
-						&r.info->dev_info);
-		}
-		len = record_print_text(&r,
-				console_msg_format & MSG_FORMAT_SYSLOG,
-				printk_time);
-		console_seq++;
-		raw_spin_unlock(&logbuf_lock);
-
-		/*
-		 * While actively printing out messages, if another printk()
-		 * were to occur on another CPU, it may wait for this one to
-		 * finish. This task can not be preempted if there is a
-		 * waiter waiting to take over.
-		 */
-		console_lock_spinning_enable();
-
-		stop_critical_timings();	/* don't trace print latency */
-		call_console_drivers(ext_text, ext_len, text, len);
-		start_critical_timings();
-
-		if (console_lock_spinning_disable_and_check()) {
-			printk_safe_exit_irqrestore(flags);
-			return;
-		}
-
-		printk_safe_exit_irqrestore(flags);
-
-		if (do_cond_resched)
-			cond_resched();
-	}
-
 	console_locked = 0;
 
-	raw_spin_unlock(&logbuf_lock);
-
 	up_console_sem();
-
-	/*
-	 * Someone could have filled up the buffer again, so re-check if there's
-	 * something to flush. In case we cannot trylock the console_sem again,
-	 * there's a new owner and the console_unlock() from them will do the
-	 * flush, no worries.
-	 */
-	raw_spin_lock(&logbuf_lock);
-	retry = prb_read_valid(prb, console_seq, NULL);
-	raw_spin_unlock(&logbuf_lock);
-	printk_safe_exit_irqrestore(flags);
-
-	if (retry && console_trylock())
-		goto again;
 }
 EXPORT_SYMBOL(console_unlock);
 
@@ -2632,23 +2649,20 @@ void console_unblank(void)
  */
 void console_flush_on_panic(enum con_flush_mode mode)
 {
-	/*
-	 * If someone else is holding the console lock, trylock will fail
-	 * and may_schedule may be set.  Ignore and proceed to unlock so
-	 * that messages are flushed out.  As this can be called from any
-	 * context and we don't want to get preempted while flushing,
-	 * ensure may_schedule is cleared.
-	 */
-	console_trylock();
+	struct console *c;
+	u64 seq;
+
+	if (!console_trylock())
+		return;
+
 	console_may_schedule = 0;
 
 	if (mode == CONSOLE_REPLAY_ALL) {
-		unsigned long flags;
-
-		logbuf_lock_irqsave(flags);
-		console_seq = prb_first_valid_seq(prb);
-		logbuf_unlock_irqrestore(flags);
+		seq = prb_first_valid_seq(prb);
+		for_each_console(c)
+			atomic64_set(&c->printk_seq, seq);
 	}
+
 	console_unlock();
 }
 EXPORT_SYMBOL(console_flush_on_panic);
@@ -2784,7 +2798,6 @@ static int try_enable_new_console(struct console *newcon, bool user_specified)
  */
 void register_console(struct console *newcon)
 {
-	unsigned long flags;
 	struct console *bcon = NULL;
 	int err;
 
@@ -2808,6 +2821,8 @@ void register_console(struct console *newcon)
 		}
 	}
 
+	newcon->thread = NULL;
+
 	if (console_drivers && console_drivers->flags & CON_BOOT)
 		bcon = console_drivers;
 
@@ -2849,8 +2864,10 @@ void register_console(struct console *newcon)
 	 * the real console are the same physical device, it's annoying to
 	 * see the beginning boot messages twice
 	 */
-	if (bcon && ((newcon->flags & (CON_CONSDEV | CON_BOOT)) == CON_CONSDEV))
+	if (bcon && ((newcon->flags & (CON_CONSDEV | CON_BOOT)) == CON_CONSDEV)) {
 		newcon->flags &= ~CON_PRINTBUFFER;
+		newcon->flags |= CON_HANDOVER;
+	}
 
 	/*
 	 *	Put this console in the list - keep the
@@ -2872,26 +2889,12 @@ void register_console(struct console *newcon)
 	if (newcon->flags & CON_EXTENDED)
 		nr_ext_console_drivers++;
 
-	if (newcon->flags & CON_PRINTBUFFER) {
-		/*
-		 * console_unlock(); will print out the buffered messages
-		 * for us.
-		 */
-		logbuf_lock_irqsave(flags);
-		/*
-		 * We're about to replay the log buffer.  Only do this to the
-		 * just-registered console to avoid excessive message spam to
-		 * the already-registered consoles.
-		 *
-		 * Set exclusive_console with disabled interrupts to reduce
-		 * race window with eventual console_flush_on_panic() that
-		 * ignores console_lock.
-		 */
-		exclusive_console = newcon;
-		exclusive_console_stop_seq = console_seq;
-		console_seq = syslog_seq;
-		logbuf_unlock_irqrestore(flags);
-	}
+	if (newcon->flags & CON_PRINTBUFFER)
+		atomic64_set(&newcon->printk_seq, 0);
+	else
+		atomic64_set(&newcon->printk_seq, prb_next_seq(prb));
+
+	console_try_thread(newcon);
 	console_unlock();
 	console_sysfs_notify();
 
@@ -2965,6 +2968,9 @@ int unregister_console(struct console *console)
 	console_unlock();
 	console_sysfs_notify();
 
+	if (console->thread && !IS_ERR(console->thread))
+		kthread_stop(console->thread);
+
 	if (console->exit)
 		res = console->exit(console);
 
@@ -3047,6 +3053,15 @@ static int __init printk_late_init(void)
 			unregister_console(con);
 		}
 	}
+
+#ifdef CONFIG_PRINTK
+	console_lock();
+	for_each_console(con)
+		start_printk_kthread(con);
+	kthreads_started = true;
+	console_unlock();
+#endif
+
 	ret = cpuhp_setup_state_nocalls(CPUHP_PRINTK_DEAD, "printk:dead", NULL,
 					console_cpu_notify);
 	WARN_ON(ret < 0);
@@ -3062,7 +3077,6 @@ late_initcall(printk_late_init);
  * Delayed printk version, for scheduler-internal messages:
  */
 #define PRINTK_PENDING_WAKEUP	0x01
-#define PRINTK_PENDING_OUTPUT	0x02
 
 static DEFINE_PER_CPU(int, printk_pending);
 
@@ -3070,14 +3084,8 @@ static void wake_up_klogd_work_func(struct irq_work *irq_work)
 {
 	int pending = __this_cpu_xchg(printk_pending, 0);
 
-	if (pending & PRINTK_PENDING_OUTPUT) {
-		/* If trylock fails, someone else is doing the printing */
-		if (console_trylock())
-			console_unlock();
-	}
-
 	if (pending & PRINTK_PENDING_WAKEUP)
-		wake_up_interruptible(&log_wait);
+		wake_up_interruptible_all(&log_wait);
 }
 
 static DEFINE_PER_CPU(struct irq_work, wake_up_klogd_work) =
@@ -3096,25 +3104,10 @@ void wake_up_klogd(void)
 	preempt_enable();
 }
 
-void defer_console_output(void)
+__printf(1, 0)
+static int vprintk_deferred(const char *fmt, va_list args)
 {
-	if (!printk_percpu_data_ready())
-		return;
-
-	preempt_disable();
-	__this_cpu_or(printk_pending, PRINTK_PENDING_OUTPUT);
-	irq_work_queue(this_cpu_ptr(&wake_up_klogd_work));
-	preempt_enable();
-}
-
-int vprintk_deferred(const char *fmt, va_list args)
-{
-	int r;
-
-	r = vprintk_emit(0, LOGLEVEL_SCHED, NULL, fmt, args);
-	defer_console_output();
-
-	return r;
+	return vprintk_emit(0, LOGLEVEL_DEFAULT, NULL, fmt, args);
 }
 
 int printk_deferred(const char *fmt, ...)
@@ -3253,8 +3246,26 @@ EXPORT_SYMBOL_GPL(kmsg_dump_reason_str);
  */
 void kmsg_dump(enum kmsg_dump_reason reason)
 {
+	struct kmsg_dumper_iter iter;
 	struct kmsg_dumper *dumper;
-	unsigned long flags;
+
+	if (!oops_in_progress) {
+		/*
+		 * If atomic consoles are available, activate kernel sync mode
+		 * to make sure any final messages are visible. The trailing
+		 * printk message is important to flush any pending messages.
+		 */
+		if (have_atomic_console()) {
+			sync_mode = true;
+			pr_info("enabled sync mode\n");
+		}
+
+		/*
+		 * Give the printing threads time to flush, allowing up to
+		 * 1s of no printing forward progress before giving up.
+		 */
+		pr_flush(1000, true);
+	}
 
 	rcu_read_lock();
 	list_for_each_entry_rcu(dumper, &dump_list, list) {
@@ -3272,25 +3283,18 @@ void kmsg_dump(enum kmsg_dump_reason reason)
 			continue;
 
 		/* initialize iterator with data about the stored records */
-		dumper->active = true;
-
-		logbuf_lock_irqsave(flags);
-		dumper->cur_seq = clear_seq;
-		dumper->next_seq = prb_next_seq(prb);
-		logbuf_unlock_irqrestore(flags);
+		iter.active = true;
+		kmsg_dump_rewind(&iter);
 
 		/* invoke dumper which will iterate over records */
-		dumper->dump(dumper, reason);
-
-		/* reset iterator */
-		dumper->active = false;
+		dumper->dump(dumper, reason, &iter);
 	}
 	rcu_read_unlock();
 }
 
 /**
- * kmsg_dump_get_line_nolock - retrieve one kmsg log line (unlocked version)
- * @dumper: registered kmsg dumper
+ * kmsg_dump_get_line - retrieve one kmsg log line
+ * @iter: kmsg dumper iterator
  * @syslog: include the "<4>" prefixes
  * @line: buffer to copy the line to
  * @size: maximum size of the buffer
@@ -3304,11 +3308,9 @@ void kmsg_dump(enum kmsg_dump_reason reason)
  *
  * A return value of FALSE indicates that there are no more records to
  * read.
- *
- * The function is similar to kmsg_dump_get_line(), but grabs no locks.
  */
-bool kmsg_dump_get_line_nolock(struct kmsg_dumper *dumper, bool syslog,
-			       char *line, size_t size, size_t *len)
+bool kmsg_dump_get_line(struct kmsg_dumper_iter *iter, bool syslog,
+			char *line, size_t size, size_t *len)
 {
 	struct printk_info info;
 	unsigned int line_count;
@@ -3318,16 +3320,16 @@ bool kmsg_dump_get_line_nolock(struct kmsg_dumper *dumper, bool syslog,
 
 	prb_rec_init_rd(&r, &info, line, size);
 
-	if (!dumper->active)
+	if (!iter->active)
 		goto out;
 
 	/* Read text or count text lines? */
 	if (line) {
-		if (!prb_read_valid(prb, dumper->cur_seq, &r))
+		if (!prb_read_valid(prb, iter->cur_seq, &r))
 			goto out;
 		l = record_print_text(&r, syslog, printk_time);
 	} else {
-		if (!prb_read_valid_info(prb, dumper->cur_seq,
+		if (!prb_read_valid_info(prb, iter->cur_seq,
 					 &info, &line_count)) {
 			goto out;
 		}
@@ -3336,48 +3338,18 @@ bool kmsg_dump_get_line_nolock(struct kmsg_dumper *dumper, bool syslog,
 
 	}
 
-	dumper->cur_seq = r.info->seq + 1;
+	iter->cur_seq = r.info->seq + 1;
 	ret = true;
 out:
 	if (len)
 		*len = l;
 	return ret;
 }
-
-/**
- * kmsg_dump_get_line - retrieve one kmsg log line
- * @dumper: registered kmsg dumper
- * @syslog: include the "<4>" prefixes
- * @line: buffer to copy the line to
- * @size: maximum size of the buffer
- * @len: length of line placed into buffer
- *
- * Start at the beginning of the kmsg buffer, with the oldest kmsg
- * record, and copy one record into the provided buffer.
- *
- * Consecutive calls will return the next available record moving
- * towards the end of the buffer with the youngest messages.
- *
- * A return value of FALSE indicates that there are no more records to
- * read.
- */
-bool kmsg_dump_get_line(struct kmsg_dumper *dumper, bool syslog,
-			char *line, size_t size, size_t *len)
-{
-	unsigned long flags;
-	bool ret;
-
-	logbuf_lock_irqsave(flags);
-	ret = kmsg_dump_get_line_nolock(dumper, syslog, line, size, len);
-	logbuf_unlock_irqrestore(flags);
-
-	return ret;
-}
 EXPORT_SYMBOL_GPL(kmsg_dump_get_line);
 
 /**
  * kmsg_dump_get_buffer - copy kmsg log lines
- * @dumper: registered kmsg dumper
+ * @iter: kmsg dumper iterator
  * @syslog: include the "<4>" prefixes
  * @buf: buffer to copy the line to
  * @size: maximum size of the buffer
@@ -3394,116 +3366,256 @@ EXPORT_SYMBOL_GPL(kmsg_dump_get_line);
  * A return value of FALSE indicates that there are no more records to
  * read.
  */
-bool kmsg_dump_get_buffer(struct kmsg_dumper *dumper, bool syslog,
-			  char *buf, size_t size, size_t *len)
+bool kmsg_dump_get_buffer(struct kmsg_dumper_iter *iter, bool syslog,
+			  char *buf, size_t size, size_t *len_out)
 {
 	struct printk_info info;
-	unsigned int line_count;
 	struct printk_record r;
-	unsigned long flags;
 	u64 seq;
 	u64 next_seq;
-	size_t l = 0;
+	size_t len = 0;
 	bool ret = false;
 	bool time = printk_time;
 
-	prb_rec_init_rd(&r, &info, buf, size);
-
-	if (!dumper->active || !buf || !size)
+	if (!iter->active || !buf || !size)
 		goto out;
 
-	logbuf_lock_irqsave(flags);
-	if (prb_read_valid_info(prb, dumper->cur_seq, &info, NULL)) {
-		if (info.seq != dumper->cur_seq) {
+	if (prb_read_valid_info(prb, iter->cur_seq, &info, NULL)) {
+		if (info.seq != iter->cur_seq) {
 			/* messages are gone, move to first available one */
-			dumper->cur_seq = info.seq;
+			iter->cur_seq = info.seq;
 		}
 	}
 
 	/* last entry */
-	if (dumper->cur_seq >= dumper->next_seq) {
-		logbuf_unlock_irqrestore(flags);
+	if (iter->cur_seq >= iter->next_seq)
 		goto out;
-	}
 
-	/* calculate length of entire buffer */
-	seq = dumper->cur_seq;
-	while (prb_read_valid_info(prb, seq, &info, &line_count)) {
-		if (r.info->seq >= dumper->next_seq)
-			break;
-		l += get_record_print_text_size(&info, line_count, syslog, time);
-		seq = r.info->seq + 1;
-	}
-
-	/* move first record forward until length fits into the buffer */
-	seq = dumper->cur_seq;
-	while (l >= size && prb_read_valid_info(prb, seq,
-						&info, &line_count)) {
-		if (r.info->seq >= dumper->next_seq)
-			break;
-		l -= get_record_print_text_size(&info, line_count, syslog, time);
-		seq = r.info->seq + 1;
-	}
+	/*
+	 * Find first record that fits, including all following records,
+	 * into the user-provided buffer for this dump. Pass in size-1
+	 * because this function (by way of record_print_text()) will
+	 * not write more than size-1 bytes of text into @buf.
+	 */
+	seq = find_first_fitting_seq(iter->cur_seq, iter->next_seq,
+				     size - 1, syslog, time);
 
-	/* last message in next interation */
+	/*
+	 * Next kmsg_dump_get_buffer() invocation will dump block of
+	 * older records stored right before this one.
+	 */
 	next_seq = seq;
 
-	/* actually read text into the buffer now */
-	l = 0;
-	while (prb_read_valid(prb, seq, &r)) {
-		if (r.info->seq >= dumper->next_seq)
-			break;
+	prb_rec_init_rd(&r, &info, buf, size);
 
-		l += record_print_text(&r, syslog, time);
+	len = 0;
+	prb_for_each_record(seq, prb, seq, &r) {
+		if (r.info->seq >= iter->next_seq)
+			break;
 
-		/* adjust record to store to remaining buffer space */
-		prb_rec_init_rd(&r, &info, buf + l, size - l);
+		len += record_print_text(&r, syslog, time);
 
-		seq = r.info->seq + 1;
+		/* Adjust record to store to remaining buffer space. */
+		prb_rec_init_rd(&r, &info, buf + len, size - len);
 	}
 
-	dumper->next_seq = next_seq;
+	iter->next_seq = next_seq;
 	ret = true;
-	logbuf_unlock_irqrestore(flags);
 out:
-	if (len)
-		*len = l;
+	if (len_out)
+		*len_out = len;
 	return ret;
 }
 EXPORT_SYMBOL_GPL(kmsg_dump_get_buffer);
 
 /**
- * kmsg_dump_rewind_nolock - reset the iterator (unlocked version)
- * @dumper: registered kmsg dumper
+ * kmsg_dump_rewind - reset the iterator
+ * @iter: kmsg dumper iterator
  *
  * Reset the dumper's iterator so that kmsg_dump_get_line() and
  * kmsg_dump_get_buffer() can be called again and used multiple
  * times within the same dumper.dump() callback.
+ */
+void kmsg_dump_rewind(struct kmsg_dumper_iter *iter)
+{
+	iter->cur_seq = latched_seq_read_nolock(&clear_seq);
+	iter->next_seq = prb_next_seq(prb);
+}
+EXPORT_SYMBOL_GPL(kmsg_dump_rewind);
+
+#endif
+
+struct prb_cpulock {
+	atomic_t owner;
+	unsigned long __percpu *irqflags;
+};
+
+#define DECLARE_STATIC_PRINTKRB_CPULOCK(name)				\
+static DEFINE_PER_CPU(unsigned long, _##name##_percpu_irqflags);	\
+static struct prb_cpulock name = {					\
+	.owner = ATOMIC_INIT(-1),					\
+	.irqflags = &_##name##_percpu_irqflags,				\
+}
+
+static bool __prb_trylock(struct prb_cpulock *cpu_lock,
+			  unsigned int *cpu_store)
+{
+	unsigned long *flags;
+	unsigned int cpu;
+
+	cpu = get_cpu();
+
+	*cpu_store = atomic_read(&cpu_lock->owner);
+	/* memory barrier to ensure the current lock owner is visible */
+	smp_rmb();
+	if (*cpu_store == -1) {
+		flags = per_cpu_ptr(cpu_lock->irqflags, cpu);
+		local_irq_save(*flags);
+		if (atomic_try_cmpxchg_acquire(&cpu_lock->owner,
+					       cpu_store, cpu)) {
+			return true;
+		}
+		local_irq_restore(*flags);
+	} else if (*cpu_store == cpu) {
+		return true;
+	}
+
+	put_cpu();
+	return false;
+}
+
+/*
+ * prb_lock: Perform a processor-reentrant spin lock.
+ * @cpu_lock: A pointer to the lock object.
+ * @cpu_store: A "flags" pointer to store lock status information.
+ *
+ * If no processor has the lock, the calling processor takes the lock and
+ * becomes the owner. If the calling processor is already the owner of the
+ * lock, this function succeeds immediately. If lock is locked by another
+ * processor, this function spins until the calling processor becomes the
+ * owner.
  *
- * The function is similar to kmsg_dump_rewind(), but grabs no locks.
+ * It is safe to call this function from any context and state.
  */
-void kmsg_dump_rewind_nolock(struct kmsg_dumper *dumper)
+static void prb_lock(struct prb_cpulock *cpu_lock, unsigned int *cpu_store)
 {
-	dumper->cur_seq = clear_seq;
-	dumper->next_seq = prb_next_seq(prb);
+	for (;;) {
+		if (__prb_trylock(cpu_lock, cpu_store))
+			break;
+		cpu_relax();
+	}
 }
 
-/**
- * kmsg_dump_rewind - reset the iterator
- * @dumper: registered kmsg dumper
+/*
+ * prb_unlock: Perform a processor-reentrant spin unlock.
+ * @cpu_lock: A pointer to the lock object.
+ * @cpu_store: A "flags" object storing lock status information.
  *
- * Reset the dumper's iterator so that kmsg_dump_get_line() and
- * kmsg_dump_get_buffer() can be called again and used multiple
- * times within the same dumper.dump() callback.
+ * Release the lock. The calling processor must be the owner of the lock.
+ *
+ * It is safe to call this function from any context and state.
  */
-void kmsg_dump_rewind(struct kmsg_dumper *dumper)
+static void prb_unlock(struct prb_cpulock *cpu_lock, unsigned int cpu_store)
 {
-	unsigned long flags;
+	unsigned long *flags;
+	unsigned int cpu;
+
+	cpu = atomic_read(&cpu_lock->owner);
+	atomic_set_release(&cpu_lock->owner, cpu_store);
+
+	if (cpu_store == -1) {
+		flags = per_cpu_ptr(cpu_lock->irqflags, cpu);
+		local_irq_restore(*flags);
+	}
 
-	logbuf_lock_irqsave(flags);
-	kmsg_dump_rewind_nolock(dumper);
-	logbuf_unlock_irqrestore(flags);
+	put_cpu();
 }
-EXPORT_SYMBOL_GPL(kmsg_dump_rewind);
 
-#endif
+DECLARE_STATIC_PRINTKRB_CPULOCK(printk_cpulock);
+
+void console_atomic_lock(unsigned int *flags)
+{
+	prb_lock(&printk_cpulock, flags);
+}
+EXPORT_SYMBOL(console_atomic_lock);
+
+void console_atomic_unlock(unsigned int flags)
+{
+	prb_unlock(&printk_cpulock, flags);
+}
+EXPORT_SYMBOL(console_atomic_unlock);
+
+static void pr_msleep(bool may_sleep, int ms)
+{
+	if (may_sleep) {
+		msleep(ms);
+	} else {
+		while (ms--)
+			udelay(1000);
+	}
+}
+
+/**
+ * pr_flush() - Wait for printing threads to catch up.
+ *
+ * @timeout_ms:        The maximum time (in ms) to wait.
+ * @reset_on_progress: Reset the timeout if forward progress is seen.
+ *
+ * A value of 0 for @timeout_ms means no waiting will occur. A value of -1
+ * represents infinite waiting.
+ *
+ * If @reset_on_progress is true, the timeout will be reset whenever any
+ * printer has been seen to make some forward progress.
+ *
+ * Context: Any context.
+ * Return: true if all enabled printers are caught up.
+ */
+bool pr_flush(int timeout_ms, bool reset_on_progress)
+{
+	int remaining = timeout_ms;
+	struct console *con;
+	u64 last_diff = 0;
+	bool may_sleep;
+	u64 printk_seq;
+	u64 diff;
+	u64 seq;
+
+	may_sleep = (preemptible() &&
+		     !in_softirq() &&
+		     system_state >= SYSTEM_RUNNING);
+
+	seq = prb_next_seq(prb);
+
+	for (;;) {
+		diff = 0;
+
+		for_each_console(con) {
+			if (!(con->flags & CON_ENABLED))
+				continue;
+			printk_seq = atomic64_read(&con->printk_seq);
+			if (printk_seq < seq)
+				diff += seq - printk_seq;
+		}
+
+		if (diff != last_diff && reset_on_progress)
+			remaining = timeout_ms;
+
+		if (!diff || remaining == 0)
+			break;
+
+		if (remaining < 0) {
+			pr_msleep(may_sleep, 100);
+		} else if (remaining < 100) {
+			pr_msleep(may_sleep, remaining);
+			remaining = 0;
+		} else {
+			pr_msleep(may_sleep, 100);
+			remaining -= 100;
+		}
+
+		last_diff = diff;
+	}
+
+	return (diff == 0);
+}
+EXPORT_SYMBOL(pr_flush);
diff --git a/kernel/printk/printk_safe.c b/kernel/printk/printk_safe.c
index b774685ccf80..218e42566550 100644
--- a/kernel/printk/printk_safe.c
+++ b/kernel/printk/printk_safe.c
@@ -15,295 +15,9 @@
 
 #include "internal.h"
 
-/*
- * printk() could not take logbuf_lock in NMI context. Instead,
- * it uses an alternative implementation that temporary stores
- * the strings into a per-CPU buffer. The content of the buffer
- * is later flushed into the main ring buffer via IRQ work.
- *
- * The alternative implementation is chosen transparently
- * by examining current printk() context mask stored in @printk_context
- * per-CPU variable.
- *
- * The implementation allows to flush the strings also from another CPU.
- * There are situations when we want to make sure that all buffers
- * were handled or when IRQs are blocked.
- */
-
-#define SAFE_LOG_BUF_LEN ((1 << CONFIG_PRINTK_SAFE_LOG_BUF_SHIFT) -	\
-				sizeof(atomic_t) -			\
-				sizeof(atomic_t) -			\
-				sizeof(struct irq_work))
-
-struct printk_safe_seq_buf {
-	atomic_t		len;	/* length of written data */
-	atomic_t		message_lost;
-	struct irq_work		work;	/* IRQ work that flushes the buffer */
-	unsigned char		buffer[SAFE_LOG_BUF_LEN];
-};
-
-static DEFINE_PER_CPU(struct printk_safe_seq_buf, safe_print_seq);
 static DEFINE_PER_CPU(int, printk_context);
 
-static DEFINE_RAW_SPINLOCK(safe_read_lock);
-
 #ifdef CONFIG_PRINTK_NMI
-static DEFINE_PER_CPU(struct printk_safe_seq_buf, nmi_print_seq);
-#endif
-
-/* Get flushed in a more safe context. */
-static void queue_flush_work(struct printk_safe_seq_buf *s)
-{
-	if (printk_percpu_data_ready())
-		irq_work_queue(&s->work);
-}
-
-/*
- * Add a message to per-CPU context-dependent buffer. NMI and printk-safe
- * have dedicated buffers, because otherwise printk-safe preempted by
- * NMI-printk would have overwritten the NMI messages.
- *
- * The messages are flushed from irq work (or from panic()), possibly,
- * from other CPU, concurrently with printk_safe_log_store(). Should this
- * happen, printk_safe_log_store() will notice the buffer->len mismatch
- * and repeat the write.
- */
-static __printf(2, 0) int printk_safe_log_store(struct printk_safe_seq_buf *s,
-						const char *fmt, va_list args)
-{
-	int add;
-	size_t len;
-	va_list ap;
-
-again:
-	len = atomic_read(&s->len);
-
-	/* The trailing '\0' is not counted into len. */
-	if (len >= sizeof(s->buffer) - 1) {
-		atomic_inc(&s->message_lost);
-		queue_flush_work(s);
-		return 0;
-	}
-
-	/*
-	 * Make sure that all old data have been read before the buffer
-	 * was reset. This is not needed when we just append data.
-	 */
-	if (!len)
-		smp_rmb();
-
-	va_copy(ap, args);
-	add = vscnprintf(s->buffer + len, sizeof(s->buffer) - len, fmt, ap);
-	va_end(ap);
-	if (!add)
-		return 0;
-
-	/*
-	 * Do it once again if the buffer has been flushed in the meantime.
-	 * Note that atomic_cmpxchg() is an implicit memory barrier that
-	 * makes sure that the data were written before updating s->len.
-	 */
-	if (atomic_cmpxchg(&s->len, len, len + add) != len)
-		goto again;
-
-	queue_flush_work(s);
-	return add;
-}
-
-static inline void printk_safe_flush_line(const char *text, int len)
-{
-	/*
-	 * Avoid any console drivers calls from here, because we may be
-	 * in NMI or printk_safe context (when in panic). The messages
-	 * must go only into the ring buffer at this stage.  Consoles will
-	 * get explicitly called later when a crashdump is not generated.
-	 */
-	printk_deferred("%.*s", len, text);
-}
-
-/* printk part of the temporary buffer line by line */
-static int printk_safe_flush_buffer(const char *start, size_t len)
-{
-	const char *c, *end;
-	bool header;
-
-	c = start;
-	end = start + len;
-	header = true;
-
-	/* Print line by line. */
-	while (c < end) {
-		if (*c == '\n') {
-			printk_safe_flush_line(start, c - start + 1);
-			start = ++c;
-			header = true;
-			continue;
-		}
-
-		/* Handle continuous lines or missing new line. */
-		if ((c + 1 < end) && printk_get_level(c)) {
-			if (header) {
-				c = printk_skip_level(c);
-				continue;
-			}
-
-			printk_safe_flush_line(start, c - start);
-			start = c++;
-			header = true;
-			continue;
-		}
-
-		header = false;
-		c++;
-	}
-
-	/* Check if there was a partial line. Ignore pure header. */
-	if (start < end && !header) {
-		static const char newline[] = KERN_CONT "\n";
-
-		printk_safe_flush_line(start, end - start);
-		printk_safe_flush_line(newline, strlen(newline));
-	}
-
-	return len;
-}
-
-static void report_message_lost(struct printk_safe_seq_buf *s)
-{
-	int lost = atomic_xchg(&s->message_lost, 0);
-
-	if (lost)
-		printk_deferred("Lost %d message(s)!\n", lost);
-}
-
-/*
- * Flush data from the associated per-CPU buffer. The function
- * can be called either via IRQ work or independently.
- */
-static void __printk_safe_flush(struct irq_work *work)
-{
-	struct printk_safe_seq_buf *s =
-		container_of(work, struct printk_safe_seq_buf, work);
-	unsigned long flags;
-	size_t len;
-	int i;
-
-	/*
-	 * The lock has two functions. First, one reader has to flush all
-	 * available message to make the lockless synchronization with
-	 * writers easier. Second, we do not want to mix messages from
-	 * different CPUs. This is especially important when printing
-	 * a backtrace.
-	 */
-	raw_spin_lock_irqsave(&safe_read_lock, flags);
-
-	i = 0;
-more:
-	len = atomic_read(&s->len);
-
-	/*
-	 * This is just a paranoid check that nobody has manipulated
-	 * the buffer an unexpected way. If we printed something then
-	 * @len must only increase. Also it should never overflow the
-	 * buffer size.
-	 */
-	if ((i && i >= len) || len > sizeof(s->buffer)) {
-		const char *msg = "printk_safe_flush: internal error\n";
-
-		printk_safe_flush_line(msg, strlen(msg));
-		len = 0;
-	}
-
-	if (!len)
-		goto out; /* Someone else has already flushed the buffer. */
-
-	/* Make sure that data has been written up to the @len */
-	smp_rmb();
-	i += printk_safe_flush_buffer(s->buffer + i, len - i);
-
-	/*
-	 * Check that nothing has got added in the meantime and truncate
-	 * the buffer. Note that atomic_cmpxchg() is an implicit memory
-	 * barrier that makes sure that the data were copied before
-	 * updating s->len.
-	 */
-	if (atomic_cmpxchg(&s->len, len, 0) != len)
-		goto more;
-
-out:
-	report_message_lost(s);
-	raw_spin_unlock_irqrestore(&safe_read_lock, flags);
-}
-
-/**
- * printk_safe_flush - flush all per-cpu nmi buffers.
- *
- * The buffers are flushed automatically via IRQ work. This function
- * is useful only when someone wants to be sure that all buffers have
- * been flushed at some point.
- */
-void printk_safe_flush(void)
-{
-	int cpu;
-
-	for_each_possible_cpu(cpu) {
-#ifdef CONFIG_PRINTK_NMI
-		__printk_safe_flush(&per_cpu(nmi_print_seq, cpu).work);
-#endif
-		__printk_safe_flush(&per_cpu(safe_print_seq, cpu).work);
-	}
-}
-
-/**
- * printk_safe_flush_on_panic - flush all per-cpu nmi buffers when the system
- *	goes down.
- *
- * Similar to printk_safe_flush() but it can be called even in NMI context when
- * the system goes down. It does the best effort to get NMI messages into
- * the main ring buffer.
- *
- * Note that it could try harder when there is only one CPU online.
- */
-void printk_safe_flush_on_panic(void)
-{
-	/*
-	 * Make sure that we could access the main ring buffer.
-	 * Do not risk a double release when more CPUs are up.
-	 */
-	if (raw_spin_is_locked(&logbuf_lock)) {
-		if (num_online_cpus() > 1)
-			return;
-
-		debug_locks_off();
-		raw_spin_lock_init(&logbuf_lock);
-	}
-
-	if (raw_spin_is_locked(&safe_read_lock)) {
-		if (num_online_cpus() > 1)
-			return;
-
-		debug_locks_off();
-		raw_spin_lock_init(&safe_read_lock);
-	}
-
-	printk_safe_flush();
-}
-EXPORT_SYMBOL_GPL(printk_safe_flush_on_panic);
-
-#ifdef CONFIG_PRINTK_NMI
-/*
- * Safe printk() for NMI context. It uses a per-CPU buffer to
- * store the message. NMIs are not nested, so there is always only
- * one writer running. But the buffer might get flushed from another
- * CPU, so we need to be careful.
- */
-static __printf(1, 0) int vprintk_nmi(const char *fmt, va_list args)
-{
-	struct printk_safe_seq_buf *s = this_cpu_ptr(&nmi_print_seq);
-
-	return printk_safe_log_store(s, fmt, args);
-}
-
 void noinstr printk_nmi_enter(void)
 {
 	this_cpu_add(printk_context, PRINTK_NMI_CONTEXT_OFFSET);
@@ -318,11 +32,6 @@ void noinstr printk_nmi_exit(void)
  * Marks a code that might produce many messages in NMI context
  * and the risk of losing them is more critical than eventual
  * reordering.
- *
- * It has effect only when called in NMI context. Then printk()
- * will try to store the messages into the main logbuf directly
- * and use the per-CPU buffers only as a fallback when the lock
- * is not available.
  */
 void printk_nmi_direct_enter(void)
 {
@@ -335,27 +44,8 @@ void printk_nmi_direct_exit(void)
 	this_cpu_and(printk_context, ~PRINTK_NMI_DIRECT_CONTEXT_MASK);
 }
 
-#else
-
-static __printf(1, 0) int vprintk_nmi(const char *fmt, va_list args)
-{
-	return 0;
-}
-
 #endif /* CONFIG_PRINTK_NMI */
 
-/*
- * Lock-less printk(), to avoid deadlocks should the printk() recurse
- * into itself. It uses a per-CPU buffer to store the message, just like
- * NMI.
- */
-static __printf(1, 0) int vprintk_safe(const char *fmt, va_list args)
-{
-	struct printk_safe_seq_buf *s = this_cpu_ptr(&safe_print_seq);
-
-	return printk_safe_log_store(s, fmt, args);
-}
-
 /* Can be preempted by NMI. */
 void printk_safe_enter(void)
 {
@@ -379,47 +69,22 @@ __printf(1, 0) int vprintk_func(const char *fmt, va_list args)
 #endif
 
 	/*
-	 * Try to use the main logbuf even in NMI. But avoid calling console
+	 * Use the main logbuf even in NMI. But avoid calling console
 	 * drivers that might have their own locks.
 	 */
-	if ((this_cpu_read(printk_context) & PRINTK_NMI_DIRECT_CONTEXT_MASK) &&
-	    raw_spin_trylock(&logbuf_lock)) {
+	if (this_cpu_read(printk_context) &
+	    (PRINTK_NMI_DIRECT_CONTEXT_MASK |
+	     PRINTK_NMI_CONTEXT_MASK |
+	     PRINTK_SAFE_CONTEXT_MASK)) {
 		int len;
 
+		printk_safe_enter_irqsave(flags);
 		len = vprintk_store(0, LOGLEVEL_DEFAULT, NULL, fmt, args);
-		raw_spin_unlock(&logbuf_lock);
+		printk_safe_exit_irqrestore(flags);
 		defer_console_output();
 		return len;
 	}
 
-	/* Use extra buffer in NMI when logbuf_lock is taken or in safe mode. */
-	if (this_cpu_read(printk_context) & PRINTK_NMI_CONTEXT_MASK)
-		return vprintk_nmi(fmt, args);
-
-	/* Use extra buffer to prevent a recursion deadlock in safe mode. */
-	if (this_cpu_read(printk_context) & PRINTK_SAFE_CONTEXT_MASK)
-		return vprintk_safe(fmt, args);
-
 	/* No obstacles. */
 	return vprintk_default(fmt, args);
 }
-
-void __init printk_safe_init(void)
-{
-	int cpu;
-
-	for_each_possible_cpu(cpu) {
-		struct printk_safe_seq_buf *s;
-
-		s = &per_cpu(safe_print_seq, cpu);
-		init_irq_work(&s->work, __printk_safe_flush);
-
-#ifdef CONFIG_PRINTK_NMI
-		s = &per_cpu(nmi_print_seq, cpu);
-		init_irq_work(&s->work, __printk_safe_flush);
-#endif
-	}
-
-	/* Flush pending messages that did not have scheduled IRQ works. */
-	printk_safe_flush();
-}
diff --git a/kernel/ptrace.c b/kernel/ptrace.c
index 6d82fba43c97..8a65ec16c512 100644
--- a/kernel/ptrace.c
+++ b/kernel/ptrace.c
@@ -197,7 +197,14 @@ static bool ptrace_freeze_traced(struct task_struct *task)
 	spin_lock_irq(&task->sighand->siglock);
 	if (task_is_traced(task) && !looks_like_a_spurious_pid(task) &&
 	    !__fatal_signal_pending(task)) {
-		task->state = __TASK_TRACED;
+		unsigned long flags;
+
+		raw_spin_lock_irqsave(&task->pi_lock, flags);
+		if (task->state & __TASK_TRACED)
+			task->state = __TASK_TRACED;
+		else
+			task->saved_state = __TASK_TRACED;
+		raw_spin_unlock_irqrestore(&task->pi_lock, flags);
 		ret = true;
 	}
 	spin_unlock_irq(&task->sighand->siglock);
@@ -207,8 +214,8 @@ static bool ptrace_freeze_traced(struct task_struct *task)
 
 static void ptrace_unfreeze_traced(struct task_struct *task)
 {
-	if (task->state != __TASK_TRACED)
-		return;
+	unsigned long flags;
+	bool frozen = true;
 
 	WARN_ON(!task->ptrace || task->parent != current);
 
@@ -217,12 +224,19 @@ static void ptrace_unfreeze_traced(struct task_struct *task)
 	 * Recheck state under the lock to close this race.
 	 */
 	spin_lock_irq(&task->sighand->siglock);
-	if (task->state == __TASK_TRACED) {
-		if (__fatal_signal_pending(task))
-			wake_up_state(task, __TASK_TRACED);
-		else
-			task->state = TASK_TRACED;
-	}
+
+	raw_spin_lock_irqsave(&task->pi_lock, flags);
+	if (task->state == __TASK_TRACED)
+		task->state = TASK_TRACED;
+	else if (task->saved_state == __TASK_TRACED)
+		task->saved_state = TASK_TRACED;
+	else
+		frozen = false;
+	raw_spin_unlock_irqrestore(&task->pi_lock, flags);
+
+	if (frozen && __fatal_signal_pending(task))
+		wake_up_state(task, __TASK_TRACED);
+
 	spin_unlock_irq(&task->sighand->siglock);
 }
 
diff --git a/kernel/rcu/Kconfig b/kernel/rcu/Kconfig
index b1d7aef10e6a..5e11e30f45eb 100644
--- a/kernel/rcu/Kconfig
+++ b/kernel/rcu/Kconfig
@@ -190,8 +190,8 @@ config RCU_FAST_NO_HZ
 
 config RCU_BOOST
 	bool "Enable RCU priority boosting"
-	depends on RT_MUTEXES && PREEMPT_RCU && RCU_EXPERT
-	default n
+	depends on (RT_MUTEXES && PREEMPT_RCU && RCU_EXPERT) || PREEMPT_RT
+	default y if PREEMPT_RT
 	help
 	  This option boosts the priority of preempted RCU readers that
 	  block the current preemptible RCU grace period for too long.
diff --git a/kernel/rcu/tree.c b/kernel/rcu/tree.c
index 4e6a44683248..8937a7a2b33f 100644
--- a/kernel/rcu/tree.c
+++ b/kernel/rcu/tree.c
@@ -100,8 +100,10 @@ static struct rcu_state rcu_state = {
 static bool dump_tree;
 module_param(dump_tree, bool, 0444);
 /* By default, use RCU_SOFTIRQ instead of rcuc kthreads. */
-static bool use_softirq = true;
+static bool use_softirq = !IS_ENABLED(CONFIG_PREEMPT_RT);
+#ifndef CONFIG_PREEMPT_RT
 module_param(use_softirq, bool, 0444);
+#endif
 /* Control rcu_node-tree auto-balancing at boot time. */
 static bool rcu_fanout_exact;
 module_param(rcu_fanout_exact, bool, 0444);
diff --git a/kernel/rcu/update.c b/kernel/rcu/update.c
index 849f0aa99333..dd94a602a6d2 100644
--- a/kernel/rcu/update.c
+++ b/kernel/rcu/update.c
@@ -56,8 +56,10 @@
 #ifndef CONFIG_TINY_RCU
 module_param(rcu_expedited, int, 0);
 module_param(rcu_normal, int, 0);
-static int rcu_normal_after_boot;
+static int rcu_normal_after_boot = IS_ENABLED(CONFIG_PREEMPT_RT);
+#ifndef CONFIG_PREEMPT_RT
 module_param(rcu_normal_after_boot, int, 0);
+#endif
 #endif /* #ifndef CONFIG_TINY_RCU */
 
 #ifdef CONFIG_DEBUG_LOCK_ALLOC
diff --git a/kernel/sched/core.c b/kernel/sched/core.c
index 62d14fba4ca6..f294e2cab773 100644
--- a/kernel/sched/core.c
+++ b/kernel/sched/core.c
@@ -65,7 +65,11 @@ const_debug unsigned int sysctl_sched_features =
  * Number of tasks to iterate in a single balance run.
  * Limited because this is done with IRQs disabled.
  */
+#ifdef CONFIG_PREEMPT_RT
+const_debug unsigned int sysctl_sched_nr_migrate = 8;
+#else
 const_debug unsigned int sysctl_sched_nr_migrate = 32;
+#endif
 
 /*
  * period over which we measure -rt task CPU usage in us.
@@ -856,9 +860,15 @@ static bool set_nr_if_polling(struct task_struct *p)
 #endif
 #endif
 
-static bool __wake_q_add(struct wake_q_head *head, struct task_struct *task)
+static bool __wake_q_add(struct wake_q_head *head, struct task_struct *task,
+			 bool sleeper)
 {
-	struct wake_q_node *node = &task->wake_q;
+	struct wake_q_node *node;
+
+	if (sleeper)
+		node = &task->wake_q_sleeper;
+	else
+		node = &task->wake_q;
 
 	/*
 	 * Atomically grab the task, if ->wake_q is !nil already it means
@@ -894,7 +904,13 @@ static bool __wake_q_add(struct wake_q_head *head, struct task_struct *task)
  */
 void wake_q_add(struct wake_q_head *head, struct task_struct *task)
 {
-	if (__wake_q_add(head, task))
+	if (__wake_q_add(head, task, false))
+		get_task_struct(task);
+}
+
+void wake_q_add_sleeper(struct wake_q_head *head, struct task_struct *task)
+{
+	if (__wake_q_add(head, task, true))
 		get_task_struct(task);
 }
 
@@ -917,28 +933,39 @@ void wake_q_add(struct wake_q_head *head, struct task_struct *task)
  */
 void wake_q_add_safe(struct wake_q_head *head, struct task_struct *task)
 {
-	if (!__wake_q_add(head, task))
+	if (!__wake_q_add(head, task, false))
 		put_task_struct(task);
 }
 
-void wake_up_q(struct wake_q_head *head)
+void __wake_up_q(struct wake_q_head *head, bool sleeper)
 {
 	struct wake_q_node *node = head->first;
 
 	while (node != WAKE_Q_TAIL) {
 		struct task_struct *task;
 
-		task = container_of(node, struct task_struct, wake_q);
+		if (sleeper)
+			task = container_of(node, struct task_struct, wake_q_sleeper);
+		else
+			task = container_of(node, struct task_struct, wake_q);
+
 		BUG_ON(!task);
 		/* Task can safely be re-inserted now: */
 		node = node->next;
-		task->wake_q.next = NULL;
 
+		if (sleeper)
+			task->wake_q_sleeper.next = NULL;
+		else
+			task->wake_q.next = NULL;
 		/*
 		 * wake_up_process() executes a full barrier, which pairs with
 		 * the queueing in wake_q_add() so as not to miss wakeups.
 		 */
-		wake_up_process(task);
+		if (sleeper)
+			wake_up_lock_sleeper(task);
+		else
+			wake_up_process(task);
+
 		put_task_struct(task);
 	}
 }
@@ -974,6 +1001,48 @@ void resched_curr(struct rq *rq)
 		trace_sched_wake_idle_without_ipi(cpu);
 }
 
+#ifdef CONFIG_PREEMPT_LAZY
+
+static int tsk_is_polling(struct task_struct *p)
+{
+#ifdef TIF_POLLING_NRFLAG
+	return test_tsk_thread_flag(p, TIF_POLLING_NRFLAG);
+#else
+	return 0;
+#endif
+}
+
+void resched_curr_lazy(struct rq *rq)
+{
+	struct task_struct *curr = rq->curr;
+	int cpu;
+
+	if (!sched_feat(PREEMPT_LAZY)) {
+		resched_curr(rq);
+		return;
+	}
+
+	lockdep_assert_held(&rq->__lock);
+
+	if (test_tsk_need_resched(curr))
+		return;
+
+	if (test_tsk_need_resched_lazy(curr))
+		return;
+
+	set_tsk_need_resched_lazy(curr);
+
+	cpu = cpu_of(rq);
+	if (cpu == smp_processor_id())
+		return;
+
+	/* NEED_RESCHED_LAZY must be visible before we test polling */
+	smp_mb();
+	if (!tsk_is_polling(curr))
+		smp_send_reschedule(cpu);
+}
+#endif
+
 void resched_cpu(int cpu)
 {
 	struct rq *rq = cpu_rq(cpu);
@@ -2063,6 +2132,82 @@ void check_preempt_curr(struct rq *rq, struct task_struct *p, int flags)
 
 #ifdef CONFIG_SMP
 
+static void
+__do_set_cpus_allowed(struct task_struct *p, const struct cpumask *new_mask, u32 flags);
+
+static int __set_cpus_allowed_ptr(struct task_struct *p,
+				  const struct cpumask *new_mask,
+				  u32 flags);
+
+static void migrate_disable_switch(struct rq *rq, struct task_struct *p)
+{
+	if (likely(!p->migration_disabled))
+		return;
+
+	if (p->cpus_ptr != &p->cpus_mask)
+		return;
+
+	/*
+	 * Violates locking rules! see comment in __do_set_cpus_allowed().
+	 */
+	__do_set_cpus_allowed(p, cpumask_of(rq->cpu), SCA_MIGRATE_DISABLE);
+}
+
+void migrate_disable(void)
+{
+	struct task_struct *p = current;
+
+	if (p->migration_disabled) {
+		p->migration_disabled++;
+		return;
+	}
+
+	trace_sched_migrate_disable_tp(p);
+
+	preempt_disable();
+	this_rq()->nr_pinned++;
+	p->migration_disabled = 1;
+	preempt_lazy_disable();
+	preempt_enable();
+}
+EXPORT_SYMBOL_GPL(migrate_disable);
+
+void migrate_enable(void)
+{
+	struct task_struct *p = current;
+
+	if (p->migration_disabled > 1) {
+		p->migration_disabled--;
+		return;
+	}
+
+	/*
+	 * Ensure stop_task runs either before or after this, and that
+	 * __set_cpus_allowed_ptr(SCA_MIGRATE_ENABLE) doesn't schedule().
+	 */
+	preempt_disable();
+	if (p->cpus_ptr != &p->cpus_mask)
+		__set_cpus_allowed_ptr(p, &p->cpus_mask, SCA_MIGRATE_ENABLE);
+	/*
+	 * Mustn't clear migration_disabled() until cpus_ptr points back at the
+	 * regular cpus_mask, otherwise things that race (eg.
+	 * select_fallback_rq) get confused.
+	 */
+	barrier();
+	p->migration_disabled = 0;
+	this_rq()->nr_pinned--;
+	preempt_lazy_enable();
+	preempt_enable();
+
+	trace_sched_migrate_enable_tp(p);
+}
+EXPORT_SYMBOL_GPL(migrate_enable);
+
+static inline bool rq_has_pinned_tasks(struct rq *rq)
+{
+	return rq->nr_pinned;
+}
+
 /*
  * Per-CPU kthreads are allowed to run on !active && online CPUs, see
  * __set_cpus_allowed_ptr() and select_fallback_rq().
@@ -2072,7 +2217,7 @@ static inline bool is_cpu_allowed(struct task_struct *p, int cpu)
 	if (!cpumask_test_cpu(cpu, p->cpus_ptr))
 		return false;
 
-	if (is_per_cpu_kthread(p))
+	if (is_per_cpu_kthread(p) || is_migration_disabled(p))
 		return cpu_online(cpu);
 
 	return cpu_active(cpu);
@@ -2117,8 +2262,21 @@ static struct rq *move_queued_task(struct rq *rq, struct rq_flags *rf,
 }
 
 struct migration_arg {
-	struct task_struct *task;
-	int dest_cpu;
+	struct task_struct		*task;
+	int				dest_cpu;
+	struct set_affinity_pending	*pending;
+};
+
+/*
+ * @refs: number of wait_for_completion()
+ * @stop_pending: is @stop_work in use
+ */
+struct set_affinity_pending {
+	refcount_t		refs;
+	unsigned int		stop_pending;
+	struct completion	done;
+	struct cpu_stop_work	stop_work;
+	struct migration_arg	arg;
 };
 
 /*
@@ -2151,15 +2309,17 @@ static struct rq *__migrate_task(struct rq *rq, struct rq_flags *rf,
 static int migration_cpu_stop(void *data)
 {
 	struct migration_arg *arg = data;
+	struct set_affinity_pending *pending = arg->pending;
 	struct task_struct *p = arg->task;
 	struct rq *rq = this_rq();
+	bool complete = false;
 	struct rq_flags rf;
 
 	/*
 	 * The original target CPU might have gone down and we might
 	 * be on another CPU but it doesn't matter.
 	 */
-	local_irq_disable();
+	local_irq_save(rf.flags);
 	/*
 	 * We need to explicitly wake pending tasks before running
 	 * __migrate_task() such that we will not miss enforcing cpus_ptr
@@ -2169,21 +2329,121 @@ static int migration_cpu_stop(void *data)
 
 	raw_spin_lock(&p->pi_lock);
 	rq_lock(rq, &rf);
+
 	/*
 	 * If task_rq(p) != rq, it cannot be migrated here, because we're
 	 * holding rq->lock, if p->on_rq == 0 it cannot get enqueued because
 	 * we're holding p->pi_lock.
 	 */
 	if (task_rq(p) == rq) {
+		if (is_migration_disabled(p))
+			goto out;
+
+		if (pending) {
+			if (p->migration_pending == pending)
+				p->migration_pending = NULL;
+			complete = true;
+
+			if (cpumask_test_cpu(task_cpu(p), &p->cpus_mask))
+				goto out;
+		}
+
 		if (task_on_rq_queued(p))
 			rq = __migrate_task(rq, &rf, p, arg->dest_cpu);
 		else
 			p->wake_cpu = arg->dest_cpu;
+
+		/*
+		 * XXX __migrate_task() can fail, at which point we might end
+		 * up running on a dodgy CPU, AFAICT this can only happen
+		 * during CPU hotplug, at which point we'll get pushed out
+		 * anyway, so it's probably not a big deal.
+		 */
+
+	} else if (pending) {
+		/*
+		 * This happens when we get migrated between migrate_enable()'s
+		 * preempt_enable() and scheduling the stopper task. At that
+		 * point we're a regular task again and not current anymore.
+		 *
+		 * A !PREEMPT kernel has a giant hole here, which makes it far
+		 * more likely.
+		 */
+
+		/*
+		 * The task moved before the stopper got to run. We're holding
+		 * ->pi_lock, so the allowed mask is stable - if it got
+		 * somewhere allowed, we're done.
+		 */
+		if (cpumask_test_cpu(task_cpu(p), p->cpus_ptr)) {
+			if (p->migration_pending == pending)
+				p->migration_pending = NULL;
+			complete = true;
+			goto out;
+		}
+
+		/*
+		 * When migrate_enable() hits a rq mis-match we can't reliably
+		 * determine is_migration_disabled() and so have to chase after
+		 * it.
+		 */
+		WARN_ON_ONCE(!pending->stop_pending);
+		task_rq_unlock(rq, p, &rf);
+		stop_one_cpu_nowait(task_cpu(p), migration_cpu_stop,
+				    &pending->arg, &pending->stop_work);
+		return 0;
 	}
-	rq_unlock(rq, &rf);
-	raw_spin_unlock(&p->pi_lock);
+out:
+	if (pending)
+		pending->stop_pending = false;
+	task_rq_unlock(rq, p, &rf);
 
-	local_irq_enable();
+	if (complete)
+		complete_all(&pending->done);
+
+	return 0;
+}
+
+int push_cpu_stop(void *arg)
+{
+	struct rq *lowest_rq = NULL, *rq = this_rq();
+	struct task_struct *p = arg;
+
+	raw_spin_lock_irq(&p->pi_lock);
+	raw_spin_lock(&rq->__lock);
+
+	if (task_rq(p) != rq)
+		goto out_unlock;
+
+	if (is_migration_disabled(p)) {
+		p->migration_flags |= MDF_PUSH;
+		goto out_unlock;
+	}
+
+	p->migration_flags &= ~MDF_PUSH;
+
+	if (p->sched_class->find_lock_rq)
+		lowest_rq = p->sched_class->find_lock_rq(p, rq);
+
+	if (!lowest_rq)
+		goto out_unlock;
+
+	// XXX validate p is still the highest prio task
+	if (task_rq(p) == rq) {
+		deactivate_task(rq, p, 0);
+		set_task_cpu(p, lowest_rq->cpu);
+		activate_task(lowest_rq, p, 0);
+		resched_curr(lowest_rq);
+	}
+
+	double_unlock_balance(rq, lowest_rq);
+
+out_unlock:
+	rq->push_busy = false;
+	raw_spin_unlock(&rq->__lock);
+	raw_spin_unlock_irq(&p->pi_lock);
+
+	put_task_struct(p);
 	return 0;
 }
 
@@ -2191,18 +2451,39 @@ static int migration_cpu_stop(void *data)
  * sched_class::set_cpus_allowed must do the below, but is not required to
  * actually call this function.
  */
-void set_cpus_allowed_common(struct task_struct *p, const struct cpumask *new_mask)
+void set_cpus_allowed_common(struct task_struct *p, const struct cpumask *new_mask, u32 flags)
 {
+	if (flags & (SCA_MIGRATE_ENABLE | SCA_MIGRATE_DISABLE)) {
+		p->cpus_ptr = new_mask;
+		return;
+	}
+
 	cpumask_copy(&p->cpus_mask, new_mask);
 	p->nr_cpus_allowed = cpumask_weight(new_mask);
 }
 
-void do_set_cpus_allowed(struct task_struct *p, const struct cpumask *new_mask)
+static void
+__do_set_cpus_allowed(struct task_struct *p, const struct cpumask *new_mask, u32 flags)
 {
 	struct rq *rq = task_rq(p);
 	bool queued, running;
 
-	lockdep_assert_held(&p->pi_lock);
+	/*
+	 * This here violates the locking rules for affinity, since we're only
+	 * supposed to change these variables while holding both rq->lock and
+	 * p->pi_lock.
+	 *
+	 * HOWEVER, it magically works, because ttwu() is the only code that
+	 * accesses these variables under p->pi_lock and only does so after
+	 * smp_cond_load_acquire(&p->on_cpu, !VAL), and we're in __schedule()
+	 * before finish_task().
+	 *
+	 * XXX do further audits, this smells like something putrid.
+	 */
+	if (flags & SCA_MIGRATE_DISABLE)
+		SCHED_WARN_ON(!p->on_cpu);
+	else
+		lockdep_assert_held(&p->pi_lock);
 
 	queued = task_on_rq_queued(p);
 	running = task_current(rq, p);
@@ -2218,7 +2499,7 @@ void do_set_cpus_allowed(struct task_struct *p, const struct cpumask *new_mask)
 	if (running)
 		put_prev_task(rq, p);
 
-	p->sched_class->set_cpus_allowed(p, new_mask);
+	p->sched_class->set_cpus_allowed(p, new_mask, flags);
 
 	if (queued)
 		enqueue_task(rq, p, ENQUEUE_RESTORE | ENQUEUE_NOCLOCK);
@@ -2226,6 +2507,222 @@ void do_set_cpus_allowed(struct task_struct *p, const struct cpumask *new_mask)
 		set_next_task(rq, p);
 }
 
+void do_set_cpus_allowed(struct task_struct *p, const struct cpumask *new_mask)
+{
+	__do_set_cpus_allowed(p, new_mask, 0);
+}
+
+/*
+ * This function is wildly self concurrent; here be dragons.
+ *
+ *
+ * When given a valid mask, __set_cpus_allowed_ptr() must block until the
+ * designated task is enqueued on an allowed CPU. If that task is currently
+ * running, we have to kick it out using the CPU stopper.
+ *
+ * Migrate-Disable comes along and tramples all over our nice sandcastle.
+ * Consider:
+ *
+ *     Initial conditions: P0->cpus_mask = [0, 1]
+ *
+ *     P0@CPU0                  P1
+ *
+ *     migrate_disable();
+ *     <preempted>
+ *                              set_cpus_allowed_ptr(P0, [1]);
+ *
+ * P1 *cannot* return from this set_cpus_allowed_ptr() call until P0 executes
+ * its outermost migrate_enable() (i.e. it exits its Migrate-Disable region).
+ * This means we need the following scheme:
+ *
+ *     P0@CPU0                  P1
+ *
+ *     migrate_disable();
+ *     <preempted>
+ *                              set_cpus_allowed_ptr(P0, [1]);
+ *                                <blocks>
+ *     <resumes>
+ *     migrate_enable();
+ *       __set_cpus_allowed_ptr();
+ *       <wakes local stopper>
+ *                         `--> <woken on migration completion>
+ *
+ * Now the fun stuff: there may be several P1-like tasks, i.e. multiple
+ * concurrent set_cpus_allowed_ptr(P0, [*]) calls. CPU affinity changes of any
+ * task p are serialized by p->pi_lock, which we can leverage: the one that
+ * should come into effect at the end of the Migrate-Disable region is the last
+ * one. This means we only need to track a single cpumask (i.e. p->cpus_mask),
+ * but we still need to properly signal those waiting tasks at the appropriate
+ * moment.
+ *
+ * This is implemented using struct set_affinity_pending. The first
+ * __set_cpus_allowed_ptr() caller within a given Migrate-Disable region will
+ * setup an instance of that struct and install it on the targeted task_struct.
+ * Any and all further callers will reuse that instance. Those then wait for
+ * a completion signaled at the tail of the CPU stopper callback (1), triggered
+ * on the end of the Migrate-Disable region (i.e. outermost migrate_enable()).
+ *
+ *
+ * (1) In the cases covered above. There is one more where the completion is
+ * signaled within affine_move_task() itself: when a subsequent affinity request
+ * cancels the need for an active migration. Consider:
+ *
+ *     Initial conditions: P0->cpus_mask = [0, 1]
+ *
+ *     P0@CPU0            P1                             P2
+ *
+ *     migrate_disable();
+ *     <preempted>
+ *                        set_cpus_allowed_ptr(P0, [1]);
+ *                          <blocks>
+ *                                                       set_cpus_allowed_ptr(P0, [0, 1]);
+ *                                                         <signal completion>
+ *                          <awakes>
+ *
+ * Note that the above is safe vs a concurrent migrate_enable(), as any
+ * pending affinity completion is preceded an uninstallion of
+ * p->migration_pending done with p->pi_lock held.
+ */
+static int affine_move_task(struct rq *rq, struct task_struct *p, struct rq_flags *rf,
+			    int dest_cpu, unsigned int flags)
+{
+	struct set_affinity_pending my_pending = { }, *pending = NULL;
+	bool stop_pending, complete = false;
+
+	/* Can the task run on the task's current CPU? If so, we're done */
+	if (cpumask_test_cpu(task_cpu(p), &p->cpus_mask)) {
+		struct task_struct *push_task = NULL;
+
+		if ((flags & SCA_MIGRATE_ENABLE) &&
+		    (p->migration_flags & MDF_PUSH) && !rq->push_busy) {
+			rq->push_busy = true;
+			push_task = get_task_struct(p);
+		}
+
+		/*
+		 * If there are pending waiters, but no pending stop_work,
+		 * then complete now.
+		 */
+		pending = p->migration_pending;
+		if (pending && !pending->stop_pending) {
+			p->migration_pending = NULL;
+			complete = true;
+		}
+
+		task_rq_unlock(rq, p, rf);
+
+		if (push_task) {
+			stop_one_cpu_nowait(rq->cpu, push_cpu_stop,
+					    p, &rq->push_work);
+		}
+
+		if (complete)
+			complete_all(&pending->done);
+
+		return 0;
+	}
+
+	if (!(flags & SCA_MIGRATE_ENABLE)) {
+		/* serialized by p->pi_lock */
+		if (!p->migration_pending) {
+			/* Install the request */
+			refcount_set(&my_pending.refs, 1);
+			init_completion(&my_pending.done);
+			my_pending.arg = (struct migration_arg) {
+				.task = p,
+				.dest_cpu = dest_cpu,
+				.pending = &my_pending,
+			};
+
+			p->migration_pending = &my_pending;
+		} else {
+			pending = p->migration_pending;
+			refcount_inc(&pending->refs);
+			/*
+			 * Affinity has changed, but we've already installed a
+			 * pending. migration_cpu_stop() *must* see this, else
+			 * we risk a completion of the pending despite having a
+			 * task on a disallowed CPU.
+			 *
+			 * Serialized by p->pi_lock, so this is safe.
+			 */
+			pending->arg.dest_cpu = dest_cpu;
+		}
+	}
+	pending = p->migration_pending;
+	/*
+	 * - !MIGRATE_ENABLE:
+	 *   we'll have installed a pending if there wasn't one already.
+	 *
+	 * - MIGRATE_ENABLE:
+	 *   we're here because the current CPU isn't matching anymore,
+	 *   the only way that can happen is because of a concurrent
+	 *   set_cpus_allowed_ptr() call, which should then still be
+	 *   pending completion.
+	 *
+	 * Either way, we really should have a @pending here.
+	 */
+	if (WARN_ON_ONCE(!pending)) {
+		task_rq_unlock(rq, p, rf);
+		return -EINVAL;
+	}
+
+	if (task_running(rq, p) || p->state == TASK_WAKING) {
+		/*
+		 * MIGRATE_ENABLE gets here because 'p == current', but for
+		 * anything else we cannot do is_migration_disabled(), punt
+		 * and have the stopper function handle it all race-free.
+		 */
+		stop_pending = pending->stop_pending;
+		if (!stop_pending)
+			pending->stop_pending = true;
+
+		if (flags & SCA_MIGRATE_ENABLE)
+			p->migration_flags &= ~MDF_PUSH;
+
+		task_rq_unlock(rq, p, rf);
+
+		if (!stop_pending) {
+			stop_one_cpu_nowait(cpu_of(rq), migration_cpu_stop,
+					    &pending->arg, &pending->stop_work);
+		}
+
+		if (flags & SCA_MIGRATE_ENABLE)
+			return 0;
+	} else {
+
+		if (!is_migration_disabled(p)) {
+			if (task_on_rq_queued(p))
+				rq = move_queued_task(rq, rf, p, dest_cpu);
+
+			if (!pending->stop_pending) {
+				p->migration_pending = NULL;
+				complete = true;
+			}
+		}
+		task_rq_unlock(rq, p, rf);
+
+		if (complete)
+			complete_all(&pending->done);
+	}
+
+	wait_for_completion(&pending->done);
+
+	if (refcount_dec_and_test(&pending->refs))
+		wake_up_var(&pending->refs); /* No UaF, just an address */
+
+	/*
+	 * Block the original owner of &pending until all subsequent callers
+	 * have seen the completion and decremented the refcount
+	 */
+	wait_var_event(&my_pending.refs, !refcount_read(&my_pending.refs));
+
+	/* ARGH */
+	WARN_ON_ONCE(my_pending.stop_pending);
+
+	return 0;
+}
+
 /*
  * Change a given task's CPU affinity. Migrate the thread to a
  * proper CPU and schedule it away if the CPU it's executing on
@@ -2236,7 +2733,8 @@ void do_set_cpus_allowed(struct task_struct *p, const struct cpumask *new_mask)
  * call is not atomic; no spinlocks may be held.
  */
 static int __set_cpus_allowed_ptr(struct task_struct *p,
-				  const struct cpumask *new_mask, bool check)
+				  const struct cpumask *new_mask,
+				  u32 flags)
 {
 	const struct cpumask *cpu_valid_mask = cpu_active_mask;
 	unsigned int dest_cpu;
@@ -2247,9 +2745,14 @@ static int __set_cpus_allowed_ptr(struct task_struct *p,
 	rq = task_rq_lock(p, &rf);
 	update_rq_clock(rq);
 
-	if (p->flags & PF_KTHREAD) {
+	if (p->flags & PF_KTHREAD || is_migration_disabled(p)) {
 		/*
-		 * Kernel threads are allowed on online && !active CPUs
+		 * Kernel threads are allowed on online && !active CPUs.
+		 *
+		 * Specifically, migration_disabled() tasks must not fail the
+		 * cpumask_any_and_distribute() pick below, esp. so on
+		 * SCA_MIGRATE_ENABLE, otherwise we'll not call
+		 * set_cpus_allowed_common() and actually reset p->cpus_ptr.
 		 */
 		cpu_valid_mask = cpu_online_mask;
 	}
@@ -2258,13 +2761,22 @@ static int __set_cpus_allowed_ptr(struct task_struct *p,
 	 * Must re-check here, to close a race against __kthread_bind(),
 	 * sched_setaffinity() is not guaranteed to observe the flag.
 	 */
-	if (check && (p->flags & PF_NO_SETAFFINITY)) {
+	if ((flags & SCA_CHECK) && (p->flags & PF_NO_SETAFFINITY)) {
 		ret = -EINVAL;
 		goto out;
 	}
 
-	if (cpumask_equal(&p->cpus_mask, new_mask))
-		goto out;
+	if (!(flags & SCA_MIGRATE_ENABLE)) {
+		if (cpumask_equal(&p->cpus_mask, new_mask))
+			goto out;
+
+		if (WARN_ON_ONCE(p == current &&
+				 is_migration_disabled(p) &&
+				 !cpumask_test_cpu(task_cpu(p), new_mask))) {
+			ret = -EBUSY;
+			goto out;
+		}
+	}
 
 	/*
 	 * Picking a ~random cpu helps in cases where we are changing affinity
@@ -2277,7 +2789,7 @@ static int __set_cpus_allowed_ptr(struct task_struct *p,
 		goto out;
 	}
 
-	do_set_cpus_allowed(p, new_mask);
+	__do_set_cpus_allowed(p, new_mask, flags);
 
 	if (p->flags & PF_KTHREAD) {
 		/*
@@ -2289,23 +2801,8 @@ static int __set_cpus_allowed_ptr(struct task_struct *p,
 			p->nr_cpus_allowed != 1);
 	}
 
-	/* Can the task run on the task's current CPU? If so, we're done */
-	if (cpumask_test_cpu(task_cpu(p), new_mask))
-		goto out;
+	return affine_move_task(rq, p, &rf, dest_cpu, flags);
 
-	if (task_running(rq, p) || p->state == TASK_WAKING) {
-		struct migration_arg arg = { p, dest_cpu };
-		/* Need help from migration thread: drop lock and wait. */
-		task_rq_unlock(rq, p, &rf);
-		stop_one_cpu(cpu_of(rq), migration_cpu_stop, &arg);
-		return 0;
-	} else if (task_on_rq_queued(p)) {
-		/*
-		 * OK, since we're going to drop the lock immediately
-		 * afterwards anyway.
-		 */
-		rq = move_queued_task(rq, &rf, p, dest_cpu);
-	}
 out:
 	task_rq_unlock(rq, p, &rf);
 
@@ -2314,7 +2811,7 @@ static int __set_cpus_allowed_ptr(struct task_struct *p,
 
 int set_cpus_allowed_ptr(struct task_struct *p, const struct cpumask *new_mask)
 {
-	return __set_cpus_allowed_ptr(p, new_mask, false);
+	return __set_cpus_allowed_ptr(p, new_mask, 0);
 }
 EXPORT_SYMBOL_GPL(set_cpus_allowed_ptr);
 
@@ -2355,6 +2852,8 @@ void set_task_cpu(struct task_struct *p, unsigned int new_cpu)
 	 * Clearly, migrating tasks to offline CPUs is a fairly daft thing.
 	 */
 	WARN_ON_ONCE(!cpu_online(new_cpu));
+
+	WARN_ON_ONCE(is_migration_disabled(p));
 #endif
 
 	trace_sched_migrate_task(p, new_cpu);
@@ -2487,6 +2986,18 @@ int migrate_swap(struct task_struct *cur, struct task_struct *p,
 }
 #endif /* CONFIG_NUMA_BALANCING */
 
+static bool check_task_state(struct task_struct *p, long match_state)
+{
+	bool match = false;
+
+	raw_spin_lock_irq(&p->pi_lock);
+	if (p->state == match_state || p->saved_state == match_state)
+		match = true;
+	raw_spin_unlock_irq(&p->pi_lock);
+
+	return match;
+}
+
 /*
  * wait_task_inactive - wait for a thread to unschedule.
  *
@@ -2531,7 +3042,7 @@ unsigned long wait_task_inactive(struct task_struct *p, long match_state)
 		 * is actually now running somewhere else!
 		 */
 		while (task_running(rq, p)) {
-			if (match_state && unlikely(p->state != match_state))
+			if (match_state && !check_task_state(p, match_state))
 				return 0;
 			cpu_relax();
 		}
@@ -2546,7 +3057,8 @@ unsigned long wait_task_inactive(struct task_struct *p, long match_state)
 		running = task_running(rq, p);
 		queued = task_on_rq_queued(p);
 		ncsw = 0;
-		if (!match_state || p->state == match_state)
+		if (!match_state || p->state == match_state ||
+		    p->saved_state == match_state)
 			ncsw = p->nvcsw | LONG_MIN; /* sets MSB */
 		task_rq_unlock(rq, p, &rf);
 
@@ -2580,7 +3092,7 @@ unsigned long wait_task_inactive(struct task_struct *p, long match_state)
 			ktime_t to = NSEC_PER_SEC / HZ;
 
 			set_current_state(TASK_UNINTERRUPTIBLE);
-			schedule_hrtimeout(&to, HRTIMER_MODE_REL);
+			schedule_hrtimeout(&to, HRTIMER_MODE_REL_HARD);
 			continue;
 		}
 
@@ -2685,6 +3197,12 @@ static int select_fallback_rq(int cpu, struct task_struct *p)
 			}
 			fallthrough;
 		case possible:
+			/*
+			 * XXX When called from select_task_rq() we only
+			 * hold p->pi_lock and again violate locking order.
+			 *
+			 * More yuck to audit.
+			 */
 			do_set_cpus_allowed(p, cpu_possible_mask);
 			state = fail;
 			break;
@@ -2719,7 +3237,7 @@ int select_task_rq(struct task_struct *p, int cpu, int sd_flags, int wake_flags)
 {
 	lockdep_assert_held(&p->pi_lock);
 
-	if (p->nr_cpus_allowed > 1)
+	if (p->nr_cpus_allowed > 1 && !is_migration_disabled(p))
 		cpu = p->sched_class->select_task_rq(p, cpu, sd_flags, wake_flags);
 	else
 		cpu = cpumask_any(p->cpus_ptr);
@@ -2742,6 +3260,7 @@ int select_task_rq(struct task_struct *p, int cpu, int sd_flags, int wake_flags)
 
 void sched_set_stop_task(int cpu, struct task_struct *stop)
 {
+	static struct lock_class_key stop_pi_lock;
 	struct sched_param param = { .sched_priority = MAX_RT_PRIO - 1 };
 	struct task_struct *old_stop = cpu_rq(cpu)->stop;
 
@@ -2757,6 +3276,20 @@ void sched_set_stop_task(int cpu, struct task_struct *stop)
 		sched_setscheduler_nocheck(stop, SCHED_FIFO, &param);
 
 		stop->sched_class = &stop_sched_class;
+
+		/*
+		 * The PI code calls rt_mutex_setprio() with ->pi_lock held to
+		 * adjust the effective priority of a task. As a result,
+		 * rt_mutex_setprio() can trigger (RT) balancing operations,
+		 * which can then trigger wakeups of the stop thread to push
+		 * around the current task.
+		 *
+		 * The stop task itself will never be part of the PI-chain, it
+		 * never blocks, therefore that ->pi_lock recursion is safe.
+		 * Tell lockdep about this by placing the stop->pi_lock in its
+		 * own class.
+		 */
+		lockdep_set_class(&stop->pi_lock, &stop_pi_lock);
 	}
 
 	cpu_rq(cpu)->stop = stop;
@@ -2770,15 +3303,23 @@ void sched_set_stop_task(int cpu, struct task_struct *stop)
 	}
 }
 
-#else
+#else /* CONFIG_SMP */
 
 static inline int __set_cpus_allowed_ptr(struct task_struct *p,
-					 const struct cpumask *new_mask, bool check)
+					 const struct cpumask *new_mask,
+					 u32 flags)
 {
 	return set_cpus_allowed_ptr(p, new_mask);
 }
 
-#endif /* CONFIG_SMP */
+static inline void migrate_disable_switch(struct rq *rq, struct task_struct *p) { }
+
+static inline bool rq_has_pinned_tasks(struct rq *rq)
+{
+	return false;
+}
+
+#endif /* !CONFIG_SMP */
 
 static void
 ttwu_stat(struct task_struct *p, int cpu, int wake_flags)
@@ -3203,7 +3744,7 @@ try_to_wake_up(struct task_struct *p, unsigned int state, int wake_flags)
 	int cpu, success = 0;
 
 	preempt_disable();
-	if (p == current) {
+	if (!IS_ENABLED(CONFIG_PREEMPT_RT) && p == current) {
 		/*
 		 * We're waking current, this means 'p->on_rq' and 'task_cpu(p)
 		 * == smp_processor_id()'. Together this means we can special
@@ -3233,8 +3774,26 @@ try_to_wake_up(struct task_struct *p, unsigned int state, int wake_flags)
 	 */
 	raw_spin_lock_irqsave(&p->pi_lock, flags);
 	smp_mb__after_spinlock();
-	if (!(p->state & state))
+	if (!(p->state & state)) {
+		/*
+		 * The task might be running due to a spinlock sleeper
+		 * wakeup. Check the saved state and set it to running
+		 * if the wakeup condition is true.
+		 */
+		if (!(wake_flags & WF_LOCK_SLEEPER)) {
+			if (p->saved_state & state) {
+				p->saved_state = TASK_RUNNING;
+				success = 1;
+			}
+		}
 		goto unlock;
+	}
+	/*
+	 * If this is a regular wakeup, then we can unconditionally
+	 * clear the saved state of a "lock sleeper".
+	 */
+	if (!(wake_flags & WF_LOCK_SLEEPER))
+		p->saved_state = TASK_RUNNING;
 
 	trace_sched_waking(p);
 
@@ -3423,6 +3982,18 @@ int wake_up_process(struct task_struct *p)
 }
 EXPORT_SYMBOL(wake_up_process);
 
+/**
+ * wake_up_lock_sleeper - Wake up a specific process blocked on a "sleeping lock"
+ * @p: The process to be woken up.
+ *
+ * Same as wake_up_process() above, but wake_flags=WF_LOCK_SLEEPER to indicate
+ * the nature of the wakeup.
+ */
+int wake_up_lock_sleeper(struct task_struct *p)
+{
+	return try_to_wake_up(p, TASK_UNINTERRUPTIBLE, WF_LOCK_SLEEPER);
+}
+
 int wake_up_state(struct task_struct *p, unsigned int state)
 {
 	return try_to_wake_up(p, state, 0);
@@ -3476,6 +4047,7 @@ static void __sched_fork(unsigned long clone_flags, struct task_struct *p)
 	init_numa_balancing(clone_flags, p);
 #ifdef CONFIG_SMP
 	p->wake_entry.u_flags = CSD_TYPE_TTWU;
+  p->migration_pending = NULL;
 #endif
 #ifdef CONFIG_BPF_SCHED
 	p->tag		= 0;
@@ -3684,6 +4256,9 @@ int sched_fork(unsigned long clone_flags, struct task_struct *p)
 	p->on_cpu = 0;
 #endif
 	init_task_preempt_count(p);
+#ifdef CONFIG_HAVE_PREEMPT_LAZY
+	task_thread_info(p)->preempt_lazy_count = 0;
+#endif
 #ifdef CONFIG_SMP
 	plist_node_init(&p->pushable_tasks, MAX_PRIO);
 	RB_CLEAR_NODE(&p->pushable_dl_tasks);
@@ -3862,51 +4437,135 @@ fire_sched_out_preempt_notifiers(struct task_struct *curr,
 		__fire_sched_out_preempt_notifiers(curr, next);
 }
 
-#else /* !CONFIG_PREEMPT_NOTIFIERS */
+#else /* !CONFIG_PREEMPT_NOTIFIERS */
+
+static inline void fire_sched_in_preempt_notifiers(struct task_struct *curr)
+{
+}
+
+static inline void
+fire_sched_out_preempt_notifiers(struct task_struct *curr,
+				 struct task_struct *next)
+{
+}
+
+#endif /* CONFIG_PREEMPT_NOTIFIERS */
+
+static inline void prepare_task(struct task_struct *next)
+{
+#ifdef CONFIG_SMP
+	/*
+	 * Claim the task as running, we do this before switching to it
+	 * such that any running task will have this set.
+	 *
+	 * See the ttwu() WF_ON_CPU case and its ordering comment.
+	 */
+	WRITE_ONCE(next->on_cpu, 1);
+#endif
+}
+
+static inline void finish_task(struct task_struct *prev)
+{
+#ifdef CONFIG_SMP
+	/*
+	 * This must be the very last reference to @prev from this CPU. After
+	 * p->on_cpu is cleared, the task can be moved to a different CPU. We
+	 * must ensure this doesn't happen until the switch is completely
+	 * finished.
+	 *
+	 * In particular, the load of prev->state in finish_task_switch() must
+	 * happen before this.
+	 *
+	 * Pairs with the smp_cond_load_acquire() in try_to_wake_up().
+	 */
+	smp_store_release(&prev->on_cpu, 0);
+#endif
+}
+
+#ifdef CONFIG_SMP
+
+static void do_balance_callbacks(struct rq *rq, struct callback_head *head)
+{
+	void (*func)(struct rq *rq);
+	struct callback_head *next;
+
+	lockdep_assert_held(&rq->__lock);
+
+	while (head) {
+		func = (void (*)(struct rq *))head->func;
+		next = head->next;
+		head->next = NULL;
+		head = next;
+
+		func(rq);
+	}
+}
+
+static inline struct callback_head *splice_balance_callbacks(struct rq *rq)
+{
+	struct callback_head *head = rq->balance_callback;
+
+	lockdep_assert_held(&rq->__lock);
+	if (head) {
+		rq->balance_callback = NULL;
+		rq->balance_flags &= ~BALANCE_WORK;
+	}
+
+	return head;
+}
+
+static void __balance_callbacks(struct rq *rq)
+{
+	do_balance_callbacks(rq, splice_balance_callbacks(rq));
+}
+
+static inline void balance_callbacks(struct rq *rq, struct callback_head *head)
+{
+	unsigned long flags;
+
+	if (unlikely(head)) {
+		raw_spin_lock_irqsave(&rq->__lock, flags);
+		do_balance_callbacks(rq, head);
+		raw_spin_unlock_irqrestore(&rq->__lock, flags);
+	}
+}
+
+static void balance_push(struct rq *rq);
 
-static inline void fire_sched_in_preempt_notifiers(struct task_struct *curr)
+static inline void balance_switch(struct rq *rq)
 {
+	if (likely(!rq->balance_flags))
+		return;
+
+	if (rq->balance_flags & BALANCE_PUSH) {
+		balance_push(rq);
+		return;
+	}
+
+	__balance_callbacks(rq);
 }
 
-static inline void
-fire_sched_out_preempt_notifiers(struct task_struct *curr,
-				 struct task_struct *next)
+#else
+
+static inline void __balance_callbacks(struct rq *rq)
 {
 }
 
-#endif /* CONFIG_PREEMPT_NOTIFIERS */
+static inline struct callback_head *splice_balance_callbacks(struct rq *rq)
+{
+	return NULL;
+}
 
-static inline void prepare_task(struct task_struct *next)
+static inline void balance_callbacks(struct rq *rq, struct callback_head *head)
 {
-#ifdef CONFIG_SMP
-	/*
-	 * Claim the task as running, we do this before switching to it
-	 * such that any running task will have this set.
-	 *
-	 * See the ttwu() WF_ON_CPU case and its ordering comment.
-	 */
-	WRITE_ONCE(next->on_cpu, 1);
-#endif
 }
 
-static inline void finish_task(struct task_struct *prev)
+static inline void balance_switch(struct rq *rq)
 {
-#ifdef CONFIG_SMP
-	/*
-	 * This must be the very last reference to @prev from this CPU. After
-	 * p->on_cpu is cleared, the task can be moved to a different CPU. We
-	 * must ensure this doesn't happen until the switch is completely
-	 * finished.
-	 *
-	 * In particular, the load of prev->state in finish_task_switch() must
-	 * happen before this.
-	 *
-	 * Pairs with the smp_cond_load_acquire() in try_to_wake_up().
-	 */
-	smp_store_release(&prev->on_cpu, 0);
-#endif
 }
 
+#endif
+
 static inline void
 prepare_lock_switch(struct rq *rq, struct task_struct *next, struct rq_flags *rf)
 {
@@ -3932,6 +4591,7 @@ static inline void finish_lock_switch(struct rq *rq)
 	 * prev into current:
 	 */
 	spin_acquire(&__rq_lockp(rq)->dep_map, 0, 0, _THIS_IP_);
+   balance_switch(rq);
 	raw_spin_rq_unlock_irq(rq);
 }
 
@@ -3947,6 +4607,22 @@ static inline void finish_lock_switch(struct rq *rq)
 # define finish_arch_post_lock_switch()	do { } while (0)
 #endif
 
+static inline void kmap_local_sched_out(void)
+{
+#ifdef CONFIG_KMAP_LOCAL
+	if (unlikely(current->kmap_ctrl.idx))
+		__kmap_local_sched_out();
+#endif
+}
+
+static inline void kmap_local_sched_in(void)
+{
+#ifdef CONFIG_KMAP_LOCAL
+	if (unlikely(current->kmap_ctrl.idx))
+		__kmap_local_sched_in();
+#endif
+}
+
 /**
  * prepare_task_switch - prepare to switch tasks
  * @rq: the runqueue preparing to switch
@@ -3969,6 +4645,7 @@ prepare_task_switch(struct rq *rq, struct task_struct *prev,
 	perf_event_task_sched_out(prev, next);
 	rseq_preempt(prev);
 	fire_sched_out_preempt_notifiers(prev, next);
+	kmap_local_sched_out();
 	prepare_task(next);
 	prepare_arch_switch(next);
 }
@@ -4036,6 +4713,7 @@ static struct rq *finish_task_switch(struct task_struct *prev)
 	finish_lock_switch(rq);
 	finish_arch_post_lock_switch();
 	kcov_finish_switch(current);
+	kmap_local_sched_in();
 
 	fire_sched_in_preempt_notifiers(current);
 	/*
@@ -4050,22 +4728,18 @@ static struct rq *finish_task_switch(struct task_struct *prev)
 	 *   provided by mmdrop(),
 	 * - a sync_core for SYNC_CORE.
 	 */
+   	/*
+	 * We use mmdrop_delayed() here so we don't have to do the
+	 * full __mmdrop() when we are the last user.
+	 */
 	if (mm) {
 		membarrier_mm_sync_core_before_usermode(mm);
-		mmdrop(mm);
+		mmdrop_delayed(mm);
 	}
 	if (unlikely(prev_state == TASK_DEAD)) {
 		if (prev->sched_class->task_dead)
 			prev->sched_class->task_dead(prev);
 
-		/*
-		 * Remove function-return probe instances associated with this
-		 * task and put them back on the free list.
-		 */
-		kprobe_flush_task(prev);
-
-		/* Task is done with its stack. */
-		put_task_stack(prev);
 
 		put_task_struct_rcu_user(prev);
 	}
@@ -4073,42 +4747,6 @@ static struct rq *finish_task_switch(struct task_struct *prev)
 	return rq;
 }
 
-#ifdef CONFIG_SMP
-
-/* rq->lock is NOT held, but preemption is disabled */
-static void __balance_callback(struct rq *rq)
-{
-	struct callback_head *head, *next;
-	void (*func)(struct rq *rq);
-	unsigned long flags;
-
-	raw_spin_rq_lock_irqsave(rq, flags);
-	head = rq->balance_callback;
-	rq->balance_callback = NULL;
-	while (head) {
-		func = (void (*)(struct rq *))head->func;
-		next = head->next;
-		head->next = NULL;
-		head = next;
-
-		func(rq);
-	}
-	raw_spin_rq_unlock_irqrestore(rq, flags);
-}
-
-static inline void balance_callback(struct rq *rq)
-{
-	if (unlikely(rq->balance_callback))
-		__balance_callback(rq);
-}
-
-#else
-
-static inline void balance_callback(struct rq *rq)
-{
-}
-
-#endif
 
 /**
  * schedule_tail - first thing a freshly forked thread must call.
@@ -4129,7 +4767,6 @@ asmlinkage __visible void schedule_tail(struct task_struct *prev)
 	 */
 
 	rq = finish_task_switch(prev);
-	balance_callback(rq);
 	preempt_enable();
 
 	if (current->set_child_tid)
@@ -5286,7 +5923,7 @@ pick_next_task(struct rq *rq, struct task_struct *prev, struct rq_flags *rf)
  *
  * WARNING: must be called with preemption disabled!
  */
-static void __sched notrace __schedule(bool preempt)
+static void __sched notrace __schedule(bool preempt, bool spinning_lock)
 {
 	struct task_struct *prev, *next;
 	unsigned long *switch_count;
@@ -5339,7 +5976,7 @@ static void __sched notrace __schedule(bool preempt)
 	 *  - ptrace_{,un}freeze_traced() can change ->state underneath us.
 	 */
 	prev_state = prev->state;
-	if (!preempt && prev_state) {
+	if ((!preempt || spinning_lock) && prev_state) {
 		if (signal_pending_state(prev_state, prev)) {
 			prev->state = TASK_RUNNING;
 		} else {
@@ -5374,6 +6011,7 @@ static void __sched notrace __schedule(bool preempt)
 
 	next = pick_next_task(rq, prev, &rf);
 	clear_tsk_need_resched(prev);
+	clear_tsk_need_resched_lazy(prev);
 	clear_preempt_need_resched();
 
 	if (likely(prev != next)) {
@@ -5399,6 +6037,7 @@ static void __sched notrace __schedule(bool preempt)
 		 */
 		++*switch_count;
 
+		migrate_disable_switch(rq, prev);
 		psi_sched_switch(prev, next, !task_on_rq_queued(prev));
 
 		trace_sched_switch(preempt, prev, next);
@@ -5407,10 +6046,11 @@ static void __sched notrace __schedule(bool preempt)
 		rq = context_switch(rq, prev, next, &rf);
 	} else {
 		rq->clock_update_flags &= ~(RQCF_ACT_SKIP|RQCF_REQ_SKIP);
-		rq_unlock_irq(rq, &rf);
-	}
 
-	balance_callback(rq);
+		rq_unpin_lock(rq, &rf);
+		__balance_callbacks(rq);
+		raw_spin_unlock_irq(&rq->__lock);
+	}
 }
 
 void __noreturn do_task_dead(void)
@@ -5421,7 +6061,7 @@ void __noreturn do_task_dead(void)
 	/* Tell freezer to ignore us: */
 	current->flags |= PF_NOFREEZE;
 
-	__schedule(false);
+	__schedule(false, false);
 	BUG();
 
 	/* Avoid "noreturn function does return" - but don't continue if BUG() is a NOP: */
@@ -5454,9 +6094,6 @@ static inline void sched_submit_work(struct task_struct *tsk)
 		preempt_enable_no_resched();
 	}
 
-	if (tsk_is_pi_blocked(tsk))
-		return;
-
 	/*
 	 * If we are going to sleep and we have plugged IO queued,
 	 * make sure to submit it to avoid deadlocks.
@@ -5482,7 +6119,7 @@ asmlinkage __visible void __sched schedule(void)
 	sched_submit_work(tsk);
 	do {
 		preempt_disable();
-		__schedule(false);
+		__schedule(false, false);
 		sched_preempt_enable_no_resched();
 	} while (need_resched());
 	sched_update_worker(tsk);
@@ -5510,7 +6147,7 @@ void __sched schedule_idle(void)
 	 */
 	WARN_ON_ONCE(current->state);
 	do {
-		__schedule(false);
+		__schedule(false, false);
 	} while (need_resched());
 }
 
@@ -5563,7 +6200,7 @@ static void __sched notrace preempt_schedule_common(void)
 		 */
 		preempt_disable_notrace();
 		preempt_latency_start(1);
-		__schedule(true);
+		__schedule(true, false);
 		preempt_latency_stop(1);
 		preempt_enable_no_resched_notrace();
 
@@ -5574,6 +6211,30 @@ static void __sched notrace preempt_schedule_common(void)
 	} while (need_resched());
 }
 
+#ifdef CONFIG_PREEMPT_LAZY
+/*
+ * If TIF_NEED_RESCHED is then we allow to be scheduled away since this is
+ * set by a RT task. Oterwise we try to avoid beeing scheduled out as long as
+ * preempt_lazy_count counter >0.
+ */
+static __always_inline int preemptible_lazy(void)
+{
+	if (test_thread_flag(TIF_NEED_RESCHED))
+		return 1;
+	if (current_thread_info()->preempt_lazy_count)
+		return 0;
+	return 1;
+}
+
+#else
+
+static inline int preemptible_lazy(void)
+{
+	return 1;
+}
+
+#endif
+
 #ifdef CONFIG_PREEMPTION
 /*
  * This is the entry point to schedule() from in-kernel preemption
@@ -5588,11 +6249,26 @@ asmlinkage __visible void __sched notrace preempt_schedule(void)
 	if (likely(!preemptible()))
 		return;
 
+	if (!preemptible_lazy())
+		return;
 	preempt_schedule_common();
 }
 NOKPROBE_SYMBOL(preempt_schedule);
 EXPORT_SYMBOL(preempt_schedule);
 
+#ifdef CONFIG_PREEMPT_RT
+void __sched notrace preempt_schedule_lock(void)
+{
+	do {
+		preempt_disable();
+		__schedule(true, true);
+		sched_preempt_enable_no_resched();
+	} while (need_resched());
+}
+NOKPROBE_SYMBOL(preempt_schedule_lock);
+EXPORT_SYMBOL(preempt_schedule_lock);
+#endif
+
 #ifdef CONFIG_PREEMPT_DYNAMIC
 DEFINE_STATIC_CALL(preempt_schedule, __preempt_schedule_func);
 EXPORT_STATIC_CALL(preempt_schedule);
@@ -5620,6 +6296,9 @@ asmlinkage __visible void __sched notrace preempt_schedule_notrace(void)
 	if (likely(!preemptible()))
 		return;
 
+	if (!preemptible_lazy())
+		return;
+
 	do {
 		/*
 		 * Because the function tracer can trace preempt_count_sub()
@@ -5642,7 +6321,7 @@ asmlinkage __visible void __sched notrace preempt_schedule_notrace(void)
 		 * an infinite recursion.
 		 */
 		prev_ctx = exception_enter();
-		__schedule(true);
+		__schedule(true, false);
 		exception_exit(prev_ctx);
 
 		preempt_latency_stop(1);
@@ -5860,7 +6539,7 @@ asmlinkage __visible void __sched preempt_schedule_irq(void)
 	do {
 		preempt_disable();
 		local_irq_enable();
-		__schedule(true);
+		__schedule(true, false);
 		local_irq_disable();
 		sched_preempt_enable_no_resched();
 	} while (need_resched());
@@ -6026,9 +6705,11 @@ void rt_mutex_setprio(struct task_struct *p, struct task_struct *pi_task)
 out_unlock:
 	/* Avoid rq from going away on us: */
 	preempt_disable();
-	__task_rq_unlock(rq, &rf);
 
-	balance_callback(rq);
+	rq_unpin_lock(rq, &rf);
+	__balance_callbacks(rq);
+	raw_spin_unlock(&rq->__lock);
+
 	preempt_enable();
 }
 #else
@@ -6271,6 +6952,7 @@ static int __sched_setscheduler(struct task_struct *p,
 	int oldpolicy = -1, policy = attr->sched_policy;
 	int retval, oldprio, newprio, queued, running;
 	const struct sched_class *prev_class;
+	struct callback_head *head;
 	struct rq_flags rf;
 	int reset_on_fork;
 	int queue_flags = DEQUEUE_SAVE | DEQUEUE_MOVE | DEQUEUE_NOCLOCK;
@@ -6525,6 +7207,7 @@ static int __sched_setscheduler(struct task_struct *p,
 
 	/* Avoid rq from going away on us: */
 	preempt_disable();
+	head = splice_balance_callbacks(rq);
 	task_rq_unlock(rq, p, &rf);
 
 	if (pi) {
@@ -6533,7 +7216,7 @@ static int __sched_setscheduler(struct task_struct *p,
 	}
 
 	/* Run balance callbacks after we've adjusted the PI chain: */
-	balance_callback(rq);
+	balance_callbacks(rq, head);
 	preempt_enable();
 
 	return 0;
@@ -7028,7 +7711,7 @@ long sched_setaffinity(pid_t pid, const struct cpumask *in_mask)
 	}
 #endif
 again:
-	retval = __set_cpus_allowed_ptr(p, new_mask, true);
+	retval = __set_cpus_allowed_ptr(p, new_mask, SCA_CHECK);
 
 	if (!retval) {
 		cpuset_cpus_allowed(p, cpus_allowed);
@@ -7614,7 +8297,7 @@ void __init init_idle(struct task_struct *idle, int cpu)
 	 *
 	 * And since this is boot we can forgo the serialization.
 	 */
-	set_cpus_allowed_common(idle, cpumask_of(cpu));
+	set_cpus_allowed_common(idle, cpumask_of(cpu), 0);
 #endif
 	/*
 	 * We're having a chicken and egg problem, even though we are
@@ -7641,7 +8324,9 @@ void __init init_idle(struct task_struct *idle, int cpu)
 
 	/* Set the preempt count _outside_ the spinlocks! */
 	init_idle_preempt_count(idle, cpu);
-
+#ifdef CONFIG_HAVE_PREEMPT_LAZY
+	task_thread_info(idle)->preempt_lazy_count = 0;
+#endif
 	/*
 	 * The idle tasks have their own, simple scheduling class:
 	 */
@@ -7751,6 +8436,7 @@ void sched_setnuma(struct task_struct *p, int nid)
 #endif /* CONFIG_NUMA_BALANCING */
 
 #ifdef CONFIG_HOTPLUG_CPU
+
 /*
  * Ensure that the idle task is using init_mm right before its CPU goes
  * offline.
@@ -7770,119 +8456,126 @@ void idle_task_exit(void)
 	/* finish_cpu(), as ran on the BP, will clean up the active_mm state */
 }
 
-/*
- * Since this CPU is going 'away' for a while, fold any nr_active delta
- * we might have. Assumes we're called after migrate_tasks() so that the
- * nr_active count is stable. We need to take the teardown thread which
- * is calling this into account, so we hand in adjust = 1 to the load
- * calculation.
- *
- * Also see the comment "Global load-average calculations".
- */
-static void calc_load_migrate(struct rq *rq)
+static int __balance_push_cpu_stop(void *arg)
 {
-	long delta = calc_load_fold_active(rq, 1);
-	if (delta)
-		atomic_long_add(delta, &calc_load_tasks);
-}
+	struct task_struct *p = arg;
+	struct rq *rq = this_rq();
+	struct rq_flags rf;
+	int cpu;
 
-static struct task_struct *__pick_migrate_task(struct rq *rq)
-{
-	const struct sched_class *class;
-	struct task_struct *next;
+	raw_spin_lock_irq(&p->pi_lock);
+	rq_lock(rq, &rf);
 
-	for_each_class(class) {
-		next = class->pick_next_task(rq);
-		if (next) {
-			next->sched_class->put_prev_task(rq, next);
-			return next;
-		}
+	update_rq_clock(rq);
+
+	if (task_rq(p) == rq && task_on_rq_queued(p)) {
+		cpu = select_fallback_rq(rq->cpu, p);
+		rq = __migrate_task(rq, &rf, p, cpu);
 	}
 
-	/* The idle class should always have a runnable task */
-	BUG();
+	rq_unlock(rq, &rf);
+	raw_spin_unlock_irq(&p->pi_lock);
+
+	put_task_struct(p);
+
+	return 0;
 }
 
+static DEFINE_PER_CPU(struct cpu_stop_work, push_work);
+
 /*
- * Migrate all tasks from the rq, sleeping tasks will be migrated by
- * try_to_wake_up()->select_task_rq().
- *
- * Called with rq->lock held even though we'er in stop_machine() and
- * there's no concurrency possible, we hold the required locks anyway
- * because of lock validation efforts.
+ * Ensure we only run per-cpu kthreads once the CPU goes !active.
  */
-static void migrate_tasks(struct rq *dead_rq, struct rq_flags *rf)
+static void balance_push(struct rq *rq)
 {
-	struct rq *rq = dead_rq;
-	struct task_struct *next, *stop = rq->stop;
-	struct rq_flags orf = *rf;
-	int dest_cpu;
+	struct task_struct *push_task = rq->curr;
+
+	lockdep_assert_held(&rq->__lock);
+	SCHED_WARN_ON(rq->cpu != smp_processor_id());
 
 	/*
-	 * Fudge the rq selection such that the below task selection loop
-	 * doesn't get stuck on the currently eligible stop task.
-	 *
-	 * We're currently inside stop_machine() and the rq is either stuck
-	 * in the stop_machine_cpu_stop() loop, or we're executing this code,
-	 * either way we should never end up calling schedule() until we're
-	 * done here.
+	 * Both the cpu-hotplug and stop task are in this case and are
+	 * required to complete the hotplug process.
 	 */
-	rq->stop = NULL;
+	if (is_per_cpu_kthread(push_task) || is_migration_disabled(push_task)) {
+		/*
+		 * If this is the idle task on the outgoing CPU try to wake
+		 * up the hotplug control thread which might wait for the
+		 * last task to vanish. The rcuwait_active() check is
+		 * accurate here because the waiter is pinned on this CPU
+		 * and can't obviously be running in parallel.
+		 *
+		 * On RT kernels this also has to check whether there are
+		 * pinned and scheduled out tasks on the runqueue. They
+		 * need to leave the migrate disabled section first.
+		 */
+		if (!rq->nr_running && !rq_has_pinned_tasks(rq) &&
+		    rcuwait_active(&rq->hotplug_wait)) {
+			raw_spin_unlock(&rq->__lock);
+			rcuwait_wake_up(&rq->hotplug_wait);
+			raw_spin_lock(&rq->__lock);
+		}
+		return;
+	}
 
+	get_task_struct(push_task);
 	/*
-	 * put_prev_task() and pick_next_task() sched
-	 * class method both need to have an up-to-date
-	 * value of rq->clock[_task]
+	 * Temporarily drop rq->lock such that we can wake-up the stop task.
+	 * Both preemption and IRQs are still disabled.
 	 */
-	update_rq_clock(rq);
+	raw_spin_unlock(&rq->__lock);
+	stop_one_cpu_nowait(rq->cpu, __balance_push_cpu_stop, push_task,
+			    this_cpu_ptr(&push_work));
+	/*
+	 * At this point need_resched() is true and we'll take the loop in
+	 * schedule(). The next pick is obviously going to be the stop task
+	 * which is_per_cpu_kthread() and will push this task away.
+	 */
+	raw_spin_lock(&rq->__lock);
+}
 
-	for (;;) {
-		/*
-		 * There's this thread running, bail when that's the only
-		 * remaining thread:
-		 */
-		if (rq->nr_running == 1)
-			break;
+static void balance_push_set(int cpu, bool on)
+{
+	struct rq *rq = cpu_rq(cpu);
+	struct rq_flags rf;
 
-		next = __pick_migrate_task(rq);
+	rq_lock_irqsave(rq, &rf);
+	if (on)
+		rq->balance_flags |= BALANCE_PUSH;
+	else
+		rq->balance_flags &= ~BALANCE_PUSH;
+	rq_unlock_irqrestore(rq, &rf);
+}
 
-		/*
-		 * Rules for changing task_struct::cpus_mask are holding
-		 * both pi_lock and rq->lock, such that holding either
-		 * stabilizes the mask.
-		 *
-		 * Drop rq->lock is not quite as disastrous as it usually is
-		 * because !cpu_active at this point, which means load-balance
-		 * will not interfere. Also, stop-machine.
-		 */
-		rq_unlock(rq, rf);
-		raw_spin_lock(&next->pi_lock);
-		rq_relock(rq, rf);
+/*
+ * Invoked from a CPUs hotplug control thread after the CPU has been marked
+ * inactive. All tasks which are not per CPU kernel threads are either
+ * pushed off this CPU now via balance_push() or placed on a different CPU
+ * during wakeup. Wait until the CPU is quiescent.
+ */
+static void balance_hotplug_wait(void)
+{
+	struct rq *rq = this_rq();
 
-		/*
-		 * Since we're inside stop-machine, _nothing_ should have
-		 * changed the task, WARN if weird stuff happened, because in
-		 * that case the above rq->lock drop is a fail too.
-		 */
-		if (WARN_ON(task_rq(next) != rq || !task_on_rq_queued(next))) {
-			raw_spin_unlock(&next->pi_lock);
-			continue;
-		}
+	rcuwait_wait_event(&rq->hotplug_wait,
+			   rq->nr_running == 1 && !rq_has_pinned_tasks(rq),
+			   TASK_UNINTERRUPTIBLE);
+}
 
-		/* Find suitable destination for @next, with force if needed. */
-		dest_cpu = select_fallback_rq(dead_rq->cpu, next);
-		rq = __migrate_task(rq, rf, next, dest_cpu);
-		if (rq != dead_rq) {
-			rq_unlock(rq, rf);
-			rq = dead_rq;
-			*rf = orf;
-			rq_relock(rq, rf);
-		}
-		raw_spin_unlock(&next->pi_lock);
-	}
+#else
+
+static inline void balance_push(struct rq *rq)
+{
+}
 
-	rq->stop = stop;
+static inline void balance_push_set(int cpu, bool on)
+{
+}
+
+static inline void balance_hotplug_wait(void)
+{
 }
+
 #endif /* CONFIG_HOTPLUG_CPU */
 
 void set_rq_online(struct rq *rq)
@@ -7970,6 +8663,8 @@ int sched_cpu_activate(unsigned int cpu)
 	struct rq *rq = cpu_rq(cpu);
 	struct rq_flags rf;
 
+	balance_push_set(cpu, false);
+
 #ifdef CONFIG_SCHED_SMT
 	/*
 	 * When going up, increment the number of cores with SMT present.
@@ -8005,6 +8700,8 @@ int sched_cpu_activate(unsigned int cpu)
 
 int sched_cpu_deactivate(unsigned int cpu)
 {
+	struct rq *rq = cpu_rq(cpu);
+	struct rq_flags rf;
 	int ret;
 
 	set_cpu_active(cpu, false);
@@ -8017,6 +8714,16 @@ int sched_cpu_deactivate(unsigned int cpu)
 	 */
 	synchronize_rcu();
 
+	balance_push_set(cpu, true);
+
+	rq_lock_irqsave(rq, &rf);
+	if (rq->rd) {
+		update_rq_clock(rq);
+		BUG_ON(!cpumask_test_cpu(cpu, rq->rd->span));
+		set_rq_offline(rq);
+	}
+	rq_unlock_irqrestore(rq, &rf);
+
 #ifdef CONFIG_SCHED_SMT
 	/*
 	 * When going down, decrement the number of cores with SMT present.
@@ -8032,6 +8739,7 @@ int sched_cpu_deactivate(unsigned int cpu)
 
 	ret = cpuset_cpu_inactive(cpu);
 	if (ret) {
+		balance_push_set(cpu, false);
 		set_cpu_active(cpu, true);
 		return ret;
 	}
@@ -8056,6 +8764,41 @@ int sched_cpu_starting(unsigned int cpu)
 }
 
 #ifdef CONFIG_HOTPLUG_CPU
+
+/*
+ * Invoked immediately before the stopper thread is invoked to bring the
+ * CPU down completely. At this point all per CPU kthreads except the
+ * hotplug thread (current) and the stopper thread (inactive) have been
+ * either parked or have been unbound from the outgoing CPU. Ensure that
+ * any of those which might be on the way out are gone.
+ *
+ * If after this point a bound task is being woken on this CPU then the
+ * responsible hotplug callback has failed to do it's job.
+ * sched_cpu_dying() will catch it with the appropriate fireworks.
+ */
+int sched_cpu_wait_empty(unsigned int cpu)
+{
+	balance_hotplug_wait();
+	return 0;
+}
+
+/*
+ * Since this CPU is going 'away' for a while, fold any nr_active delta we
+ * might have. Called from the CPU stopper task after ensuring that the
+ * stopper is the last running task on the CPU, so nr_active count is
+ * stable. We need to take the teardown thread which is calling this into
+ * account, so we hand in adjust = 1 to the load calculation.
+ *
+ * Also see the comment "Global load-average calculations".
+ */
+static void calc_load_migrate(struct rq *rq)
+{
+	long delta = calc_load_fold_active(rq, 1);
+
+	if (delta)
+		atomic_long_add(delta, &calc_load_tasks);
+}
+
 int sched_cpu_dying(unsigned int cpu)
 {
 	struct rq *rq = cpu_rq(cpu);
@@ -8065,12 +8808,7 @@ int sched_cpu_dying(unsigned int cpu)
 	sched_tick_stop(cpu);
 
 	rq_lock_irqsave(rq, &rf);
-	if (rq->rd) {
-		BUG_ON(!cpumask_test_cpu(cpu, rq->rd->span));
-		set_rq_offline(rq);
-	}
-	migrate_tasks(rq, &rf);
-	BUG_ON(rq->nr_running != 1);
+	BUG_ON(rq->nr_running != 1 || rq_has_pinned_tasks(rq));
 	rq_unlock_irqrestore(rq, &rf);
 
 	calc_load_migrate(rq);
@@ -8281,6 +9019,9 @@ void __init sched_init(void)
 
 		INIT_CSD(&rq->nohz_csd, nohz_csd_func, rq);
 #endif
+#ifdef CONFIG_HOTPLUG_CPU
+		rcuwait_init(&rq->hotplug_wait);
+#endif
 #endif /* CONFIG_SMP */
 		hrtick_rq_init(rq);
 		atomic_set(&rq->nr_iowait, 0);
@@ -8331,7 +9072,7 @@ void __init sched_init(void)
 #ifdef CONFIG_DEBUG_ATOMIC_SLEEP
 static inline int preempt_count_equals(int preempt_offset)
 {
-	int nested = preempt_count() + rcu_preempt_depth();
+	int nested = preempt_count() + sched_rcu_preempt_depth();
 
 	return (nested == preempt_offset);
 }
@@ -8428,6 +9169,39 @@ void __cant_sleep(const char *file, int line, int preempt_offset)
 	add_taint(TAINT_WARN, LOCKDEP_STILL_OK);
 }
 EXPORT_SYMBOL_GPL(__cant_sleep);
+
+#ifdef CONFIG_SMP
+void __cant_migrate(const char *file, int line)
+{
+	static unsigned long prev_jiffy;
+
+	if (irqs_disabled())
+		return;
+
+	if (is_migration_disabled(current))
+		return;
+
+	if (!IS_ENABLED(CONFIG_PREEMPT_COUNT))
+		return;
+
+	if (preempt_count() > 0)
+		return;
+
+	if (time_before(jiffies, prev_jiffy + HZ) && prev_jiffy)
+		return;
+	prev_jiffy = jiffies;
+
+	pr_err("BUG: assuming non migratable context at %s:%d\n", file, line);
+	pr_err("in_atomic(): %d, irqs_disabled(): %d, migration_disabled() %u pid: %d, name: %s\n",
+	       in_atomic(), irqs_disabled(), is_migration_disabled(current),
+	       current->pid, current->comm);
+
+	debug_show_held_locks(current);
+	dump_stack();
+	add_taint(TAINT_WARN, LOCKDEP_STILL_OK);
+}
+EXPORT_SYMBOL_GPL(__cant_migrate);
+#endif
 #endif
 
 #ifdef CONFIG_MAGIC_SYSRQ
diff --git a/kernel/sched/cpudeadline.c b/kernel/sched/cpudeadline.c
index 8cb06c8c7eb1..ceb03d76c0cc 100644
--- a/kernel/sched/cpudeadline.c
+++ b/kernel/sched/cpudeadline.c
@@ -120,7 +120,7 @@ int cpudl_find(struct cpudl *cp, struct task_struct *p,
 	const struct sched_dl_entity *dl_se = &p->dl;
 
 	if (later_mask &&
-	    cpumask_and(later_mask, cp->free_cpus, p->cpus_ptr)) {
+	    cpumask_and(later_mask, cp->free_cpus, &p->cpus_mask)) {
 		unsigned long cap, max_cap = 0;
 		int cpu, max_cpu = -1;
 
@@ -151,7 +151,7 @@ int cpudl_find(struct cpudl *cp, struct task_struct *p,
 
 		WARN_ON(best_cpu != -1 && !cpu_present(best_cpu));
 
-		if (cpumask_test_cpu(best_cpu, p->cpus_ptr) &&
+		if (cpumask_test_cpu(best_cpu, &p->cpus_mask) &&
 		    dl_time_before(dl_se->deadline, cp->elements[0].dl)) {
 			if (later_mask)
 				cpumask_set_cpu(best_cpu, later_mask);
diff --git a/kernel/sched/cpupri.c b/kernel/sched/cpupri.c
index 0033731a0797..11c4df2010de 100644
--- a/kernel/sched/cpupri.c
+++ b/kernel/sched/cpupri.c
@@ -73,11 +73,11 @@ static inline int __cpupri_find(struct cpupri *cp, struct task_struct *p,
 	if (skip)
 		return 0;
 
-	if (cpumask_any_and(p->cpus_ptr, vec->mask) >= nr_cpu_ids)
+	if (cpumask_any_and(&p->cpus_mask, vec->mask) >= nr_cpu_ids)
 		return 0;
 
 	if (lowest_mask) {
-		cpumask_and(lowest_mask, p->cpus_ptr, vec->mask);
+		cpumask_and(lowest_mask, &p->cpus_mask, vec->mask);
 
 		/*
 		 * We have to ensure that we have at least one bit
diff --git a/kernel/sched/cputime.c b/kernel/sched/cputime.c
index ca0eef7d3852..02a5aa60fe7e 100644
--- a/kernel/sched/cputime.c
+++ b/kernel/sched/cputime.c
@@ -44,12 +44,13 @@ static void irqtime_account_delta(struct irqtime *irqtime, u64 delta,
 }
 
 /*
- * Called before incrementing preempt_count on {soft,}irq_enter
+ * Called after incrementing preempt_count on {soft,}irq_enter
  * and before decrementing preempt_count on {soft,}irq_exit.
  */
-void irqtime_account_irq(struct task_struct *curr)
+void irqtime_account_irq(struct task_struct *curr, unsigned int offset)
 {
 	struct irqtime *irqtime = this_cpu_ptr(&cpu_irqtime);
+	unsigned int pc;
 	s64 delta;
 	int cpu;
 
@@ -59,6 +60,7 @@ void irqtime_account_irq(struct task_struct *curr)
 	cpu = smp_processor_id();
 	delta = sched_clock_cpu(cpu) - irqtime->irq_start_time;
 	irqtime->irq_start_time += delta;
+	pc = irq_count() - offset;
 
 	/*
 	 * We do not account for softirq time from ksoftirqd here.
@@ -66,12 +68,11 @@ void irqtime_account_irq(struct task_struct *curr)
 	 * in that case, so as not to confuse scheduler with a special task
 	 * that do not consume any time, but still wants to run.
 	 */
-	if (hardirq_count())
+	if (pc & HARDIRQ_MASK)
 		irqtime_account_delta(irqtime, delta, CPUTIME_IRQ);
-	else if (in_serving_softirq() && curr != this_cpu_ksoftirqd())
+	else if ((pc & SOFTIRQ_OFFSET) && curr != this_cpu_ksoftirqd())
 		irqtime_account_delta(irqtime, delta, CPUTIME_SOFTIRQ);
 }
-EXPORT_SYMBOL_GPL(irqtime_account_irq);
 
 static u64 irqtime_tick_accounted(u64 maxtime)
 {
@@ -418,24 +419,21 @@ void vtime_task_switch(struct task_struct *prev)
 }
 # endif
 
-/*
- * Archs that account the whole time spent in the idle task
- * (outside irq) as idle time can rely on this and just implement
- * vtime_account_kernel() and vtime_account_idle(). Archs that
- * have other meaning of the idle time (s390 only includes the
- * time spent by the CPU when it's in low power mode) must override
- * vtime_account().
- */
-#ifndef __ARCH_HAS_VTIME_ACCOUNT
-void vtime_account_irq_enter(struct task_struct *tsk)
+void vtime_account_irq(struct task_struct *tsk, unsigned int offset)
 {
-	if (!in_interrupt() && is_idle_task(tsk))
+	unsigned int pc = irq_count() - offset;
+
+	if (pc & HARDIRQ_OFFSET) {
+		vtime_account_hardirq(tsk);
+	} else if (pc & SOFTIRQ_OFFSET) {
+		vtime_account_softirq(tsk);
+	} else if (!IS_ENABLED(CONFIG_HAVE_VIRT_CPU_ACCOUNTING_IDLE) &&
+		   is_idle_task(tsk)) {
 		vtime_account_idle(tsk);
-	else
+	} else {
 		vtime_account_kernel(tsk);
+	}
 }
-EXPORT_SYMBOL_GPL(vtime_account_irq_enter);
-#endif /* __ARCH_HAS_VTIME_ACCOUNT */
 
 void cputime_adjust(struct task_cputime *curr, struct prev_cputime *prev,
 		    u64 *ut, u64 *st)
diff --git a/kernel/sched/deadline.c b/kernel/sched/deadline.c
index c4c0d760d252..14252d5be166 100644
--- a/kernel/sched/deadline.c
+++ b/kernel/sched/deadline.c
@@ -551,7 +551,7 @@ static int push_dl_task(struct rq *rq);
 
 static inline bool need_pull_dl_task(struct rq *rq, struct task_struct *prev)
 {
-	return dl_task(prev);
+	return rq->online && dl_task(prev);
 }
 
 static DEFINE_PER_CPU(struct callback_head, dl_push_head);
@@ -1913,7 +1913,7 @@ static void task_fork_dl(struct task_struct *p)
 static int pick_dl_task(struct rq *rq, struct task_struct *p, int cpu)
 {
 	if (!task_running(rq, p) &&
-	    cpumask_test_cpu(cpu, p->cpus_ptr))
+	    cpumask_test_cpu(cpu, &p->cpus_mask))
 		return 1;
 	return 0;
 }
@@ -2003,8 +2003,8 @@ static int find_later_rq(struct task_struct *task)
 				return this_cpu;
 			}
 
-			best_cpu = cpumask_first_and(later_mask,
-							sched_domain_span(sd));
+			best_cpu = cpumask_any_and_distribute(later_mask,
+							      sched_domain_span(sd));
 			/*
 			 * Last chance: if a CPU being in both later_mask
 			 * and current sd span is valid, that becomes our
@@ -2026,7 +2026,7 @@ static int find_later_rq(struct task_struct *task)
 	if (this_cpu != -1)
 		return this_cpu;
 
-	cpu = cpumask_any(later_mask);
+	cpu = cpumask_any_distribute(later_mask);
 	if (cpu < nr_cpu_ids)
 		return cpu;
 
@@ -2091,7 +2091,7 @@ static struct rq *find_lock_later_rq(struct task_struct *task, struct rq *rq)
 			 */
 			next_task = pick_next_pushable_dl_task(rq);
 			if (unlikely(next_task != task ||
-						!cpumask_test_cpu(later_rq->cpu, task->cpus_ptr))) {
+						!cpumask_test_cpu(later_rq->cpu, &task->cpus_mask))) {
 				double_unlock_balance(rq, later_rq);
 				later_rq = NULL;
 				break;
@@ -2135,6 +2135,9 @@ static int push_dl_task(struct rq *rq)
 		return 0;
 
 retry:
+	if (is_migration_disabled(next_task))
+		return 0;
+
 	if (WARN_ON(next_task == rq->curr))
 		return 0;
 
@@ -2212,7 +2215,7 @@ static void push_dl_tasks(struct rq *rq)
 static void pull_dl_task(struct rq *this_rq)
 {
 	int this_cpu = this_rq->cpu, cpu;
-	struct task_struct *p;
+	struct task_struct *p, *push_task;
 	bool resched = false;
 	struct rq *src_rq;
 	u64 dmin = LONG_MAX;
@@ -2242,6 +2245,7 @@ static void pull_dl_task(struct rq *this_rq)
 			continue;
 
 		/* Might drop this_rq->lock */
+		push_task = NULL;
 		double_lock_balance(this_rq, src_rq);
 
 		/*
@@ -2273,17 +2277,28 @@ static void pull_dl_task(struct rq *this_rq)
 					   src_rq->curr->dl.deadline))
 				goto skip;
 
-			resched = true;
-
-			deactivate_task(src_rq, p, 0);
-			set_task_cpu(p, this_cpu);
-			activate_task(this_rq, p, 0);
-			dmin = p->dl.deadline;
+			if (is_migration_disabled(p)) {
+				trace_sched_migrate_pull_tp(p);
+				push_task = get_push_task(src_rq);
+			} else {
+				deactivate_task(src_rq, p, 0);
+				set_task_cpu(p, this_cpu);
+				activate_task(this_rq, p, 0);
+				dmin = p->dl.deadline;
+				resched = true;
+			}
 
 			/* Is there any other task even earlier? */
 		}
 skip:
 		double_unlock_balance(this_rq, src_rq);
+
+		if (push_task) {
+			raw_spin_unlock(&this_rq->__lock);
+			stop_one_cpu_nowait(src_rq->cpu, push_cpu_stop,
+					    push_task, &src_rq->push_work);
+			raw_spin_lock(&this_rq->__lock);
+		}
 	}
 
 	if (resched)
@@ -2307,7 +2322,8 @@ static void task_woken_dl(struct rq *rq, struct task_struct *p)
 }
 
 static void set_cpus_allowed_dl(struct task_struct *p,
-				const struct cpumask *new_mask)
+				const struct cpumask *new_mask,
+				u32 flags)
 {
 	struct root_domain *src_rd;
 	struct rq *rq;
@@ -2336,7 +2352,7 @@ static void set_cpus_allowed_dl(struct task_struct *p,
 		raw_spin_unlock(&src_dl_b->lock);
 	}
 
-	set_cpus_allowed_common(p, new_mask);
+	set_cpus_allowed_common(p, new_mask, flags);
 }
 
 /* Assumes rq->lock is held */
@@ -2532,6 +2548,7 @@ const struct sched_class dl_sched_class
 	.rq_online              = rq_online_dl,
 	.rq_offline             = rq_offline_dl,
 	.task_woken		= task_woken_dl,
+	.find_lock_rq		= find_lock_later_rq,
 #endif
 
 	.task_tick		= task_tick_dl,
diff --git a/kernel/sched/fair.c b/kernel/sched/fair.c
index 654e964b5c31..7c4f89d3013d 100644
--- a/kernel/sched/fair.c
+++ b/kernel/sched/fair.c
@@ -4460,7 +4460,7 @@ check_preempt_tick(struct cfs_rq *cfs_rq, struct sched_entity *curr)
 #endif
 
 	if (delta_exec > ideal_runtime) {
-		resched_curr(rq_of(cfs_rq));
+		resched_curr_lazy(rq_of(cfs_rq));
 		/*
 		 * The current task ran long enough, ensure it doesn't get
 		 * re-elected due to buddy favours.
@@ -4484,7 +4484,7 @@ check_preempt_tick(struct cfs_rq *cfs_rq, struct sched_entity *curr)
 		return;
 
 	if (delta > ideal_runtime)
-		resched_curr(rq_of(cfs_rq));
+		resched_curr_lazy(rq_of(cfs_rq));
 }
 
 static void
@@ -4627,7 +4627,7 @@ entity_tick(struct cfs_rq *cfs_rq, struct sched_entity *curr, int queued)
 	 * validating it and just reschedule.
 	 */
 	if (queued) {
-		resched_curr(rq_of(cfs_rq));
+		resched_curr_lazy(rq_of(cfs_rq));
 		return;
 	}
 	/*
@@ -4776,7 +4776,7 @@ static void __account_cfs_rq_runtime(struct cfs_rq *cfs_rq, u64 delta_exec)
 	 * hierarchy can be throttled
 	 */
 	if (!assign_cfs_rq_runtime(cfs_rq) && likely(cfs_rq->curr))
-		resched_curr(rq_of(cfs_rq));
+		resched_curr_lazy(rq_of(cfs_rq));
 }
 
 static __always_inline
@@ -5528,7 +5528,7 @@ static void hrtick_start_fair(struct rq *rq, struct task_struct *p)
 
 		if (delta < 0) {
 			if (rq->curr == p)
-				resched_curr(rq);
+				resched_curr_lazy(rq);
 			return;
 		}
 		hrtick_start(rq, delta);
@@ -7252,7 +7252,7 @@ static void check_preempt_wakeup(struct rq *rq, struct task_struct *p, int wake_
 	return;
 
 preempt:
-	resched_curr(rq);
+	resched_curr_lazy(rq);
 	/*
 	 * Only set the backward buddy when the current task is still
 	 * on the rq. This can happen when a wakeup gets interleaved
@@ -11904,7 +11904,7 @@ static void task_fork_fair(struct task_struct *p)
 		 * 'current' within the tree based on its new key value.
 		 */
 		swap(curr->vruntime, se->vruntime);
-		resched_curr(rq);
+		resched_curr_lazy(rq);
 	}
 
 	se->vruntime -= cfs_rq->min_vruntime;
@@ -11931,7 +11931,7 @@ prio_changed_fair(struct rq *rq, struct task_struct *p, int oldprio)
 	 */
 	if (rq->curr == p) {
 		if (p->prio > oldprio)
-			resched_curr(rq);
+			resched_curr_lazy(rq);
 	} else
 		check_preempt_curr(rq, p, 0);
 }
diff --git a/kernel/sched/features.h b/kernel/sched/features.h
index fef48f5be2fa..f8a556887472 100644
--- a/kernel/sched/features.h
+++ b/kernel/sched/features.h
@@ -45,11 +45,19 @@ SCHED_FEAT(DOUBLE_TICK, false)
  */
 SCHED_FEAT(NONTASK_CAPACITY, true)
 
+#ifdef CONFIG_PREEMPT_RT
+SCHED_FEAT(TTWU_QUEUE, false)
+# ifdef CONFIG_PREEMPT_LAZY
+SCHED_FEAT(PREEMPT_LAZY, true)
+# endif
+#else
+
 /*
  * Queue remote wakeups on the target CPU and process them
  * using the scheduler IPI. Reduces rq->lock contention/bounces.
  */
 SCHED_FEAT(TTWU_QUEUE, true)
+#endif
 
 /*
  * When doing wakeups, attempt to limit superfluous scans of the LLC domain.
diff --git a/kernel/sched/rt.c b/kernel/sched/rt.c
index 0f349d8d076d..c0ae7ff2b4ee 100644
--- a/kernel/sched/rt.c
+++ b/kernel/sched/rt.c
@@ -270,7 +270,7 @@ static void pull_rt_task(struct rq *this_rq);
 static inline bool need_pull_rt_task(struct rq *rq, struct task_struct *prev)
 {
 	/* Try to pull RT tasks here if we lower this rq's prio */
-	return rq->rt.highest_prio.curr > prev->prio;
+	return rq->online && rq->rt.highest_prio.curr > prev->prio;
 }
 
 static inline int rt_overloaded(struct rq *rq)
@@ -1679,7 +1679,7 @@ static void put_prev_task_rt(struct rq *rq, struct task_struct *p)
 static int pick_rt_task(struct rq *rq, struct task_struct *p, int cpu)
 {
 	if (!task_running(rq, p) &&
-	    cpumask_test_cpu(cpu, p->cpus_ptr))
+	    cpumask_test_cpu(cpu, &p->cpus_mask))
 		return 1;
 
 	return 0;
@@ -1773,8 +1773,8 @@ static int find_lowest_rq(struct task_struct *task)
 				return this_cpu;
 			}
 
-			best_cpu = cpumask_first_and(lowest_mask,
-						     sched_domain_span(sd));
+			best_cpu = cpumask_any_and_distribute(lowest_mask,
+							      sched_domain_span(sd));
 			if (best_cpu < nr_cpu_ids) {
 				rcu_read_unlock();
 				return best_cpu;
@@ -1791,7 +1791,7 @@ static int find_lowest_rq(struct task_struct *task)
 	if (this_cpu != -1)
 		return this_cpu;
 
-	cpu = cpumask_any(lowest_mask);
+	cpu = cpumask_any_distribute(lowest_mask);
 	if (cpu < nr_cpu_ids)
 		return cpu;
 
@@ -1852,7 +1852,7 @@ static struct rq *find_lock_lowest_rq(struct task_struct *task, struct rq *rq)
 			 */
 			struct task_struct *next_task = pick_next_pushable_task(rq);
 			if (unlikely(next_task != task ||
-				     !cpumask_test_cpu(lowest_rq->cpu, task->cpus_ptr))) {
+				     !cpumask_test_cpu(lowest_rq->cpu, &task->cpus_mask))) {
 				double_unlock_balance(rq, lowest_rq);
 				lowest_rq = NULL;
 				break;
@@ -1876,7 +1876,7 @@ static struct rq *find_lock_lowest_rq(struct task_struct *task, struct rq *rq)
  * running task can migrate over to a CPU that is running a task
  * of lesser priority.
  */
-static int push_rt_task(struct rq *rq)
+static int push_rt_task(struct rq *rq, bool pull)
 {
 	struct task_struct *next_task;
 	struct rq *lowest_rq;
@@ -1890,6 +1890,39 @@ static int push_rt_task(struct rq *rq)
 		return 0;
 
 retry:
+	if (is_migration_disabled(next_task)) {
+		struct task_struct *push_task = NULL;
+		int cpu;
+
+		if (!pull)
+			return 0;
+
+		trace_sched_migrate_pull_tp(next_task);
+
+		if (rq->push_busy)
+			return 0;
+
+		cpu = find_lowest_rq(rq->curr);
+		if (cpu == -1 || cpu == rq->cpu)
+			return 0;
+
+		/*
+		 * Given we found a CPU with lower priority than @next_task,
+		 * therefore it should be running. However we cannot migrate it
+		 * to this other CPU, instead attempt to push the current
+		 * running task on this CPU away.
+		 */
+		push_task = get_push_task(rq);
+		if (push_task) {
+			raw_spin_unlock(&rq->__lock);
+			stop_one_cpu_nowait(rq->cpu, push_cpu_stop,
+					    push_task, &rq->push_work);
+			raw_spin_lock(&rq->__lock);
+		}
+
+		return 0;
+	}
+
 	if (WARN_ON(next_task == rq->curr))
 		return 0;
 
@@ -1944,12 +1977,10 @@ static int push_rt_task(struct rq *rq)
 	deactivate_task(rq, next_task, 0);
 	set_task_cpu(next_task, lowest_rq->cpu);
 	activate_task(lowest_rq, next_task, 0);
-	ret = 1;
-
 	resched_curr(lowest_rq);
+	ret = 1;
 
 	double_unlock_balance(rq, lowest_rq);
-
 out:
 	put_task_struct(next_task);
 
@@ -1959,7 +1990,7 @@ static int push_rt_task(struct rq *rq)
 static void push_rt_tasks(struct rq *rq)
 {
 	/* push_rt_task will return true if it moved an RT */
-	while (push_rt_task(rq))
+	while (push_rt_task(rq, false))
 		;
 }
 
@@ -2112,7 +2143,8 @@ void rto_push_irq_work_func(struct irq_work *work)
 	 */
 	if (has_pushable_tasks(rq)) {
 		raw_spin_rq_lock(rq);
-		push_rt_tasks(rq);
+		while (push_rt_task(rq, true))
+			;
 		raw_spin_rq_unlock(rq);
 	}
 
@@ -2137,7 +2169,7 @@ static void pull_rt_task(struct rq *this_rq)
 {
 	int this_cpu = this_rq->cpu, cpu;
 	bool resched = false;
-	struct task_struct *p;
+	struct task_struct *p, *push_task;
 	struct rq *src_rq;
 	int rt_overload_count = rt_overloaded(this_rq);
 
@@ -2184,6 +2216,7 @@ static void pull_rt_task(struct rq *this_rq)
 		 * double_lock_balance, and another CPU could
 		 * alter this_rq
 		 */
+		push_task = NULL;
 		double_lock_balance(this_rq, src_rq);
 
 		/*
@@ -2211,11 +2244,15 @@ static void pull_rt_task(struct rq *this_rq)
 			if (p->prio < src_rq->curr->prio)
 				goto skip;
 
-			resched = true;
-
-			deactivate_task(src_rq, p, 0);
-			set_task_cpu(p, this_cpu);
-			activate_task(this_rq, p, 0);
+			if (is_migration_disabled(p)) {
+				trace_sched_migrate_pull_tp(p);
+				push_task = get_push_task(src_rq);
+			} else {
+				deactivate_task(src_rq, p, 0);
+				set_task_cpu(p, this_cpu);
+				activate_task(this_rq, p, 0);
+				resched = true;
+			}
 			/*
 			 * We continue with the search, just in
 			 * case there's an even higher prio task
@@ -2225,6 +2262,13 @@ static void pull_rt_task(struct rq *this_rq)
 		}
 skip:
 		double_unlock_balance(this_rq, src_rq);
+
+		if (push_task) {
+			raw_spin_unlock(&this_rq->__lock);
+			stop_one_cpu_nowait(src_rq->cpu, push_cpu_stop,
+					    push_task, &src_rq->push_work);
+			raw_spin_lock(&this_rq->__lock);
+		}
 	}
 
 	if (resched)
@@ -2474,6 +2518,7 @@ const struct sched_class rt_sched_class
 	.rq_offline             = rq_offline_rt,
 	.task_woken		= task_woken_rt,
 	.switched_from		= switched_from_rt,
+	.find_lock_rq		= find_lock_lowest_rq,
 #endif
 
 	.task_tick		= task_tick_rt,
diff --git a/kernel/sched/sched.h b/kernel/sched/sched.h
index 0ab8e2532f2d..df54480b48b2 100644
--- a/kernel/sched/sched.h
+++ b/kernel/sched/sched.h
@@ -1032,6 +1032,7 @@ struct rq {
 	unsigned long		cpu_capacity_orig;
 
 	struct callback_head	*balance_callback;
+	unsigned char		balance_flags;
 
 	unsigned char		nohz_idle_balance;
 	unsigned char		idle_balance;
@@ -1062,6 +1063,10 @@ struct rq {
 
 	/* This is used to determine avg_idle's max value */
 	u64			max_idle_balance_cost;
+
+#ifdef CONFIG_HOTPLUG_CPU
+	struct rcuwait		hotplug_wait;
+#endif
 #endif /* CONFIG_SMP */
 
 #ifdef CONFIG_IRQ_TIME_ACCOUNTING
@@ -1135,7 +1140,11 @@ struct rq {
 	unsigned char		core_forceidle;
 	unsigned int		core_forceidle_seq;
 #endif
-
+#ifdef CONFIG_SMP
+	unsigned int		nr_pinned;
+#endif
+	unsigned int		push_busy;
+	struct cpu_stop_work	push_work;
 	KABI_RESERVE(1)
 	KABI_RESERVE(2)
 	KABI_RESERVE(3)
@@ -1171,6 +1180,17 @@ static inline int cpu_of(struct rq *rq)
 #endif
 }
 
+#define MDF_PUSH       0x01
+
+static inline bool is_migration_disabled(struct task_struct *p)
+{
+#ifdef CONFIG_SMP
+       return p->migration_disabled;
+#else
+       return false;
+#endif
+}
+
 #ifdef CONFIG_QOS_SCHED
 enum task_qos_level {
 	QOS_LEVEL_OFFLINE = -1,
@@ -1545,6 +1565,12 @@ struct rq_flags {
 	 */
 	unsigned int clock_update_flags;
 #endif
+
+#ifdef CONFIG_SMP
+	unsigned int		nr_pinned;
+#endif
+	unsigned int		push_busy;
+	struct cpu_stop_work	push_work;
 };
 
 /*
@@ -1565,6 +1591,9 @@ static inline void rq_pin_lock(struct rq *rq, struct rq_flags *rf)
 	rq->clock_update_flags &= (RQCF_REQ_SKIP|RQCF_ACT_SKIP);
 	rf->clock_update_flags = 0;
 #endif
+#ifdef CONFIG_SMP
+	SCHED_WARN_ON(rq->balance_callback);
+#endif
 }
 
 static inline void rq_unpin_lock(struct rq *rq, struct rq_flags *rf)
@@ -1730,6 +1759,9 @@ init_numa_balancing(unsigned long clone_flags, struct task_struct *p)
 
 #ifdef CONFIG_SMP
 
+#define BALANCE_WORK	0x01
+#define BALANCE_PUSH	0x02
+
 static inline void
 queue_balance_callback(struct rq *rq,
 		       struct callback_head *head,
@@ -1737,12 +1769,12 @@ queue_balance_callback(struct rq *rq,
 {
 	lockdep_assert_rq_held(rq);
 
-	if (unlikely(head->next))
+	if (unlikely(head->next || (rq->balance_flags & BALANCE_PUSH)))
 		return;
 
 	head->func = (void (*)(struct callback_head *))func;
 	head->next = rq->balance_callback;
-	rq->balance_callback = head;
+	rq->balance_flags |= BALANCE_WORK;
 }
 
 #define rcu_dereference_check_sched_domain(p) \
@@ -2067,6 +2099,7 @@ static inline int task_on_rq_migrating(struct task_struct *p)
 #define WF_FORK			0x02		/* Child wakeup after fork */
 #define WF_MIGRATED		0x04		/* Internal use, task got migrated */
 #define WF_ON_CPU		0x08		/* Wakee is on_cpu */
+#define WF_LOCK_SLEEPER		0x10		/* Wakeup spinlock "sleeper" */
 
 /*
  * To aid in avoiding the subversion of "niceness" due to uneven distribution
@@ -2148,10 +2181,13 @@ struct sched_class {
 	void (*task_woken)(struct rq *this_rq, struct task_struct *task);
 
 	void (*set_cpus_allowed)(struct task_struct *p,
-				 const struct cpumask *newmask);
+				 const struct cpumask *newmask,
+				 u32 flags);
 
 	void (*rq_online)(struct rq *rq);
 	void (*rq_offline)(struct rq *rq);
+
+	struct rq *(*find_lock_rq)(struct task_struct *p, struct rq *rq);
 #endif
 
 	void (*task_tick)(struct rq *rq, struct task_struct *p, int queued);
@@ -2241,13 +2277,38 @@ static inline bool sched_fair_runnable(struct rq *rq)
 extern struct task_struct *pick_next_task_fair(struct rq *rq, struct task_struct *prev, struct rq_flags *rf);
 extern struct task_struct *pick_next_task_idle(struct rq *rq);
 
+#define SCA_CHECK		0x01
+#define SCA_MIGRATE_DISABLE	0x02
+#define SCA_MIGRATE_ENABLE	0x04
+
 #ifdef CONFIG_SMP
 
 extern void update_group_capacity(struct sched_domain *sd, int cpu);
 
 extern void trigger_load_balance(struct rq *rq);
 
-extern void set_cpus_allowed_common(struct task_struct *p, const struct cpumask *new_mask);
+extern void set_cpus_allowed_common(struct task_struct *p, const struct cpumask *new_mask, u32 flags);
+
+static inline struct task_struct *get_push_task(struct rq *rq)
+{
+	struct task_struct *p = rq->curr;
+
+	lockdep_assert_held(&rq->__lock);
+
+	if (rq->push_busy)
+		return NULL;
+
+	if (p->nr_cpus_allowed == 1)
+		return NULL;
+
+	if (p->migration_disabled)
+		return NULL;
+
+	rq->push_busy = true;
+	return get_task_struct(p);
+}
+
+extern int push_cpu_stop(void *arg);
 
 #endif
 
@@ -2291,6 +2352,15 @@ extern void reweight_task(struct task_struct *p, int prio);
 extern void resched_curr(struct rq *rq);
 extern void resched_cpu(int cpu);
 
+#ifdef CONFIG_PREEMPT_LAZY
+extern void resched_curr_lazy(struct rq *rq);
+#else
+static inline void resched_curr_lazy(struct rq *rq)
+{
+	resched_curr(rq);
+}
+#endif
+
 extern struct rt_bandwidth def_rt_bandwidth;
 extern void init_rt_bandwidth(struct rt_bandwidth *rt_b, u64 period, u64 runtime);
 
@@ -2674,7 +2744,6 @@ extern void nohz_balance_exit_idle(struct rq *rq);
 static inline void nohz_balance_exit_idle(struct rq *rq) { }
 #endif
 
-
 #ifdef CONFIG_SMP
 static inline
 void __dl_update(struct dl_bw *dl_b, s64 bw)
diff --git a/kernel/sched/swait.c b/kernel/sched/swait.c
index e1c655f928c7..f230b1ac7f91 100644
--- a/kernel/sched/swait.c
+++ b/kernel/sched/swait.c
@@ -64,6 +64,7 @@ void swake_up_all(struct swait_queue_head *q)
 	struct swait_queue *curr;
 	LIST_HEAD(tmp);
 
+	WARN_ON(irqs_disabled());
 	raw_spin_lock_irq(&q->lock);
 	list_splice_init(&q->task_list, &tmp);
 	while (!list_empty(&tmp)) {
diff --git a/kernel/sched/topology.c b/kernel/sched/topology.c
index 2678e7590cfc..0c94b0e41ce7 100644
--- a/kernel/sched/topology.c
+++ b/kernel/sched/topology.c
@@ -529,6 +529,7 @@ static int init_rootdomain(struct root_domain *rd)
 	rd->rto_cpu = -1;
 	raw_spin_lock_init(&rd->rto_lock);
 	init_irq_work(&rd->rto_push_work, rto_push_irq_work_func);
+	atomic_or(IRQ_WORK_HARD_IRQ, &rd->rto_push_work.node.a_flags);
 #endif
 
 	init_dl_bw(&rd->dl_bw);
diff --git a/kernel/signal.c b/kernel/signal.c
index d874c96315a6..2b8ba0d38444 100644
--- a/kernel/signal.c
+++ b/kernel/signal.c
@@ -20,6 +20,7 @@
 #include <linux/sched/task.h>
 #include <linux/sched/task_stack.h>
 #include <linux/sched/cputime.h>
+#include <linux/sched/rt.h>
 #include <linux/file.h>
 #include <linux/fs.h>
 #include <linux/proc_fs.h>
@@ -406,13 +407,30 @@ void task_join_group_stop(struct task_struct *task)
 	task_set_jobctl_pending(task, mask | JOBCTL_STOP_PENDING);
 }
 
+static inline struct sigqueue *get_task_cache(struct task_struct *t)
+{
+	struct sigqueue *q = t->sigqueue_cache;
+
+	if (cmpxchg(&t->sigqueue_cache, q, NULL) != q)
+		return NULL;
+	return q;
+}
+
+static inline int put_task_cache(struct task_struct *t, struct sigqueue *q)
+{
+	if (cmpxchg(&t->sigqueue_cache, NULL, q) == NULL)
+		return 0;
+	return 1;
+}
+
 /*
  * allocate a new signal queue record
  * - this may be called without locks if and only if t == current, otherwise an
  *   appropriate lock must be held to stop the target task from exiting
  */
 static struct sigqueue *
-__sigqueue_alloc(int sig, struct task_struct *t, gfp_t flags, int override_rlimit)
+__sigqueue_do_alloc(int sig, struct task_struct *t, gfp_t flags,
+		    int override_rlimit, int fromslab)
 {
 	struct sigqueue *q = NULL;
 	struct user_struct *user;
@@ -434,7 +452,10 @@ __sigqueue_alloc(int sig, struct task_struct *t, gfp_t flags, int override_rlimi
 	rcu_read_unlock();
 
 	if (override_rlimit || likely(sigpending <= task_rlimit(t, RLIMIT_SIGPENDING))) {
-		q = kmem_cache_alloc(sigqueue_cachep, flags);
+		if (!fromslab)
+			q = get_task_cache(t);
+		if (!q)
+			q = kmem_cache_alloc(sigqueue_cachep, flags);
 	} else {
 		print_dropped_signal(sig);
 	}
@@ -451,6 +472,13 @@ __sigqueue_alloc(int sig, struct task_struct *t, gfp_t flags, int override_rlimi
 	return q;
 }
 
+static struct sigqueue *
+__sigqueue_alloc(int sig, struct task_struct *t, gfp_t flags,
+		 int override_rlimit)
+{
+	return __sigqueue_do_alloc(sig, t, flags, override_rlimit, 0);
+}
+
 static void __sigqueue_free(struct sigqueue *q)
 {
 	if (q->flags & SIGQUEUE_PREALLOC)
@@ -460,6 +488,21 @@ static void __sigqueue_free(struct sigqueue *q)
 	kmem_cache_free(sigqueue_cachep, q);
 }
 
+static void sigqueue_free_current(struct sigqueue *q)
+{
+	struct user_struct *up;
+
+	if (q->flags & SIGQUEUE_PREALLOC)
+		return;
+
+	up = q->user;
+	if (rt_prio(current->normal_prio) && !put_task_cache(current, q)) {
+		if (atomic_dec_and_test(&up->sigpending))
+			free_uid(up);
+	} else
+		  __sigqueue_free(q);
+}
+
 void flush_sigqueue(struct sigpending *queue)
 {
 	struct sigqueue *q;
@@ -472,6 +515,21 @@ void flush_sigqueue(struct sigpending *queue)
 	}
 }
 
+/*
+ * Called from __exit_signal. Flush tsk->pending and
+ * tsk->sigqueue_cache
+ */
+void flush_task_sigqueue(struct task_struct *tsk)
+{
+	struct sigqueue *q;
+
+	flush_sigqueue(&tsk->pending);
+
+	q = get_task_cache(tsk);
+	if (q)
+		kmem_cache_free(sigqueue_cachep, q);
+}
+
 /*
  * Flush all pending signals for this kthread.
  */
@@ -596,7 +654,7 @@ static void collect_signal(int sig, struct sigpending *list, kernel_siginfo_t *i
 			(info->si_code == SI_TIMER) &&
 			(info->si_sys_private);
 
-		__sigqueue_free(first);
+		sigqueue_free_current(first);
 	} else {
 		/*
 		 * Ok, it wasn't in the queue.  This must be
@@ -633,6 +691,8 @@ int dequeue_signal(struct task_struct *tsk, sigset_t *mask, kernel_siginfo_t *in
 	bool resched_timer = false;
 	int signr;
 
+	WARN_ON_ONCE(tsk != current);
+
 	/* We only dequeue private signals from ourselves, we don't let
 	 * signalfd steal them
 	 */
@@ -1320,6 +1380,34 @@ force_sig_info_to_task(struct kernel_siginfo *info, struct task_struct *t)
 	struct k_sigaction *action;
 	int sig = info->si_signo;
 
+	/*
+	 * On some archs, PREEMPT_RT has to delay sending a signal from a trap
+	 * since it can not enable preemption, and the signal code's spin_locks
+	 * turn into mutexes. Instead, it must set TIF_NOTIFY_RESUME which will
+	 * send the signal on exit of the trap.
+	 */
+#ifdef ARCH_RT_DELAYS_SIGNAL_SEND
+	if (in_atomic()) {
+		struct task_struct *t = current;
+
+		if (WARN_ON_ONCE(t->forced_info.si_signo))
+			return 0;
+
+		if (is_si_special(info)) {
+			WARN_ON_ONCE(info != SEND_SIG_PRIV);
+			t->forced_info.si_signo = info->si_signo;
+			t->forced_info.si_errno = 0;
+			t->forced_info.si_code = SI_KERNEL;
+			t->forced_info.si_pid = 0;
+			t->forced_info.si_uid = 0;
+		} else {
+			t->forced_info = *info;
+		}
+
+		set_tsk_thread_flag(t, TIF_NOTIFY_RESUME);
+		return 0;
+	}
+#endif
 	spin_lock_irqsave(&t->sighand->siglock, flags);
 	action = &t->sighand->action[sig-1];
 	ignored = action->sa.sa_handler == SIG_IGN;
@@ -1813,7 +1901,8 @@ EXPORT_SYMBOL(kill_pid);
  */
 struct sigqueue *sigqueue_alloc(void)
 {
-	struct sigqueue *q = __sigqueue_alloc(-1, current, GFP_KERNEL, 0);
+	/* Preallocated sigqueue objects always from the slabcache ! */
+	struct sigqueue *q = __sigqueue_do_alloc(-1, current, GFP_KERNEL, 0, 1);
 
 	if (q)
 		q->flags |= SIGQUEUE_PREALLOC;
@@ -2199,16 +2288,8 @@ static void ptrace_stop(int exit_code, int why, int clear_code, kernel_siginfo_t
 		if (gstop_done && ptrace_reparented(current))
 			do_notify_parent_cldstop(current, false, why);
 
-		/*
-		 * Don't want to allow preemption here, because
-		 * sys_ptrace() needs this task to be inactive.
-		 *
-		 * XXX: implement read_unlock_no_resched().
-		 */
-		preempt_disable();
 		read_unlock(&tasklist_lock);
 		cgroup_enter_frozen();
-		preempt_enable_no_resched();
 		freezable_schedule();
 		cgroup_leave_frozen(true);
 	} else {
diff --git a/kernel/smp.c b/kernel/smp.c
index 114776d0d11e..6d35929a1990 100644
--- a/kernel/smp.c
+++ b/kernel/smp.c
@@ -480,8 +480,18 @@ void flush_smp_call_function_from_idle(void)
 
 	local_irq_save(flags);
 	flush_smp_call_function_queue(true);
-	if (local_softirq_pending())
-		do_softirq();
+
+	if (local_softirq_pending()) {
+
+		if (!IS_ENABLED(CONFIG_PREEMPT_RT)) {
+			do_softirq();
+		} else {
+			struct task_struct *ksoftirqd = this_cpu_ksoftirqd();
+
+			if (ksoftirqd && ksoftirqd->state != TASK_RUNNING)
+				wake_up_process(ksoftirqd);
+		}
+	}
 
 	local_irq_restore(flags);
 }
diff --git a/kernel/softirq.c b/kernel/softirq.c
index 09229ad82209..c9adc5c46248 100644
--- a/kernel/softirq.c
+++ b/kernel/softirq.c
@@ -13,6 +13,7 @@
 #include <linux/kernel_stat.h>
 #include <linux/interrupt.h>
 #include <linux/init.h>
+#include <linux/local_lock.h>
 #include <linux/mm.h>
 #include <linux/notifier.h>
 #include <linux/percpu.h>
@@ -25,6 +26,7 @@
 #include <linux/smpboot.h>
 #include <linux/tick.h>
 #include <linux/irq.h>
+#include <linux/wait_bit.h>
 
 #define CREATE_TRACE_POINTS
 #include <trace/events/irq.h>
@@ -92,27 +94,212 @@ static bool ksoftirqd_running(unsigned long pending)
 		!__kthread_should_park(tsk);
 }
 
+#ifdef CONFIG_TRACE_IRQFLAGS
+DEFINE_PER_CPU(int, hardirqs_enabled);
+DEFINE_PER_CPU(int, hardirq_context);
+EXPORT_PER_CPU_SYMBOL_GPL(hardirqs_enabled);
+EXPORT_PER_CPU_SYMBOL_GPL(hardirq_context);
+#endif
+
 /*
- * preempt_count and SOFTIRQ_OFFSET usage:
- * - preempt_count is changed by SOFTIRQ_OFFSET on entering or leaving
- *   softirq processing.
- * - preempt_count is changed by SOFTIRQ_DISABLE_OFFSET (= 2 * SOFTIRQ_OFFSET)
+ * SOFTIRQ_OFFSET usage:
+ *
+ * On !RT kernels 'count' is the preempt counter, on RT kernels this applies
+ * to a per CPU counter and to task::softirqs_disabled_cnt.
+ *
+ * - count is changed by SOFTIRQ_OFFSET on entering or leaving softirq
+ *   processing.
+ *
+ * - count is changed by SOFTIRQ_DISABLE_OFFSET (= 2 * SOFTIRQ_OFFSET)
  *   on local_bh_disable or local_bh_enable.
+ *
  * This lets us distinguish between whether we are currently processing
  * softirq and whether we just have bh disabled.
  */
+#ifdef CONFIG_PREEMPT_RT
 
 /*
- * This one is for softirq.c-internal use,
- * where hardirqs are disabled legitimately:
+ * RT accounts for BH disabled sections in task::softirqs_disabled_cnt and
+ * also in per CPU softirq_ctrl::cnt. This is necessary to allow tasks in a
+ * softirq disabled section to be preempted.
+ *
+ * The per task counter is used for softirq_count(), in_softirq() and
+ * in_serving_softirqs() because these counts are only valid when the task
+ * holding softirq_ctrl::lock is running.
+ *
+ * The per CPU counter prevents pointless wakeups of ksoftirqd in case that
+ * the task which is in a softirq disabled section is preempted or blocks.
  */
-#ifdef CONFIG_TRACE_IRQFLAGS
+struct softirq_ctrl {
+	local_lock_t	lock;
+	int		cnt;
+};
 
-DEFINE_PER_CPU(int, hardirqs_enabled);
-DEFINE_PER_CPU(int, hardirq_context);
-EXPORT_PER_CPU_SYMBOL_GPL(hardirqs_enabled);
-EXPORT_PER_CPU_SYMBOL_GPL(hardirq_context);
+static DEFINE_PER_CPU(struct softirq_ctrl, softirq_ctrl) = {
+	.lock	= INIT_LOCAL_LOCK(softirq_ctrl.lock),
+};
+
+/**
+ * local_bh_blocked() - Check for idle whether BH processing is blocked
+ *
+ * Returns false if the per CPU softirq::cnt is 0 otherwise true.
+ *
+ * This is invoked from the idle task to guard against false positive
+ * softirq pending warnings, which would happen when the task which holds
+ * softirq_ctrl::lock was the only running task on the CPU and blocks on
+ * some other lock.
+ */
+bool local_bh_blocked(void)
+{
+	return __this_cpu_read(softirq_ctrl.cnt) != 0;
+}
+
+void __local_bh_disable_ip(unsigned long ip, unsigned int cnt)
+{
+	unsigned long flags;
+	int newcnt;
+
+	WARN_ON_ONCE(in_hardirq());
+
+	/* First entry of a task into a BH disabled section? */
+	if (!current->softirq_disable_cnt) {
+		if (preemptible()) {
+			local_lock(&softirq_ctrl.lock);
+			/* Required to meet the RCU bottomhalf requirements. */
+			rcu_read_lock();
+		} else {
+			DEBUG_LOCKS_WARN_ON(this_cpu_read(softirq_ctrl.cnt));
+		}
+	}
+
+	/*
+	 * Track the per CPU softirq disabled state. On RT this is per CPU
+	 * state to allow preemption of bottom half disabled sections.
+	 */
+	newcnt = __this_cpu_add_return(softirq_ctrl.cnt, cnt);
+	/*
+	 * Reflect the result in the task state to prevent recursion on the
+	 * local lock and to make softirq_count() & al work.
+	 */
+	current->softirq_disable_cnt = newcnt;
+
+	if (IS_ENABLED(CONFIG_TRACE_IRQFLAGS) && newcnt == cnt) {
+		raw_local_irq_save(flags);
+		lockdep_softirqs_off(ip);
+		raw_local_irq_restore(flags);
+	}
+}
+EXPORT_SYMBOL(__local_bh_disable_ip);
+
+static void __local_bh_enable(unsigned int cnt, bool unlock)
+{
+	unsigned long flags;
+	int newcnt;
+
+	DEBUG_LOCKS_WARN_ON(current->softirq_disable_cnt !=
+			    this_cpu_read(softirq_ctrl.cnt));
+
+	if (IS_ENABLED(CONFIG_TRACE_IRQFLAGS) && softirq_count() == cnt) {
+		raw_local_irq_save(flags);
+		lockdep_softirqs_on(_RET_IP_);
+		raw_local_irq_restore(flags);
+	}
+
+	newcnt = __this_cpu_sub_return(softirq_ctrl.cnt, cnt);
+	current->softirq_disable_cnt = newcnt;
+
+	if (!newcnt && unlock) {
+		rcu_read_unlock();
+		local_unlock(&softirq_ctrl.lock);
+	}
+}
+
+void __local_bh_enable_ip(unsigned long ip, unsigned int cnt)
+{
+	bool preempt_on = preemptible();
+	unsigned long flags;
+	u32 pending;
+	int curcnt;
+
+	WARN_ON_ONCE(in_irq());
+	lockdep_assert_irqs_enabled();
+
+	local_irq_save(flags);
+	curcnt = __this_cpu_read(softirq_ctrl.cnt);
+
+	/*
+	 * If this is not reenabling soft interrupts, no point in trying to
+	 * run pending ones.
+	 */
+	if (curcnt != cnt)
+		goto out;
+
+	pending = local_softirq_pending();
+	if (!pending || ksoftirqd_running(pending))
+		goto out;
+
+	/*
+	 * If this was called from non preemptible context, wake up the
+	 * softirq daemon.
+	 */
+	if (!preempt_on) {
+		wakeup_softirqd();
+		goto out;
+	}
+
+	/*
+	 * Adjust softirq count to SOFTIRQ_OFFSET which makes
+	 * in_serving_softirq() become true.
+	 */
+	cnt = SOFTIRQ_OFFSET;
+	__local_bh_enable(cnt, false);
+	__do_softirq();
+
+out:
+	__local_bh_enable(cnt, preempt_on);
+	local_irq_restore(flags);
+}
+EXPORT_SYMBOL(__local_bh_enable_ip);
+
+/*
+ * Invoked from ksoftirqd_run() outside of the interrupt disabled section
+ * to acquire the per CPU local lock for reentrancy protection.
+ */
+static inline void ksoftirqd_run_begin(void)
+{
+	__local_bh_disable_ip(_RET_IP_, SOFTIRQ_OFFSET);
+	local_irq_disable();
+}
+
+/* Counterpart to ksoftirqd_run_begin() */
+static inline void ksoftirqd_run_end(void)
+{
+	__local_bh_enable(SOFTIRQ_OFFSET, true);
+	WARN_ON_ONCE(in_interrupt());
+	local_irq_enable();
+}
+
+static inline void softirq_handle_begin(void) { }
+static inline void softirq_handle_end(void) { }
 
+static inline bool should_wake_ksoftirqd(void)
+{
+	return !this_cpu_read(softirq_ctrl.cnt);
+}
+
+static inline void invoke_softirq(void)
+{
+	if (should_wake_ksoftirqd())
+		wakeup_softirqd();
+}
+
+#else /* CONFIG_PREEMPT_RT */
+
+/*
+ * This one is for softirq.c-internal use, where hardirqs are disabled
+ * legitimately:
+ */
+#ifdef CONFIG_TRACE_IRQFLAGS
 void __local_bh_disable_ip(unsigned long ip, unsigned int cnt)
 {
 	unsigned long flags;
@@ -203,6 +390,78 @@ void __local_bh_enable_ip(unsigned long ip, unsigned int cnt)
 }
 EXPORT_SYMBOL(__local_bh_enable_ip);
 
+static inline void softirq_handle_begin(void)
+{
+	__local_bh_disable_ip(_RET_IP_, SOFTIRQ_OFFSET);
+}
+
+static inline void softirq_handle_end(void)
+{
+	__local_bh_enable(SOFTIRQ_OFFSET);
+	WARN_ON_ONCE(in_interrupt());
+}
+
+static inline void ksoftirqd_run_begin(void)
+{
+	local_irq_disable();
+}
+
+static inline void ksoftirqd_run_end(void)
+{
+	local_irq_enable();
+}
+
+static inline bool should_wake_ksoftirqd(void)
+{
+	return true;
+}
+
+static inline void invoke_softirq(void)
+{
+	if (ksoftirqd_running(local_softirq_pending()))
+		return;
+
+	if (!force_irqthreads) {
+#ifdef CONFIG_HAVE_IRQ_EXIT_ON_IRQ_STACK
+		/*
+		 * We can safely execute softirq on the current stack if
+		 * it is the irq stack, because it should be near empty
+		 * at this stage.
+		 */
+		__do_softirq();
+#else
+		/*
+		 * Otherwise, irq_exit() is called on the task stack that can
+		 * be potentially deep already. So call softirq in its own stack
+		 * to prevent from any overrun.
+		 */
+		do_softirq_own_stack();
+#endif
+	} else {
+		wakeup_softirqd();
+	}
+}
+
+asmlinkage __visible void do_softirq(void)
+{
+	__u32 pending;
+	unsigned long flags;
+
+	if (in_interrupt())
+		return;
+
+	local_irq_save(flags);
+
+	pending = local_softirq_pending();
+
+	if (pending && !ksoftirqd_running(pending))
+		do_softirq_own_stack();
+
+	local_irq_restore(flags);
+}
+
+#endif /* !CONFIG_PREEMPT_RT */
+
 /*
  * We restart softirq processing for at most MAX_SOFTIRQ_RESTART times,
  * but break the loop if need_resched() is set or after 2 ms.
@@ -270,10 +529,10 @@ asmlinkage __visible void __softirq_entry __do_softirq(void)
 	current->flags &= ~PF_MEMALLOC;
 
 	pending = local_softirq_pending();
-	account_irq_enter_time(current);
 
-	__local_bh_disable_ip(_RET_IP_, SOFTIRQ_OFFSET);
+	softirq_handle_begin();
 	in_hardirq = lockdep_softirq_start();
+	account_softirq_enter(current);
 
 restart:
 	/* Reset the pending bitmask before enabling irqs */
@@ -307,8 +566,10 @@ asmlinkage __visible void __softirq_entry __do_softirq(void)
 		pending >>= softirq_bit;
 	}
 
-	if (__this_cpu_read(ksoftirqd) == current)
+	if (!IS_ENABLED(CONFIG_PREEMPT_RT) &&
+	    __this_cpu_read(ksoftirqd) == current)
 		rcu_softirq_qs();
+
 	local_irq_disable();
 
 	pending = local_softirq_pending();
@@ -320,46 +581,23 @@ asmlinkage __visible void __softirq_entry __do_softirq(void)
 		wakeup_softirqd();
 	}
 
+	account_softirq_exit(current);
 	lockdep_softirq_end(in_hardirq);
-	account_irq_exit_time(current);
-	__local_bh_enable(SOFTIRQ_OFFSET);
-	WARN_ON_ONCE(in_interrupt());
+	softirq_handle_end();
 	current_restore_flags(old_flags, PF_MEMALLOC);
 }
 
-asmlinkage __visible void do_softirq(void)
-{
-	__u32 pending;
-	unsigned long flags;
-
-	if (in_interrupt())
-		return;
-
-	local_irq_save(flags);
-
-	pending = local_softirq_pending();
-
-	if (pending && !ksoftirqd_running(pending))
-		do_softirq_own_stack();
-
-	local_irq_restore(flags);
-}
-
 /**
  * irq_enter_rcu - Enter an interrupt context with RCU watching
  */
 void irq_enter_rcu(void)
 {
-	if (is_idle_task(current) && !in_interrupt()) {
-		/*
-		 * Prevent raise_softirq from needlessly waking up ksoftirqd
-		 * here, as softirq will be serviced on return from interrupt.
-		 */
-		local_bh_disable();
+	__irq_enter_raw();
+
+	if (is_idle_task(current) && (irq_count() == HARDIRQ_OFFSET))
 		tick_irq_enter();
-		_local_bh_enable();
-	}
-	__irq_enter();
+
+	account_hardirq_enter(current);
 }
 
 /**
@@ -371,32 +609,6 @@ void irq_enter(void)
 	irq_enter_rcu();
 }
 
-static inline void invoke_softirq(void)
-{
-	if (ksoftirqd_running(local_softirq_pending()))
-		return;
-
-	if (!force_irqthreads) {
-#ifdef CONFIG_HAVE_IRQ_EXIT_ON_IRQ_STACK
-		/*
-		 * We can safely execute softirq on the current stack if
-		 * it is the irq stack, because it should be near empty
-		 * at this stage.
-		 */
-		__do_softirq();
-#else
-		/*
-		 * Otherwise, irq_exit() is called on the task stack that can
-		 * be potentially deep already. So call softirq in its own stack
-		 * to prevent from any overrun.
-		 */
-		do_softirq_own_stack();
-#endif
-	} else {
-		wakeup_softirqd();
-	}
-}
-
 static inline void tick_irq_exit(void)
 {
 #ifdef CONFIG_NO_HZ_COMMON
@@ -417,7 +629,7 @@ static inline void __irq_exit_rcu(void)
 #else
 	lockdep_assert_irqs_disabled();
 #endif
-	account_irq_exit_time(current);
+	account_hardirq_exit(current);
 	preempt_count_sub(HARDIRQ_OFFSET);
 	if (!in_interrupt() && local_softirq_pending())
 		invoke_softirq();
@@ -466,7 +678,7 @@ inline void raise_softirq_irqoff(unsigned int nr)
 	 * Otherwise we wake up ksoftirqd to make sure we
 	 * schedule the softirq soon.
 	 */
-	if (!in_interrupt())
+	if (!in_interrupt() && should_wake_ksoftirqd())
 		wakeup_softirqd();
 }
 
@@ -532,6 +744,16 @@ void __tasklet_hi_schedule(struct tasklet_struct *t)
 }
 EXPORT_SYMBOL(__tasklet_hi_schedule);
 
+static inline bool tasklet_clear_sched(struct tasklet_struct *t)
+{
+	if (test_and_clear_bit(TASKLET_STATE_SCHED, &t->state)) {
+		wake_up_var(&t->state);
+		return true;
+	}
+
+	return false;
+}
+
 static void tasklet_action_common(struct softirq_action *a,
 				  struct tasklet_head *tl_head,
 				  unsigned int softirq_nr)
@@ -551,8 +773,7 @@ static void tasklet_action_common(struct softirq_action *a,
 
 		if (tasklet_trylock(t)) {
 			if (!atomic_read(&t->count)) {
-				if (!test_and_clear_bit(TASKLET_STATE_SCHED,
-							&t->state))
+				if (!tasklet_clear_sched(t))
 					BUG();
 				if (t->use_callback)
 					t->callback(t);
@@ -607,21 +828,62 @@ void tasklet_init(struct tasklet_struct *t,
 }
 EXPORT_SYMBOL(tasklet_init);
 
+#if defined(CONFIG_SMP) || defined(CONFIG_PREEMPT_RT)
+/*
+ * Do not use in new code. Waiting for tasklets from atomic contexts is
+ * error prone and should be avoided.
+ */
+void tasklet_unlock_spin_wait(struct tasklet_struct *t)
+{
+	while (test_bit(TASKLET_STATE_RUN, &(t)->state)) {
+		if (IS_ENABLED(CONFIG_PREEMPT_RT)) {
+			/*
+			 * Prevent a live lock when current preempted soft
+			 * interrupt processing or prevents ksoftirqd from
+			 * running. If the tasklet runs on a different CPU
+			 * then this has no effect other than doing the BH
+			 * disable/enable dance for nothing.
+			 */
+			local_bh_disable();
+			local_bh_enable();
+		} else {
+			cpu_relax();
+		}
+	}
+}
+EXPORT_SYMBOL(tasklet_unlock_spin_wait);
+#endif
+
 void tasklet_kill(struct tasklet_struct *t)
 {
 	if (in_interrupt())
 		pr_notice("Attempt to kill tasklet from interrupt\n");
 
-	while (test_and_set_bit(TASKLET_STATE_SCHED, &t->state)) {
-		do {
-			yield();
-		} while (test_bit(TASKLET_STATE_SCHED, &t->state));
-	}
+	while (test_and_set_bit(TASKLET_STATE_SCHED, &t->state))
+		wait_var_event(&t->state, !test_bit(TASKLET_STATE_SCHED, &t->state));
+
 	tasklet_unlock_wait(t);
-	clear_bit(TASKLET_STATE_SCHED, &t->state);
+	tasklet_clear_sched(t);
 }
 EXPORT_SYMBOL(tasklet_kill);
 
+#if defined(CONFIG_SMP) || defined(CONFIG_PREEMPT_RT)
+void tasklet_unlock(struct tasklet_struct *t)
+{
+	smp_mb__before_atomic();
+	clear_bit(TASKLET_STATE_RUN, &t->state);
+	smp_mb__after_atomic();
+	wake_up_var(&t->state);
+}
+EXPORT_SYMBOL_GPL(tasklet_unlock);
+
+void tasklet_unlock_wait(struct tasklet_struct *t)
+{
+	wait_var_event(&t->state, !test_bit(TASKLET_STATE_RUN, &t->state));
+}
+EXPORT_SYMBOL_GPL(tasklet_unlock_wait);
+#endif
+
 void __init softirq_init(void)
 {
 	int cpu;
@@ -644,18 +906,18 @@ static int ksoftirqd_should_run(unsigned int cpu)
 
 static void run_ksoftirqd(unsigned int cpu)
 {
-	local_irq_disable();
+	ksoftirqd_run_begin();
 	if (local_softirq_pending()) {
 		/*
 		 * We can safely run softirq on inline stack, as we are not deep
 		 * in the task stack here.
 		 */
 		__do_softirq();
-		local_irq_enable();
+		ksoftirqd_run_end();
 		cond_resched();
 		return;
 	}
-	local_irq_enable();
+	ksoftirqd_run_end();
 }
 
 #ifdef CONFIG_HOTPLUG_CPU
diff --git a/kernel/stop_machine.c b/kernel/stop_machine.c
index d0bf6da49322..7a74b501a3e9 100644
--- a/kernel/stop_machine.c
+++ b/kernel/stop_machine.c
@@ -47,11 +47,27 @@ struct cpu_stopper {
 	struct list_head	works;		/* list of pending works */
 
 	struct cpu_stop_work	stop_work;	/* for stop_cpus */
+	unsigned long		caller;
+	cpu_stop_fn_t		fn;
 };
 
 static DEFINE_PER_CPU(struct cpu_stopper, cpu_stopper);
 static bool stop_machine_initialized = false;
 
+void print_stop_info(const char *log_lvl, struct task_struct *task)
+{
+	/*
+	 * If @task is a stopper task, it cannot migrate and task_cpu() is
+	 * stable.
+	 */
+	struct cpu_stopper *stopper = per_cpu_ptr(&cpu_stopper, task_cpu(task));
+
+	if (task != stopper->thread)
+		return;
+
+	printk("%sStopper: %pS <- %pS\n", log_lvl, stopper->fn, (void *)stopper->caller);
+}
+
 /* static data for stop_cpus */
 static DEFINE_MUTEX(stop_cpus_mutex);
 static bool stop_cpus_in_progress;
@@ -128,7 +144,7 @@ static bool cpu_stop_queue_work(unsigned int cpu, struct cpu_stop_work *work)
 int stop_one_cpu(unsigned int cpu, cpu_stop_fn_t fn, void *arg)
 {
 	struct cpu_stop_done done;
-	struct cpu_stop_work work = { .fn = fn, .arg = arg, .done = &done };
+	struct cpu_stop_work work = { .fn = fn, .arg = arg, .done = &done, .caller = _RET_IP_ };
 
 	cpu_stop_init_done(&done, 1);
 	if (!cpu_stop_queue_work(cpu, &work))
@@ -344,7 +360,8 @@ int stop_two_cpus(unsigned int cpu1, unsigned int cpu2, cpu_stop_fn_t fn, void *
 	work1 = work2 = (struct cpu_stop_work){
 		.fn = multi_cpu_stop,
 		.arg = &msdata,
-		.done = &done
+		.done = &done,
+		.caller = _RET_IP_,
 	};
 
 	cpu_stop_init_done(&done, 2);
@@ -380,7 +397,7 @@ int stop_two_cpus(unsigned int cpu1, unsigned int cpu2, cpu_stop_fn_t fn, void *
 bool stop_one_cpu_nowait(unsigned int cpu, cpu_stop_fn_t fn, void *arg,
 			struct cpu_stop_work *work_buf)
 {
-	*work_buf = (struct cpu_stop_work){ .fn = fn, .arg = arg, };
+	*work_buf = (struct cpu_stop_work){ .fn = fn, .arg = arg, .caller = _RET_IP_, };
 	return cpu_stop_queue_work(cpu, work_buf);
 }
 
@@ -500,6 +517,8 @@ static void cpu_stopper_thread(unsigned int cpu)
 		int ret;
 
 		/* cpu stop callbacks must not sleep, make in_atomic() == T */
+		stopper->caller = work->caller;
+		stopper->fn = fn;
 		preempt_count_inc();
 		ret = fn(arg);
 		if (done) {
@@ -508,6 +527,8 @@ static void cpu_stopper_thread(unsigned int cpu)
 			cpu_stop_signal_done(done);
 		}
 		preempt_count_dec();
+		stopper->fn = NULL;
+		stopper->caller = 0;
 		WARN_ONCE(preempt_count(),
 			  "cpu_stop: %ps(%p) leaked preempt count\n", fn, arg);
 		goto repeat;
diff --git a/kernel/time/hrtimer.c b/kernel/time/hrtimer.c
index 544ce87ba38a..3db616aecb17 100644
--- a/kernel/time/hrtimer.c
+++ b/kernel/time/hrtimer.c
@@ -2052,6 +2052,36 @@ SYSCALL_DEFINE2(nanosleep_time32, struct old_timespec32 __user *, rqtp,
 }
 #endif
 
+#ifdef CONFIG_PREEMPT_RT
+/*
+ * Sleep for 1 ms in hope whoever holds what we want will let it go.
+ */
+void cpu_chill(void)
+{
+	unsigned int freeze_flag = current->flags & PF_NOFREEZE;
+	struct task_struct *self = current;
+	ktime_t chill_time;
+
+	raw_spin_lock_irq(&self->pi_lock);
+	self->saved_state = self->state;
+	__set_current_state_no_track(TASK_UNINTERRUPTIBLE);
+	raw_spin_unlock_irq(&self->pi_lock);
+
+	chill_time = ktime_set(0, NSEC_PER_MSEC);
+
+	current->flags |= PF_NOFREEZE;
+	schedule_hrtimeout(&chill_time, HRTIMER_MODE_REL_HARD);
+	if (!freeze_flag)
+		current->flags &= ~PF_NOFREEZE;
+
+	raw_spin_lock_irq(&self->pi_lock);
+	__set_current_state_no_track(self->saved_state);
+	self->saved_state = TASK_RUNNING;
+	raw_spin_unlock_irq(&self->pi_lock);
+}
+EXPORT_SYMBOL(cpu_chill);
+#endif
+
 /*
  * Functions related to boot-time initialization:
  */
diff --git a/kernel/time/tick-sched.c b/kernel/time/tick-sched.c
index 33750db5b564..90f3c8ad5f47 100644
--- a/kernel/time/tick-sched.c
+++ b/kernel/time/tick-sched.c
@@ -989,7 +989,7 @@ static bool can_stop_idle_tick(int cpu, struct tick_sched *ts)
 	if (unlikely(local_softirq_pending())) {
 		static int ratelimit;
 
-		if (ratelimit < 10 &&
+		if (ratelimit < 10 && !local_bh_blocked() &&
 		    (local_softirq_pending() & SOFTIRQ_STOP_IDLE_MASK)) {
 			pr_warn("NOHZ tick-stop error: Non-RCU local softirq work is pending, handler #%02x!!!\n",
 				(unsigned int) local_softirq_pending());
diff --git a/kernel/time/timer.c b/kernel/time/timer.c
index f7d3a108e27c..f24e6fed6633 100644
--- a/kernel/time/timer.c
+++ b/kernel/time/timer.c
@@ -1287,7 +1287,7 @@ static void del_timer_wait_running(struct timer_list *timer)
 	u32 tf;
 
 	tf = READ_ONCE(timer->flags);
-	if (!(tf & TIMER_MIGRATING)) {
+	if (!(tf & (TIMER_MIGRATING | TIMER_IRQSAFE))) {
 		struct timer_base *base = get_timer_base(tf);
 
 		/*
@@ -1371,6 +1371,13 @@ int del_timer_sync(struct timer_list *timer)
 	 */
 	WARN_ON(in_irq() && !(timer->flags & TIMER_IRQSAFE));
 
+	/*
+	 * Must be able to sleep on PREEMPT_RT because of the slowpath in
+	 * del_timer_wait_running().
+	 */
+	if (IS_ENABLED(CONFIG_PREEMPT_RT) && !(timer->flags & TIMER_IRQSAFE))
+		lockdep_assert_preemption_enabled();
+
 	do {
 		ret = try_to_del_timer_sync(timer);
 
diff --git a/kernel/trace/trace.c b/kernel/trace/trace.c
index 4e130e2bb566..50a2db7a791d 100644
--- a/kernel/trace/trace.c
+++ b/kernel/trace/trace.c
@@ -2592,60 +2592,43 @@ enum print_line_t trace_handle_return(struct trace_seq *s)
 }
 EXPORT_SYMBOL_GPL(trace_handle_return);
 
-unsigned int tracing_gen_ctx_flags(unsigned long irqflags)
+static unsigned short migration_disable_value(void)
 {
-	unsigned int trace_flags = 0;
+#if defined(CONFIG_SMP) && defined(CONFIG_PREEMPT_RT)
+	return current->migration_disabled;
+#else
+	return 0;
+#endif
+}
+
+unsigned int tracing_gen_ctx_irq_test(unsigned int irqs_status)
+{
+	unsigned int trace_flags = irqs_status;
 	unsigned int pc;
 
 	pc = preempt_count();
 
-#ifdef CONFIG_TRACE_IRQFLAGS_SUPPORT
-	if (irqs_disabled_flags(irqflags))
-		trace_flags |= TRACE_FLAG_IRQS_OFF;
-#else
-	trace_flags |= TRACE_FLAG_IRQS_NOSUPPORT;
-#endif
-
 	if (pc & NMI_MASK)
 		trace_flags |= TRACE_FLAG_NMI;
 	if (pc & HARDIRQ_MASK)
 		trace_flags |= TRACE_FLAG_HARDIRQ;
-
-	if (pc & SOFTIRQ_OFFSET)
+	if (in_serving_softirq())
 		trace_flags |= TRACE_FLAG_SOFTIRQ;
 
 	if (tif_need_resched())
 		trace_flags |= TRACE_FLAG_NEED_RESCHED;
 	if (test_preempt_need_resched())
 		trace_flags |= TRACE_FLAG_PREEMPT_RESCHED;
-	return (trace_flags << 16) | (pc & 0xff);
-}
 
-unsigned int tracing_gen_ctx(void)
-{
-	unsigned long irqflags;
-
-#ifdef CONFIG_TRACE_IRQFLAGS_SUPPORT
-	local_save_flags(irqflags);
-#else
-	irqflags = 0;
+#ifdef CONFIG_PREEMPT_LAZY
+	if (need_resched_lazy())
+		trace_flags |= TRACE_FLAG_NEED_RESCHED_LAZY;
 #endif
-	return tracing_gen_ctx_flags(irqflags);
-}
 
-unsigned int tracing_gen_ctx_dec(void)
-{
-	unsigned int trace_ctx;
-
-	trace_ctx = tracing_gen_ctx();
-
-	/*
-	 * Subtract one from the preeption counter if preemption is enabled,
-	 * see trace_event_buffer_reserve()for details.
-	 */
-	if (IS_ENABLED(CONFIG_PREEMPTION))
-		trace_ctx--;
-	return trace_ctx;
+	return (pc & 0xff) |
+		(migration_disable_value() & 0xff) << 8 |
+		(preempt_lazy_count() & 0xff) << 16 |
+		(trace_flags << 24);
 }
 
 struct ring_buffer_event *
@@ -3841,14 +3824,17 @@ unsigned long trace_total_entries(struct trace_array *tr)
 
 static void print_lat_help_header(struct seq_file *m)
 {
-	seq_puts(m, "#                    _------=> CPU#            \n"
-		    "#                   / _-----=> irqs-off        \n"
-		    "#                  | / _----=> need-resched    \n"
-		    "#                  || / _---=> hardirq/softirq \n"
-		    "#                  ||| / _--=> preempt-depth   \n"
-		    "#                  |||| /     delay            \n"
-		    "#  cmd     pid     ||||| time  |   caller      \n"
-		    "#     \\   /        |||||  \\    |   /         \n");
+	seq_puts(m, "#                    _--------=> CPU#            \n"
+		    "#                   / _-------=> irqs-off        \n"
+		    "#                  | / _------=> need-resched    \n"
+		    "#                  || / _-----=> need-resched-lazy\n"
+		    "#                  ||| / _----=> hardirq/softirq \n"
+		    "#                  |||| / _---=> preempt-depth   \n"
+		    "#                  ||||| / _--=> preempt-lazy-depth\n"
+		    "#                  |||||| / _-=> migrate-disable \n"
+		    "#                  ||||||| /     delay           \n"
+		    "#  cmd     pid     |||||||| time  |   caller     \n"
+		    "#     \\   /        ||||||||  \\    |    /       \n");
 }
 
 static void print_event_info(struct array_buffer *buf, struct seq_file *m)
@@ -3882,13 +3868,16 @@ static void print_func_help_header_irq(struct array_buffer *buf, struct seq_file
 
 	print_event_info(buf, m);
 
-	seq_printf(m, "#                            %.*s  _-----=> irqs-off\n", prec, space);
-	seq_printf(m, "#                            %.*s / _----=> need-resched\n", prec, space);
-	seq_printf(m, "#                            %.*s| / _---=> hardirq/softirq\n", prec, space);
-	seq_printf(m, "#                            %.*s|| / _--=> preempt-depth\n", prec, space);
-	seq_printf(m, "#                            %.*s||| /     delay\n", prec, space);
-	seq_printf(m, "#           TASK-PID  %.*s CPU#  ||||   TIMESTAMP  FUNCTION\n", prec, "     TGID   ");
-	seq_printf(m, "#              | |    %.*s   |   ||||      |         |\n", prec, "       |    ");
+	seq_printf(m, "#                            %.*s  _-------=> irqs-off\n", prec, space);
+	seq_printf(m, "#                            %.*s / _------=> need-resched\n", prec, space);
+	seq_printf(m, "#                            %.*s| / _-----=> need-resched-lazy\n", prec, space);
+	seq_printf(m, "#                            %.*s|| / _----=> hardirq/softirq\n", prec, space);
+	seq_printf(m, "#                            %.*s||| / _---=> preempt-depth\n", prec, space);
+	seq_printf(m, "#                            %.*s|||| / _--=> preempt-lazy-depth\n", prec, space);
+	seq_printf(m, "#                            %.*s||||| / _-=> migrate-disable\n", prec, space);
+	seq_printf(m, "#                            %.*s|||||| /     delay\n", prec, space);
+	seq_printf(m, "#           TASK-PID  %.*s CPU#  |||||||  TIMESTAMP  FUNCTION\n", prec, "     TGID   ");
+	seq_printf(m, "#              | |    %.*s   |   |||||||      |         |\n", prec, "       |    ");
 }
 
 void
@@ -9431,7 +9420,6 @@ void ftrace_dump(enum ftrace_dump_mode oops_dump_mode)
 	tracing_off();
 
 	local_irq_save(flags);
-	printk_nmi_direct_enter();
 
 	/* Simulate the iterator */
 	trace_init_global_iter(&iter);
@@ -9511,7 +9499,6 @@ void ftrace_dump(enum ftrace_dump_mode oops_dump_mode)
 		atomic_dec(&per_cpu_ptr(iter.array_buffer->data, cpu)->disabled);
 	}
 	atomic_dec(&dump_running);
-	printk_nmi_direct_exit();
 	local_irq_restore(flags);
 }
 EXPORT_SYMBOL_GPL(ftrace_dump);
diff --git a/kernel/trace/trace.h b/kernel/trace/trace.h
index c0596e250c2a..44943a9be317 100644
--- a/kernel/trace/trace.h
+++ b/kernel/trace/trace.h
@@ -141,25 +141,6 @@ struct kretprobe_trace_entry_head {
 	unsigned long		ret_ip;
 };
 
-/*
- * trace_flag_type is an enumeration that holds different
- * states when a trace occurs. These are:
- *  IRQS_OFF		- interrupts were disabled
- *  IRQS_NOSUPPORT	- arch does not support irqs_disabled_flags
- *  NEED_RESCHED	- reschedule is requested
- *  HARDIRQ		- inside an interrupt handler
- *  SOFTIRQ		- inside a softirq handler
- */
-enum trace_flag_type {
-	TRACE_FLAG_IRQS_OFF		= 0x01,
-	TRACE_FLAG_IRQS_NOSUPPORT	= 0x02,
-	TRACE_FLAG_NEED_RESCHED		= 0x04,
-	TRACE_FLAG_HARDIRQ		= 0x08,
-	TRACE_FLAG_SOFTIRQ		= 0x10,
-	TRACE_FLAG_PREEMPT_RESCHED	= 0x20,
-	TRACE_FLAG_NMI			= 0x40,
-};
-
 #define TRACE_BUF_SIZE		1024
 
 struct trace_array;
diff --git a/kernel/trace/trace_events.c b/kernel/trace/trace_events.c
index d29a9a5e5743..9ad773198754 100644
--- a/kernel/trace/trace_events.c
+++ b/kernel/trace/trace_events.c
@@ -184,6 +184,8 @@ static int trace_define_common_fields(void)
 	__common_field(unsigned char, flags);
 	__common_field(unsigned char, preempt_count);
 	__common_field(int, pid);
+	__common_field(unsigned char, migrate_disable);
+	__common_field(unsigned char, preempt_lazy_count);
 
 	return ret;
 }
diff --git a/kernel/trace/trace_output.c b/kernel/trace/trace_output.c
index 7042544c5bde..c711eb334811 100644
--- a/kernel/trace/trace_output.c
+++ b/kernel/trace/trace_output.c
@@ -441,6 +441,7 @@ int trace_print_lat_fmt(struct trace_seq *s, struct trace_entry *entry)
 {
 	char hardsoft_irq;
 	char need_resched;
+	char need_resched_lazy;
 	char irqs_off;
 	int hardirq;
 	int softirq;
@@ -471,6 +472,9 @@ int trace_print_lat_fmt(struct trace_seq *s, struct trace_entry *entry)
 		break;
 	}
 
+	need_resched_lazy =
+		(entry->flags & TRACE_FLAG_NEED_RESCHED_LAZY) ? 'L' : '.';
+
 	hardsoft_irq =
 		(nmi && hardirq)     ? 'Z' :
 		nmi                  ? 'z' :
@@ -479,14 +483,25 @@ int trace_print_lat_fmt(struct trace_seq *s, struct trace_entry *entry)
 		softirq              ? 's' :
 		                       '.' ;
 
-	trace_seq_printf(s, "%c%c%c",
-			 irqs_off, need_resched, hardsoft_irq);
+	trace_seq_printf(s, "%c%c%c%c",
+			 irqs_off, need_resched, need_resched_lazy,
+			 hardsoft_irq);
 
 	if (entry->preempt_count)
 		trace_seq_printf(s, "%x", entry->preempt_count);
 	else
 		trace_seq_putc(s, '.');
 
+	if (entry->preempt_lazy_count)
+		trace_seq_printf(s, "%x", entry->preempt_lazy_count);
+	else
+		trace_seq_putc(s, '.');
+
+	if (entry->migrate_disable)
+		trace_seq_printf(s, "%x", entry->migrate_disable);
+	else
+		trace_seq_putc(s, '.');
+
 	return !trace_seq_has_overflowed(s);
 }
 
diff --git a/kernel/workqueue.c b/kernel/workqueue.c
index a27605c17f07..de6678df18c3 100644
--- a/kernel/workqueue.c
+++ b/kernel/workqueue.c
@@ -4818,9 +4818,9 @@ void show_workqueue_state(void)
 				 * drivers that queue work while holding locks
 				 * also taken in their write paths.
 				 */
-				printk_safe_enter();
+
 				show_pwq(pwq);
-				printk_safe_exit();
+
 			}
 			raw_spin_unlock_irqrestore(&pwq->pool->lock, flags);
 			/*
@@ -4844,7 +4844,7 @@ void show_workqueue_state(void)
 		 * queue work while holding locks also taken in their write
 		 * paths.
 		 */
-		printk_safe_enter();
+
 		pr_info("pool %d:", pool->id);
 		pr_cont_pool_info(pool);
 		pr_cont(" hung=%us workers=%d",
@@ -4859,7 +4859,7 @@ void show_workqueue_state(void)
 			first = false;
 		}
 		pr_cont("\n");
-		printk_safe_exit();
+
 	next_pool:
 		raw_spin_unlock_irqrestore(&pool->lock, flags);
 		/*
@@ -4951,6 +4951,10 @@ static void unbind_workers(int cpu)
 		pool->flags |= POOL_DISASSOCIATED;
 
 		raw_spin_unlock_irq(&pool->lock);
+
+		for_each_pool_worker(worker, pool)
+			WARN_ON_ONCE(set_cpus_allowed_ptr(worker->task, cpu_active_mask) < 0);
+
 		mutex_unlock(&wq_pool_attach_mutex);
 
 		/*
diff --git a/lib/Kconfig.debug b/lib/Kconfig.debug
index 10e425c30486..68857da74e6f 100644
--- a/lib/Kconfig.debug
+++ b/lib/Kconfig.debug
@@ -1406,7 +1406,7 @@ config DEBUG_ATOMIC_SLEEP
 
 config DEBUG_LOCKING_API_SELFTESTS
 	bool "Locking API boot-time self-tests"
-	depends on DEBUG_KERNEL
+	depends on DEBUG_KERNEL && !PREEMPT_RT
 	help
 	  Say Y here if you want the kernel to run a short self-test during
 	  bootup. The self-test checks whether common types of locking bugs
diff --git a/lib/bug.c b/lib/bug.c
index 4ab398a2de93..9c681f29e61e 100644
--- a/lib/bug.c
+++ b/lib/bug.c
@@ -202,6 +202,7 @@ enum bug_trap_type report_bug(unsigned long bugaddr, struct pt_regs *regs)
 	else
 		pr_crit("Kernel BUG at %pB [verbose debug info unavailable]\n",
 			(void *)bugaddr);
+	pr_flush(1000, true);
 
 	return BUG_TRAP_TYPE_BUG;
 }
diff --git a/lib/cpumask.c b/lib/cpumask.c
index fb22fb266f93..c3c76b833384 100644
--- a/lib/cpumask.c
+++ b/lib/cpumask.c
@@ -261,3 +261,21 @@ int cpumask_any_and_distribute(const struct cpumask *src1p,
 	return next;
 }
 EXPORT_SYMBOL(cpumask_any_and_distribute);
+
+int cpumask_any_distribute(const struct cpumask *srcp)
+{
+	int next, prev;
+
+	/* NOTE: our first selection will skip 0. */
+	prev = __this_cpu_read(distribute_cpu_mask_prev);
+
+	next = cpumask_next(prev, srcp);
+	if (next >= nr_cpu_ids)
+		next = cpumask_first(srcp);
+
+	if (next < nr_cpu_ids)
+		__this_cpu_write(distribute_cpu_mask_prev, next);
+
+	return next;
+}
+EXPORT_SYMBOL(cpumask_any_distribute);
diff --git a/lib/debugobjects.c b/lib/debugobjects.c
index 9e14ae02306b..083882a3cf2f 100644
--- a/lib/debugobjects.c
+++ b/lib/debugobjects.c
@@ -557,7 +557,10 @@ __debug_object_init(void *addr, const struct debug_obj_descr *descr, int onstack
 	struct debug_obj *obj;
 	unsigned long flags;
 
-	fill_pool();
+#ifdef CONFIG_PREEMPT_RT
+	if (preempt_count() == 0 && !irqs_disabled())
+#endif
+		fill_pool();
 
 	db = get_bucket((unsigned long) addr);
 
diff --git a/lib/dump_stack.c b/lib/dump_stack.c
index a00ee6eedc7c..f5a33b6f773f 100644
--- a/lib/dump_stack.c
+++ b/lib/dump_stack.c
@@ -12,6 +12,7 @@
 #include <linux/atomic.h>
 #include <linux/kexec.h>
 #include <linux/utsname.h>
+#include <linux/stop_machine.h>
 
 static char dump_stack_arch_desc_str[128];
 
@@ -57,6 +58,7 @@ void dump_stack_print_info(const char *log_lvl)
 		       log_lvl, dump_stack_arch_desc_str);
 
 	print_worker_info(log_lvl, current);
+	print_stop_info(log_lvl, current);
 }
 
 /**
diff --git a/lib/irq_poll.c b/lib/irq_poll.c
index 2f17b488d58e..7557bf7ecf1f 100644
--- a/lib/irq_poll.c
+++ b/lib/irq_poll.c
@@ -37,6 +37,7 @@ void irq_poll_sched(struct irq_poll *iop)
 	list_add_tail(&iop->list, this_cpu_ptr(&blk_cpu_iopoll));
 	raise_softirq_irqoff(IRQ_POLL_SOFTIRQ);
 	local_irq_restore(flags);
+	preempt_check_resched_rt();
 }
 EXPORT_SYMBOL(irq_poll_sched);
 
@@ -72,6 +73,7 @@ void irq_poll_complete(struct irq_poll *iop)
 	local_irq_save(flags);
 	__irq_poll_complete(iop);
 	local_irq_restore(flags);
+	preempt_check_resched_rt();
 }
 EXPORT_SYMBOL(irq_poll_complete);
 
@@ -96,6 +98,7 @@ static void __latent_entropy irq_poll_softirq(struct softirq_action *h)
 		}
 
 		local_irq_enable();
+		preempt_check_resched_rt();
 
 		/* Even though interrupts have been re-enabled, this
 		 * access is safe because interrupts can only add new
@@ -133,6 +136,7 @@ static void __latent_entropy irq_poll_softirq(struct softirq_action *h)
 		__raise_softirq_irqoff(IRQ_POLL_SOFTIRQ);
 
 	local_irq_enable();
+	preempt_check_resched_rt();
 }
 
 /**
@@ -196,6 +200,7 @@ static int irq_poll_cpu_dead(unsigned int cpu)
 			 this_cpu_ptr(&blk_cpu_iopoll));
 	__raise_softirq_irqoff(IRQ_POLL_SOFTIRQ);
 	local_irq_enable();
+	preempt_check_resched_rt();
 
 	return 0;
 }
diff --git a/lib/locking-selftest.c b/lib/locking-selftest.c
index 76c52b0b76d3..98c376b02dff 100644
--- a/lib/locking-selftest.c
+++ b/lib/locking-selftest.c
@@ -787,6 +787,8 @@ GENERATE_TESTCASE(init_held_rtmutex);
 #include "locking-selftest-spin-hardirq.h"
 GENERATE_PERMUTATIONS_2_EVENTS(irqsafe1_hard_spin)
 
+#ifndef CONFIG_PREEMPT_RT
+
 #include "locking-selftest-rlock-hardirq.h"
 GENERATE_PERMUTATIONS_2_EVENTS(irqsafe1_hard_rlock)
 
@@ -802,9 +804,12 @@ GENERATE_PERMUTATIONS_2_EVENTS(irqsafe1_soft_rlock)
 #include "locking-selftest-wlock-softirq.h"
 GENERATE_PERMUTATIONS_2_EVENTS(irqsafe1_soft_wlock)
 
+#endif
+
 #undef E1
 #undef E2
 
+#ifndef CONFIG_PREEMPT_RT
 /*
  * Enabling hardirqs with a softirq-safe lock held:
  */
@@ -837,6 +842,8 @@ GENERATE_PERMUTATIONS_2_EVENTS(irqsafe2A_rlock)
 #undef E1
 #undef E2
 
+#endif
+
 /*
  * Enabling irqs with an irq-safe lock held:
  */
@@ -860,6 +867,8 @@ GENERATE_PERMUTATIONS_2_EVENTS(irqsafe2A_rlock)
 #include "locking-selftest-spin-hardirq.h"
 GENERATE_PERMUTATIONS_2_EVENTS(irqsafe2B_hard_spin)
 
+#ifndef CONFIG_PREEMPT_RT
+
 #include "locking-selftest-rlock-hardirq.h"
 GENERATE_PERMUTATIONS_2_EVENTS(irqsafe2B_hard_rlock)
 
@@ -875,6 +884,8 @@ GENERATE_PERMUTATIONS_2_EVENTS(irqsafe2B_soft_rlock)
 #include "locking-selftest-wlock-softirq.h"
 GENERATE_PERMUTATIONS_2_EVENTS(irqsafe2B_soft_wlock)
 
+#endif
+
 #undef E1
 #undef E2
 
@@ -906,6 +917,8 @@ GENERATE_PERMUTATIONS_2_EVENTS(irqsafe2B_soft_wlock)
 #include "locking-selftest-spin-hardirq.h"
 GENERATE_PERMUTATIONS_3_EVENTS(irqsafe3_hard_spin)
 
+#ifndef CONFIG_PREEMPT_RT
+
 #include "locking-selftest-rlock-hardirq.h"
 GENERATE_PERMUTATIONS_3_EVENTS(irqsafe3_hard_rlock)
 
@@ -921,6 +934,8 @@ GENERATE_PERMUTATIONS_3_EVENTS(irqsafe3_soft_rlock)
 #include "locking-selftest-wlock-softirq.h"
 GENERATE_PERMUTATIONS_3_EVENTS(irqsafe3_soft_wlock)
 
+#endif
+
 #undef E1
 #undef E2
 #undef E3
@@ -954,6 +969,8 @@ GENERATE_PERMUTATIONS_3_EVENTS(irqsafe3_soft_wlock)
 #include "locking-selftest-spin-hardirq.h"
 GENERATE_PERMUTATIONS_3_EVENTS(irqsafe4_hard_spin)
 
+#ifndef CONFIG_PREEMPT_RT
+
 #include "locking-selftest-rlock-hardirq.h"
 GENERATE_PERMUTATIONS_3_EVENTS(irqsafe4_hard_rlock)
 
@@ -969,10 +986,14 @@ GENERATE_PERMUTATIONS_3_EVENTS(irqsafe4_soft_rlock)
 #include "locking-selftest-wlock-softirq.h"
 GENERATE_PERMUTATIONS_3_EVENTS(irqsafe4_soft_wlock)
 
+#endif
+
 #undef E1
 #undef E2
 #undef E3
 
+#ifndef CONFIG_PREEMPT_RT
+
 /*
  * read-lock / write-lock irq inversion.
  *
@@ -1162,6 +1183,11 @@ GENERATE_PERMUTATIONS_3_EVENTS(W1W2_R2R3_R3W1)
 #undef E1
 #undef E2
 #undef E3
+
+#endif
+
+#ifndef CONFIG_PREEMPT_RT
+
 /*
  * read-lock / write-lock recursion that is actually safe.
  */
@@ -1208,6 +1234,8 @@ GENERATE_PERMUTATIONS_3_EVENTS(irq_read_recursion_soft_wlock)
 #undef E2
 #undef E3
 
+#endif
+
 /*
  * read-lock / write-lock recursion that is unsafe.
  */
@@ -2456,6 +2484,7 @@ void locking_selftest(void)
 
 	printk("  --------------------------------------------------------------------------\n");
 
+#ifndef CONFIG_PREEMPT_RT
 	/*
 	 * irq-context testcases:
 	 */
@@ -2470,6 +2499,28 @@ void locking_selftest(void)
 	DO_TESTCASE_6x2x2RW("irq read-recursion #2", irq_read_recursion2);
 	DO_TESTCASE_6x2x2RW("irq read-recursion #3", irq_read_recursion3);
 
+#else
+	/* On -rt, we only do hardirq context test for raw spinlock */
+	DO_TESTCASE_1B("hard-irqs-on + irq-safe-A", irqsafe1_hard_spin, 12);
+	DO_TESTCASE_1B("hard-irqs-on + irq-safe-A", irqsafe1_hard_spin, 21);
+
+	DO_TESTCASE_1B("hard-safe-A + irqs-on", irqsafe2B_hard_spin, 12);
+	DO_TESTCASE_1B("hard-safe-A + irqs-on", irqsafe2B_hard_spin, 21);
+
+	DO_TESTCASE_1B("hard-safe-A + unsafe-B #1", irqsafe3_hard_spin, 123);
+	DO_TESTCASE_1B("hard-safe-A + unsafe-B #1", irqsafe3_hard_spin, 132);
+	DO_TESTCASE_1B("hard-safe-A + unsafe-B #1", irqsafe3_hard_spin, 213);
+	DO_TESTCASE_1B("hard-safe-A + unsafe-B #1", irqsafe3_hard_spin, 231);
+	DO_TESTCASE_1B("hard-safe-A + unsafe-B #1", irqsafe3_hard_spin, 312);
+	DO_TESTCASE_1B("hard-safe-A + unsafe-B #1", irqsafe3_hard_spin, 321);
+
+	DO_TESTCASE_1B("hard-safe-A + unsafe-B #2", irqsafe4_hard_spin, 123);
+	DO_TESTCASE_1B("hard-safe-A + unsafe-B #2", irqsafe4_hard_spin, 132);
+	DO_TESTCASE_1B("hard-safe-A + unsafe-B #2", irqsafe4_hard_spin, 213);
+	DO_TESTCASE_1B("hard-safe-A + unsafe-B #2", irqsafe4_hard_spin, 231);
+	DO_TESTCASE_1B("hard-safe-A + unsafe-B #2", irqsafe4_hard_spin, 312);
+	DO_TESTCASE_1B("hard-safe-A + unsafe-B #2", irqsafe4_hard_spin, 321);
+#endif
 	ww_tests();
 
 	force_read_lock_recursive = 0;
diff --git a/lib/nmi_backtrace.c b/lib/nmi_backtrace.c
index 8abe1870dba4..b09a490f5f70 100644
--- a/lib/nmi_backtrace.c
+++ b/lib/nmi_backtrace.c
@@ -75,12 +75,6 @@ void nmi_trigger_cpumask_backtrace(const cpumask_t *mask,
 		touch_softlockup_watchdog();
 	}
 
-	/*
-	 * Force flush any remote buffers that might be stuck in IRQ context
-	 * and therefore could not run their irq_work.
-	 */
-	printk_safe_flush();
-
 	clear_bit_unlock(0, &backtrace_flag);
 	put_cpu();
 }
diff --git a/lib/scatterlist.c b/lib/scatterlist.c
index a59778946404..907f59045998 100644
--- a/lib/scatterlist.c
+++ b/lib/scatterlist.c
@@ -892,7 +892,7 @@ void sg_miter_stop(struct sg_mapping_iter *miter)
 			flush_kernel_dcache_page(miter->page);
 
 		if (miter->__flags & SG_MITER_ATOMIC) {
-			WARN_ON_ONCE(preemptible());
+			WARN_ON_ONCE(!pagefault_disabled());
 			kunmap_atomic(miter->addr);
 		} else
 			kunmap(miter->page);
diff --git a/lib/smp_processor_id.c b/lib/smp_processor_id.c
index 2916606a9333..0c0c42b14370 100644
--- a/lib/smp_processor_id.c
+++ b/lib/smp_processor_id.c
@@ -26,6 +26,11 @@ unsigned int check_preemption_disabled(const char *what1, const char *what2)
 	if (current->nr_cpus_allowed == 1)
 		goto out;
 
+#ifdef CONFIG_SMP
+	if (current->migration_disabled)
+		goto out;
+#endif
+
 	/*
 	 * It is valid to assume CPU-locality during early bootup:
 	 */
diff --git a/lib/test_lockup.c b/lib/test_lockup.c
index 78a630bbd03d..d27a80502204 100644
--- a/lib/test_lockup.c
+++ b/lib/test_lockup.c
@@ -485,6 +485,21 @@ static int __init test_lockup_init(void)
 		return -EINVAL;
 
 #ifdef CONFIG_DEBUG_SPINLOCK
+#ifdef CONFIG_PREEMPT_RT
+	if (test_magic(lock_spinlock_ptr,
+		       offsetof(spinlock_t, lock.wait_lock.magic),
+		       SPINLOCK_MAGIC) ||
+	    test_magic(lock_rwlock_ptr,
+		       offsetof(rwlock_t, rtmutex.wait_lock.magic),
+		       SPINLOCK_MAGIC) ||
+	    test_magic(lock_mutex_ptr,
+		       offsetof(struct mutex, lock.wait_lock.magic),
+		       SPINLOCK_MAGIC) ||
+	    test_magic(lock_rwsem_ptr,
+		       offsetof(struct rw_semaphore, rtmutex.wait_lock.magic),
+		       SPINLOCK_MAGIC))
+		return -EINVAL;
+#else
 	if (test_magic(lock_spinlock_ptr,
 		       offsetof(spinlock_t, rlock.magic),
 		       SPINLOCK_MAGIC) ||
@@ -498,6 +513,7 @@ static int __init test_lockup_init(void)
 		       offsetof(struct rw_semaphore, wait_lock.magic),
 		       SPINLOCK_MAGIC))
 		return -EINVAL;
+#endif
 #endif
 
 	if ((wait_state != TASK_RUNNING ||
diff --git a/mm/Kconfig b/mm/Kconfig
index be7fd4ed2c4f..10fd751596a7 100644
--- a/mm/Kconfig
+++ b/mm/Kconfig
@@ -404,7 +404,7 @@ config NOMMU_INITIAL_TRIM_EXCESS
 
 config TRANSPARENT_HUGEPAGE
 	bool "Transparent Hugepage Support"
-	depends on HAVE_ARCH_TRANSPARENT_HUGEPAGE
+	depends on HAVE_ARCH_TRANSPARENT_HUGEPAGE && !PREEMPT_RT
 	select COMPACTION
 	select XARRAY_MULTI
 	help
@@ -995,4 +995,7 @@ config CLEAR_FREELIST_PAGE
 
 source "mm/damon/Kconfig"
 
+config KMAP_LOCAL
+	bool
+
 endmenu
diff --git a/mm/highmem.c b/mm/highmem.c
index efe38ab479b5..16f3ecd4ad35 100644
--- a/mm/highmem.c
+++ b/mm/highmem.c
@@ -31,10 +31,6 @@
 #include <asm/tlbflush.h>
 #include <linux/vmalloc.h>
 
-#if defined(CONFIG_HIGHMEM) || defined(CONFIG_X86_32)
-DEFINE_PER_CPU(int, __kmap_atomic_idx);
-#endif
-
 /*
  * Virtual_count is not a pure "count".
  *  0 means that it is not mapped, and has not been mapped
@@ -108,9 +104,7 @@ static inline wait_queue_head_t *get_pkmap_wait_queue_head(unsigned int color)
 atomic_long_t _totalhigh_pages __read_mostly;
 EXPORT_SYMBOL(_totalhigh_pages);
 
-EXPORT_PER_CPU_SYMBOL(__kmap_atomic_idx);
-
-unsigned int nr_free_highpages (void)
+unsigned int __nr_free_highpages (void)
 {
 	struct zone *zone;
 	unsigned int pages = 0;
@@ -147,7 +141,7 @@ pte_t * pkmap_page_table;
 		do { spin_unlock(&kmap_lock); (void)(flags); } while (0)
 #endif
 
-struct page *kmap_to_page(void *vaddr)
+struct page *__kmap_to_page(void *vaddr)
 {
 	unsigned long addr = (unsigned long)vaddr;
 
@@ -158,7 +152,7 @@ struct page *kmap_to_page(void *vaddr)
 
 	return virt_to_page(addr);
 }
-EXPORT_SYMBOL(kmap_to_page);
+EXPORT_SYMBOL(__kmap_to_page);
 
 static void flush_all_zero_pkmaps(void)
 {
@@ -200,10 +194,7 @@ static void flush_all_zero_pkmaps(void)
 		flush_tlb_kernel_range(PKMAP_ADDR(0), PKMAP_ADDR(LAST_PKMAP));
 }
 
-/**
- * kmap_flush_unused - flush all unused kmap mappings in order to remove stray mappings
- */
-void kmap_flush_unused(void)
+void __kmap_flush_unused(void)
 {
 	lock_kmap();
 	flush_all_zero_pkmaps();
@@ -367,7 +358,6 @@ void kunmap_high(struct page *page)
 	if (need_wakeup)
 		wake_up(pkmap_map_wait);
 }
-
 EXPORT_SYMBOL(kunmap_high);
 
 #ifdef CONFIG_TRANSPARENT_HUGEPAGE
@@ -428,7 +418,249 @@ void zero_user_segments(struct page *page, unsigned start1, unsigned end1,
 }
 EXPORT_SYMBOL(zero_user_segments);
 #endif /* CONFIG_TRANSPARENT_HUGEPAGE */
-#endif	/* CONFIG_HIGHMEM */
+#endif /* CONFIG_HIGHMEM */
+
+#ifdef CONFIG_KMAP_LOCAL
+
+#include <asm/kmap_size.h>
+
+/*
+ * With DEBUG_HIGHMEM the stack depth is doubled and every second
+ * slot is unused which acts as a guard page
+ */
+#ifdef CONFIG_DEBUG_HIGHMEM
+# define KM_INCR	2
+#else
+# define KM_INCR	1
+#endif
+
+static inline int kmap_local_idx_push(void)
+{
+	WARN_ON_ONCE(in_irq() && !irqs_disabled());
+	current->kmap_ctrl.idx += KM_INCR;
+	BUG_ON(current->kmap_ctrl.idx >= KM_MAX_IDX);
+	return current->kmap_ctrl.idx - 1;
+}
+
+static inline int kmap_local_idx(void)
+{
+	return current->kmap_ctrl.idx - 1;
+}
+
+static inline void kmap_local_idx_pop(void)
+{
+	current->kmap_ctrl.idx -= KM_INCR;
+	BUG_ON(current->kmap_ctrl.idx < 0);
+}
+
+#ifndef arch_kmap_local_post_map
+# define arch_kmap_local_post_map(vaddr, pteval)	do { } while (0)
+#endif
+
+#ifndef arch_kmap_local_pre_unmap
+# define arch_kmap_local_pre_unmap(vaddr)		do { } while (0)
+#endif
+
+#ifndef arch_kmap_local_post_unmap
+# define arch_kmap_local_post_unmap(vaddr)		do { } while (0)
+#endif
+
+#ifndef arch_kmap_local_map_idx
+#define arch_kmap_local_map_idx(idx, pfn)	kmap_local_calc_idx(idx)
+#endif
+
+#ifndef arch_kmap_local_unmap_idx
+#define arch_kmap_local_unmap_idx(idx, vaddr)	kmap_local_calc_idx(idx)
+#endif
+
+#ifndef arch_kmap_local_high_get
+static inline void *arch_kmap_local_high_get(struct page *page)
+{
+	return NULL;
+}
+#endif
+
+/* Unmap a local mapping which was obtained by kmap_high_get() */
+static inline bool kmap_high_unmap_local(unsigned long vaddr)
+{
+#ifdef ARCH_NEEDS_KMAP_HIGH_GET
+	if (vaddr >= PKMAP_ADDR(0) && vaddr < PKMAP_ADDR(LAST_PKMAP)) {
+		kunmap_high(pte_page(pkmap_page_table[PKMAP_NR(vaddr)]));
+		return true;
+	}
+#endif
+	return false;
+}
+
+static inline int kmap_local_calc_idx(int idx)
+{
+	return idx + KM_MAX_IDX * smp_processor_id();
+}
+
+static pte_t *__kmap_pte;
+
+static pte_t *kmap_get_pte(void)
+{
+	if (!__kmap_pte)
+		__kmap_pte = virt_to_kpte(__fix_to_virt(FIX_KMAP_BEGIN));
+	return __kmap_pte;
+}
+
+void *__kmap_local_pfn_prot(unsigned long pfn, pgprot_t prot)
+{
+	pte_t pteval, *kmap_pte = kmap_get_pte();
+	unsigned long vaddr;
+	int idx;
+
+	/*
+	 * Disable migration so resulting virtual address is stable
+	 * accross preemption.
+	 */
+	migrate_disable();
+	preempt_disable();
+	idx = arch_kmap_local_map_idx(kmap_local_idx_push(), pfn);
+	vaddr = __fix_to_virt(FIX_KMAP_BEGIN + idx);
+	BUG_ON(!pte_none(*(kmap_pte - idx)));
+	pteval = pfn_pte(pfn, prot);
+	set_pte_at(&init_mm, vaddr, kmap_pte - idx, pteval);
+	arch_kmap_local_post_map(vaddr, pteval);
+	current->kmap_ctrl.pteval[kmap_local_idx()] = pteval;
+	preempt_enable();
+
+	return (void *)vaddr;
+}
+EXPORT_SYMBOL_GPL(__kmap_local_pfn_prot);
+
+void *__kmap_local_page_prot(struct page *page, pgprot_t prot)
+{
+	void *kmap;
+
+	if (!PageHighMem(page))
+		return page_address(page);
+
+	/* Try kmap_high_get() if architecture has it enabled */
+	kmap = arch_kmap_local_high_get(page);
+	if (kmap)
+		return kmap;
+
+	return __kmap_local_pfn_prot(page_to_pfn(page), prot);
+}
+EXPORT_SYMBOL(__kmap_local_page_prot);
+
+void kunmap_local_indexed(void *vaddr)
+{
+	unsigned long addr = (unsigned long) vaddr & PAGE_MASK;
+	pte_t *kmap_pte = kmap_get_pte();
+	int idx;
+
+	if (addr < __fix_to_virt(FIX_KMAP_END) ||
+	    addr > __fix_to_virt(FIX_KMAP_BEGIN)) {
+		/*
+		 * Handle mappings which were obtained by kmap_high_get()
+		 * first as the virtual address of such mappings is below
+		 * PAGE_OFFSET. Warn for all other addresses which are in
+		 * the user space part of the virtual address space.
+		 */
+		if (!kmap_high_unmap_local(addr))
+			WARN_ON_ONCE(addr < PAGE_OFFSET);
+		return;
+	}
+
+	preempt_disable();
+	idx = arch_kmap_local_unmap_idx(kmap_local_idx(), addr);
+	WARN_ON_ONCE(addr != __fix_to_virt(FIX_KMAP_BEGIN + idx));
+
+	arch_kmap_local_pre_unmap(addr);
+	pte_clear(&init_mm, addr, kmap_pte - idx);
+	arch_kmap_local_post_unmap(addr);
+	current->kmap_ctrl.pteval[kmap_local_idx()] = __pte(0);
+	kmap_local_idx_pop();
+	preempt_enable();
+	migrate_enable();
+}
+EXPORT_SYMBOL(kunmap_local_indexed);
+
+/*
+ * Invoked before switch_to(). This is safe even when during or after
+ * clearing the maps an interrupt which needs a kmap_local happens because
+ * the task::kmap_ctrl.idx is not modified by the unmapping code so a
+ * nested kmap_local will use the next unused index and restore the index
+ * on unmap. The already cleared kmaps of the outgoing task are irrelevant
+ * because the interrupt context does not know about them. The same applies
+ * when scheduling back in for an interrupt which happens before the
+ * restore is complete.
+ */
+void __kmap_local_sched_out(void)
+{
+	struct task_struct *tsk = current;
+	pte_t *kmap_pte = kmap_get_pte();
+	int i;
+
+	/* Clear kmaps */
+	for (i = 0; i < tsk->kmap_ctrl.idx; i++) {
+		pte_t pteval = tsk->kmap_ctrl.pteval[i];
+		unsigned long addr;
+		int idx;
+
+		/* With debug all even slots are unmapped and act as guard */
+		if (IS_ENABLED(CONFIG_DEBUG_HIGHMEM) && !(i & 0x01)) {
+			WARN_ON_ONCE(!pte_none(pteval));
+			continue;
+		}
+		if (WARN_ON_ONCE(pte_none(pteval)))
+			continue;
+
+		/*
+		 * This is a horrible hack for XTENSA to calculate the
+		 * coloured PTE index. Uses the PFN encoded into the pteval
+		 * and the map index calculation because the actual mapped
+		 * virtual address is not stored in task::kmap_ctrl.
+		 * For any sane architecture this is optimized out.
+		 */
+		idx = arch_kmap_local_map_idx(i, pte_pfn(pteval));
+
+		addr = __fix_to_virt(FIX_KMAP_BEGIN + idx);
+		arch_kmap_local_pre_unmap(addr);
+		pte_clear(&init_mm, addr, kmap_pte - idx);
+		arch_kmap_local_post_unmap(addr);
+	}
+}
+
+void __kmap_local_sched_in(void)
+{
+	struct task_struct *tsk = current;
+	pte_t *kmap_pte = kmap_get_pte();
+	int i;
+
+	/* Restore kmaps */
+	for (i = 0; i < tsk->kmap_ctrl.idx; i++) {
+		pte_t pteval = tsk->kmap_ctrl.pteval[i];
+		unsigned long addr;
+		int idx;
+
+		/* With debug all even slots are unmapped and act as guard */
+		if (IS_ENABLED(CONFIG_DEBUG_HIGHMEM) && !(i & 0x01)) {
+			WARN_ON_ONCE(!pte_none(pteval));
+			continue;
+		}
+		if (WARN_ON_ONCE(pte_none(pteval)))
+			continue;
+
+		/* See comment in __kmap_local_sched_out() */
+		idx = arch_kmap_local_map_idx(i, pte_pfn(pteval));
+		addr = __fix_to_virt(FIX_KMAP_BEGIN + idx);
+		set_pte_at(&init_mm, addr, kmap_pte - idx, pteval);
+		arch_kmap_local_post_map(addr, pteval);
+	}
+}
+
+void kmap_local_fork(struct task_struct *tsk)
+{
+	if (WARN_ON_ONCE(tsk->kmap_ctrl.idx))
+		memset(&tsk->kmap_ctrl, 0, sizeof(tsk->kmap_ctrl));
+}
+
+#endif
 
 #if defined(HASHED_PAGE_VIRTUAL)
 
diff --git a/mm/memcontrol.c b/mm/memcontrol.c
index b2c4bc4bb591..6cf0ac765634 100644
--- a/mm/memcontrol.c
+++ b/mm/memcontrol.c
@@ -67,6 +67,7 @@
 #include <net/sock.h>
 #include <net/ip.h>
 #include "slab.h"
+#include <linux/local_lock.h>
 
 #include <linux/uaccess.h>
 
@@ -96,6 +97,12 @@ bool cgroup_memory_noswap __read_mostly;
 #ifdef CONFIG_CGROUP_WRITEBACK
 static DECLARE_WAIT_QUEUE_HEAD(memcg_cgwb_frn_waitq);
 #endif
+struct event_lock {
+	local_lock_t l;
+};
+static DEFINE_PER_CPU(struct event_lock, event_lock) = {
+	.l      = INIT_LOCAL_LOCK(l),
+};
 
 /* Whether legacy memory+swap accounting is active */
 static bool do_memsw_account(void)
@@ -756,6 +763,7 @@ void __mod_memcg_lruvec_state(struct lruvec *lruvec, enum node_stat_item idx,
 	pn = container_of(lruvec, struct mem_cgroup_per_node, lruvec);
 	memcg = pn->memcg;
 
+	preempt_disable_rt();
 	/* Update memcg */
 	__this_cpu_add(memcg->vmstats_percpu->state[idx], val);
 
@@ -763,6 +771,7 @@ void __mod_memcg_lruvec_state(struct lruvec *lruvec, enum node_stat_item idx,
 	__this_cpu_add(pn->lruvec_stats_percpu->state[idx], val);
 
 	memcg_rstat_updated(memcg);
+	preempt_enable_rt();
 }
 
 /**
@@ -2172,6 +2181,7 @@ void unlock_page_memcg(struct page *page)
 EXPORT_SYMBOL(unlock_page_memcg);
 
 struct memcg_stock_pcp {
+	local_lock_t lock;
 	struct mem_cgroup *cached; /* this never be root cgroup */
 	unsigned int nr_pages;
 
@@ -2223,7 +2233,7 @@ static bool consume_stock(struct mem_cgroup *memcg, unsigned int nr_pages)
 	if (nr_pages > MEMCG_CHARGE_BATCH)
 		return ret;
 
-	local_irq_save(flags);
+	local_lock_irqsave(&memcg_stock.lock, flags);
 
 	stock = this_cpu_ptr(&memcg_stock);
 	if (memcg == stock->cached && stock->nr_pages >= nr_pages) {
@@ -2231,7 +2241,7 @@ static bool consume_stock(struct mem_cgroup *memcg, unsigned int nr_pages)
 		ret = true;
 	}
 
-	local_irq_restore(flags);
+	local_unlock_irqrestore(&memcg_stock.lock, flags);
 
 	return ret;
 }
@@ -2266,14 +2276,14 @@ static void drain_local_stock(struct work_struct *dummy)
 	 * The only protection from memory hotplug vs. drain_stock races is
 	 * that we always operate on local CPU stock here with IRQ disabled
 	 */
-	local_irq_save(flags);
+	local_lock_irqsave(&memcg_stock.lock, flags);
 
 	stock = this_cpu_ptr(&memcg_stock);
 	drain_obj_stock(stock);
 	drain_stock(stock);
 	clear_bit(FLUSHING_CACHED_CHARGE, &stock->flags);
 
-	local_irq_restore(flags);
+	local_unlock_irqrestore(&memcg_stock.lock, flags);
 }
 
 /*
@@ -2285,7 +2295,7 @@ static void refill_stock(struct mem_cgroup *memcg, unsigned int nr_pages)
 	struct memcg_stock_pcp *stock;
 	unsigned long flags;
 
-	local_irq_save(flags);
+	local_lock_irqsave(&memcg_stock.lock, flags);
 
 	stock = this_cpu_ptr(&memcg_stock);
 	if (stock->cached != memcg) { /* reset if necessary */
@@ -2298,7 +2308,7 @@ static void refill_stock(struct mem_cgroup *memcg, unsigned int nr_pages)
 	if (stock->nr_pages > MEMCG_CHARGE_BATCH)
 		drain_stock(stock);
 
-	local_irq_restore(flags);
+	local_unlock_irqrestore(&memcg_stock.lock, flags);
 }
 
 /*
@@ -2318,7 +2328,7 @@ static void drain_all_stock(struct mem_cgroup *root_memcg)
 	 * as well as workers from this path always operate on the local
 	 * per-cpu data. CPU up doesn't touch memcg_stock at all.
 	 */
-	curcpu = get_cpu();
+	curcpu = get_cpu_light();
 	for_each_online_cpu(cpu) {
 		struct memcg_stock_pcp *stock = &per_cpu(memcg_stock, cpu);
 		struct mem_cgroup *memcg;
@@ -2341,7 +2351,7 @@ static void drain_all_stock(struct mem_cgroup *root_memcg)
 				schedule_work_on(cpu, &stock->work);
 		}
 	}
-	put_cpu();
+	put_cpu_light();
 	mutex_unlock(&percpu_charge_mutex);
 }
 
@@ -3143,7 +3153,7 @@ static bool consume_obj_stock(struct obj_cgroup *objcg, unsigned int nr_bytes)
 	unsigned long flags;
 	bool ret = false;
 
-	local_irq_save(flags);
+	local_lock_irqsave(&memcg_stock.lock, flags);
 
 	stock = this_cpu_ptr(&memcg_stock);
 	if (objcg == stock->cached_objcg && stock->nr_bytes >= nr_bytes) {
@@ -3151,7 +3161,7 @@ static bool consume_obj_stock(struct obj_cgroup *objcg, unsigned int nr_bytes)
 		ret = true;
 	}
 
-	local_irq_restore(flags);
+	local_unlock_irqrestore(&memcg_stock.lock, flags);
 
 	return ret;
 }
@@ -3207,7 +3217,7 @@ static void refill_obj_stock(struct obj_cgroup *objcg, unsigned int nr_bytes)
 	struct memcg_stock_pcp *stock;
 	unsigned long flags;
 
-	local_irq_save(flags);
+	local_lock_irqsave(&memcg_stock.lock, flags);
 
 	stock = this_cpu_ptr(&memcg_stock);
 	if (stock->cached_objcg != objcg) { /* reset if necessary */
@@ -3221,7 +3231,7 @@ static void refill_obj_stock(struct obj_cgroup *objcg, unsigned int nr_bytes)
 	if (stock->nr_bytes > PAGE_SIZE)
 		drain_obj_stock(stock);
 
-	local_irq_restore(flags);
+	local_unlock_irqrestore(&memcg_stock.lock, flags);
 }
 
 int obj_cgroup_charge(struct obj_cgroup *objcg, gfp_t gfp, size_t size)
@@ -6312,12 +6322,12 @@ static int mem_cgroup_move_account(struct page *page,
 
 	ret = 0;
 
-	local_irq_disable();
+	local_lock_irq(&event_lock.l);
 	mem_cgroup_charge_statistics(to, page, nr_pages);
 	memcg_check_events(to, page);
 	mem_cgroup_charge_statistics(from, page, -nr_pages);
 	memcg_check_events(from, page);
-	local_irq_enable();
+	local_unlock_irq(&event_lock.l);
 out_unlock:
 	unlock_page(page);
 out:
@@ -7294,10 +7304,10 @@ int mem_cgroup_charge(struct page *page, struct mm_struct *mm, gfp_t gfp_mask)
 	css_get(&memcg->css);
 	commit_charge(page, memcg);
 
-	local_irq_disable();
+	local_lock_irq(&event_lock.l);
 	mem_cgroup_charge_statistics(memcg, page, nr_pages);
 	memcg_check_events(memcg, page);
-	local_irq_enable();
+	local_unlock_irq(&event_lock.l);
 
 	/*
 	 * Cgroup1's unified memory+swap counter has been charged with the
@@ -7353,11 +7363,11 @@ static void uncharge_batch(const struct uncharge_gather *ug)
 		memcg_oom_recover(ug->memcg);
 	}
 
-	local_irq_save(flags);
+	local_lock_irqsave(&event_lock.l, flags);
 	__count_memcg_events(ug->memcg, PGPGOUT, ug->pgpgout);
 	__this_cpu_add(ug->memcg->vmstats_percpu->nr_page_events, ug->nr_memory);
 	memcg_check_events(ug->memcg, ug->dummy_page);
-	local_irq_restore(flags);
+	local_unlock_irqrestore(&event_lock.l, flags);
 
 	/* drop reference from uncharge_page */
 	css_put(&ug->memcg->css);
@@ -7529,10 +7539,10 @@ void mem_cgroup_migrate(struct page *oldpage, struct page *newpage)
 	css_get(&memcg->css);
 	commit_charge(newpage, memcg);
 
-	local_irq_save(flags);
+	local_lock_irqsave(&event_lock.l, flags);
 	mem_cgroup_charge_statistics(memcg, newpage, nr_pages);
 	memcg_check_events(memcg, newpage);
-	local_irq_restore(flags);
+	local_unlock_irqrestore(&event_lock.l, flags);
 }
 
 DEFINE_STATIC_KEY_FALSE(memcg_sockets_enabled_key);
@@ -7662,9 +7672,13 @@ static int __init mem_cgroup_init(void)
 	cpuhp_setup_state_nocalls(CPUHP_MM_MEMCQ_DEAD, "mm/memctrl:dead", NULL,
 				  memcg_hotplug_cpu_dead);
 
-	for_each_possible_cpu(cpu)
-		INIT_WORK(&per_cpu_ptr(&memcg_stock, cpu)->work,
-			  drain_local_stock);
+	for_each_possible_cpu(cpu) {
+		struct memcg_stock_pcp *stock;
+
+		stock = per_cpu_ptr(&memcg_stock, cpu);
+		INIT_WORK(&stock->work, drain_local_stock);
+		local_lock_init(&stock->lock);
+	}
 
 	for_each_node(node) {
 		struct mem_cgroup_tree_per_node *rtpn;
@@ -7715,6 +7729,7 @@ void mem_cgroup_swapout(struct page *page, swp_entry_t entry)
 	struct mem_cgroup *memcg, *swap_memcg;
 	unsigned int nr_entries;
 	unsigned short oldid;
+	unsigned long flags;
 
 	VM_BUG_ON_PAGE(PageLRU(page), page);
 	VM_BUG_ON_PAGE(page_count(page), page);
@@ -7760,9 +7775,13 @@ void mem_cgroup_swapout(struct page *page, swp_entry_t entry)
 	 * important here to have the interrupts disabled because it is the
 	 * only synchronisation we have for updating the per-CPU variables.
 	 */
+	local_lock_irqsave(&event_lock.l, flags);
+#ifndef CONFIG_PREEMPT_RT
 	VM_BUG_ON(!irqs_disabled());
+#endif
 	mem_cgroup_charge_statistics(memcg, page, -nr_entries);
 	memcg_check_events(memcg, page);
+	local_unlock_irqrestore(&event_lock.l, flags);
 
 	css_put(&memcg->css);
 }
diff --git a/mm/page_alloc.c b/mm/page_alloc.c
index 274b68a147ea..933f08627e7b 100644
--- a/mm/page_alloc.c
+++ b/mm/page_alloc.c
@@ -61,6 +61,7 @@
 #include <linux/hugetlb.h>
 #include <linux/sched/rt.h>
 #include <linux/sched/mm.h>
+#include <linux/local_lock.h>
 #include <linux/page_owner.h>
 #include <linux/kthread.h>
 #include <linux/memcontrol.h>
@@ -389,6 +390,13 @@ EXPORT_SYMBOL(nr_node_ids);
 EXPORT_SYMBOL(nr_online_nodes);
 #endif
 
+struct pa_lock {
+	local_lock_t l;
+};
+static DEFINE_PER_CPU(struct pa_lock, pa_lock) = {
+	.l	= INIT_LOCAL_LOCK(l),
+};
+
 int page_group_by_mobility_disabled __read_mostly;
 
 #ifdef CONFIG_DEFERRED_STRUCT_PAGE_INIT
@@ -1333,7 +1341,7 @@ static inline void prefetch_buddy(struct page *page)
 }
 
 /*
- * Frees a number of pages from the PCP lists
+ * Frees a number of pages which have been collected from the pcp lists.
  * Assumes all pages on list are in same zone, and of same order.
  * count is the number of pages to free.
  *
@@ -1343,15 +1351,56 @@ static inline void prefetch_buddy(struct page *page)
  * And clear the zone's pages_scanned counter, to hold off the "all pages are
  * pinned" detection logic.
  */
-static void free_pcppages_bulk(struct zone *zone, int count,
-					struct per_cpu_pages *pcp)
+static void free_pcppages_bulk(struct zone *zone, struct list_head *head,
+			       bool zone_retry)
+{
+	bool isolated_pageblocks;
+	struct page *page, *tmp;
+	unsigned long flags;
+
+	spin_lock_irqsave(&zone->lock, flags);
+	isolated_pageblocks = has_isolate_pageblock(zone);
+
+	/*
+	 * Use safe version since after __free_one_page(),
+	 * page->lru.next will not point to original list.
+	 */
+	list_for_each_entry_safe(page, tmp, head, lru) {
+		int mt = get_pcppage_migratetype(page);
+
+		if (page_zone(page) != zone) {
+			/*
+			 * free_unref_page_list() sorts pages by zone. If we end
+			 * up with pages from a different NUMA nodes belonging
+			 * to the same ZONE index then we need to redo with the
+			 * correct ZONE pointer. Skip the page for now, redo it
+			 * on the next iteration.
+			 */
+			WARN_ON_ONCE(zone_retry == false);
+			if (zone_retry)
+				continue;
+		}
+
+		/* MIGRATE_ISOLATE page should not go to pcplists */
+		VM_BUG_ON_PAGE(is_migrate_isolate(mt), page);
+		/* Pageblock could have been isolated meanwhile */
+		if (unlikely(isolated_pageblocks))
+			mt = get_pageblock_migratetype(page);
+
+		list_del(&page->lru);
+		__free_one_page(page, page_to_pfn(page), zone, 0, mt, FPI_NONE);
+		trace_mm_page_pcpu_drain(page, 0, mt);
+	}
+	spin_unlock_irqrestore(&zone->lock, flags);
+}
+
+static void isolate_pcp_pages(int count, struct per_cpu_pages *pcp,
+			      struct list_head *dst)
 {
 	int migratetype = 0;
 	int batch_free = 0;
 	int prefetch_nr = READ_ONCE(pcp->batch);
-	bool isolated_pageblocks;
-	struct page *page, *tmp;
-	LIST_HEAD(head);
+	struct page *page;
 
 	/*
 	 * Ensure proper count is passed which otherwise would stuck in the
@@ -1388,7 +1437,7 @@ static void free_pcppages_bulk(struct zone *zone, int count,
 			if (bulkfree_pcp_prepare(page))
 				continue;
 
-			list_add_tail(&page->lru, &head);
+			list_add_tail(&page->lru, dst);
 
 			/*
 			 * We are going to put the page back to the global
@@ -1405,26 +1454,6 @@ static void free_pcppages_bulk(struct zone *zone, int count,
 			}
 		} while (--count && --batch_free && !list_empty(list));
 	}
-
-	spin_lock(&zone->lock);
-	isolated_pageblocks = has_isolate_pageblock(zone);
-
-	/*
-	 * Use safe version since after __free_one_page(),
-	 * page->lru.next will not point to original list.
-	 */
-	list_for_each_entry_safe(page, tmp, &head, lru) {
-		int mt = get_pcppage_migratetype(page);
-		/* MIGRATE_ISOLATE page should not go to pcplists */
-		VM_BUG_ON_PAGE(is_migrate_isolate(mt), page);
-		/* Pageblock could have been isolated meanwhile */
-		if (unlikely(isolated_pageblocks))
-			mt = get_pageblock_migratetype(page);
-
-		__free_one_page(page, page_to_pfn(page), zone, 0, mt, FPI_NONE);
-		trace_mm_page_pcpu_drain(page, 0, mt);
-	}
-	spin_unlock(&zone->lock);
 }
 
 static void free_one_page(struct zone *zone,
@@ -1526,11 +1555,11 @@ static void __free_pages_ok(struct page *page, unsigned int order,
 		return;
 
 	migratetype = get_pfnblock_migratetype(page, pfn);
-	local_irq_save(flags);
+	local_lock_irqsave(&pa_lock.l, flags);
 	__count_vm_events(PGFREE, 1 << order);
 	free_one_page(page_zone(page), page, pfn, order, migratetype,
 		      fpi_flags);
-	local_irq_restore(flags);
+	local_unlock_irqrestore(&pa_lock.l, flags);
 }
 
 void __free_pages_core(struct page *page, unsigned int order)
@@ -2941,13 +2970,18 @@ void drain_zone_pages(struct zone *zone, struct per_cpu_pages *pcp)
 {
 	unsigned long flags;
 	int to_drain, batch;
+	LIST_HEAD(dst);
 
-	local_irq_save(flags);
+	local_lock_irqsave(&pa_lock.l, flags);
 	batch = READ_ONCE(pcp->batch);
 	to_drain = min(pcp->count, batch);
 	if (to_drain > 0)
-		free_pcppages_bulk(zone, to_drain, pcp);
-	local_irq_restore(flags);
+		isolate_pcp_pages(to_drain, pcp, &dst);
+
+	local_unlock_irqrestore(&pa_lock.l, flags);
+
+	if (to_drain > 0)
+		free_pcppages_bulk(zone, &dst, false);
 }
 #endif
 
@@ -2963,14 +2997,21 @@ static void drain_pages_zone(unsigned int cpu, struct zone *zone)
 	unsigned long flags;
 	struct per_cpu_pageset *pset;
 	struct per_cpu_pages *pcp;
+	LIST_HEAD(dst);
+	int count;
 
-	local_irq_save(flags);
+	local_lock_irqsave(&pa_lock.l, flags);
 	pset = per_cpu_ptr(zone->pageset, cpu);
 
 	pcp = &pset->pcp;
-	if (pcp->count)
-		free_pcppages_bulk(zone, pcp->count, pcp);
-	local_irq_restore(flags);
+	count = pcp->count;
+	if (count)
+		isolate_pcp_pages(count, pcp, &dst);
+
+	local_unlock_irqrestore(&pa_lock.l, flags);
+
+	if (count)
+		free_pcppages_bulk(zone, &dst, false);
 }
 
 /*
@@ -3018,9 +3059,9 @@ static void drain_local_pages_wq(struct work_struct *work)
 	 * cpu which is allright but we also have to make sure to not move to
 	 * a different one.
 	 */
-	preempt_disable();
+	migrate_disable();
 	drain_local_pages(drain->zone);
-	preempt_enable();
+	migrate_enable();
 }
 
 /*
@@ -3190,7 +3231,8 @@ static bool free_unref_page_prepare(struct page *page, unsigned long pfn)
 	return true;
 }
 
-static void free_unref_page_commit(struct page *page, unsigned long pfn)
+static void free_unref_page_commit(struct page *page, unsigned long pfn,
+				   struct list_head *dst)
 {
 	struct zone *zone = page_zone(page);
 	struct per_cpu_pages *pcp;
@@ -3218,8 +3260,11 @@ static void free_unref_page_commit(struct page *page, unsigned long pfn)
 	pcp = &this_cpu_ptr(zone->pageset)->pcp;
 	list_add(&page->lru, &pcp->lists[migratetype]);
 	pcp->count++;
-	if (pcp->count >= READ_ONCE(pcp->high))
-		free_pcppages_bulk(zone, READ_ONCE(pcp->batch), pcp);
+	if (pcp->count >= READ_ONCE(pcp->high)) {
+		unsigned long batch = READ_ONCE(pcp->batch);
+
+		isolate_pcp_pages(batch, pcp, dst);
+	}
 }
 
 /*
@@ -3229,6 +3274,8 @@ void free_unref_page(struct page *page)
 {
 	unsigned long flags;
 	unsigned long pfn = page_to_pfn(page);
+	struct zone *zone = page_zone(page);
+	LIST_HEAD(dst);
 
 	/* Free dynamic hugetlb page */
 	if (free_page_to_dhugetlb_pool(page))
@@ -3237,9 +3284,11 @@ void free_unref_page(struct page *page)
 	if (!free_unref_page_prepare(page, pfn))
 		return;
 
-	local_irq_save(flags);
-	free_unref_page_commit(page, pfn);
-	local_irq_restore(flags);
+	local_lock_irqsave(&pa_lock.l, flags);
+	free_unref_page_commit(page, pfn, &dst);
+	local_unlock_irqrestore(&pa_lock.l, flags);
+	if (!list_empty(&dst))
+		free_pcppages_bulk(zone, &dst, false);
 }
 
 /*
@@ -3250,6 +3299,11 @@ void free_unref_page_list(struct list_head *list)
 	struct page *page, *next;
 	unsigned long flags, pfn;
 	int batch_count = 0;
+	struct list_head dsts[__MAX_NR_ZONES];
+	int i;
+
+	for (i = 0; i < __MAX_NR_ZONES; i++)
+		INIT_LIST_HEAD(&dsts[i]);
 
 	/* Free dynamic hugetlb page list */
 	free_page_list_to_dhugetlb_pool(list);
@@ -3262,25 +3316,42 @@ void free_unref_page_list(struct list_head *list)
 		set_page_private(page, pfn);
 	}
 
-	local_irq_save(flags);
+	local_lock_irqsave(&pa_lock.l, flags);
 	list_for_each_entry_safe(page, next, list, lru) {
 		unsigned long pfn = page_private(page);
+		enum zone_type type;
 
 		set_page_private(page, 0);
 		trace_mm_page_free_batched(page);
-		free_unref_page_commit(page, pfn);
+		type = page_zonenum(page);
+		free_unref_page_commit(page, pfn, &dsts[type]);
 
 		/*
 		 * Guard against excessive IRQ disabled times when we get
 		 * a large list of pages to free.
 		 */
 		if (++batch_count == SWAP_CLUSTER_MAX) {
-			local_irq_restore(flags);
+			local_unlock_irqrestore(&pa_lock.l, flags);
 			batch_count = 0;
-			local_irq_save(flags);
+			local_lock_irqsave(&pa_lock.l, flags);
 		}
 	}
-	local_irq_restore(flags);
+	local_unlock_irqrestore(&pa_lock.l, flags);
+
+	for (i = 0; i < __MAX_NR_ZONES; ) {
+		struct page *page;
+		struct zone *zone;
+
+		if (list_empty(&dsts[i])) {
+			i++;
+			continue;
+		}
+
+		page = list_first_entry(&dsts[i], struct page, lru);
+		zone = page_zone(page);
+
+		free_pcppages_bulk(zone, &dsts[i], true);
+	}
 }
 
 /*
@@ -3437,7 +3508,7 @@ static struct page *rmqueue_pcplist(struct zone *preferred_zone,
 	struct page *page;
 	unsigned long flags;
 
-	local_irq_save(flags);
+	local_lock_irqsave(&pa_lock.l, flags);
 	pcp = &this_cpu_ptr(zone->pageset)->pcp;
 	list = &pcp->lists[migratetype];
 	page = __rmqueue_pcplist(zone,  migratetype, alloc_flags, pcp, list);
@@ -3445,7 +3516,7 @@ static struct page *rmqueue_pcplist(struct zone *preferred_zone,
 		__count_zid_vm_events(PGALLOC, page_zonenum(page), 1);
 		zone_statistics(preferred_zone, zone);
 	}
-	local_irq_restore(flags);
+	local_unlock_irqrestore(&pa_lock.l, flags);
 	return page;
 }
 
@@ -3479,7 +3550,8 @@ struct page *rmqueue(struct zone *preferred_zone,
 	 * allocate greater than order-1 page units with __GFP_NOFAIL.
 	 */
 	WARN_ON_ONCE((gfp_flags & __GFP_NOFAIL) && (order > 1));
-	spin_lock_irqsave(&zone->lock, flags);
+	local_lock_irqsave(&pa_lock.l, flags);
+	spin_lock(&zone->lock);
 
 	do {
 		page = NULL;
@@ -3505,7 +3577,7 @@ struct page *rmqueue(struct zone *preferred_zone,
 
 	__count_zid_vm_events(PGALLOC, page_zonenum(page), 1 << order);
 	zone_statistics(preferred_zone, zone);
-	local_irq_restore(flags);
+	local_unlock_irqrestore(&pa_lock.l, flags);
 
 out:
 	/* Separate test+clear to avoid unnecessary atomics */
@@ -3518,7 +3590,7 @@ struct page *rmqueue(struct zone *preferred_zone,
 	return page;
 
 failed:
-	local_irq_restore(flags);
+	local_unlock_irqrestore(&pa_lock.l, flags);
 	return NULL;
 }
 
@@ -9252,7 +9324,7 @@ void zone_pcp_reset(struct zone *zone)
 	struct per_cpu_pageset *pset;
 
 	/* avoid races with drain_pages()  */
-	local_irq_save(flags);
+	local_lock_irqsave(&pa_lock.l, flags);
 	if (zone->pageset != &boot_pageset) {
 		for_each_online_cpu(cpu) {
 			pset = per_cpu_ptr(zone->pageset, cpu);
@@ -9261,7 +9333,7 @@ void zone_pcp_reset(struct zone *zone)
 		free_percpu(zone->pageset);
 		zone->pageset = &boot_pageset;
 	}
-	local_irq_restore(flags);
+	local_unlock_irqrestore(&pa_lock.l, flags);
 }
 
 #ifdef CONFIG_MEMORY_HOTREMOVE
diff --git a/mm/shmem.c b/mm/shmem.c
index f7caf1dec81c..bc971d864e9a 100644
--- a/mm/shmem.c
+++ b/mm/shmem.c
@@ -307,10 +307,10 @@ static int shmem_reserve_inode(struct super_block *sb, ino_t *inop)
 	ino_t ino;
 
 	if (!(sb->s_flags & SB_KERNMOUNT)) {
-		spin_lock(&sbinfo->stat_lock);
+		raw_spin_lock(&sbinfo->stat_lock);
 		if (sbinfo->max_inodes) {
 			if (!sbinfo->free_inodes) {
-				spin_unlock(&sbinfo->stat_lock);
+				raw_spin_unlock(&sbinfo->stat_lock);
 				return -ENOSPC;
 			}
 			sbinfo->free_inodes--;
@@ -333,7 +333,7 @@ static int shmem_reserve_inode(struct super_block *sb, ino_t *inop)
 			}
 			*inop = ino;
 		}
-		spin_unlock(&sbinfo->stat_lock);
+		raw_spin_unlock(&sbinfo->stat_lock);
 	} else if (inop) {
 		/*
 		 * __shmem_file_setup, one of our callers, is lock-free: it
@@ -348,13 +348,14 @@ static int shmem_reserve_inode(struct super_block *sb, ino_t *inop)
 		 * to worry about things like glibc compatibility.
 		 */
 		ino_t *next_ino;
+
 		next_ino = per_cpu_ptr(sbinfo->ino_batch, get_cpu());
 		ino = *next_ino;
 		if (unlikely(ino % SHMEM_INO_BATCH == 0)) {
-			spin_lock(&sbinfo->stat_lock);
+			raw_spin_lock(&sbinfo->stat_lock);
 			ino = sbinfo->next_ino;
 			sbinfo->next_ino += SHMEM_INO_BATCH;
-			spin_unlock(&sbinfo->stat_lock);
+			raw_spin_unlock(&sbinfo->stat_lock);
 			if (unlikely(is_zero_ino(ino)))
 				ino++;
 		}
@@ -370,9 +371,9 @@ static void shmem_free_inode(struct super_block *sb)
 {
 	struct shmem_sb_info *sbinfo = SHMEM_SB(sb);
 	if (sbinfo->max_inodes) {
-		spin_lock(&sbinfo->stat_lock);
+		raw_spin_lock(&sbinfo->stat_lock);
 		sbinfo->free_inodes++;
-		spin_unlock(&sbinfo->stat_lock);
+		raw_spin_unlock(&sbinfo->stat_lock);
 	}
 }
 
@@ -1471,10 +1472,10 @@ static struct mempolicy *shmem_get_sbmpol(struct shmem_sb_info *sbinfo)
 {
 	struct mempolicy *mpol = NULL;
 	if (sbinfo->mpol) {
-		spin_lock(&sbinfo->stat_lock);	/* prevent replace/use races */
+		raw_spin_lock(&sbinfo->stat_lock);	/* prevent replace/use races */
 		mpol = sbinfo->mpol;
 		mpol_get(mpol);
-		spin_unlock(&sbinfo->stat_lock);
+		raw_spin_unlock(&sbinfo->stat_lock);
 	}
 	return mpol;
 }
@@ -3575,9 +3576,10 @@ static int shmem_reconfigure(struct fs_context *fc)
 	struct shmem_options *ctx = fc->fs_private;
 	struct shmem_sb_info *sbinfo = SHMEM_SB(fc->root->d_sb);
 	unsigned long inodes;
+  struct mempolicy *mpol = NULL;
 	const char *err;
 
-	spin_lock(&sbinfo->stat_lock);
+	raw_spin_lock(&sbinfo->stat_lock);
 	inodes = sbinfo->max_inodes - sbinfo->free_inodes;
 
 	if ((ctx->seen & SHMEM_SEEN_BLOCKS) && ctx->blocks) {
@@ -3623,14 +3625,15 @@ static int shmem_reconfigure(struct fs_context *fc)
 	 * Preserve previous mempolicy unless mpol remount option was specified.
 	 */
 	if (ctx->mpol) {
-		mpol_put(sbinfo->mpol);
+		mpol = sbinfo->mpol;
 		sbinfo->mpol = ctx->mpol;	/* transfers initial ref */
 		ctx->mpol = NULL;
 	}
-	spin_unlock(&sbinfo->stat_lock);
+	raw_spin_unlock(&sbinfo->stat_lock);
+	mpol_put(mpol);
 	return 0;
 out:
-	spin_unlock(&sbinfo->stat_lock);
+	raw_spin_unlock(&sbinfo->stat_lock);
 	return invalfc(fc, "%s", err);
 }
 
@@ -3747,7 +3750,7 @@ static int shmem_fill_super(struct super_block *sb, struct fs_context *fc)
 	sbinfo->mpol = ctx->mpol;
 	ctx->mpol = NULL;
 
-	spin_lock_init(&sbinfo->stat_lock);
+	raw_spin_lock_init(&sbinfo->stat_lock);
 	if (percpu_counter_init(&sbinfo->used_blocks, 0, GFP_KERNEL))
 		goto failed;
 	spin_lock_init(&sbinfo->shrinklist_lock);
diff --git a/mm/slab.c b/mm/slab.c
index ae84578f3fde..a65a5f169fd5 100644
--- a/mm/slab.c
+++ b/mm/slab.c
@@ -234,7 +234,7 @@ static void kmem_cache_node_init(struct kmem_cache_node *parent)
 	parent->shared = NULL;
 	parent->alien = NULL;
 	parent->colour_next = 0;
-	spin_lock_init(&parent->list_lock);
+	raw_spin_lock_init(&parent->list_lock);
 	parent->free_objects = 0;
 	parent->free_touched = 0;
 }
@@ -559,9 +559,9 @@ static noinline void cache_free_pfmemalloc(struct kmem_cache *cachep,
 	page_node = page_to_nid(page);
 	n = get_node(cachep, page_node);
 
-	spin_lock(&n->list_lock);
+	raw_spin_lock(&n->list_lock);
 	free_block(cachep, &objp, 1, page_node, &list);
-	spin_unlock(&n->list_lock);
+	raw_spin_unlock(&n->list_lock);
 
 	slabs_destroy(cachep, &list);
 }
@@ -699,7 +699,7 @@ static void __drain_alien_cache(struct kmem_cache *cachep,
 	struct kmem_cache_node *n = get_node(cachep, node);
 
 	if (ac->avail) {
-		spin_lock(&n->list_lock);
+		raw_spin_lock(&n->list_lock);
 		/*
 		 * Stuff objects into the remote nodes shared array first.
 		 * That way we could avoid the overhead of putting the objects
@@ -710,7 +710,7 @@ static void __drain_alien_cache(struct kmem_cache *cachep,
 
 		free_block(cachep, ac->entry, ac->avail, node, list);
 		ac->avail = 0;
-		spin_unlock(&n->list_lock);
+		raw_spin_unlock(&n->list_lock);
 	}
 }
 
@@ -783,9 +783,9 @@ static int __cache_free_alien(struct kmem_cache *cachep, void *objp,
 		slabs_destroy(cachep, &list);
 	} else {
 		n = get_node(cachep, page_node);
-		spin_lock(&n->list_lock);
+		raw_spin_lock(&n->list_lock);
 		free_block(cachep, &objp, 1, page_node, &list);
-		spin_unlock(&n->list_lock);
+		raw_spin_unlock(&n->list_lock);
 		slabs_destroy(cachep, &list);
 	}
 	return 1;
@@ -826,10 +826,10 @@ static int init_cache_node(struct kmem_cache *cachep, int node, gfp_t gfp)
 	 */
 	n = get_node(cachep, node);
 	if (n) {
-		spin_lock_irq(&n->list_lock);
+		raw_spin_lock_irq(&n->list_lock);
 		n->free_limit = (1 + nr_cpus_node(node)) * cachep->batchcount +
 				cachep->num;
-		spin_unlock_irq(&n->list_lock);
+		raw_spin_unlock_irq(&n->list_lock);
 
 		return 0;
 	}
@@ -908,7 +908,7 @@ static int setup_kmem_cache_node(struct kmem_cache *cachep,
 		goto fail;
 
 	n = get_node(cachep, node);
-	spin_lock_irq(&n->list_lock);
+	raw_spin_lock_irq(&n->list_lock);
 	if (n->shared && force_change) {
 		free_block(cachep, n->shared->entry,
 				n->shared->avail, node, &list);
@@ -926,7 +926,7 @@ static int setup_kmem_cache_node(struct kmem_cache *cachep,
 		new_alien = NULL;
 	}
 
-	spin_unlock_irq(&n->list_lock);
+	raw_spin_unlock_irq(&n->list_lock);
 	slabs_destroy(cachep, &list);
 
 	/*
@@ -965,7 +965,7 @@ static void cpuup_canceled(long cpu)
 		if (!n)
 			continue;
 
-		spin_lock_irq(&n->list_lock);
+		raw_spin_lock_irq(&n->list_lock);
 
 		/* Free limit for this kmem_cache_node */
 		n->free_limit -= cachep->batchcount;
@@ -976,7 +976,7 @@ static void cpuup_canceled(long cpu)
 		nc->avail = 0;
 
 		if (!cpumask_empty(mask)) {
-			spin_unlock_irq(&n->list_lock);
+			raw_spin_unlock_irq(&n->list_lock);
 			goto free_slab;
 		}
 
@@ -990,7 +990,7 @@ static void cpuup_canceled(long cpu)
 		alien = n->alien;
 		n->alien = NULL;
 
-		spin_unlock_irq(&n->list_lock);
+		raw_spin_unlock_irq(&n->list_lock);
 
 		kfree(shared);
 		if (alien) {
@@ -1174,7 +1174,7 @@ static void __init init_list(struct kmem_cache *cachep, struct kmem_cache_node *
 	/*
 	 * Do not assume that spinlocks can be initialized via memcpy:
 	 */
-	spin_lock_init(&ptr->list_lock);
+	raw_spin_lock_init(&ptr->list_lock);
 
 	MAKE_ALL_LISTS(cachep, ptr, nodeid);
 	cachep->node[nodeid] = ptr;
@@ -1345,11 +1345,11 @@ slab_out_of_memory(struct kmem_cache *cachep, gfp_t gfpflags, int nodeid)
 	for_each_kmem_cache_node(cachep, node, n) {
 		unsigned long total_slabs, free_slabs, free_objs;
 
-		spin_lock_irqsave(&n->list_lock, flags);
+		raw_spin_lock_irqsave(&n->list_lock, flags);
 		total_slabs = n->total_slabs;
 		free_slabs = n->free_slabs;
 		free_objs = n->free_objects;
-		spin_unlock_irqrestore(&n->list_lock, flags);
+		raw_spin_unlock_irqrestore(&n->list_lock, flags);
 
 		pr_warn("  node %d: slabs: %ld/%ld, objs: %ld/%ld\n",
 			node, total_slabs - free_slabs, total_slabs,
@@ -2106,7 +2106,7 @@ static void check_spinlock_acquired(struct kmem_cache *cachep)
 {
 #ifdef CONFIG_SMP
 	check_irq_off();
-	assert_spin_locked(&get_node(cachep, numa_mem_id())->list_lock);
+	assert_raw_spin_locked(&get_node(cachep, numa_mem_id())->list_lock);
 #endif
 }
 
@@ -2114,7 +2114,7 @@ static void check_spinlock_acquired_node(struct kmem_cache *cachep, int node)
 {
 #ifdef CONFIG_SMP
 	check_irq_off();
-	assert_spin_locked(&get_node(cachep, node)->list_lock);
+	assert_raw_spin_locked(&get_node(cachep, node)->list_lock);
 #endif
 }
 
@@ -2154,9 +2154,9 @@ static void do_drain(void *arg)
 	check_irq_off();
 	ac = cpu_cache_get(cachep);
 	n = get_node(cachep, node);
-	spin_lock(&n->list_lock);
+	raw_spin_lock(&n->list_lock);
 	free_block(cachep, ac->entry, ac->avail, node, &list);
-	spin_unlock(&n->list_lock);
+	raw_spin_unlock(&n->list_lock);
 	ac->avail = 0;
 	slabs_destroy(cachep, &list);
 }
@@ -2174,9 +2174,9 @@ static void drain_cpu_caches(struct kmem_cache *cachep)
 			drain_alien_cache(cachep, n->alien);
 
 	for_each_kmem_cache_node(cachep, node, n) {
-		spin_lock_irq(&n->list_lock);
+		raw_spin_lock_irq(&n->list_lock);
 		drain_array_locked(cachep, n->shared, node, true, &list);
-		spin_unlock_irq(&n->list_lock);
+		raw_spin_unlock_irq(&n->list_lock);
 
 		slabs_destroy(cachep, &list);
 	}
@@ -2198,10 +2198,10 @@ static int drain_freelist(struct kmem_cache *cache,
 	nr_freed = 0;
 	while (nr_freed < tofree && !list_empty(&n->slabs_free)) {
 
-		spin_lock_irq(&n->list_lock);
+		raw_spin_lock_irq(&n->list_lock);
 		p = n->slabs_free.prev;
 		if (p == &n->slabs_free) {
-			spin_unlock_irq(&n->list_lock);
+			raw_spin_unlock_irq(&n->list_lock);
 			goto out;
 		}
 
@@ -2214,7 +2214,7 @@ static int drain_freelist(struct kmem_cache *cache,
 		 * to the cache.
 		 */
 		n->free_objects -= cache->num;
-		spin_unlock_irq(&n->list_lock);
+		raw_spin_unlock_irq(&n->list_lock);
 		slab_destroy(cache, page);
 		nr_freed++;
 	}
@@ -2650,7 +2650,7 @@ static void cache_grow_end(struct kmem_cache *cachep, struct page *page)
 	INIT_LIST_HEAD(&page->slab_list);
 	n = get_node(cachep, page_to_nid(page));
 
-	spin_lock(&n->list_lock);
+	raw_spin_lock(&n->list_lock);
 	n->total_slabs++;
 	if (!page->active) {
 		list_add_tail(&page->slab_list, &n->slabs_free);
@@ -2660,7 +2660,7 @@ static void cache_grow_end(struct kmem_cache *cachep, struct page *page)
 
 	STATS_INC_GROWN(cachep);
 	n->free_objects += cachep->num - page->active;
-	spin_unlock(&n->list_lock);
+	raw_spin_unlock(&n->list_lock);
 
 	fixup_objfreelist_debug(cachep, &list);
 }
@@ -2826,7 +2826,7 @@ static struct page *get_first_slab(struct kmem_cache_node *n, bool pfmemalloc)
 {
 	struct page *page;
 
-	assert_spin_locked(&n->list_lock);
+	assert_raw_spin_locked(&n->list_lock);
 	page = list_first_entry_or_null(&n->slabs_partial, struct page,
 					slab_list);
 	if (!page) {
@@ -2853,10 +2853,10 @@ static noinline void *cache_alloc_pfmemalloc(struct kmem_cache *cachep,
 	if (!gfp_pfmemalloc_allowed(flags))
 		return NULL;
 
-	spin_lock(&n->list_lock);
+	raw_spin_lock(&n->list_lock);
 	page = get_first_slab(n, true);
 	if (!page) {
-		spin_unlock(&n->list_lock);
+		raw_spin_unlock(&n->list_lock);
 		return NULL;
 	}
 
@@ -2865,7 +2865,7 @@ static noinline void *cache_alloc_pfmemalloc(struct kmem_cache *cachep,
 
 	fixup_slab_list(cachep, n, page, &list);
 
-	spin_unlock(&n->list_lock);
+	raw_spin_unlock(&n->list_lock);
 	fixup_objfreelist_debug(cachep, &list);
 
 	return obj;
@@ -2924,7 +2924,7 @@ static void *cache_alloc_refill(struct kmem_cache *cachep, gfp_t flags)
 	if (!n->free_objects && (!shared || !shared->avail))
 		goto direct_grow;
 
-	spin_lock(&n->list_lock);
+	raw_spin_lock(&n->list_lock);
 	shared = READ_ONCE(n->shared);
 
 	/* See if we can refill from the shared array */
@@ -2948,7 +2948,7 @@ static void *cache_alloc_refill(struct kmem_cache *cachep, gfp_t flags)
 must_grow:
 	n->free_objects -= ac->avail;
 alloc_done:
-	spin_unlock(&n->list_lock);
+	raw_spin_unlock(&n->list_lock);
 	fixup_objfreelist_debug(cachep, &list);
 
 direct_grow:
@@ -3173,7 +3173,7 @@ static void *____cache_alloc_node(struct kmem_cache *cachep, gfp_t flags,
 	BUG_ON(!n);
 
 	check_irq_off();
-	spin_lock(&n->list_lock);
+	raw_spin_lock(&n->list_lock);
 	page = get_first_slab(n, false);
 	if (!page)
 		goto must_grow;
@@ -3191,12 +3191,12 @@ static void *____cache_alloc_node(struct kmem_cache *cachep, gfp_t flags,
 
 	fixup_slab_list(cachep, n, page, &list);
 
-	spin_unlock(&n->list_lock);
+	raw_spin_unlock(&n->list_lock);
 	fixup_objfreelist_debug(cachep, &list);
 	return obj;
 
 must_grow:
-	spin_unlock(&n->list_lock);
+	raw_spin_unlock(&n->list_lock);
 	page = cache_grow_begin(cachep, gfp_exact_node(flags), nodeid);
 	if (page) {
 		/* This slab isn't counted yet so don't update free_objects */
@@ -3384,7 +3384,7 @@ static void cache_flusharray(struct kmem_cache *cachep, struct array_cache *ac)
 
 	check_irq_off();
 	n = get_node(cachep, node);
-	spin_lock(&n->list_lock);
+	raw_spin_lock(&n->list_lock);
 	if (n->shared) {
 		struct array_cache *shared_array = n->shared;
 		int max = shared_array->limit - shared_array->avail;
@@ -3413,7 +3413,7 @@ static void cache_flusharray(struct kmem_cache *cachep, struct array_cache *ac)
 		STATS_SET_FREEABLE(cachep, i);
 	}
 #endif
-	spin_unlock(&n->list_lock);
+	raw_spin_unlock(&n->list_lock);
 	ac->avail -= batchcount;
 	memmove(ac->entry, &(ac->entry[batchcount]), sizeof(void *)*ac->avail);
 	slabs_destroy(cachep, &list);
@@ -3849,9 +3849,9 @@ static int do_tune_cpucache(struct kmem_cache *cachep, int limit,
 
 		node = cpu_to_mem(cpu);
 		n = get_node(cachep, node);
-		spin_lock_irq(&n->list_lock);
+		raw_spin_lock_irq(&n->list_lock);
 		free_block(cachep, ac->entry, ac->avail, node, &list);
-		spin_unlock_irq(&n->list_lock);
+		raw_spin_unlock_irq(&n->list_lock);
 		slabs_destroy(cachep, &list);
 	}
 	free_percpu(prev);
@@ -3946,9 +3946,9 @@ static void drain_array(struct kmem_cache *cachep, struct kmem_cache_node *n,
 		return;
 	}
 
-	spin_lock_irq(&n->list_lock);
+	raw_spin_lock_irq(&n->list_lock);
 	drain_array_locked(cachep, ac, node, false, &list);
-	spin_unlock_irq(&n->list_lock);
+	raw_spin_unlock_irq(&n->list_lock);
 
 	slabs_destroy(cachep, &list);
 }
@@ -4032,7 +4032,7 @@ void get_slabinfo(struct kmem_cache *cachep, struct slabinfo *sinfo)
 
 	for_each_kmem_cache_node(cachep, node, n) {
 		check_irq_on();
-		spin_lock_irq(&n->list_lock);
+		raw_spin_lock_irq(&n->list_lock);
 
 		total_slabs += n->total_slabs;
 		free_slabs += n->free_slabs;
@@ -4041,7 +4041,7 @@ void get_slabinfo(struct kmem_cache *cachep, struct slabinfo *sinfo)
 		if (n->shared)
 			shared_avail += n->shared->avail;
 
-		spin_unlock_irq(&n->list_lock);
+		raw_spin_unlock_irq(&n->list_lock);
 	}
 	num_objs = total_slabs * cachep->num;
 	active_slabs = total_slabs - free_slabs;
diff --git a/mm/slab.h b/mm/slab.h
index 8414c345127b..d937f8673193 100644
--- a/mm/slab.h
+++ b/mm/slab.h
@@ -523,7 +523,7 @@ static inline void slab_post_alloc_hook(struct kmem_cache *s,
  * The slab lists for all objects.
  */
 struct kmem_cache_node {
-	spinlock_t list_lock;
+	raw_spinlock_t list_lock;
 
 #ifdef CONFIG_SLAB
 	struct list_head slabs_partial;	/* partial list first, better asm code */
diff --git a/mm/slub.c b/mm/slub.c
index ad44734dbf72..d558074fe384 100644
--- a/mm/slub.c
+++ b/mm/slub.c
@@ -458,7 +458,7 @@ static inline bool cmpxchg_double_slab(struct kmem_cache *s, struct page *page,
 
 #ifdef CONFIG_SLUB_DEBUG
 static unsigned long object_map[BITS_TO_LONGS(MAX_OBJS_PER_PAGE)];
-static DEFINE_SPINLOCK(object_map_lock);
+static DEFINE_RAW_SPINLOCK(object_map_lock);
 
 /*
  * Determine a map of object in use on a page.
@@ -474,7 +474,7 @@ static unsigned long *get_map(struct kmem_cache *s, struct page *page)
 
 	VM_BUG_ON(!irqs_disabled());
 
-	spin_lock(&object_map_lock);
+	raw_spin_lock(&object_map_lock);
 
 	bitmap_zero(object_map, page->objects);
 
@@ -487,7 +487,7 @@ static unsigned long *get_map(struct kmem_cache *s, struct page *page)
 static void put_map(unsigned long *map) __releases(&object_map_lock)
 {
 	VM_BUG_ON(map != object_map);
-	spin_unlock(&object_map_lock);
+	raw_spin_unlock(&object_map_lock);
 }
 
 static inline unsigned int size_from_object(struct kmem_cache *s)
@@ -1238,7 +1238,7 @@ static noinline int free_debug_processing(
 	unsigned long flags;
 	int ret = 0;
 
-	spin_lock_irqsave(&n->list_lock, flags);
+	raw_spin_lock_irqsave(&n->list_lock, flags);
 	slab_lock(page);
 
 	if (s->flags & SLAB_CONSISTENCY_CHECKS) {
@@ -1273,7 +1273,7 @@ static noinline int free_debug_processing(
 			 bulk_cnt, cnt);
 
 	slab_unlock(page);
-	spin_unlock_irqrestore(&n->list_lock, flags);
+	raw_spin_unlock_irqrestore(&n->list_lock, flags);
 	if (!ret)
 		slab_fix(s, "Object at 0x%p not freed", object);
 	return ret;
@@ -1521,6 +1521,12 @@ static bool freelist_corrupted(struct kmem_cache *s, struct page *page,
 }
 #endif /* CONFIG_SLUB_DEBUG */
 
+struct slub_free_list {
+	raw_spinlock_t		lock;
+	struct list_head	list;
+};
+static DEFINE_PER_CPU(struct slub_free_list, slub_free_list);
+
 /*
  * Hooks for other subsystems that check memory allocations. In a typical
  * production configuration these hooks all should produce no code at all.
@@ -1776,10 +1782,18 @@ static struct page *allocate_slab(struct kmem_cache *s, gfp_t flags, int node)
 	void *start, *p, *next;
 	int idx;
 	bool shuffle;
+	bool enableirqs = false;
 
 	flags &= gfp_allowed_mask;
 
 	if (gfpflags_allow_blocking(flags))
+		enableirqs = true;
+
+#ifdef CONFIG_PREEMPT_RT
+	if (system_state > SYSTEM_BOOTING && system_state < SYSTEM_SUSPEND)
+		enableirqs = true;
+#endif
+	if (enableirqs)
 		local_irq_enable();
 
 	flags |= s->allocflags;
@@ -1838,7 +1852,7 @@ static struct page *allocate_slab(struct kmem_cache *s, gfp_t flags, int node)
 	page->frozen = 1;
 
 out:
-	if (gfpflags_allow_blocking(flags))
+	if (enableirqs)
 		local_irq_disable();
 	if (!page)
 		return NULL;
@@ -1881,6 +1895,16 @@ static void __free_slab(struct kmem_cache *s, struct page *page)
 	__free_pages(page, order);
 }
 
+static void free_delayed(struct list_head *h)
+{
+	while (!list_empty(h)) {
+		struct page *page = list_first_entry(h, struct page, lru);
+
+		list_del(&page->lru);
+		__free_slab(page->slab_cache, page);
+	}
+}
+
 static void rcu_free_slab(struct rcu_head *h)
 {
 	struct page *page = container_of(h, struct page, rcu_head);
@@ -1892,6 +1916,12 @@ static void free_slab(struct kmem_cache *s, struct page *page)
 {
 	if (unlikely(s->flags & SLAB_TYPESAFE_BY_RCU)) {
 		call_rcu(&page->rcu_head, rcu_free_slab);
+	} else if (irqs_disabled()) {
+		struct slub_free_list *f = this_cpu_ptr(&slub_free_list);
+
+		raw_spin_lock(&f->lock);
+		list_add(&page->lru, &f->list);
+		raw_spin_unlock(&f->lock);
 	} else
 		__free_slab(s, page);
 }
@@ -1999,7 +2029,7 @@ static void *get_partial_node(struct kmem_cache *s, struct kmem_cache_node *n,
 	if (!n || !n->nr_partial)
 		return NULL;
 
-	spin_lock(&n->list_lock);
+	raw_spin_lock(&n->list_lock);
 	list_for_each_entry_safe(page, page2, &n->partial, slab_list) {
 		void *t;
 
@@ -2024,7 +2054,7 @@ static void *get_partial_node(struct kmem_cache *s, struct kmem_cache_node *n,
 			break;
 
 	}
-	spin_unlock(&n->list_lock);
+	raw_spin_unlock(&n->list_lock);
 	return object;
 }
 
@@ -2267,7 +2297,7 @@ static void deactivate_slab(struct kmem_cache *s, struct page *page,
 			 * that acquire_slab() will see a slab page that
 			 * is frozen
 			 */
-			spin_lock(&n->list_lock);
+			raw_spin_lock(&n->list_lock);
 		}
 	} else {
 		m = M_FULL;
@@ -2279,7 +2309,7 @@ static void deactivate_slab(struct kmem_cache *s, struct page *page,
 			 * slabs from diagnostic functions will not see
 			 * any frozen slabs.
 			 */
-			spin_lock(&n->list_lock);
+			raw_spin_lock(&n->list_lock);
 		}
 #endif
 	}
@@ -2304,7 +2334,7 @@ static void deactivate_slab(struct kmem_cache *s, struct page *page,
 		goto redo;
 
 	if (lock)
-		spin_unlock(&n->list_lock);
+		raw_spin_unlock(&n->list_lock);
 
 	if (m == M_PARTIAL)
 		stat(s, tail);
@@ -2344,10 +2374,10 @@ static void unfreeze_partials(struct kmem_cache *s,
 		n2 = get_node(s, page_to_nid(page));
 		if (n != n2) {
 			if (n)
-				spin_unlock(&n->list_lock);
+				raw_spin_unlock(&n->list_lock);
 
 			n = n2;
-			spin_lock(&n->list_lock);
+			raw_spin_lock(&n->list_lock);
 		}
 
 		do {
@@ -2376,7 +2406,7 @@ static void unfreeze_partials(struct kmem_cache *s,
 	}
 
 	if (n)
-		spin_unlock(&n->list_lock);
+		raw_spin_unlock(&n->list_lock);
 
 	while (discard_page) {
 		page = discard_page;
@@ -2413,14 +2443,21 @@ static void put_cpu_partial(struct kmem_cache *s, struct page *page, int drain)
 			pobjects = oldpage->pobjects;
 			pages = oldpage->pages;
 			if (drain && pobjects > slub_cpu_partial(s)) {
+				struct slub_free_list *f;
 				unsigned long flags;
+				LIST_HEAD(tofree);
 				/*
 				 * partial array is full. Move the existing
 				 * set to the per node partial list.
 				 */
 				local_irq_save(flags);
 				unfreeze_partials(s, this_cpu_ptr(s->cpu_slab));
+				f = this_cpu_ptr(&slub_free_list);
+				raw_spin_lock(&f->lock);
+				list_splice_init(&f->list, &tofree);
+				raw_spin_unlock(&f->lock);
 				local_irq_restore(flags);
+				free_delayed(&tofree);
 				oldpage = NULL;
 				pobjects = 0;
 				pages = 0;
@@ -2486,7 +2523,19 @@ static bool has_cpu_slab(int cpu, void *info)
 
 static void flush_all(struct kmem_cache *s)
 {
+	LIST_HEAD(tofree);
+	int cpu;
+
 	on_each_cpu_cond(has_cpu_slab, flush_cpu_slab, s, 1);
+	for_each_online_cpu(cpu) {
+		struct slub_free_list *f;
+
+		f = &per_cpu(slub_free_list, cpu);
+		raw_spin_lock_irq(&f->lock);
+		list_splice_init(&f->list, &tofree);
+		raw_spin_unlock_irq(&f->lock);
+		free_delayed(&tofree);
+	}
 }
 
 /*
@@ -2541,10 +2590,10 @@ static unsigned long count_partial(struct kmem_cache_node *n,
 	unsigned long x = 0;
 	struct page *page;
 
-	spin_lock_irqsave(&n->list_lock, flags);
+	raw_spin_lock_irqsave(&n->list_lock, flags);
 	list_for_each_entry(page, &n->partial, slab_list)
 		x += get_count(page);
-	spin_unlock_irqrestore(&n->list_lock, flags);
+	raw_spin_unlock_irqrestore(&n->list_lock, flags);
 	return x;
 }
 #endif /* CONFIG_SLUB_DEBUG || CONFIG_SYSFS */
@@ -2683,8 +2732,10 @@ static inline void *get_freelist(struct kmem_cache *s, struct page *page)
  * already disabled (which is the case for bulk allocation).
  */
 static void *___slab_alloc(struct kmem_cache *s, gfp_t gfpflags, int node,
-			  unsigned long addr, struct kmem_cache_cpu *c)
+			  unsigned long addr, struct kmem_cache_cpu *c,
+			  struct list_head *to_free)
 {
+	struct slub_free_list *f;
 	void *freelist;
 	struct page *page;
 
@@ -2753,6 +2804,13 @@ static void *___slab_alloc(struct kmem_cache *s, gfp_t gfpflags, int node,
 	VM_BUG_ON(!c->page->frozen);
 	c->freelist = get_freepointer(s, freelist);
 	c->tid = next_tid(c->tid);
+
+out:
+	f = this_cpu_ptr(&slub_free_list);
+	raw_spin_lock(&f->lock);
+	list_splice_init(&f->list, to_free);
+	raw_spin_unlock(&f->lock);
+
 	return freelist;
 
 new_slab:
@@ -2768,7 +2826,7 @@ static void *___slab_alloc(struct kmem_cache *s, gfp_t gfpflags, int node,
 
 	if (unlikely(!freelist)) {
 		slab_out_of_memory(s, gfpflags, node);
-		return NULL;
+		goto out;
 	}
 
 	page = c->page;
@@ -2781,7 +2839,7 @@ static void *___slab_alloc(struct kmem_cache *s, gfp_t gfpflags, int node,
 		goto new_slab;	/* Slab failed checks. Next slab needed */
 
 	deactivate_slab(s, page, get_freepointer(s, freelist), c);
-	return freelist;
+	goto out;
 }
 
 /*
@@ -2793,6 +2851,7 @@ static void *__slab_alloc(struct kmem_cache *s, gfp_t gfpflags, int node,
 {
 	void *p;
 	unsigned long flags;
+	LIST_HEAD(tofree);
 
 	local_irq_save(flags);
 #ifdef CONFIG_PREEMPTION
@@ -2804,8 +2863,9 @@ static void *__slab_alloc(struct kmem_cache *s, gfp_t gfpflags, int node,
 	c = this_cpu_ptr(s->cpu_slab);
 #endif
 
-	p = ___slab_alloc(s, gfpflags, node, addr, c);
+	p = ___slab_alloc(s, gfpflags, node, addr, c, &tofree);
 	local_irq_restore(flags);
+	free_delayed(&tofree);
 	return p;
 }
 
@@ -2839,6 +2899,10 @@ static __always_inline void *slab_alloc_node(struct kmem_cache *s,
 	unsigned long tid;
 	struct obj_cgroup *objcg = NULL;
 
+	if (IS_ENABLED(CONFIG_PREEMPT_RT) && IS_ENABLED(CONFIG_DEBUG_ATOMIC_SLEEP))
+		WARN_ON_ONCE(!preemptible() &&
+			     (system_state > SYSTEM_BOOTING && system_state < SYSTEM_SUSPEND));
+
 	s = slab_pre_alloc_hook(s, &objcg, 1, gfpflags);
 	if (!s)
 		return NULL;
@@ -3013,7 +3077,7 @@ static void __slab_free(struct kmem_cache *s, struct page *page,
 
 	do {
 		if (unlikely(n)) {
-			spin_unlock_irqrestore(&n->list_lock, flags);
+			raw_spin_unlock_irqrestore(&n->list_lock, flags);
 			n = NULL;
 		}
 		prior = page->freelist;
@@ -3045,7 +3109,7 @@ static void __slab_free(struct kmem_cache *s, struct page *page,
 				 * Otherwise the list_lock will synchronize with
 				 * other processors updating the list of slabs.
 				 */
-				spin_lock_irqsave(&n->list_lock, flags);
+				raw_spin_lock_irqsave(&n->list_lock, flags);
 
 			}
 		}
@@ -3087,7 +3151,7 @@ static void __slab_free(struct kmem_cache *s, struct page *page,
 		add_partial(n, page, DEACTIVATE_TO_TAIL);
 		stat(s, FREE_ADD_PARTIAL);
 	}
-	spin_unlock_irqrestore(&n->list_lock, flags);
+	raw_spin_unlock_irqrestore(&n->list_lock, flags);
 	return;
 
 slab_empty:
@@ -3102,7 +3166,7 @@ static void __slab_free(struct kmem_cache *s, struct page *page,
 		remove_full(s, n, page);
 	}
 
-	spin_unlock_irqrestore(&n->list_lock, flags);
+	raw_spin_unlock_irqrestore(&n->list_lock, flags);
 	stat(s, FREE_SLAB);
 	discard_slab(s, page);
 }
@@ -3329,9 +3393,14 @@ int kmem_cache_alloc_bulk(struct kmem_cache *s, gfp_t flags, size_t size,
 			  void **p)
 {
 	struct kmem_cache_cpu *c;
+	LIST_HEAD(to_free);
 	int i;
 	struct obj_cgroup *objcg = NULL;
 
+	if (IS_ENABLED(CONFIG_PREEMPT_RT) && IS_ENABLED(CONFIG_DEBUG_ATOMIC_SLEEP))
+		WARN_ON_ONCE(!preemptible() &&
+			     (system_state > SYSTEM_BOOTING && system_state < SYSTEM_SUSPEND));
+
 	/* memcg and kmem_cache debug support */
 	s = slab_pre_alloc_hook(s, &objcg, size, flags);
 	if (unlikely(!s))
@@ -3368,7 +3437,7 @@ int kmem_cache_alloc_bulk(struct kmem_cache *s, gfp_t flags, size_t size,
 			 * of re-populating per CPU c->freelist
 			 */
 			p[i] = ___slab_alloc(s, flags, NUMA_NO_NODE,
-					    _RET_IP_, c);
+					    _RET_IP_, c, &to_free);
 			if (unlikely(!p[i]))
 				goto error;
 
@@ -3383,6 +3452,7 @@ int kmem_cache_alloc_bulk(struct kmem_cache *s, gfp_t flags, size_t size,
 	}
 	c->tid = next_tid(c->tid);
 	local_irq_enable();
+	free_delayed(&to_free);
 
 	/* Clear memory outside IRQ disabled fastpath loop */
 	if (unlikely(slab_want_init_on_alloc(flags, s))) {
@@ -3397,6 +3467,7 @@ int kmem_cache_alloc_bulk(struct kmem_cache *s, gfp_t flags, size_t size,
 	return i;
 error:
 	local_irq_enable();
+	free_delayed(&to_free);
 	slab_post_alloc_hook(s, objcg, flags, i, p);
 	__kmem_cache_free_bulk(s, i, p);
 	return 0;
@@ -3532,7 +3603,7 @@ static void
 init_kmem_cache_node(struct kmem_cache_node *n)
 {
 	n->nr_partial = 0;
-	spin_lock_init(&n->list_lock);
+	raw_spin_lock_init(&n->list_lock);
 	INIT_LIST_HEAD(&n->partial);
 #ifdef CONFIG_SLUB_DEBUG
 	atomic_long_set(&n->nr_slabs, 0);
@@ -3927,7 +3998,7 @@ static void free_partial(struct kmem_cache *s, struct kmem_cache_node *n)
 	struct page *page, *h;
 
 	BUG_ON(irqs_disabled());
-	spin_lock_irq(&n->list_lock);
+	raw_spin_lock_irq(&n->list_lock);
 	list_for_each_entry_safe(page, h, &n->partial, slab_list) {
 		if (!page->inuse) {
 			remove_partial(n, page);
@@ -3937,7 +4008,7 @@ static void free_partial(struct kmem_cache *s, struct kmem_cache_node *n)
 			  "Objects remaining in %s on __kmem_cache_shutdown()");
 		}
 	}
-	spin_unlock_irq(&n->list_lock);
+	raw_spin_unlock_irq(&n->list_lock);
 
 	list_for_each_entry_safe(page, h, &discard, slab_list)
 		discard_slab(s, page);
@@ -4206,7 +4277,7 @@ int __kmem_cache_shrink(struct kmem_cache *s)
 		for (i = 0; i < SHRINK_PROMOTE_MAX; i++)
 			INIT_LIST_HEAD(promote + i);
 
-		spin_lock_irqsave(&n->list_lock, flags);
+		raw_spin_lock_irqsave(&n->list_lock, flags);
 
 		/*
 		 * Build lists of slabs to discard or promote.
@@ -4237,7 +4308,7 @@ int __kmem_cache_shrink(struct kmem_cache *s)
 		for (i = SHRINK_PROMOTE_MAX - 1; i >= 0; i--)
 			list_splice(promote + i, &n->partial);
 
-		spin_unlock_irqrestore(&n->list_lock, flags);
+		raw_spin_unlock_irqrestore(&n->list_lock, flags);
 
 		/* Release empty slabs */
 		list_for_each_entry_safe(page, t, &discard, slab_list)
@@ -4413,6 +4484,12 @@ void __init kmem_cache_init(void)
 	static __initdata struct kmem_cache boot_kmem_cache,
 		boot_kmem_cache_node;
 	int node;
+	int cpu;
+
+	for_each_possible_cpu(cpu) {
+		raw_spin_lock_init(&per_cpu(slub_free_list, cpu).lock);
+		INIT_LIST_HEAD(&per_cpu(slub_free_list, cpu).list);
+	}
 
 	if (debug_guardpage_minorder())
 		slub_max_order = 0;
@@ -4611,7 +4688,7 @@ static int validate_slab_node(struct kmem_cache *s,
 	struct page *page;
 	unsigned long flags;
 
-	spin_lock_irqsave(&n->list_lock, flags);
+	raw_spin_lock_irqsave(&n->list_lock, flags);
 
 	list_for_each_entry(page, &n->partial, slab_list) {
 		validate_slab(s, page);
@@ -4633,7 +4710,7 @@ static int validate_slab_node(struct kmem_cache *s,
 		       s->name, count, atomic_long_read(&n->nr_slabs));
 
 out:
-	spin_unlock_irqrestore(&n->list_lock, flags);
+	raw_spin_unlock_irqrestore(&n->list_lock, flags);
 	return count;
 }
 
@@ -4684,6 +4761,9 @@ static int alloc_loc_track(struct loc_track *t, unsigned long max, gfp_t flags)
 	struct location *l;
 	int order;
 
+	if (IS_ENABLED(CONFIG_PREEMPT_RT) && flags == GFP_ATOMIC)
+		return 0;
+
 	order = get_order(sizeof(struct location) * max);
 
 	l = (void *)__get_free_pages(flags, order);
@@ -4812,12 +4892,12 @@ static int list_locations(struct kmem_cache *s, char *buf,
 		if (!atomic_long_read(&n->nr_slabs))
 			continue;
 
-		spin_lock_irqsave(&n->list_lock, flags);
+		raw_spin_lock_irqsave(&n->list_lock, flags);
 		list_for_each_entry(page, &n->partial, slab_list)
 			process_slab(&t, s, page, alloc);
 		list_for_each_entry(page, &n->full, slab_list)
 			process_slab(&t, s, page, alloc);
-		spin_unlock_irqrestore(&n->list_lock, flags);
+		raw_spin_unlock_irqrestore(&n->list_lock, flags);
 	}
 
 	for (i = 0; i < t.count; i++) {
diff --git a/mm/vmalloc.c b/mm/vmalloc.c
index d7a68eb0db42..ebe4de5f90d9 100644
--- a/mm/vmalloc.c
+++ b/mm/vmalloc.c
@@ -1887,7 +1887,7 @@ static void *new_vmap_block(unsigned int order, gfp_t gfp_mask)
 	struct vmap_block *vb;
 	struct vmap_area *va;
 	unsigned long vb_idx;
-	int node, err;
+	int node, err, cpu;
 	void *vaddr;
 
 	node = numa_node_id();
@@ -1924,11 +1924,12 @@ static void *new_vmap_block(unsigned int order, gfp_t gfp_mask)
 		return ERR_PTR(err);
 	}
 
-	vbq = &get_cpu_var(vmap_block_queue);
+	cpu = get_cpu_light();
+	vbq = this_cpu_ptr(&vmap_block_queue);
 	spin_lock(&vbq->lock);
 	list_add_tail_rcu(&vb->free_list, &vbq->free);
 	spin_unlock(&vbq->lock);
-	put_cpu_var(vmap_block_queue);
+	put_cpu_light();
 
 	return vaddr;
 }
@@ -1993,6 +1994,7 @@ static void *vb_alloc(unsigned long size, gfp_t gfp_mask)
 	struct vmap_block *vb;
 	void *vaddr = NULL;
 	unsigned int order;
+	int cpu;
 
 	BUG_ON(offset_in_page(size));
 	BUG_ON(size > PAGE_SIZE*VMAP_MAX_ALLOC);
@@ -2007,7 +2009,8 @@ static void *vb_alloc(unsigned long size, gfp_t gfp_mask)
 	order = get_order(size);
 
 	rcu_read_lock();
-	vbq = &get_cpu_var(vmap_block_queue);
+	cpu = get_cpu_light();
+	vbq = this_cpu_ptr(&vmap_block_queue);
 	list_for_each_entry_rcu(vb, &vbq->free, free_list) {
 		unsigned long pages_off;
 
@@ -2030,7 +2033,7 @@ static void *vb_alloc(unsigned long size, gfp_t gfp_mask)
 		break;
 	}
 
-	put_cpu_var(vmap_block_queue);
+	put_cpu_light();
 	rcu_read_unlock();
 
 	/* Allocate new block if nothing was found */
diff --git a/mm/vmstat.c b/mm/vmstat.c
index 05433f66376b..afb32defb498 100644
--- a/mm/vmstat.c
+++ b/mm/vmstat.c
@@ -321,6 +321,7 @@ void __mod_zone_page_state(struct zone *zone, enum zone_stat_item item,
 	long x;
 	long t;
 
+	preempt_disable_rt();
 	x = delta + __this_cpu_read(*p);
 
 	t = __this_cpu_read(pcp->stat_threshold);
@@ -330,6 +331,7 @@ void __mod_zone_page_state(struct zone *zone, enum zone_stat_item item,
 		x = 0;
 	}
 	__this_cpu_write(*p, x);
+	preempt_enable_rt();
 }
 EXPORT_SYMBOL(__mod_zone_page_state);
 
@@ -346,6 +348,7 @@ void __mod_node_page_state(struct pglist_data *pgdat, enum node_stat_item item,
 		delta >>= PAGE_SHIFT;
 	}
 
+	preempt_disable_rt();
 	x = delta + __this_cpu_read(*p);
 
 	t = __this_cpu_read(pcp->stat_threshold);
@@ -355,6 +358,7 @@ void __mod_node_page_state(struct pglist_data *pgdat, enum node_stat_item item,
 		x = 0;
 	}
 	__this_cpu_write(*p, x);
+	preempt_enable_rt();
 }
 EXPORT_SYMBOL(__mod_node_page_state);
 
@@ -387,6 +391,7 @@ void __inc_zone_state(struct zone *zone, enum zone_stat_item item)
 	s8 __percpu *p = pcp->vm_stat_diff + item;
 	s8 v, t;
 
+	preempt_disable_rt();
 	v = __this_cpu_inc_return(*p);
 	t = __this_cpu_read(pcp->stat_threshold);
 	if (unlikely(v > t)) {
@@ -395,6 +400,7 @@ void __inc_zone_state(struct zone *zone, enum zone_stat_item item)
 		zone_page_state_add(v + overstep, zone, item);
 		__this_cpu_write(*p, -overstep);
 	}
+	preempt_enable_rt();
 }
 
 void __inc_node_state(struct pglist_data *pgdat, enum node_stat_item item)
@@ -405,6 +411,7 @@ void __inc_node_state(struct pglist_data *pgdat, enum node_stat_item item)
 
 	VM_WARN_ON_ONCE(vmstat_item_in_bytes(item));
 
+	preempt_disable_rt();
 	v = __this_cpu_inc_return(*p);
 	t = __this_cpu_read(pcp->stat_threshold);
 	if (unlikely(v > t)) {
@@ -413,6 +420,7 @@ void __inc_node_state(struct pglist_data *pgdat, enum node_stat_item item)
 		node_page_state_add(v + overstep, pgdat, item);
 		__this_cpu_write(*p, -overstep);
 	}
+	preempt_enable_rt();
 }
 
 void __inc_zone_page_state(struct page *page, enum zone_stat_item item)
@@ -433,6 +441,7 @@ void __dec_zone_state(struct zone *zone, enum zone_stat_item item)
 	s8 __percpu *p = pcp->vm_stat_diff + item;
 	s8 v, t;
 
+	preempt_disable_rt();
 	v = __this_cpu_dec_return(*p);
 	t = __this_cpu_read(pcp->stat_threshold);
 	if (unlikely(v < - t)) {
@@ -441,6 +450,7 @@ void __dec_zone_state(struct zone *zone, enum zone_stat_item item)
 		zone_page_state_add(v - overstep, zone, item);
 		__this_cpu_write(*p, overstep);
 	}
+	preempt_enable_rt();
 }
 
 void __dec_node_state(struct pglist_data *pgdat, enum node_stat_item item)
@@ -451,6 +461,7 @@ void __dec_node_state(struct pglist_data *pgdat, enum node_stat_item item)
 
 	VM_WARN_ON_ONCE(vmstat_item_in_bytes(item));
 
+	preempt_disable_rt();
 	v = __this_cpu_dec_return(*p);
 	t = __this_cpu_read(pcp->stat_threshold);
 	if (unlikely(v < - t)) {
@@ -459,6 +470,7 @@ void __dec_node_state(struct pglist_data *pgdat, enum node_stat_item item)
 		node_page_state_add(v - overstep, pgdat, item);
 		__this_cpu_write(*p, overstep);
 	}
+	preempt_enable_rt();
 }
 
 void __dec_zone_page_state(struct page *page, enum zone_stat_item item)
diff --git a/mm/workingset.c b/mm/workingset.c
index 4a30e4a813a5..4c92584ca34d 100644
--- a/mm/workingset.c
+++ b/mm/workingset.c
@@ -431,6 +431,8 @@ static struct list_lru shadow_nodes;
 
 void workingset_update_node(struct xa_node *node)
 {
+	struct address_space *mapping;
+
 	/*
 	 * Track non-empty nodes that contain only shadow entries;
 	 * unlink those that contain pages or are being freed.
@@ -439,7 +441,8 @@ void workingset_update_node(struct xa_node *node)
 	 * already where they should be. The list_empty() test is safe
 	 * as node->private_list is protected by the i_pages lock.
 	 */
-	VM_WARN_ON_ONCE(!irqs_disabled());  /* For __inc_lruvec_page_state */
+	mapping = container_of(node->array, struct address_space, i_pages);
+	lockdep_assert_held(&mapping->i_pages.xa_lock);
 
 	if (node->count && node->count == node->nr_values) {
 		if (list_empty(&node->private_list)) {
diff --git a/mm/z3fold.c b/mm/z3fold.c
index f75c638c69db..6fdf4774fdbe 100644
--- a/mm/z3fold.c
+++ b/mm/z3fold.c
@@ -623,14 +623,16 @@ static inline void add_to_unbuddied(struct z3fold_pool *pool,
 {
 	if (zhdr->first_chunks == 0 || zhdr->last_chunks == 0 ||
 			zhdr->middle_chunks == 0) {
-		struct list_head *unbuddied = get_cpu_ptr(pool->unbuddied);
-
+		struct list_head *unbuddied;
 		int freechunks = num_free_chunks(zhdr);
+
+		migrate_disable();
+		unbuddied = this_cpu_ptr(pool->unbuddied);
 		spin_lock(&pool->lock);
 		list_add(&zhdr->buddy, &unbuddied[freechunks]);
 		spin_unlock(&pool->lock);
 		zhdr->cpu = smp_processor_id();
-		put_cpu_ptr(pool->unbuddied);
+		migrate_enable();
 	}
 }
 
@@ -880,8 +882,9 @@ static inline struct z3fold_header *__z3fold_alloc(struct z3fold_pool *pool,
 	int chunks = size_to_chunks(size), i;
 
 lookup:
+	migrate_disable();
 	/* First, try to find an unbuddied z3fold page. */
-	unbuddied = get_cpu_ptr(pool->unbuddied);
+	unbuddied = this_cpu_ptr(pool->unbuddied);
 	for_each_unbuddied_list(i, chunks) {
 		struct list_head *l = &unbuddied[i];
 
@@ -899,7 +902,7 @@ static inline struct z3fold_header *__z3fold_alloc(struct z3fold_pool *pool,
 		    !z3fold_page_trylock(zhdr)) {
 			spin_unlock(&pool->lock);
 			zhdr = NULL;
-			put_cpu_ptr(pool->unbuddied);
+			migrate_enable();
 			if (can_sleep)
 				cond_resched();
 			goto lookup;
@@ -913,7 +916,7 @@ static inline struct z3fold_header *__z3fold_alloc(struct z3fold_pool *pool,
 		    test_bit(PAGE_CLAIMED, &page->private)) {
 			z3fold_page_unlock(zhdr);
 			zhdr = NULL;
-			put_cpu_ptr(pool->unbuddied);
+			migrate_enable();
 			if (can_sleep)
 				cond_resched();
 			goto lookup;
@@ -928,7 +931,7 @@ static inline struct z3fold_header *__z3fold_alloc(struct z3fold_pool *pool,
 		kref_get(&zhdr->refcount);
 		break;
 	}
-	put_cpu_ptr(pool->unbuddied);
+	migrate_enable();
 
 	if (!zhdr) {
 		int cpu;
diff --git a/mm/zsmalloc.c b/mm/zsmalloc.c
index c18dc8e61d35..16ce2b05df90 100644
--- a/mm/zsmalloc.c
+++ b/mm/zsmalloc.c
@@ -57,6 +57,7 @@
 #include <linux/wait.h>
 #include <linux/pagemap.h>
 #include <linux/fs.h>
+#include <linux/local_lock.h>
 
 #define ZSPAGE_MAGIC	0x58
 
@@ -77,6 +78,20 @@
 
 #define ZS_HANDLE_SIZE (sizeof(unsigned long))
 
+#ifdef CONFIG_PREEMPT_RT
+
+struct zsmalloc_handle {
+	unsigned long addr;
+	spinlock_t lock;
+};
+
+#define ZS_HANDLE_ALLOC_SIZE (sizeof(struct zsmalloc_handle))
+
+#else
+
+#define ZS_HANDLE_ALLOC_SIZE (sizeof(unsigned long))
+#endif
+
 /*
  * Object location (<PFN>, <obj_idx>) is encoded as
  * a single (unsigned long) handle value.
@@ -293,6 +308,7 @@ struct zspage {
 };
 
 struct mapping_area {
+	local_lock_t lock;
 	char *vm_buf; /* copy buffer for objects that span pages */
 	char *vm_addr; /* address of kmap_atomic()'ed pages */
 	enum zs_mapmode vm_mm; /* mapping mode */
@@ -322,7 +338,7 @@ static void SetZsPageMovable(struct zs_pool *pool, struct zspage *zspage) {}
 
 static int create_cache(struct zs_pool *pool)
 {
-	pool->handle_cachep = kmem_cache_create("zs_handle", ZS_HANDLE_SIZE,
+	pool->handle_cachep = kmem_cache_create("zs_handle", ZS_HANDLE_ALLOC_SIZE,
 					0, 0, NULL);
 	if (!pool->handle_cachep)
 		return 1;
@@ -346,10 +362,27 @@ static void destroy_cache(struct zs_pool *pool)
 
 static unsigned long cache_alloc_handle(struct zs_pool *pool, gfp_t gfp)
 {
-	return (unsigned long)kmem_cache_alloc(pool->handle_cachep,
-			gfp & ~(__GFP_HIGHMEM|__GFP_MOVABLE));
+	void *p;
+
+	p = kmem_cache_alloc(pool->handle_cachep,
+			     gfp & ~(__GFP_HIGHMEM|__GFP_MOVABLE));
+#ifdef CONFIG_PREEMPT_RT
+	if (p) {
+		struct zsmalloc_handle *zh = p;
+
+		spin_lock_init(&zh->lock);
+	}
+#endif
+	return (unsigned long)p;
 }
 
+#ifdef CONFIG_PREEMPT_RT
+static struct zsmalloc_handle *zs_get_pure_handle(unsigned long handle)
+{
+	return (void *)(handle &~((1 << OBJ_TAG_BITS) - 1));
+}
+#endif
+
 static void cache_free_handle(struct zs_pool *pool, unsigned long handle)
 {
 	kmem_cache_free(pool->handle_cachep, (void *)handle);
@@ -368,12 +401,18 @@ static void cache_free_zspage(struct zs_pool *pool, struct zspage *zspage)
 
 static void record_obj(unsigned long handle, unsigned long obj)
 {
+#ifdef CONFIG_PREEMPT_RT
+	struct zsmalloc_handle *zh = zs_get_pure_handle(handle);
+
+	WRITE_ONCE(zh->addr, obj);
+#else
 	/*
 	 * lsb of @obj represents handle lock while other bits
 	 * represent object value the handle is pointing so
 	 * updating shouldn't do store tearing.
 	 */
 	WRITE_ONCE(*(unsigned long *)handle, obj);
+#endif
 }
 
 /* zpool driver */
@@ -455,7 +494,10 @@ MODULE_ALIAS("zpool-zsmalloc");
 #endif /* CONFIG_ZPOOL */
 
 /* per-cpu VM mapping areas for zspage accesses that cross page boundaries */
-static DEFINE_PER_CPU(struct mapping_area, zs_map_area);
+static DEFINE_PER_CPU(struct mapping_area, zs_map_area) = {
+	/* XXX remove this and use a spin_lock_t in pin_tag() */
+	.lock	= INIT_LOCAL_LOCK(lock),
+};
 
 static bool is_zspage_isolated(struct zspage *zspage)
 {
@@ -865,7 +907,13 @@ static unsigned long location_to_obj(struct page *page, unsigned int obj_idx)
 
 static unsigned long handle_to_obj(unsigned long handle)
 {
+#ifdef CONFIG_PREEMPT_RT
+	struct zsmalloc_handle *zh = zs_get_pure_handle(handle);
+
+	return zh->addr;
+#else
 	return *(unsigned long *)handle;
+#endif
 }
 
 static unsigned long obj_to_head(struct page *page, void *obj)
@@ -879,22 +927,46 @@ static unsigned long obj_to_head(struct page *page, void *obj)
 
 static inline int testpin_tag(unsigned long handle)
 {
+#ifdef CONFIG_PREEMPT_RT
+	struct zsmalloc_handle *zh = zs_get_pure_handle(handle);
+
+	return spin_is_locked(&zh->lock);
+#else
 	return bit_spin_is_locked(HANDLE_PIN_BIT, (unsigned long *)handle);
+#endif
 }
 
 static inline int trypin_tag(unsigned long handle)
 {
+#ifdef CONFIG_PREEMPT_RT
+	struct zsmalloc_handle *zh = zs_get_pure_handle(handle);
+
+	return spin_trylock(&zh->lock);
+#else
 	return bit_spin_trylock(HANDLE_PIN_BIT, (unsigned long *)handle);
+#endif
 }
 
 static void pin_tag(unsigned long handle) __acquires(bitlock)
 {
+#ifdef CONFIG_PREEMPT_RT
+	struct zsmalloc_handle *zh = zs_get_pure_handle(handle);
+
+	return spin_lock(&zh->lock);
+#else
 	bit_spin_lock(HANDLE_PIN_BIT, (unsigned long *)handle);
+#endif
 }
 
 static void unpin_tag(unsigned long handle) __releases(bitlock)
 {
+#ifdef CONFIG_PREEMPT_RT
+	struct zsmalloc_handle *zh = zs_get_pure_handle(handle);
+
+	return spin_unlock(&zh->lock);
+#else
 	bit_spin_unlock(HANDLE_PIN_BIT, (unsigned long *)handle);
+#endif
 }
 
 static void reset_page(struct page *page)
@@ -1278,7 +1350,8 @@ void *zs_map_object(struct zs_pool *pool, unsigned long handle,
 	class = pool->size_class[class_idx];
 	off = (class->size * obj_idx) & ~PAGE_MASK;
 
-	area = &get_cpu_var(zs_map_area);
+	local_lock(&zs_map_area.lock);
+	area = this_cpu_ptr(&zs_map_area);
 	area->vm_mm = mm;
 	if (off + class->size <= PAGE_SIZE) {
 		/* this object is contained entirely within a page */
@@ -1332,7 +1405,7 @@ void zs_unmap_object(struct zs_pool *pool, unsigned long handle)
 
 		__zs_unmap_object(area, pages, off, class->size);
 	}
-	put_cpu_var(zs_map_area);
+	local_unlock(&zs_map_area.lock);
 
 	migrate_read_unlock(zspage);
 	unpin_tag(handle);
diff --git a/mm/zswap.c b/mm/zswap.c
index 358f48b173dc..0c9a52a2fca3 100644
--- a/mm/zswap.c
+++ b/mm/zswap.c
@@ -18,6 +18,7 @@
 #include <linux/highmem.h>
 #include <linux/slab.h>
 #include <linux/spinlock.h>
+#include <linux/local_lock.h>
 #include <linux/types.h>
 #include <linux/atomic.h>
 #include <linux/frontswap.h>
diff --git a/net/Kconfig b/net/Kconfig
index d6567162c1cf..05b0f041f039 100644
--- a/net/Kconfig
+++ b/net/Kconfig
@@ -282,7 +282,7 @@ config CGROUP_NET_CLASSID
 
 config NET_RX_BUSY_POLL
 	bool
-	default y
+	default y if !PREEMPT_RT
 
 config BQL
 	bool
diff --git a/net/core/dev.c b/net/core/dev.c
index 64837bb056ee..dee3d89c80e6 100644
--- a/net/core/dev.c
+++ b/net/core/dev.c
@@ -221,14 +221,14 @@ static inline struct hlist_head *dev_index_hash(struct net *net, int ifindex)
 static inline void rps_lock(struct softnet_data *sd)
 {
 #ifdef CONFIG_RPS
-	spin_lock(&sd->input_pkt_queue.lock);
+	raw_spin_lock(&sd->input_pkt_queue.raw_lock);
 #endif
 }
 
 static inline void rps_unlock(struct softnet_data *sd)
 {
 #ifdef CONFIG_RPS
-	spin_unlock(&sd->input_pkt_queue.lock);
+	raw_spin_unlock(&sd->input_pkt_queue.raw_lock);
 #endif
 }
 
@@ -3051,6 +3051,7 @@ static void __netif_reschedule(struct Qdisc *q)
 	sd->output_queue_tailp = &q->next_sched;
 	raise_softirq_irqoff(NET_TX_SOFTIRQ);
 	local_irq_restore(flags);
+	preempt_check_resched_rt();
 }
 
 void __netif_schedule(struct Qdisc *q)
@@ -3113,6 +3114,7 @@ void __dev_kfree_skb_irq(struct sk_buff *skb, enum skb_free_reason reason)
 	__this_cpu_write(softnet_data.completion_queue, skb);
 	raise_softirq_irqoff(NET_TX_SOFTIRQ);
 	local_irq_restore(flags);
+	preempt_check_resched_rt();
 }
 EXPORT_SYMBOL(__dev_kfree_skb_irq);
 
@@ -3791,7 +3793,11 @@ static inline int __dev_xmit_skb(struct sk_buff *skb, struct Qdisc *q,
 	 * This permits qdisc->running owner to get the lock more
 	 * often and dequeue packets faster.
 	 */
+#ifdef CONFIG_PREEMPT_RT
+	contended = true;
+#else
 	contended = qdisc_is_running(q);
+#endif
 	if (unlikely(contended))
 		spin_lock(&q->busylock);
 
@@ -4591,6 +4597,7 @@ static int enqueue_to_backlog(struct sk_buff *skb, int cpu,
 	rps_unlock(sd);
 
 	local_irq_restore(flags);
+	preempt_check_resched_rt();
 
 	atomic_long_inc(&skb->dev->rx_dropped);
 	kfree_skb(skb);
@@ -4810,7 +4817,7 @@ static int netif_rx_internal(struct sk_buff *skb)
 		struct rps_dev_flow voidflow, *rflow = &voidflow;
 		int cpu;
 
-		preempt_disable();
+		migrate_disable();
 		rcu_read_lock();
 
 		cpu = get_rps_cpu(skb->dev, skb, &rflow);
@@ -4820,14 +4827,14 @@ static int netif_rx_internal(struct sk_buff *skb)
 		ret = enqueue_to_backlog(skb, cpu, &rflow->last_qtail);
 
 		rcu_read_unlock();
-		preempt_enable();
+		migrate_enable();
 	} else
 #endif
 	{
 		unsigned int qtail;
 
-		ret = enqueue_to_backlog(skb, get_cpu(), &qtail);
-		put_cpu();
+		ret = enqueue_to_backlog(skb, get_cpu_light(), &qtail);
+		put_cpu_light();
 	}
 	return ret;
 }
@@ -4866,11 +4873,9 @@ int netif_rx_ni(struct sk_buff *skb)
 
 	trace_netif_rx_ni_entry(skb);
 
-	preempt_disable();
+	local_bh_disable();
 	err = netif_rx_internal(skb);
-	if (local_softirq_pending())
-		do_softirq();
-	preempt_enable();
+	local_bh_enable();
 	trace_netif_rx_ni_exit(err);
 
 	return err;
@@ -6346,12 +6351,14 @@ static void net_rps_action_and_irq_enable(struct softnet_data *sd)
 		sd->rps_ipi_list = NULL;
 
 		local_irq_enable();
+		preempt_check_resched_rt();
 
 		/* Send pending IPI's to kick RPS processing on remote cpus. */
 		net_rps_send_ipi(remsd);
 	} else
 #endif
 		local_irq_enable();
+	preempt_check_resched_rt();
 }
 
 static bool sd_has_rps_ipi_waiting(struct softnet_data *sd)
@@ -6429,6 +6436,7 @@ void __napi_schedule(struct napi_struct *n)
 	local_irq_save(flags);
 	____napi_schedule(this_cpu_ptr(&softnet_data), n);
 	local_irq_restore(flags);
+	preempt_check_resched_rt();
 }
 EXPORT_SYMBOL(__napi_schedule);
 
@@ -10978,6 +10986,7 @@ static int dev_cpu_dead(unsigned int oldcpu)
 
 	raise_softirq_irqoff(NET_TX_SOFTIRQ);
 	local_irq_enable();
+	preempt_check_resched_rt();
 
 #ifdef CONFIG_RPS
 	remsd = oldsd->rps_ipi_list;
@@ -10991,7 +11000,7 @@ static int dev_cpu_dead(unsigned int oldcpu)
 		netif_rx_ni(skb);
 		input_queue_head_incr(oldsd);
 	}
-	while ((skb = skb_dequeue(&oldsd->input_pkt_queue))) {
+	while ((skb = __skb_dequeue(&oldsd->input_pkt_queue))) {
 		netif_rx_ni(skb);
 		input_queue_head_incr(oldsd);
 	}
@@ -11307,7 +11316,7 @@ static int __init net_dev_init(void)
 
 		INIT_WORK(flush, flush_backlog);
 
-		skb_queue_head_init(&sd->input_pkt_queue);
+		skb_queue_head_init_raw(&sd->input_pkt_queue);
 		skb_queue_head_init(&sd->process_queue);
 #ifdef CONFIG_XFRM_OFFLOAD
 		skb_queue_head_init(&sd->xfrm_backlog);
diff --git a/net/core/gen_estimator.c b/net/core/gen_estimator.c
index 8e582e29a41e..e51f4854d8b2 100644
--- a/net/core/gen_estimator.c
+++ b/net/core/gen_estimator.c
@@ -42,7 +42,7 @@
 struct net_rate_estimator {
 	struct gnet_stats_basic_packed	*bstats;
 	spinlock_t		*stats_lock;
-	seqcount_t		*running;
+	net_seqlock_t		*running;
 	struct gnet_stats_basic_cpu __percpu *cpu_bstats;
 	u8			ewma_log;
 	u8			intvl_log; /* period : (250ms << intvl_log) */
@@ -125,7 +125,7 @@ int gen_new_estimator(struct gnet_stats_basic_packed *bstats,
 		      struct gnet_stats_basic_cpu __percpu *cpu_bstats,
 		      struct net_rate_estimator __rcu **rate_est,
 		      spinlock_t *lock,
-		      seqcount_t *running,
+		      net_seqlock_t *running,
 		      struct nlattr *opt)
 {
 	struct gnet_estimator *parm = nla_data(opt);
@@ -226,7 +226,7 @@ int gen_replace_estimator(struct gnet_stats_basic_packed *bstats,
 			  struct gnet_stats_basic_cpu __percpu *cpu_bstats,
 			  struct net_rate_estimator __rcu **rate_est,
 			  spinlock_t *lock,
-			  seqcount_t *running, struct nlattr *opt)
+			  net_seqlock_t *running, struct nlattr *opt)
 {
 	return gen_new_estimator(bstats, cpu_bstats, rate_est,
 				 lock, running, opt);
diff --git a/net/core/gen_stats.c b/net/core/gen_stats.c
index e491b083b348..ef432cea2e10 100644
--- a/net/core/gen_stats.c
+++ b/net/core/gen_stats.c
@@ -137,7 +137,7 @@ __gnet_stats_copy_basic_cpu(struct gnet_stats_basic_packed *bstats,
 }
 
 void
-__gnet_stats_copy_basic(const seqcount_t *running,
+__gnet_stats_copy_basic(net_seqlock_t *running,
 			struct gnet_stats_basic_packed *bstats,
 			struct gnet_stats_basic_cpu __percpu *cpu,
 			struct gnet_stats_basic_packed *b)
@@ -150,15 +150,15 @@ __gnet_stats_copy_basic(const seqcount_t *running,
 	}
 	do {
 		if (running)
-			seq = read_seqcount_begin(running);
+			seq = net_seq_begin(running);
 		bstats->bytes = b->bytes;
 		bstats->packets = b->packets;
-	} while (running && read_seqcount_retry(running, seq));
+	} while (running && net_seq_retry(running, seq));
 }
 EXPORT_SYMBOL(__gnet_stats_copy_basic);
 
 static int
-___gnet_stats_copy_basic(const seqcount_t *running,
+___gnet_stats_copy_basic(net_seqlock_t *running,
 			 struct gnet_dump *d,
 			 struct gnet_stats_basic_cpu __percpu *cpu,
 			 struct gnet_stats_basic_packed *b,
@@ -204,7 +204,7 @@ ___gnet_stats_copy_basic(const seqcount_t *running,
  * if the room in the socket buffer was not sufficient.
  */
 int
-gnet_stats_copy_basic(const seqcount_t *running,
+gnet_stats_copy_basic(net_seqlock_t *running,
 		      struct gnet_dump *d,
 		      struct gnet_stats_basic_cpu __percpu *cpu,
 		      struct gnet_stats_basic_packed *b)
@@ -228,7 +228,7 @@ EXPORT_SYMBOL(gnet_stats_copy_basic);
  * if the room in the socket buffer was not sufficient.
  */
 int
-gnet_stats_copy_basic_hw(const seqcount_t *running,
+gnet_stats_copy_basic_hw(net_seqlock_t *running,
 			 struct gnet_dump *d,
 			 struct gnet_stats_basic_cpu __percpu *cpu,
 			 struct gnet_stats_basic_packed *b)
diff --git a/net/core/sock.c b/net/core/sock.c
index 56a927b9b372..28acdfbcdd22 100644
--- a/net/core/sock.c
+++ b/net/core/sock.c
@@ -3059,12 +3059,11 @@ void lock_sock_nested(struct sock *sk, int subclass)
 	if (sk->sk_lock.owned)
 		__lock_sock(sk);
 	sk->sk_lock.owned = 1;
-	spin_unlock(&sk->sk_lock.slock);
+	spin_unlock_bh(&sk->sk_lock.slock);
 	/*
 	 * The sk_lock has mutex_lock() semantics here:
 	 */
 	mutex_acquire(&sk->sk_lock.dep_map, subclass, 0, _RET_IP_);
-	local_bh_enable();
 }
 EXPORT_SYMBOL(lock_sock_nested);
 
@@ -3113,12 +3112,11 @@ bool lock_sock_fast(struct sock *sk)
 
 	__lock_sock(sk);
 	sk->sk_lock.owned = 1;
-	spin_unlock(&sk->sk_lock.slock);
+	spin_unlock_bh(&sk->sk_lock.slock);
 	/*
 	 * The sk_lock has mutex_lock() semantics here:
 	 */
 	mutex_acquire(&sk->sk_lock.dep_map, 0, 0, _RET_IP_);
-	local_bh_enable();
 	return true;
 }
 EXPORT_SYMBOL(lock_sock_fast);
diff --git a/net/sched/sch_api.c b/net/sched/sch_api.c
index 6e18aa417782..2d538f14edf8 100644
--- a/net/sched/sch_api.c
+++ b/net/sched/sch_api.c
@@ -1264,7 +1264,7 @@ static struct Qdisc *qdisc_create(struct net_device *dev,
 		rcu_assign_pointer(sch->stab, stab);
 	}
 	if (tca[TCA_RATE]) {
-		seqcount_t *running;
+		net_seqlock_t *running;
 
 		err = -EOPNOTSUPP;
 		if (sch->flags & TCQ_F_MQROOT) {
diff --git a/net/sched/sch_generic.c b/net/sched/sch_generic.c
index 68f1e89430b3..455f9b21b264 100644
--- a/net/sched/sch_generic.c
+++ b/net/sched/sch_generic.c
@@ -578,7 +578,11 @@ struct Qdisc noop_qdisc = {
 	.ops		=	&noop_qdisc_ops,
 	.q.lock		=	__SPIN_LOCK_UNLOCKED(noop_qdisc.q.lock),
 	.dev_queue	=	&noop_netdev_queue,
+#ifdef CONFIG_PREEMPT_RT
+	.running	=	__SEQLOCK_UNLOCKED(noop_qdisc.running),
+#else
 	.running	=	SEQCNT_ZERO(noop_qdisc.running),
+#endif
 	.busylock	=	__SPIN_LOCK_UNLOCKED(noop_qdisc.busylock),
 	.gso_skb = {
 		.next = (struct sk_buff *)&noop_qdisc.gso_skb,
@@ -889,9 +893,15 @@ struct Qdisc *qdisc_alloc(struct netdev_queue *dev_queue,
 	lockdep_set_class(&sch->seqlock,
 			  dev->qdisc_tx_busylock ?: &qdisc_tx_busylock);
 
+#ifdef CONFIG_PREEMPT_RT
+	seqlock_init(&sch->running);
+	lockdep_set_class(&sch->running.lock,
+			  dev->qdisc_running_key ?: &qdisc_running_key);
+#else
 	seqcount_init(&sch->running);
 	lockdep_set_class(&sch->running,
 			  dev->qdisc_running_key ?: &qdisc_running_key);
+#endif
 
 	sch->ops = ops;
 	sch->flags = ops->static_flags;
diff --git a/net/sunrpc/svc_xprt.c b/net/sunrpc/svc_xprt.c
index 362487f3a6de..5c6c31fc7890 100644
--- a/net/sunrpc/svc_xprt.c
+++ b/net/sunrpc/svc_xprt.c
@@ -422,7 +422,7 @@ void svc_xprt_do_enqueue(struct svc_xprt *xprt)
 	if (test_and_set_bit(XPT_BUSY, &xprt->xpt_flags))
 		return;
 
-	cpu = get_cpu();
+	cpu = get_cpu_light();
 	pool = svc_pool_for_cpu(xprt->xpt_server, cpu);
 
 	atomic_long_inc(&pool->sp_stats.packets);
@@ -446,7 +446,7 @@ void svc_xprt_do_enqueue(struct svc_xprt *xprt)
 	rqstp = NULL;
 out_unlock:
 	rcu_read_unlock();
-	put_cpu();
+	put_cpu_light();
 	trace_svc_xprt_do_enqueue(xprt, rqstp);
 }
 EXPORT_SYMBOL_GPL(svc_xprt_do_enqueue);
diff --git a/net/xfrm/xfrm_state.c b/net/xfrm/xfrm_state.c
index ac2f1a7330c9..84f421e6b12c 100644
--- a/net/xfrm/xfrm_state.c
+++ b/net/xfrm/xfrm_state.c
@@ -2673,7 +2673,8 @@ int __net_init xfrm_state_init(struct net *net)
 	net->xfrm.state_num = 0;
 	INIT_WORK(&net->xfrm.state_hash_work, xfrm_hash_resize);
 	spin_lock_init(&net->xfrm.xfrm_state_lock);
-	seqcount_init(&net->xfrm.xfrm_state_hash_generation);
+	seqcount_spinlock_init(&net->xfrm.xfrm_state_hash_generation,
+			       &net->xfrm.xfrm_state_lock);
 	return 0;
 
 out_byspi:
-- 
2.36.1

